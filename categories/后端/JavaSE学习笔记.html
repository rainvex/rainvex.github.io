<!DOCTYPE html>
<html lang="zh-CN,en,default">
    <head hexo-theme='https://github.com/volantis-x/hexo-theme-volantis/#5.7.4'>
  <meta name="generator" content="Hexo 5.4.2">
  <meta name="Volantis" content="5.7.4">
  <meta charset="utf-8">
  <!-- SEO相关 -->
  
  <link rel="canonical" href="http://rainvex.com/categories/后端/javase学习笔记.html"/>
  <!-- 渲染优化 -->
    <meta http-equiv='x-dns-prefetch-control' content='on' />
      <link rel='dns-prefetch' href='https://unpkg.com'>
      <link rel="preconnect" href="https://unpkg.com" crossorigin>
  <meta name="renderer" content="webkit">
  <meta name="force-rendering" content="webkit">
  <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta http-equiv="Content-Security-Policy" content=" default-src 'self' https:; block-all-mixed-content; base-uri 'self' https:; form-action 'self' https:; worker-src 'self' https:; connect-src 'self' https: *; img-src 'self' data: https: *; media-src 'self' https: *; font-src 'self' data: https: *; frame-src 'self' https: *; manifest-src 'self' https: *; child-src https:; script-src 'self' https: 'unsafe-inline' *; style-src 'self' https: 'unsafe-inline' *; ">
  <meta name="HandheldFriendly" content="True" >
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=5">
  <meta content="black-translucent" name="apple-mobile-web-app-status-bar-style">
  <meta content="telephone=no" name="format-detection">
  <!-- import head_begin begin -->
  <!-- import head_begin end -->
  <!-- Custom Files headBegin begin-->
  
  <!-- Custom Files headBegin end-->
    <link rel="shortcut icon" type='image/x-icon' href="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/avatar.jpg">
  <link rel="preload" href="/css/style.659c7404.css" as="style">
  <link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">
<link rel="preload" href="https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf" as="font" type="font/ttf" crossorigin="anonymous">

  <!-- feed -->
      <link rel="alternate" href="/atom.xml" title="夜雨声烦" type="application/atom+xml">
  <!-- 页面元数据 -->
  <title>JavaSE学习笔记 - 夜雨声烦</title>
  <meta name="keywords" content="笔记,Java,后端,rainvex,blog,夜雨声烦">
  <meta desc name="description" content="夜雨声烦的个人博客 - 夜雨声烦 - 夜雨声烦">
  
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE学习笔记">
<meta property="og:url" content="http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html">
<meta property="og:site_name" content="夜雨声烦">
<meta property="og:description" content="JavaSE学习笔记JDK8官方文档查看：https:&#x2F;&#x2F;docs.oracle.com&#x2F;javase&#x2F;8&#x2F;docs&#x2F;api&#x2F; 一、Java基础语法1.1 数据类型Java是强类型语言，要求变量的使用要严格符合规定，所有变量必须定义后才能使用 Java的数据类型分为两大类：基本类型和引用类型 位（bit）：是计算机内部数据储存的最小单位 字节（byte）：是计算机中数据处理的基本单位，习惯用大写B">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
<meta property="article:published_time" content="2022-03-27T13:38:17.000Z">
<meta property="article:modified_time" content="2022-03-27T13:38:17.000Z">
<meta property="article:author" content="夜雨声烦">
<meta property="article:tag" content="笔记">
<meta property="article:tag" content="Java">
<meta property="article:tag" content="后端">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png">
  <style>
    /* 首屏样式 */
    #safearea {
  display: none;
}
:root {
  --color-site-body: #f4f4f4;
  --color-site-bg: #f4f4f4;
  --color-site-inner: #787878;
  --color-site-footer: #787878;
  --color-card: #fff;
  --color-text: #444;
  --color-block: #f6f6f6;
  --color-inlinecode: #c74f00;
  --color-codeblock: #fff7ea;
  --color-h1: #3a3a3a;
  --color-h2: #3a3a3a;
  --color-h3: #333;
  --color-h4: #444;
  --color-h5: #555;
  --color-h6: #666;
  --color-p: #444;
  --color-list: #666;
  --color-list-hl: #6e08c2;
  --color-meta: #888;
  --color-read-bkg: #e0d8c8;
  --color-read-post: #f8f1e2;
  --color-copyright-bkg: #f5f5f5;
}
* {
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  outline: none;
  margin: 0;
  padding: 0;
}
*::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
*::-webkit-scrollbar-track-piece {
  background: transparent;
}
*::-webkit-scrollbar-thumb {
  background: #8a0af3;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
*::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
html {
  color: var(--color-text);
  width: 100%;
  height: 100%;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  font-size: 16px;
}
html >::-webkit-scrollbar {
  height: 4px;
  width: 4px;
}
html >::-webkit-scrollbar-track-piece {
  background: transparent;
}
html >::-webkit-scrollbar-thumb {
  background: #8a0af3;
  cursor: pointer;
  border-radius: 2px;
  -webkit-border-radius: 2px;
}
html >::-webkit-scrollbar-thumb:hover {
  background: #ff5722;
}
body {
  background-color: var(--color-site-body);
  text-rendering: optimizelegibility;
  -webkit-tap-highlight-color: rgba(0,0,0,0);
  line-height: 1.6;
  -webkit-text-size-adjust: 100%;
  -ms-text-size-adjust: 100%;
}
body.modal-active {
  overflow: hidden;
}
@media screen and (max-width: 680px) {
  body.modal-active {
    position: fixed;
    top: 0;
    right: 0;
    bottom: 0;
    left: 0;
  }
}
a {
  color: #4dec1c;
  cursor: pointer;
  text-decoration: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
a:hover {
  color: #ff5722;
}
a:active,
a:hover {
  outline: 0;
}
ul,
ol {
  padding-left: 0;
}
ul li,
ol li {
  list-style: none;
}
header {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
img {
  border: 0;
  background: none;
  max-width: 100%;
}
svg:not(:root) {
  overflow: hidden;
}
hr {
  -moz-box-sizing: content-box;
  box-sizing: content-box;
  -webkit-box-sizing: content-box;
  -moz-box-sizing: content-box;
  height: 0;
  border: 0;
  border-radius: 1px;
  -webkit-border-radius: 1px;
  border-bottom: 1px solid rgba(68,68,68,0.1);
}
button,
input {
  color: inherit;
  font: inherit;
  margin: 0;
}
button {
  overflow: visible;
  text-transform: none;
  -webkit-appearance: button;
  cursor: pointer;
}
@supports (backdrop-filter: blur(20px)) {
  .blur {
    background: rgba(255,255,255,0.9) !important;
    backdrop-filter: saturate(200%) blur(20px);
  }
}
@supports (backdrop-filter: blur(20px)) {
  .blur#comments {
    backdrop-filter: unset;
  }
}
#layoutHelper-comments {
  margin-bottom: 100px;
}
.shadow {
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.shadow.floatable {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.shadow.floatable:hover {
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.1), 0 4px 8px 0px rgba(0,0,0,0.1), 0 8px 16px 0px rgba(0,0,0,0.1);
}
#l_cover {
  min-height: 64px;
}
.cover-wrapper {
  top: 0;
  left: 0;
  max-width: 100%;
  height: 100vh;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  align-self: center;
  align-content: center;
  color: var(--color-site-inner);
  padding: 0 16px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
  position: relative;
  overflow: hidden;
  margin-bottom: -100px;
}
.cover-wrapper .cover-body {
  z-index: 1;
  position: relative;
  width: 100%;
  height: 100%;
}
.cover-wrapper#full {
  height: calc(100vh + 100px);
  padding-bottom: 100px;
}
.cover-wrapper#half {
  max-height: 640px;
  min-height: 400px;
  height: calc(36vh - 64px + 200px);
}
.cover-wrapper #scroll-down {
  width: 100%;
  height: 64px;
  position: absolute;
  bottom: 100px;
  text-align: center;
  cursor: pointer;
}
.cover-wrapper #scroll-down .scroll-down-effects {
  color: #fff;
  font-size: 24px;
  line-height: 64px;
  position: absolute;
  width: 24px;
  left: calc(50% - 12px);
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
  animation: scroll-down-effect 1.5s infinite;
  -webkit-animation: scroll-down-effect 1.5s infinite;
  -khtml-animation: scroll-down-effect 1.5s infinite;
  -moz-animation: scroll-down-effect 1.5s infinite;
  -o-animation: scroll-down-effect 1.5s infinite;
  -ms-animation: scroll-down-effect 1.5s infinite;
}
@-moz-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes scroll-down-effect {
  0% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
  50% {
    top: -16px;
    opacity: 0.4;
    -webkit-opacity: 0.4;
    -moz-opacity: 0.4;
  }
  100% {
    top: 0;
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.cover-wrapper .cover-body {
  margin-top: 64px;
  margin-bottom: 100px;
}
.cover-wrapper .cover-body,
.cover-wrapper .cover-body .top,
.cover-wrapper .cover-body .bottom {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  max-width: 100%;
}
.cover-wrapper .cover-body .bottom {
  margin-top: 32px;
}
.cover-wrapper .cover-body .title {
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
  font-size: 3.125rem;
  line-height: 1.2;
  text-shadow: 0 1px 2px rgba(0,0,0,0.1);
}
.cover-wrapper .cover-body .subtitle {
  font-size: 20px;
}
.cover-wrapper .cover-body .logo {
  max-height: 120px;
  max-width: calc(100% - 4 * 16px);
}
@media screen and (min-height: 1024px) {
  .cover-wrapper .cover-body .title {
    font-size: 3rem;
  }
  .cover-wrapper .cover-body .subtitle {
    font-size: 1.05rem;
  }
  .cover-wrapper .cover-body .logo {
    max-height: 150px;
  }
}
.cover-wrapper .cover-body .m_search {
  position: relative;
  max-width: calc(100% - 16px);
  width: 320px;
  vertical-align: middle;
}
.cover-wrapper .cover-body .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  width: 100%;
}
.cover-wrapper .cover-body .m_search .icon,
.cover-wrapper .cover-body .m_search .input {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.cover-wrapper .cover-body .m_search .icon {
  position: absolute;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  line-height: 2.5rem;
  width: 32px;
  top: 0;
  left: 5px;
  color: rgba(68,68,68,0.75);
}
.cover-wrapper .cover-body .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  height: 2.5rem;
  width: 100%;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  font-size: 0.875rem;
  -webkit-appearance: none;
  padding-left: 36px;
  border-radius: 1.4rem;
  -webkit-border-radius: 1.4rem;
  background: rgba(255,255,255,0.6);
  backdrop-filter: blur(10px);
  border: none;
  color: var(--color-text);
}
@media screen and (max-width: 500px) {
  .cover-wrapper .cover-body .m_search .input {
    padding-left: 36px;
  }
}
.cover-wrapper .cover-body .m_search .input:hover {
  background: rgba(255,255,255,0.8);
}
.cover-wrapper .cover-body .m_search .input:focus {
  background: #fff;
}
.cover-wrapper .list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  flex-wrap: wrap;
  -webkit-flex-wrap: wrap;
  -khtml-flex-wrap: wrap;
  -moz-flex-wrap: wrap;
  -o-flex-wrap: wrap;
  -ms-flex-wrap: wrap;
  align-items: stretch;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.cover-wrapper .list-h a {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 0;
  -ms-flex: 1 0;
  flex: 1 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  font-weight: 600;
}
.cover-wrapper .list-h a img {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  border-radius: 2px;
  -webkit-border-radius: 2px;
  margin: 4px;
  min-width: 40px;
  max-width: 44px;
}
@media screen and (max-width: 768px) {
  .cover-wrapper .list-h a img {
    min-width: 36px;
    max-width: 40px;
  }
}
@media screen and (max-width: 500px) {
  .cover-wrapper .list-h a img {
    margin: 2px 4px;
    min-width: 32px;
    max-width: 36px;
  }
}
@media screen and (max-width: 375px) {
  .cover-wrapper .list-h a img {
    min-width: 28px;
    max-width: 32px;
  }
}
.cover-wrapper {
  max-width: 100%;
}
.cover-wrapper.search .bottom .menu {
  margin-top: 16px;
}
.cover-wrapper.search .bottom .menu .list-h a {
  white-space: nowrap;
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: horizontal;
  -moz-box-orient: horizontal;
  -webkit-flex-direction: row;
  -ms-flex-direction: row;
  flex-direction: row;
  align-items: baseline;
  padding: 2px;
  margin: 4px;
  color: var(--color-site-inner);
  opacity: 0.75;
  -webkit-opacity: 0.75;
  -moz-opacity: 0.75;
  text-shadow: 0 1px 2px rgba(0,0,0,0.05);
  border-bottom: 2px solid transparent;
}
.cover-wrapper.search .bottom .menu .list-h a i {
  margin-right: 4px;
}
.cover-wrapper.search .bottom .menu .list-h a p {
  font-size: 0.9375rem;
}
.cover-wrapper.search .bottom .menu .list-h a:hover,
.cover-wrapper.search .bottom .menu .list-h a.active,
.cover-wrapper.search .bottom .menu .list-h a:active {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
  border-bottom: 2px solid var(--color-site-inner);
}
.cover-wrapper.dock .menu,
.cover-wrapper.featured .menu,
.cover-wrapper.focus .menu {
  border-radius: 6px;
  -webkit-border-radius: 6px;
}
.cover-wrapper.dock .menu .list-h a,
.cover-wrapper.featured .menu .list-h a,
.cover-wrapper.focus .menu .list-h a {
  -webkit-box-direction: normal;
  -moz-box-direction: normal;
  -webkit-box-orient: vertical;
  -moz-box-orient: vertical;
  -webkit-flex-direction: column;
  -ms-flex-direction: column;
  flex-direction: column;
  align-items: center;
  padding: 12px;
  line-height: 24px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  border-bottom: none;
  text-align: center;
  align-content: flex-end;
  color: rgba(68,68,68,0.7);
  font-size: 1.5rem;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h a,
  .cover-wrapper.featured .menu .list-h a,
  .cover-wrapper.focus .menu .list-h a {
    padding: 12px 8px;
  }
}
.cover-wrapper.dock .menu .list-h a i,
.cover-wrapper.featured .menu .list-h a i,
.cover-wrapper.focus .menu .list-h a i {
  margin: 8px;
}
.cover-wrapper.dock .menu .list-h a p,
.cover-wrapper.featured .menu .list-h a p,
.cover-wrapper.focus .menu .list-h a p {
  font-size: 0.875rem;
}
.cover-wrapper.dock .menu .list-h a.active,
.cover-wrapper.featured .menu .list-h a.active,
.cover-wrapper.focus .menu .list-h a.active {
  background: var(--color-card);
  backdrop-filter: none;
}
.cover-wrapper.dock .menu .list-h a.active i,
.cover-wrapper.featured .menu .list-h a.active i,
.cover-wrapper.focus .menu .list-h a.active i,
.cover-wrapper.dock .menu .list-h a.active i+p,
.cover-wrapper.featured .menu .list-h a.active i+p,
.cover-wrapper.focus .menu .list-h a.active i+p {
  color: #8a0af3;
}
.cover-wrapper.dock .menu .list-h a.active img+p,
.cover-wrapper.featured .menu .list-h a.active img+p,
.cover-wrapper.focus .menu .list-h a.active img+p {
  color: var(--color-text);
}
.cover-wrapper.dock .menu .list-h a:hover,
.cover-wrapper.featured .menu .list-h a:hover,
.cover-wrapper.focus .menu .list-h a:hover {
  background: var(--color-card);
}
.cover-wrapper.dock .top {
  margin-bottom: 48px;
}
.cover-wrapper.dock .menu {
  background: rgba(255,255,255,0.5);
  position: absolute;
  bottom: 0;
  max-width: 100%;
}
.cover-wrapper.dock .menu .list-h {
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  margin: 4px;
}
.cover-wrapper.dock .menu .list-h a+a {
  margin-left: 4px;
}
@media screen and (max-width: 500px) {
  .cover-wrapper.dock .menu .list-h {
    overflow-x: scroll;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar {
    height: 0;
    width: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-track-piece {
    background: transparent;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb {
    background: #8a0af3;
    cursor: pointer;
    border-radius: 0;
    -webkit-border-radius: 0;
  }
  .cover-wrapper.dock .menu .list-h::-webkit-scrollbar-thumb:hover {
    background: #ff5722;
  }
}
@supports (backdrop-filter: blur(20px)) {
  .cover-wrapper.dock .menu {
    background: rgba(255,255,255,0.5);
    backdrop-filter: saturate(200%) blur(20px);
  }
}
.cover-wrapper #parallax-window {
  position: absolute;
  width: 100%;
  height: 100%;
  background: transparent;
}
.parallax-mirror {
  animation-delay: 0s;
  animation-duration: 0.5s;
  animation-fill-mode: forwards;
  animation-timing-function: ease-out;
  animation-name: fadeIn;
}
@-moz-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-webkit-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@-o-keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@keyframes fadeIn {
  0% {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
    filter: blur(12px);
  }
  100% {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-mode: 'dark';
  }
  :root:not([color-scheme]) {
    --color-site-body: #1f1f1f;
    --color-read-bkg: #1f1f1f;
    --color-read-post: #262626;
    --color-site-bg: #1f1f1f;
    --color-site-inner: rgba(238,238,238,0.871);
    --color-site-footer: rgba(170,170,170,0.871);
    --color-card: #262626;
    --color-text: rgba(238,238,238,0.871);
    --color-block: #434343;
    --color-codeblock: #1f1f1f;
    --color-inlinecode: #d56d28;
    --color-h1: rgba(255,255,255,0.871);
    --color-h2: rgba(255,255,255,0.871);
    --color-h3: rgba(255,255,255,0.6);
    --color-h4: rgba(255,255,255,0.6);
    --color-h5: rgba(255,255,255,0.6);
    --color-h6: rgba(255,255,255,0.6);
    --color-p: rgba(217,217,217,0.871);
    --color-list: rgba(217,217,217,0.871);
    --color-list-hl: #a13af5;
    --color-meta: rgba(191,191,191,0.871);
    --color-link: rgba(191,191,191,0.871);
    --color-copyright-bkg: #21252b;
  }
  :root:not([color-scheme]) img {
    filter: brightness(70%) !important;
  }
  :root:not([color-scheme]) .blur {
    background: rgba(31,31,31,0.9) !important;
  }
  :root:not([color-scheme]) .white-box.blur {
    background: rgba(38,38,38,0.9) !important;
  }
  :root:not([color-scheme]) .nav-main .u-search-input {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) #l_main .article .prev-next>a:hover {
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) .article blockquote {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .article-title a {
    color: var(--color-h1) !important;
  }
  :root:not([color-scheme]) details>summary {
    color: var(--color-p) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) details {
    border: 1px solid var(--color-site-bg) !important;
    background: var(--color-site-bg) !important;
  }
  :root:not([color-scheme]) #u-search .modal,
  :root:not([color-scheme]) #u-search .modal-header,
  :root:not([color-scheme]) #u-search .modal-body {
    background: var(--color-card) !important;
  }
  :root:not([color-scheme]) #u-search .modal-body .modal-results .result:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:hover {
    background: var(--color-block) !important;
  }
  :root:not([color-scheme]) .u-search-input:focus {
    background: var(--color-site-body) !important;
  }
}
[color-scheme='dark'] {
  --color-site-body: #1f1f1f;
  --color-read-bkg: #1f1f1f;
  --color-read-post: #262626;
  --color-site-bg: #1f1f1f;
  --color-site-inner: rgba(238,238,238,0.871);
  --color-site-footer: rgba(170,170,170,0.871);
  --color-card: #262626;
  --color-text: rgba(238,238,238,0.871);
  --color-block: #434343;
  --color-codeblock: #1f1f1f;
  --color-inlinecode: #d56d28;
  --color-h1: rgba(255,255,255,0.871);
  --color-h2: rgba(255,255,255,0.871);
  --color-h3: rgba(255,255,255,0.6);
  --color-h4: rgba(255,255,255,0.6);
  --color-h5: rgba(255,255,255,0.6);
  --color-h6: rgba(255,255,255,0.6);
  --color-p: rgba(217,217,217,0.871);
  --color-list: rgba(217,217,217,0.871);
  --color-list-hl: #a13af5;
  --color-meta: rgba(191,191,191,0.871);
  --color-link: rgba(191,191,191,0.871);
  --color-copyright-bkg: #21252b;
}
[color-scheme='dark'] img {
  filter: brightness(70%) !important;
}
[color-scheme='dark'] .blur {
  background: rgba(31,31,31,0.9) !important;
}
[color-scheme='dark'] .white-box.blur {
  background: rgba(38,38,38,0.9) !important;
}
[color-scheme='dark'] .nav-main .u-search-input {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a {
  background: var(--color-block) !important;
}
[color-scheme='dark'] #l_main .article .prev-next>a:hover {
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] .article blockquote {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .article-title a {
  color: var(--color-h1) !important;
}
[color-scheme='dark'] details>summary {
  color: var(--color-p) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] details {
  border: 1px solid var(--color-site-bg) !important;
  background: var(--color-site-bg) !important;
}
[color-scheme='dark'] #u-search .modal,
[color-scheme='dark'] #u-search .modal-header,
[color-scheme='dark'] #u-search .modal-body {
  background: var(--color-card) !important;
}
[color-scheme='dark'] #u-search .modal-body .modal-results .result:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:hover {
  background: var(--color-block) !important;
}
[color-scheme='dark'] .u-search-input:focus {
  background: var(--color-site-body) !important;
}
@media screen and (max-width: 500px) {
  [color-scheme='dark'] .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}
@font-face {
  font-family: 'UbuntuMono';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/UbuntuMono/UbuntuMono-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
@font-face {
  font-family: 'Varela Round';
  src: url("https://unpkg.com/volantis-static@0.0.1654736714924/media/fonts/VarelaRound/VarelaRound-Regular.ttf");
  font-weight: 'normal';
  font-style: 'normal';
  font-display: swap;
}
.l_header {
  position: fixed;
  z-index: 1000;
  top: 0;
  width: 100%;
  height: 64px;
  background: var(--color-card);
  box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
  -webkit-box-shadow: 0 1px 2px 0px rgba(0,0,0,0.1);
}
.l_header.auto {
  transition: opacity 0.4s ease;
  -webkit-transition: opacity 0.4s ease;
  -khtml-transition: opacity 0.4s ease;
  -moz-transition: opacity 0.4s ease;
  -o-transition: opacity 0.4s ease;
  -ms-transition: opacity 0.4s ease;
  visibility: hidden;
}
.l_header.auto.show {
  opacity: 1 !important;
  -webkit-opacity: 1 !important;
  -moz-opacity: 1 !important;
  visibility: visible;
}
.l_header .container {
  margin-left: 16px;
  margin-right: 16px;
}
.l_header #wrapper {
  height: 100%;
  user-select: none;
  -webkit-user-select: none;
  -moz-user-select: none;
  -ms-user-select: none;
}
.l_header #wrapper .nav-main,
.l_header #wrapper .nav-sub {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  flex-wrap: nowrap;
  -webkit-flex-wrap: nowrap;
  -khtml-flex-wrap: nowrap;
  -moz-flex-wrap: nowrap;
  -o-flex-wrap: nowrap;
  -ms-flex-wrap: nowrap;
  justify-content: space-between;
  -webkit-justify-content: space-between;
  -khtml-justify-content: space-between;
  -moz-justify-content: space-between;
  -o-justify-content: space-between;
  -ms-justify-content: space-between;
  align-items: center;
}
.l_header #wrapper .nav-main {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.l_header #wrapper.sub .nav-main {
  transform: translateY(-64px);
  -webkit-transform: translateY(-64px);
  -khtml-transform: translateY(-64px);
  -moz-transform: translateY(-64px);
  -o-transform: translateY(-64px);
  -ms-transform: translateY(-64px);
}
.l_header #wrapper .nav-sub {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  opacity: 0;
  -webkit-opacity: 0;
  -moz-opacity: 0;
  height: 64px;
  width: calc(100% - 2 * 16px);
  position: absolute;
}
.l_header #wrapper .nav-sub ::-webkit-scrollbar {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (min-width: 2048px) {
  .l_header #wrapper .nav-sub {
    max-width: 55vw;
    margin: auto;
  }
}
.l_header #wrapper.sub .nav-sub {
  opacity: 1;
  -webkit-opacity: 1;
  -moz-opacity: 1;
}
.l_header #wrapper .title {
  position: relative;
  color: var(--color-text);
  padding-left: 24px;
  max-height: 64px;
}
.l_header #wrapper .nav-main .title {
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  flex-shrink: 0;
  line-height: 64px;
  padding: 0 24px;
  font-size: 1.25rem;
  font-family: "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Helvetica, monospace;
}
.l_header #wrapper .nav-main .title img {
  height: 64px;
}
.l_header .nav-sub {
  max-width: 1080px;
  margin: auto;
}
.l_header .nav-sub .title {
  font-weight: bold;
  font-family: UbuntuMono, "Varela Round", "PingFang SC", "Microsoft YaHei", Helvetica, Arial, Menlo, Monaco, monospace, sans-serif;
  line-height: 1.2;
  max-height: 64px;
  white-space: normal;
  flex-shrink: 1;
}
.l_header .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  line-height: 64px;
  align-items: center;
}
.l_header .switcher .s-toc {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
}
@media screen and (max-width: 768px) {
  .l_header .switcher .s-toc {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
  }
}
.l_header .switcher >li {
  height: 48px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  margin: 2px;
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li {
    margin: 0 1px;
    height: 48px;
  }
}
.l_header .switcher >li >a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  align-items: center;
  width: 48px;
  height: 48px;
  padding: 0.85em 1.1em;
  border-radius: 100px;
  -webkit-border-radius: 100px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  color: #8a0af3;
}
.l_header .switcher >li >a:hover {
  border: none;
}
.l_header .switcher >li >a.active,
.l_header .switcher >li >a:active {
  border: none;
  background: var(--color-site-bg);
}
@media screen and (max-width: 500px) {
  .l_header .switcher >li >a {
    width: 36px;
    height: 48px;
  }
}
.l_header .nav-sub .switcher {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
}
.l_header .m_search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  height: 64px;
  width: 240px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (max-width: 1024px) {
  .l_header .m_search {
    width: 44px;
    min-width: 44px;
  }
  .l_header .m_search input::placeholder {
    opacity: 0;
    -webkit-opacity: 0;
    -moz-opacity: 0;
  }
  .l_header .m_search:hover {
    width: 240px;
  }
  .l_header .m_search:hover input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (min-width: 500px) {
  .l_header .m_search:hover .input {
    width: 100%;
  }
  .l_header .m_search:hover .input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search {
    min-width: 0;
  }
  .l_header .m_search input::placeholder {
    opacity: 1;
    -webkit-opacity: 1;
    -moz-opacity: 1;
  }
}
.l_header .m_search .form {
  position: relative;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  width: 100%;
  align-items: center;
}
.l_header .m_search .icon {
  position: absolute;
  width: 36px;
  left: 5px;
  color: var(--color-meta);
}
@media screen and (max-width: 500px) {
  .l_header .m_search .icon {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
.l_header .m_search .input {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding-top: 8px;
  padding-bottom: 8px;
  line-height: 1.3;
  width: 100%;
  color: var(--color-text);
  background: #fafafa;
  box-shadow: none;
  -webkit-box-shadow: none;
  box-sizing: border-box;
  -webkit-box-sizing: border-box;
  -moz-box-sizing: border-box;
  padding-left: 40px;
  font-size: 0.875rem;
  border-radius: 8px;
  -webkit-border-radius: 8px;
  border: none;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
@media screen and (min-width: 500px) {
  .l_header .m_search .input:focus {
    box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
    -webkit-box-shadow: 0 4px 8px 0px rgba(0,0,0,0.1);
  }
}
@media screen and (max-width: 500px) {
  .l_header .m_search .input {
    background: var(--color-block);
    padding-left: 8px;
    border: none;
  }
  .l_header .m_search .input:hover,
  .l_header .m_search .input:focus {
    border: none;
  }
}
@media (max-width: 500px) {
  .l_header .m_search {
    left: 0;
    width: 0;
    overflow: hidden;
    position: absolute;
    background: #fff;
    transition: all 0.28s ease;
    -webkit-transition: all 0.28s ease;
    -khtml-transition: all 0.28s ease;
    -moz-transition: all 0.28s ease;
    -o-transition: all 0.28s ease;
    -ms-transition: all 0.28s ease;
  }
  .l_header .m_search .input {
    border-radius: 32px;
    -webkit-border-radius: 32px;
    margin-left: 16px;
    padding-left: 16px;
  }
  .l_header.z_search-open .m_search {
    width: 100%;
  }
  .l_header.z_search-open .m_search .input {
    width: calc(100% - 120px);
  }
}
ul.m-pc >li>a {
  color: inherit;
  border-bottom: 2px solid transparent;
}
ul.m-pc >li>a:active,
ul.m-pc >li>a.active {
  border-bottom: 2px solid #8a0af3;
}
ul.m-pc li:hover >ul.list-v,
ul.list-v li:hover >ul.list-v {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.nav-list-h {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: -ms-flexbox /* TWEENER - IE 10 */;
  display: -webkit-flex /* NEW - Chrome */;
  display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
  display: flex;
  align-items: stretch;
}
ul.nav-list-h>li {
  position: relative;
  justify-content: center;
  -webkit-justify-content: center;
  -khtml-justify-content: center;
  -moz-justify-content: center;
  -o-justify-content: center;
  -ms-justify-content: center;
  height: 100%;
  line-height: 2.4;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
ul.nav-list-h>li >a {
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  font-weight: 600;
}
ul.list-v {
  z-index: 1;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: absolute;
  background: var(--color-card);
  box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  -webkit-box-shadow: 0 2px 4px 0px rgba(0,0,0,0.08), 0 4px 8px 0px rgba(0,0,0,0.08), 0 8px 16px 0px rgba(0,0,0,0.08);
  margin-top: -6px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
  padding: 8px 0;
}
ul.list-v.show {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
}
ul.list-v hr {
  margin-top: 8px;
  margin-bottom: 8px;
}
ul.list-v >li {
  white-space: nowrap;
  word-break: keep-all;
}
ul.list-v >li.header {
  font-size: 0.78125rem;
  font-weight: bold;
  line-height: 2em;
  color: var(--color-meta);
  margin: 8px 16px 4px;
}
ul.list-v >li.header i {
  margin-right: 8px;
}
ul.list-v >li ul {
  margin-left: 0;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: -40px;
}
ul.list-v .aplayer-container {
  min-height: 64px;
  padding: 6px 16px;
}
ul.list-v >li>a {
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  color: var(--color-list);
  font-size: 0.875rem;
  font-weight: bold;
  line-height: 36px;
  padding: 0 20px 0 16px;
  text-overflow: ellipsis;
  margin: 0 4px;
  border-radius: 4px;
  -webkit-border-radius: 4px;
}
@media screen and (max-width: 1024px) {
  ul.list-v >li>a {
    line-height: 40px;
  }
}
ul.list-v >li>a >i {
  margin-right: 8px;
}
ul.list-v >li>a:active,
ul.list-v >li>a.active {
  color: var(--color-list-hl);
}
ul.list-v >li>a:hover {
  color: var(--color-list-hl);
  background: var(--color-site-bg);
}
.l_header .menu >ul>li>a {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: block;
  padding: 0 8px;
}
.l_header .menu >ul>li>a >i {
  margin-right: 4px;
}
.l_header ul.nav-list-h>li {
  color: var(--color-list);
  line-height: 64px;
}
.l_header ul.nav-list-h>li >a {
  max-height: 64px;
  overflow: hidden;
  color: inherit;
}
.l_header ul.nav-list-h>li >a:active,
.l_header ul.nav-list-h>li >a.active {
  color: #8a0af3;
}
.l_header ul.nav-list-h>li:hover>a {
  color: var(--color-list-hl);
}
.l_header ul.nav-list-h>li i.music {
  animation: rotate-effect 1.5s linear infinite;
  -webkit-animation: rotate-effect 1.5s linear infinite;
  -khtml-animation: rotate-effect 1.5s linear infinite;
  -moz-animation: rotate-effect 1.5s linear infinite;
  -o-animation: rotate-effect 1.5s linear infinite;
  -ms-animation: rotate-effect 1.5s linear infinite;
}
@-moz-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-webkit-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@-o-keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
@keyframes rotate-effect {
  0% {
    transform: rotate(0);
    -webkit-transform: rotate(0);
    -khtml-transform: rotate(0);
    -moz-transform: rotate(0);
    -o-transform: rotate(0);
    -ms-transform: rotate(0);
  }
  25% {
    transform: rotate(90deg);
    -webkit-transform: rotate(90deg);
    -khtml-transform: rotate(90deg);
    -moz-transform: rotate(90deg);
    -o-transform: rotate(90deg);
    -ms-transform: rotate(90deg);
  }
  50% {
    transform: rotate(180deg);
    -webkit-transform: rotate(180deg);
    -khtml-transform: rotate(180deg);
    -moz-transform: rotate(180deg);
    -o-transform: rotate(180deg);
    -ms-transform: rotate(180deg);
  }
  75% {
    transform: rotate(270deg);
    -webkit-transform: rotate(270deg);
    -khtml-transform: rotate(270deg);
    -moz-transform: rotate(270deg);
    -o-transform: rotate(270deg);
    -ms-transform: rotate(270deg);
  }
  100% {
    transform: rotate(360deg);
    -webkit-transform: rotate(360deg);
    -khtml-transform: rotate(360deg);
    -moz-transform: rotate(360deg);
    -o-transform: rotate(360deg);
    -ms-transform: rotate(360deg);
  }
}
.menu-phone li ul.list-v {
  right: calc(100% - 0.5 * 16px);
}
.menu-phone li ul.list-v ul {
  right: calc(100% - 0.5 * 16px);
}
#wrapper {
  max-width: 1080px;
  margin: auto;
}
@media screen and (min-width: 2048px) {
  #wrapper {
    max-width: 55vw;
  }
}
#wrapper .menu {
  -webkit-box-flex: 1;
  -moz-box-flex: 1;
  -webkit-flex: 1 1;
  -ms-flex: 1 1;
  flex: 1 1;
  margin: 0 16px 0 0;
}
#wrapper .menu .list-v ul {
  left: calc(100% - 0.5 * 16px);
}
.menu-phone {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  margin-top: 16px;
  right: 8px;
  transition: all 0.28s ease;
  -webkit-transition: all 0.28s ease;
  -khtml-transition: all 0.28s ease;
  -moz-transition: all 0.28s ease;
  -o-transition: all 0.28s ease;
  -ms-transition: all 0.28s ease;
}
.menu-phone ul {
  right: calc(100% - 0.5 * 16px);
}
@media screen and (max-width: 500px) {
  .menu-phone {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: block;
  }
}
.l_header {
  max-width: 65vw;
  left: calc((100% - 65vw) * 0.5);
  border-bottom-left-radius: 8px;
  border-bottom-right-radius: 8px;
}
@media screen and (max-width: 2048px) {
  .l_header {
    max-width: 1112px;
    left: calc((100% - 1112px) * 0.5);
  }
}
@media screen and (max-width: 1112px) {
  .l_header {
    left: 0;
    border-radius: 0;
    -webkit-border-radius: 0;
    max-width: 100%;
  }
}
@media screen and (max-width: 500px) {
  .l_header .container {
    margin-left: 0;
    margin-right: 0;
  }
  .l_header #wrapper .nav-main .title {
    padding-left: 16px;
    padding-right: 16px;
  }
  .l_header #wrapper .nav-sub {
    width: 100%;
  }
  .l_header #wrapper .nav-sub .title {
    overflow-y: scroll;
    margin-top: 2px;
    padding: 8px 16px;
  }
  .l_header #wrapper .switcher {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: -ms-flexbox /* TWEENER - IE 10 */;
    display: -webkit-flex /* NEW - Chrome */;
    display: flex /* NEW, Spec - Opera 12.1, Firefox 20+ */;
    display: flex;
    margin-right: 8px;
  }
  .l_header .menu {
    display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
    display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
    display: none;
  }
}
@media screen and (max-width: 500px) {
  .list-v li {
    max-width: 270px;
  }
}
#u-search {
  display: -webkit-box /* OLD - iOS 6-, Safari 3.1-6 */;
  display: -moz-box /* OLD - Firefox 19- (buggy but mostly works) */;
  display: none;
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  padding: 60px 20px;
  z-index: 1001;
}
@media screen and (max-width: 680px) {
  #u-search {
    padding: 0px;
  }
}
@media screen and (prefers-color-scheme: dark) and (max-width: 500px) {
  .l_header .m_search {
    background: var(--color-site-bg) !important;
  }
}

  </style>
  <link rel="stylesheet" href="/css/style.659c7404.css" media="print" onload="this.media='all';this.onload=null">
  <noscript><link rel="stylesheet" href="/css/style.659c7404.css"></noscript>
    <script>
      let userColorScheme=localStorage.getItem("color-scheme")
      if(userColorScheme){
        document.documentElement.setAttribute("color-scheme", userColorScheme);
      }
    </script>
  
<script>
if (/*@cc_on!@*/false || (!!window.MSInputMethodContext && !!document.documentMode))
    document.write(
	'<style>'+
		'html{'+
			'overflow-x: hidden !important;'+
			'overflow-y: hidden !important;'+
		'}'+
		'.kill-ie{'+
			'text-align:center;'+
			'height: 100%;'+
			'margin-top: 15%;'+
			'margin-bottom: 5500%;'+
		'}'+
    '.kill-t{'+
      'font-size: 2rem;'+
    '}'+
    '.kill-c{'+
      'font-size: 1.2rem;'+
    '}'+
		'#l_header,#l_body{'+
			'display: none;'+
		'}'+
	'</style>'+
    '<div class="kill-ie">'+
        `<span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>`+
        `<span class="kill-c">微软已经于2016年终止了对 Internet Explorer (IE) 10 及更早版本的支持，<br/>继续使用存在极大的安全隐患，请使用当代主流的浏览器进行访问。</span><br/>`+
        `<a target="_blank" rel="noopener" href="https://blogs.windows.com/windowsexperience/2021/05/19/the-future-of-internet-explorer-on-windows-10-is-in-microsoft-edge/"><strong>了解详情 ></strong></a>`+
    '</div>');
</script>


<noscript>
	<style>
		html{
			overflow-x: hidden !important;
			overflow-y: hidden !important;
		}
		.kill-noscript{
			text-align:center;
			height: 100%;
			margin-top: 15%;
			margin-bottom: 5500%;
		}
    .kill-t{
      font-size: 2rem;
    }
    .kill-c{
      font-size: 1.2rem;
    }
		#l_header,#l_body{
			display: none;
		}
	</style>
    <div class="kill-noscript">
        <span class="kill-t"><b>抱歉，您的浏览器无法访问本站</b></span><br/>
        <span class="kill-c">本页面需要浏览器支持（启用）JavaScript</span><br/>
        <a target="_blank" rel="noopener" href="https://www.baidu.com/s?wd=启用JavaScript"><strong>了解详情 ></strong></a>
    </div>
</noscript>


  <script>
  /************这个文件存放不需要重载的全局变量和全局函数*********/
  window.volantis = {}; // volantis 全局变量
  volantis.debug = false; // 开启调试模式
  volantis.dom = {}; // 页面Dom see: /source/js/app.js etc.

  volantis.GLOBAL_CONFIG ={
    debug: false,
    cdn: {"js":{"app":"/js/app.af2d54c8.js","parallax":"/js/plugins/parallax.8bf0ab10.js","rightMenu":"/js/plugins/rightMenu.d9437285.js","rightMenus":"/js/plugins/rightMenus.1aa99ff1.js","sites":"/js/plugins/tags/sites.76bf19b8.js","friends":"/js/plugins/tags/friends.f372da57.js","contributors":"/js/plugins/tags/contributors.aec80453.js","search":"/js/search/hexo.0e52f222.js"},"css":{"style":"/css/style.659c7404.css"}},
    default: {"avatar":null,"link":null,"cover":null,"image":null},
    lastupdate: new Date(1661220170750),
    sidebar: {
      for_page: ["blogger","navigation","music","webinfo","category","tagcloud","lastupdate"],
      for_post: ["toc"],
      webinfo: {
        lastupd: {
          enable: true,
          friendlyShow: true
        },
        runtime: {
          data: "2022/08/22",
          unit: "天"
        }
      }
    },
    plugins: {
      message: {"enable":true,"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/css/iziToast.min.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/izitoast/dist/js/iziToast.min.js","icon":{"default":"fa-solid fa-info-circle light-blue","quection":"fa-solid fa-question-circle light-blue"},"time":{"default":5000,"quection":20000},"position":"topRight","transitionIn":"bounceInLeft","transitionOut":"fadeOutRight","titleColor":"var(--color-text)","messageColor":"var(--color-text)","backgroundColor":"var(--color-card)","zindex":2147483647,"copyright":{"enable":true,"title":"知识共享许可协议","message":"请遵守 CC BY-NC-SA 4.0 协议。","icon":"far fa-copyright light-blue"},"aplayer":{"enable":true,"play":"fa-solid fa-play","pause":"fa-solid fa-pause"},"rightmenu":{"enable":true,"notice":true}},
      fancybox: {"css":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.css","js":"https://unpkg.com/volantis-static@0.0.1654736714924/libs/@fancyapps/ui/dist/fancybox.umd.js"},
      
      aplayer: {
        id: 8413384953,
        enable:true
      },
      
      
      
      rightmenus: {"enable":true,"order":["plugins.navigation","hr","plugins.inputBox","plugins.seletctText","plugins.elementCheck","plugins.elementImage","menus.link","hr","menus.darkMode","plugins.articlePage","music"],"options":{"iconPrefix":"fa-solid","articleShowLink":true,"musicAlwaysShow":true},"plugins":{"navigation":[{"id":"left","name":"转到上一页","icon":"fa-solid fa-arrow-left","event":"history.back()","group":"navigation"},{"id":"right","name":"转到下一页","icon":"fa-solid fa-arrow-right","event":"history.forward()","group":"navigation"},{"id":"redo","name":"刷新当前页面","icon":"fa-solid fa-redo","event":"window.location.reload()","group":"navigation"},{"id":"up","name":"回到顶部","icon":"fa-solid fa-arrow-up","event":"VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)","group":"navigation"},{"id":"home","name":"回到首页","icon":"fa-solid fa-home","link":"/","group":"navigation"}],"inputBox":[{"id":"copyPaste","name":"粘贴文本","icon":"fa-solid fa-paste","event":"copyPaste","group":"inputBox"},{"id":"copyAll","name":"全选文本","icon":"fa-solid fa-object-ungroup","event":"copyAll","group":"inputBox"},{"id":"copyCut","name":"剪切文本","icon":"fa-solid fa-cut","event":"copyCut","group":"inputBox"}],"seletctText":[{"id":"copyText","name":"复制文本","icon":"fa-solid fa-copy","event":"copyText","group":"seletctText"},{"id":"searchWord","name":"站内搜索","icon":"fa-solid fa-search","event":"OpenSearch(__text__)","group":"seletctText"},{"id":"bingSearch","name":"必应搜索","icon":"fa-solid fa-search","event":"window.open(`https://cn.bing.com/search?q=${__text__}`)","group":"seletctText"},{"id":"googleSearch","name":"谷歌搜索","icon":"fa-solid fa-search","event":"window.open(`https://www.google.com/search?q=${__text__}`)","group":"seletctText"}],"elementCheck":[{"id":"openTab","name":"新标签页打开","icon":"fa-solid fa-external-link-square-alt","event":"window.open(__link__)","group":"elementCheck"},{"id":"copyLink","name":"复制链接地址","icon":"fa-solid fa-link","event":"copyLink","group":"elementCheck"}],"elementImage":[{"id":"copyImg","name":"复制图片","icon":"fa-solid fa-image","event":"copyImg","group":"elementImage"},{"id":"googleImg","name":"谷歌识图","icon":"fa-solid fa-images","event":"window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)","group":"elementImage"}],"articlePage":[{"id":"printMode","name":"打印页面","icon":"fa-solid fa-print","event":"printMode","group":"articlePage"},{"id":"readMode","name":"阅读模式","icon":"fa-solid fa-book-open","event":"readMode","group":"articlePage"}]},"menus":{"link":[{"id":"github","name":"本站源码","icon":"fa-solid fa-code-branch SUNFLOWER","link":"https://github.com/rainvex","group":"link"},{"id":"friends","name":"我的朋友们","icon":"fa-solid fa-flower-daffodil AMETHYST","link":"friends/","group":"link"},{"id":"archive","name":"文章归档","icon":"fa-solid fa-globe-asia CONCRETE","link":"archives/","group":"link"},{"id":"about","name":"关于我","icon":"fa-solid fa-gingerbread-man WISTERIA","link":"about/","group":"link"}],"darkMode":[{"id":"darkMode","name":"暗黑模式","icon":"fa-solid fa-eclipse-alt WISTERIA","event":"volantis.dark.toggle()","group":"darkMode"}]}}
      
    }
  }

  /******************** volantis.EventListener ********************************/
  // 事件监听器 see: /source/js/app.js
  volantis.EventListener = {}
  // 这里存放pjax切换页面时将被移除的事件监听器
  volantis.EventListener.list = []
  //构造方法
  function volantisEventListener(type, f, ele) {
    this.type = type
    this.f = f
    this.ele = ele
  }
  // 移除事件监听器
  volantis.EventListener.remove = () => {
    volantis.EventListener.list.forEach(function (i) {
      i.ele.removeEventListener(i.type, i.f, false)
    })
    volantis.EventListener.list = []
  }
  /******************** volantis.dom.$ ********************************/
  // 注：这里没有选择器，也没有forEach一次只处理一个dom，这里重新封装主题常用的dom方法，返回的是dom对象，对象包含了以下方法，同时保留dom的原生API
  function volantisDom(ele) {
    if (!ele) ele = document.createElement("div")
    this.ele = ele;
    // ==============================================================
    this.ele.find = (c) => {
      let q = this.ele.querySelector(c)
      if (q)
        return new volantisDom(q)
    }
    // ==============================================================
    this.ele.hasClass = (c) => {
      return this.ele.className.match(new RegExp('(\\s|^)' + c + '(\\s|$)'));
    }
    this.ele.addClass = (c) => {
      this.ele.classList.add(c);
      return this.ele
    }
    this.ele.removeClass = (c) => {
      this.ele.classList.remove(c);
      return this.ele
    }
    this.ele.toggleClass = (c) => {
      if (this.ele.hasClass(c)) {
        this.ele.removeClass(c)
      } else {
        this.ele.addClass(c)
      }
      return this.ele
    }
    // ==============================================================
    // 参数 r 为 true 表示pjax切换页面时事件监听器将被移除，false不移除
    this.ele.on = (c, f, r = 1) => {
      this.ele.addEventListener(c, f, false)
      if (r) {
        volantis.EventListener.list.push(new volantisEventListener(c, f, this.ele))
      }
      return this.ele
    }
    this.ele.click = (f, r) => {
      this.ele.on("click", f, r)
      return this.ele
    }
    this.ele.scroll = (f, r) => {
      this.ele.on("scroll", f, r)
      return this.ele
    }
    // ==============================================================
    this.ele.html = (c) => {
      // if(c=== undefined){
      //   return this.ele.innerHTML
      // }else{
      this.ele.innerHTML = c
      return this.ele
      // }
    }
    // ==============================================================
    this.ele.hide = (c) => {
      this.ele.style.display = "none"
      return this.ele
    }
    this.ele.show = (c) => {
      this.ele.style.display = "block"
      return this.ele
    }
    // ==============================================================
    return this.ele
  }
  volantis.dom.$ = (ele) => {
    return !!ele ? new volantisDom(ele) : null;
  }
  /******************** RunItem ********************************/
  function RunItem() {
    this.list = []; // 存放回调函数
    this.start = () => {
      for (var i = 0; i < this.list.length; i++) {
        this.list[i].run();
      }
    };
    this.push = (fn, name, setRequestAnimationFrame = true) => {
      let myfn = fn
      if (setRequestAnimationFrame) {
        myfn = ()=>{
          volantis.requestAnimationFrame(fn)
        }
      }
      var f = new Item(myfn, name);
      this.list.push(f);
    };
    this.remove = (name) =>{
      for (let index = 0; index < this.list.length; index++) {
        const e = this.list[index];
        if (e.name == name) {
          this.list.splice(index,1);
        }
      }
    }
    // 构造一个可以run的对象
    function Item(fn, name) {
      // 函数名称
      this.name = name || fn.name;
      // run方法
      this.run = () => {
        try {
          fn()
        } catch (error) {
          console.log(error);
        }
      };
    }
  }
  /******************** Pjax ********************************/
  // /layout/_plugins/pjax/index.ejs
  // volantis.pjax.send(callBack[,"callBackName"]) 传入pjax:send回调函数
  // volantis.pjax.push(callBack[,"callBackName"]) 传入pjax:complete回调函数
  // volantis.pjax.error(callBack[,"callBackName"]) 传入pjax:error回调函数
  volantis.pjax = {};
  volantis.pjax.method = {
    complete: new RunItem(),
    error: new RunItem(),
    send: new RunItem(),
  };
  volantis.pjax = Object.assign(volantis.pjax, {
    push: volantis.pjax.method.complete.push,
    error: volantis.pjax.method.error.push,
    send: volantis.pjax.method.send.push,
  });
  /******************** RightMenu ********************************/
  // volantis.rightmenu.handle(callBack[,"callBackName"]) 外部菜单项控制
  // 可在 volantis.mouseEvent 处获取右键事件
  volantis.rightmenu = {};
  volantis.rightmenu.method = {
    handle: new RunItem(),
  }
  volantis.rightmenu = Object.assign(volantis.rightmenu, {
    handle: volantis.rightmenu.method.handle.push,
  });
  /********************  Dark Mode  ********************************/
  // /layout/_partial/scripts/darkmode.ejs
  // volantis.dark.mode 当前模式 dark or light
  // volantis.dark.toggle() 暗黑模式触发器
  // volantis.dark.push(callBack[,"callBackName"]) 传入触发器回调函数
  volantis.dark = {};
  volantis.dark.method = {
    toggle: new RunItem(),
  };
  volantis.dark = Object.assign(volantis.dark, {
    push: volantis.dark.method.toggle.push,
  });
  /********************  Message  ********************************/
  // VolantisApp.message
  /********************  isMobile  ********************************/
  // /source/js/app.js
  // volantis.isMobile
  // volantis.isMobileOld
  /********************脚本动态加载函数********************************/
  // volantis.js(src, cb)  cb 可以传入onload回调函数 或者 JSON对象 例如: volantis.js("src", ()=>{}) 或 volantis.js("src", {defer:true,onload:()=>{}})
  // volantis.css(src)

  // 返回Promise对象，如下方法同步加载资源，这利于处理文件资源之间的依赖关系，例如：APlayer 需要在 MetingJS 之前加载
  // (async () => {
  //     await volantis.js("...theme.plugins.aplayer.js.aplayer...")
  //     await volantis.js("...theme.plugins.aplayer.js.meting...")
  // })();

  // 已经加入了setTimeout
  volantis.js = (src, cb) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var HEAD = document.getElementsByTagName("head")[0] || document.documentElement;
        var script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        if (cb) {
          if (JSON.stringify(cb)) {
            for (let p in cb) {
              if (p == "onload") {
                script[p] = () => {
                  cb[p]()
                  resolve()
                }
              } else {
                script[p] = cb[p]
                script.onload = resolve
              }
            }
          } else {
            script.onload = () => {
              cb()
              resolve()
            };
          }
        } else {
          script.onload = resolve
        }
        script.setAttribute("src", src);
        HEAD.appendChild(script);
      });
    });
  }
  volantis.css = (src) => {
    return new Promise(resolve => {
      setTimeout(function () {
        var link = document.createElement('link');
        link.rel = "stylesheet";
        link.href = src;
        link.onload = resolve;
        document.getElementsByTagName("head")[0].appendChild(link);
      });
    });
  }
  /********************按需加载的插件********************************/
  // volantis.import.jQuery().then(()=>{})
  volantis.import = {
    jQuery: () => {
      if (typeof jQuery == "undefined") {
        return volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/jquery/dist/jquery.min.js")
      } else {
        return new Promise(resolve => {
          resolve()
        });
      }
    }
  }
  /********************** requestAnimationFrame ********************************/
  // 1、requestAnimationFrame 会把每一帧中的所有 DOM 操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。
  // 2、在隐藏或不可见的元素中，requestAnimationFrame 将不会进行重绘或回流，这当然就意味着更少的的 cpu，gpu 和内存使用量。
  volantis.requestAnimationFrame = (fn)=>{
    if (!window.requestAnimationFrame) {
      window.requestAnimationFrame = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame;
    }
    window.requestAnimationFrame(fn)
  }
  /************************ layoutHelper *****************************************/
  volantis.layoutHelper = (helper, html, opt)=>{
    opt = Object.assign({clean:false, pjax:true}, opt)
    function myhelper(helper, html, clean) {
      volantis.tempDiv = document.createElement("div");
      volantis.tempDiv.innerHTML = html;
      let layoutHelper = document.querySelector("#layoutHelper-"+helper)
      if (layoutHelper) {
        if (clean) {
          layoutHelper.innerHTML = ""
        }
        layoutHelper.append(volantis.tempDiv);
      }
    }
    myhelper(helper, html, opt.clean)
    if (opt.pjax) {
      volantis.pjax.push(()=>{
        myhelper(helper, html, opt.clean)
      },"layoutHelper-"+helper)
    }
  }
  /****************************** 滚动事件处理 ****************************************/
  volantis.scroll = {
    engine: new RunItem(),
    unengine: new RunItem(),
  };
  volantis.scroll = Object.assign(volantis.scroll, {
    push: volantis.scroll.engine.push,
  });
  // 滚动条距离顶部的距离
  volantis.scroll.getScrollTop = () =>{
    let scrollPos;
    if (window.pageYOffset) {
      scrollPos = window.pageYOffset;
    } else if (document.compatMode && document.compatMode != 'BackCompat') {
      scrollPos = document.documentElement.scrollTop;
    } else if (document.body) {
      scrollPos = document.body.scrollTop;
    }
    return scrollPos;
  }
  // 使用 requestAnimationFrame 处理滚动事件
  // `volantis.scroll.del` 中存储了一个数值, 该数值检测一定时间间隔内滚动条滚动的位移, 数值的检测频率是浏览器的刷新频率. 数值为正数时, 表示向下滚动. 数值为负数时, 表示向上滚动.
  volantis.scroll.handleScrollEvents = () => {
    volantis.scroll.lastScrollTop = volantis.scroll.getScrollTop()
    function loop() {
      const scrollTop = volantis.scroll.getScrollTop();
      if (volantis.scroll.lastScrollTop !== scrollTop) {
        volantis.scroll.del = scrollTop - volantis.scroll.lastScrollTop;
        volantis.scroll.lastScrollTop = scrollTop;
        // if (volantis.scroll.del > 0) {
        //   console.log("向下滚动");
        // } else {
        //   console.log("向上滚动");
        // }
        // 注销过期的unengine未滚动事件
        volantis.scroll.unengine.list=[]
        volantis.scroll.engine.start();
      }else{
        volantis.scroll.unengine.start();
      }
      volantis.requestAnimationFrame(loop)
    }
    volantis.requestAnimationFrame(loop)
  }
  volantis.scroll.handleScrollEvents()
  // 触发页面滚动至目标元素位置
  volantis.scroll.to = (ele, option = {}) =>{
    // 默认配置
    opt = {
      top: ele.getBoundingClientRect().top + document.documentElement.scrollTop,
      behavior: "smooth"
    }
    // 定义配置
    if ("top" in option) {
      opt.top = option.top
    }
    if ("behavior" in option) {
      opt.behavior = option.behavior
    }
    if ("addTop" in option) {
      opt.top += option.addTop
    }
    if (!("observerDic" in option)) {
      option.observerDic = 100
    }
    // 滚动
    window.scrollTo(opt);
    // 监视器
    // 监视并矫正元素滚动到指定位置
    // 用于处理 lazyload 引起的 cls 导致的定位失败问题
    // option.observer = false
    if (option.observer) {
      setTimeout(()=>{
        volantis.scroll.unengine.push(()=>{
          let me = ele.getBoundingClientRect().top
          if(!(me >= -option.observerDic && me <= option.observerDic)){
            volantis.scroll.to(ele, option)
          }
          volantis.scroll.unengine.remove("unengineObserver")
        },"unengineObserver")
      },1000)
    }
  }
  /********************** Content Visibility ********************************/
  // 见 source/css/first.styl 如果遇到任何问题 删除 .post-story 即可
  // 一个元素被声明 content-visibility 属性后 如果元素不在 viewport 中 浏览器不会计算其后代元素样式和属性 从而节省 Style & Layout 耗时
  // content-visibility 的副作用: 锚点失效 等等(实验初期 暂不明确), 使用此方法清除样式
  volantis.cleanContentVisibility = ()=>{
    if (document.querySelector(".post-story")) {
      console.log("cleanContentVisibility");
      document.querySelectorAll(".post-story").forEach(e=>{
        e.classList.remove("post-story")
      })
    }
  }
  /******************************************************************************/
  /******************************************************************************/
  /******************************************************************************/
  //图像加载出错时的处理
  function errorImgAvatar(img) {
    img.src = "";
    img.onerror = null;
  }
  function errorImgCover(img) {
    img.src = "";
    img.onerror = null;
  }
  /******************************************************************************/
</script>

  <!-- import head_end begin -->
  <!-- import head_end end -->
  <!-- Custom Files headEnd begin-->
  
  <!-- Custom Files headEnd end-->
</head>
  <body itemscope itemtype="http://schema.org/WebPage">
    <!-- import body_begin begin-->
    <!-- import body_begin end-->
    <!-- Custom Files bodyBegin begin-->
    
    <!-- Custom Files bodyBegin end-->
    <header itemscope itemtype="http://schema.org/WPHeader" id="l_header" class="l_header auto shadow floatable blur " style='opacity: 0' >
  <div class='container'>
  <div id='wrapper'>
    <div class='nav-sub'>
      <p class="title"></p>
      <ul class='switcher nav-list-h m-phone' id="pjax-header-nav-list">
        <li><a id="s-comment" class="fa-solid fa-comments fa-fw" target="_self"  href="/" onclick="return false;" title="comment"></a></li>
        
          <li><a id="s-toc" class="s-toc fa-solid fa-list fa-fw" target="_self"  href="/" onclick="return false;" title="toc"></a></li>
        
      </ul>
    </div>
		<div class="nav-main">
      
        
        <a class="title flat-box" target="_self" href='/'>
          
          
          
            夜雨声烦<sup style="color:#00ff90">dev</sup>
          
        </a>
      

			<div class='menu navigation'>
				<ul class='nav-list-h m-pc'>
          
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="主页"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-light fa-house fa-fw'></i>主页
                </a>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="文章"
                  
                  
                  >
                  <i class='fa-light fa-book-open-reader fa-fw'></i>文章
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-light fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-light fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-light fa-box-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="导航"
                  
                  
                  >
                  <i class='fa-light fa-cube fa-fw'></i>导航
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-light fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/info/" title="留言板"
                  
                  
                  
                    active-action="action-info"
                  >
                  <i class='fa-light fa-message-dots fa-fw'></i>留言板
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-light fa-circle-info fa-fw'></i>关于
                </a>
                
              </li>
            
          
                    
                      
            
              <hr>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/anime/" title="番剧"
                  
                  
                  
                    active-action="action-anime"
                  >
                  <i class='fa-light fa-video fa-spin fa-fw'></i>番剧
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
            
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="功能"
                  
                  
                  >
                  <i class='fa-light fa-screwdriver-wrench fa-fw'></i>功能
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-light fa-moon fa-fw'></i>深色模式
                </a>
              <li>
            
          
                    
                      
            
              
                <li>
                  <a class="menuitem flat-box">
                    <i class='fa-light fa-compact-disc fa-fw music'></i>背景音乐
                  </a>
                  <ul class="list-v">
                    <li>
                      <div class="aplayer-container">
                        

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='200px'
      server='tencent'
      type='playlist'
      id='8413384953'
      list-folded='true'>
    </meting-js>
  


                      </div>
                    </li>
                  </ul>
                <li>
              
            
          
                    
                      
            
              <hr>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/atom.xml" title="RSS 订阅"
                  
                  
                  
                    active-action="action-atomxml"
                  >
                  <i class='fa-light fa-rss fa-fw'></i>RSS 订阅
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
          
				</ul>
			</div>
      
      <div class="m_search">
        <form name="searchform" class="form u-search-form">
          <i class="icon fa-solid fa-search fa-fw"></i>
          <input type="text" class="input u-search-input" placeholder="搜索" />
        </form>
      </div>
      

			<ul class='switcher nav-list-h m-phone'>
				
					<li><a class="s-search fa-solid fa-search fa-fw" target="_self" href="/" onclick="return false;" title="search"></a></li>
				
				<li>
          <a class="s-menu fa-solid fa-bars fa-fw" target="_self" href="/" onclick="return false;" title="menu"></a>
          <ul class="menu-phone list-v navigation white-box">
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/" title="主页"
                  
                  
                  
                    active-action="action-home"
                  >
                  <i class='fa-light fa-house fa-fw'></i>主页
                </a>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="文章"
                  
                  
                  >
                  <i class='fa-light fa-book-open-reader fa-fw'></i>文章
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/categories/" title="分类"
                  
                  
                  
                    active-action="action-categories"
                  >
                  <i class='fa-light fa-folder-open fa-fw'></i>分类
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/tags/" title="标签"
                  
                  
                  
                    active-action="action-tags"
                  >
                  <i class='fa-light fa-tags fa-fw'></i>标签
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/archives/" title="归档"
                  
                  
                  
                    active-action="action-archives"
                  >
                  <i class='fa-light fa-box-archive fa-fw'></i>归档
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="导航"
                  
                  
                  >
                  <i class='fa-light fa-cube fa-fw'></i>导航
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/friends/" title="友链"
                  
                  
                  
                    active-action="action-friends"
                  >
                  <i class='fa-light fa-link fa-fw'></i>友链
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/info/" title="留言板"
                  
                  
                  
                    active-action="action-info"
                  >
                  <i class='fa-light fa-message-dots fa-fw'></i>留言板
                </a>
                
              </li>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/about/" title="关于"
                  
                  
                  
                    active-action="action-about"
                  >
                  <i class='fa-light fa-circle-info fa-fw'></i>关于
                </a>
                
              </li>
            
          
                    
                      
            
              <hr>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/anime/" title="番剧"
                  
                  
                  
                    active-action="action-anime"
                  >
                  <i class='fa-light fa-video fa-spin fa-fw'></i>番剧
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
              
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                 href="/" onclick="return false;" title="功能"
                  
                  
                  >
                  <i class='fa-light fa-screwdriver-wrench fa-fw'></i>功能
                </a>
                
                  <ul class="list-v">
                    
                      
            
              <li>
                <a class="menuitem flat-box header toggle-mode-btn">
                  <i class='fa-light fa-moon fa-fw'></i>深色模式
                </a>
              <li>
            
          
                    
                      
            
              
            
          
                    
                      
            
              <hr>
            
          
                    
                      
            
              <li>
                <a class="menuitem flat-box faa-parent animated-hover"
                href="/atom.xml" title="RSS 订阅"
                  
                  
                  
                    active-action="action-atomxml"
                  >
                  <i class='fa-light fa-rss fa-fw'></i>RSS 订阅
                </a>
                
              </li>
            
          
                    
                  </ul>
                
              </li>
            
          
            
          </ul>
        </li>
			</ul>

      <!-- Custom Files header begin -->
      
      <!-- Custom Files header end -->
		</div>
	</div>
  </div>
</header>

    <div id="l_body">
      <div id="l_cover">
  
    
      <!-- see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs -->
      <div id="half" class='cover-wrapper post dock' style="display: ;">
        
  <div id="parallax-window"></div>

<div class='cover-body'>
  <div class='top'>
    
    
      <p class="title">夜雨声烦</p>
    
    
      <p class="subtitle">Rainvex</p>
    
  </div>
  <div class='bottom'>
    <div class='menu navigation'>
      <div class='list-h'>
        
          
            <a href="/"
              
              
              active-action="action-home">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f4f0.svg'><p>博客</p>
            </a>
          
            <a href="/categories/"
              
              
              active-action="action-categories">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5c3.svg'><p>分类</p>
            </a>
          
            <a href="/tags/"
              
              
              active-action="action-tags">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5d2.svg'><p>标签</p>
            </a>
          
            <a href="/archives/"
              
              
              active-action="action-archives">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5de.svg'><p>归档</p>
            </a>
          
            <a href="/friends/"
              
              
              active-action="action-friends">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f4e2.svg'><p>友链</p>
            </a>
          
            <a href="/about/"
              
              
              active-action="action-about">
              <img src='https://unpkg.com/volantis-static@0.0.1654736714924/media/twemoji/assets/svg/1f5a5.svg'><p>关于</p>
            </a>
          
        
      </div>
    </div>
  </div>
</div>

        <div id="scroll-down" style="display: none;"><i class="fa fa-chevron-down scroll-down-effects"></i></div>
      </div>
    
  
</div>

      <div id="safearea">
        <div class="body-wrapper">
          
<div id="l_main" class=''>
  <article itemscope itemtype="http://schema.org/Article" class="article post white-box reveal md shadow floatable article-type-post" id="post" itemscope itemprop="blogPost">
  <link itemprop="mainEntityOfPage" href="http://rainvex.com/categories/后端/JavaSE学习笔记.html">
  <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
    <meta itemprop="name" content="夜雨声烦">
  </span>
  <span hidden itemprop="post" itemscope itemtype="http://schema.org/Post">
    <meta itemprop="name" content="夜雨声烦">
    <meta itemprop="description" content="夜雨声烦的个人博客">
  </span>
  


  
    <div class='headimg-div'>
      <a class='headimg-a'>
        <img itemprop="image" class='headimg' src='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Java.png'/>
      </a>
    </div>
  
  <div class="article-meta" id="top">
    
      

  
    <meting-js
      mini='true'
      volume='0.7'
      loop='all'
      order='random'
      server='tencent'
      type='playlist'
      id='8413384953'>
    </meting-js>
  


    
    
    
      <h1 class="title" itemprop="name headline">
        JavaSE学习笔记
      </h1>
      <div class='new-meta-box'>
        
          
            
<div class='new-meta-item author' itemprop="author" itemscope itemtype="http://schema.org/Person">
  <a itemprop="url" class='author' href="/" rel="nofollow">
    <img itemprop="image" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/avatar.jpg" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/avatar.jpg" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
    <p itemprop="name">夜雨声烦</p>
  </a>
</div>

          
        
          
            
  <div class="new-meta-item wordcount">
    <a class='notlink'>
      <i class="fa-solid fa-keyboard fa-fw" aria-hidden="true"></i>
      <p>字数：89.6k 字</p>
    </a>
  </div>
  <div class="new-meta-item readtime">
    <a class='notlink'>
      <i class="fa-solid fa-hourglass-half fa-fw" aria-hidden="true"></i>
      <p>时长：373 分钟</p>
    </a>
  </div>


          
        
          
            
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url"><span itemprop="name">后端</span></a>
      </span>
    
  </div>


          
        
          
            <div class="new-meta-item date" itemprop="dateCreated datePublished" datetime="2022-03-27T21:38:17+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-calendar-days fa-fw" aria-hidden="true"></i>
    <p>发布于：2022年3月27日</p>
  </a>
</div>

          
        
          
            


<div class="new-meta-item browse">
  <a class='notlink'>
    <p>
      <i class="fa-solid fa-eye fa-fw" aria-hidden="true"></i>
      
      <span id="lc-pv" data-title="JavaSE学习笔记" data-path="/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0">
        <span id='number'><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span>
      </span>
      
      <span>次浏览</span>
    </p>
  </a>
</div>


          
        
        <!-- Custom Files topMeta begin-->
        
        <!-- Custom Files topMeta end-->
      </div>
    
  </div>


  <div id="layoutHelper-page-plugins"></div>
  <div id="post-body" itemprop="articleBody">
    <h1 id="JavaSE学习笔记"><a href="#JavaSE学习笔记" class="headerlink" title="JavaSE学习笔记"></a>JavaSE学习笔记</h1><p>JDK8官方文档查看：<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/8/docs/api/">https://docs.oracle.com/javase/8/docs/api/</a></p>
<h2 id="一、Java基础语法"><a href="#一、Java基础语法" class="headerlink" title="一、Java基础语法"></a>一、Java基础语法</h2><h3 id="1-1-数据类型"><a href="#1-1-数据类型" class="headerlink" title="1.1 数据类型"></a>1.1 数据类型</h3><p>Java是强类型语言，要求变量的使用要严格符合规定，所有变量必须定义后才能使用</p>
<p>Java的数据类型分为两大类：基本类型和引用类型</p>
<p>位（bit）：是计算机内部数据储存的最小单位</p>
<p>字节（byte）：是计算机中数据处理的基本单位，习惯用大写B表示</p>
<p>1B=8bit，1024B=1KB，1024KB=1M，1024M=1G</p>
<h4 id="1-1-1-基本数据类型"><a href="#1-1-1-基本数据类型" class="headerlink" title="1.1.1 基本数据类型"></a>1.1.1 基本数据类型</h4><p>基本数据类型又分为数值类型和boolean类型</p>
<blockquote>
<p>数值类型</p>
<blockquote>
<p>整数类型</p>
<ul>
<li><p><code>byte</code>占1个字节范围：-128~127</p>
</li>
<li><p><code>short</code>占2个字节范围：-32768~32767</p>
</li>
<li><p><code>int</code>占4个字节范围：-2147483648~2147483647</p>
</li>
<li><p><code>long</code>占8个字节范围</p>
</li>
</ul>
<p>浮点类型</p>
<ul>
<li><code>float</code>占4个字节</li>
<li><code>double</code>占8个字节</li>
</ul>
<p>字符类型</p>
<ul>
<li><code>char</code>占2个字节</li>
</ul>
</blockquote>
</blockquote>
<p><strong>注：字符串String不是关键字，是类；最好完全使用浮点数进行比较</strong></p>
<blockquote>
<p>boolean类型</p>
<ul>
<li>占1个字节，值只有true和false两个</li>
</ul>
</blockquote>
<h4 id="1-1-2-引用数据类型"><a href="#1-1-2-引用数据类型" class="headerlink" title="1.1.2 引用数据类型"></a>1.1.2 引用数据类型</h4><p>引用数据类型分为类、接口、数组</p>
<h4 id="1-1-3-类型转换"><a href="#1-1-3-类型转换" class="headerlink" title="1.1.3 类型转换"></a>1.1.3 类型转换</h4><p>运算中，不同类型的数据先转换为同一类型，然后进行运算</p>
<p>数据类型范围小的数据转化为数据类型范围大的数据不需要进行强制转换；范围大的转化为范围小的需要进行强制转换，但是数据精度可能会有丢失</p>
<p>即，<!--高->低   强制转换    低->高   自动转换--></p>
<p>注：不能对布尔值进行转换；不能把对象类型转换为不相干的类型；转换的时候可能出现内存溢出或者精度问题</p>
<h4 id="1-1-4-赋值问题"><a href="#1-1-4-赋值问题" class="headerlink" title="1.1.4 赋值问题"></a>1.1.4 赋值问题</h4><p>操作比较大的数的时候，需要注意溢出问题</p>
<pre><code class="java">int money = 1000000000;
int year = 20;
int total = money*year; //此时的total已经溢出，输出的结果就不是20000000000
long total2 = money*year; //此时输出total2的值也是错的，因为money*year作为int类型赋值给long类型的total2之前得到的值就已经出现了问题，所以应该在计算之前就进行转换，即第三种
long total3 = (long)money*year; //此时因为将money强制转化为long类型，所以运算是按照数据范围更大的long类型进行运算，所以此时输出total3是正确的值；money*(long)year也行
</code></pre>
<h3 id="1-2-变量"><a href="#1-2-变量" class="headerlink" title="1.2 变量"></a>1.2 变量</h3><h4 id="1-2-1-变量声明"><a href="#1-2-1-变量声明" class="headerlink" title="1.2.1 变量声明"></a>1.2.1 变量声明</h4><p>Java是一种强类型语言，每个变量都必须声明其类型</p>
<p>Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域</p>
<pre><code class="java">type varName[=value] [&#123;,varName[=value]&#125;] ;
//数据类型变量名=值;可以使用逗号隔开来声明多个同类型变量。
int a=1,b=2,c=3;
String name = &quot;xk&quot;;
char x = &#39;x&#39;;
double pi = 3.14;
float f = 2.454f;
long L = 34532847L;
</code></pre>
<p><strong>注：每个变量都有类型，类型可以是基本类型，也可以是引用类型；变量名必须是合法的标识符；变量声明是一条完整的语句，因此每一个声明都必须以分号结束。</strong></p>
<h4 id="1-2-2-变量分类及作用域"><a href="#1-2-2-变量分类及作用域" class="headerlink" title="1.2.2 变量分类及作用域"></a>1.2.2 变量分类及作用域</h4><p>变量分为类变量、实例变量、局部变量</p>
<h5 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h5><p>①局部变量声明在<strong>方法、构造方法或者语句块中</strong></p>
<p>②局部变量在<strong>方法、构造方法、或者语句块被执行的时候创建</strong>，当它们执行完成后，变量将会被销毁</p>
<p>③<strong>访问修饰符不能用于局部变量</strong></p>
<p>④局部变量<strong>只在声明它的方法、构造方法或者语句块中可见</strong></p>
<p>⑤局部变量是在栈上分配的</p>
<p>⑥局部变量<strong>没有默认值</strong>，所以局部变量被声明后，必须经过初始化，才可以使用</p>
<pre><code class="java">public class Test&#123; 
   public void pupAge()&#123;
      int age = 0;
      age = age + 7;
      System.out.println(&quot;小狗的年龄是: &quot; + age);
   &#125;
   
   public static void main(String[] args)&#123;
      Test test = new Test();
      test.pupAge();
   &#125;
&#125;
</code></pre>
<h5 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h5><p>①实例变量<strong>声明在一个类中</strong>，但在方法、构造方法和语句块之外</p>
<p>②当一个<strong>对象被实例化之后，每个实例变量的值就跟着确定</strong></p>
<p>③实例变量在对象创建的时候创建，在对象被销毁的时候销毁</p>
<p>④<strong>实例变量的值应该至少被一个方法、构造方法或者语句块引用</strong>，使得外部能够通过这些方式获取实例变量信息</p>
<p>⑤<strong>实例变量可以声明在使用前或者使用后</strong></p>
<p>⑥<strong>访问修饰符可以修饰实例变量</strong></p>
<p>⑦<strong>实例变量对于类中的方法、构造方法或者语句块是可见的</strong>。一般情况下应该把实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见</p>
<p>⑧<strong>实例变量具有默认值</strong>。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定</p>
<p>⑨实例变量<strong>可以直接通过变量名访问</strong>。但在静态方法以及其他类中，就应该使用完全限定名：<strong>ObejectReference.VariableName（对象名.变量名）</strong></p>
<pre><code class="java">public class Employee&#123;
   // 这个实例变量对子类可见
   public String name;
   // 私有变量，仅在该类可见
   private double salary;
   //在构造器中对name赋值
   public Employee (String empName)&#123;
      name = empName;
   &#125;
   //设定salary的值
   public void setSalary(double empSal)&#123;
      salary = empSal;
   &#125;  
   // 打印信息
   public void printEmp()&#123;
      System.out.println(&quot;名字 : &quot; + name );
      System.out.println(&quot;薪水 : &quot; + salary);
   &#125;
 
   public static void main(String[] args)&#123;
      Employee empOne = new Employee(&quot;RUNOOB&quot;);
      empOne.setSalary(1000.0);
      empOne.printEmp();
   &#125;
&#125;
</code></pre>
<h5 id="类变量（静态变量）"><a href="#类变量（静态变量）" class="headerlink" title="类变量（静态变量）"></a>类变量（静态变量）</h5><p>①类变量也称为静态变量，在类中以 static 关键字声明，但<strong>必须在方法之外</strong></p>
<p>②<strong>无论一个类创建了多少个对象，类只拥有类变量的一份拷贝</strong>（所有对象共享一份静态变量）</p>
<p>③静态变量除了被声明为常量外很少使用，静态变量是指声明为public/private，final 和 static 类型的变量。<strong>静态变量初始化后不可改变</strong></p>
<p>④<strong>静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量</strong></p>
<p>⑤<strong>静态变量在第一次被访问时创建，在程序结束时销毁</strong></p>
<p>⑥与实例变量具有相似的可见性。但为了对类的使用者可见，<strong>大多数静态变量声明为 public 类型</strong></p>
<p>⑦<strong>默认值和实例变量相似</strong>。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，<strong>静态变量还可以在静态语句块中初始化</strong></p>
<p>⑧静态变量可以通过：<strong><em>ClassName.VariableName</em>（类名.变量名）的方式访问</strong>，也可以通过<code>对象名.静态变量</code>进行访问但java<strong>不推荐</strong>这样做</p>
<p>⑨<strong>类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母</strong>。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致</p>
<pre><code class="java">public class Employee &#123;
    //salary是静态的私有变量
    private static double salary;
    // DEPARTMENT是一个常量
    public static final String DEPARTMENT = &quot;开发人员&quot;;
    public static void main(String[] args)&#123;
    salary = 10000;
        System.out.println(DEPARTMENT+&quot;平均工资:&quot;+salary);
    &#125;
&#125;
//注：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT
</code></pre>
<h4 id="1-2-3-常量"><a href="#1-2-3-常量" class="headerlink" title="1.2.3 常量"></a>1.2.3 常量</h4><p>常量(Constant)：初始化(initialize)后不能再改变值!不会变动的值</p>
<p>所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。</p>
<p>final 常量名=值；<br>final double PI=3.14；</p>
<p>常量名一般使用大写字符，final是指该变量只准被修改一次</p>
<h3 id="1-3-运算符"><a href="#1-3-运算符" class="headerlink" title="1.3 运算符"></a>1.3 运算符</h3><p>Java支持的运算符：</p>
<ul>
<li>算术运算符：+、-、*、/、%、++、–</li>
<li>赋值运算符：=</li>
<li>关系运算符：&gt;、&lt;、&gt;=、&lt;=、==、!=、instanceof</li>
<li>逻辑运算符：&amp;&amp;、||、!</li>
<li>位运算符：&amp;、|、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;(了解)</li>
<li>条件运算符（三元运算符）：？：</li>
<li>扩展赋值运算符：+=、-=、*=、/=</li>
</ul>
<h4 id="1-3-1-自增-、自减-–-运算符"><a href="#1-3-1-自增-、自减-–-运算符" class="headerlink" title="1.3.1 自增(++)、自减(–)运算符"></a>1.3.1 自增(++)、自减(–)运算符</h4><pre><code class="java">int a = 3;
int b = a++; //先给b赋值，再自增
int c = ++a; //先自增，再给b赋值
</code></pre>
<h4 id="1-3-2-逻辑运算符、位运算符"><a href="#1-3-2-逻辑运算符、位运算符" class="headerlink" title="1.3.2 逻辑运算符、位运算符"></a>1.3.2 逻辑运算符、位运算符</h4><p>逻辑运算符：与（and）、或（or）、非（!）</p>
<p>逻辑与运算、逻辑或运算又分为短路与(&amp;&amp;)、长路与(&amp;)、短路或(||)、长路或(|)</p>
<p>区别：</p>
<p>短路与和长路与：长路与 两侧都会被运算；短路与 只要第一个是false，第二个就不会进行运算了</p>
<p>短路或和长路或：长路或 两侧都会被运算；短路或 只要第一个是true，第二个就不会进行运算了</p>
<pre><code class="java">//与（and）   或（or）   非（取反）
boolean a = true;
boolean b = false;

System.out.println(a&amp;&amp;b); //与运算，都为真结果才能为真
System.out.println(a||b); //或运算，其中一个为真，结果就为真
System.out.println(!(a&amp;&amp;b)); //如果a&amp;&amp;b是真，结果为假；否则为真
</code></pre>
<p>位运算符：长路与(&amp;)、长路或(|)、异或(^)、非(~)、左移(&lt;&lt;)、右移(&gt;&gt;)</p>
<pre><code class="java">//位运算，效率极高！！

A = 0011 1100;
B = 0000 1101;

A&amp;B = 0000 1100; //与，都为1才为1
A|B = 0011 1101; //或，其中一个为1就为1
A^B = 1100 1110; //异或运算，相同为真，不同为假
~B = 1111 0010; //位取反

/*  2*8=16   2*2*2*2
    &lt;&lt;   相当于*，根据一个整数的二进制表达，将其每一位都向左移动，最右边补0
    &gt;&gt;   相当于/，根据一个整数的二进制表达，将其每一位都向右移动     
    0000 0010    2
    0000 1000    8
    0001 0000    16
*/
System.out.println(2&lt;&lt;3);  //结果为16，即将2的二进制表达的每一位向左移动3位，也相当于2*2*2*2
</code></pre>
<h4 id="1-3-3-三元运算符、字符串连接符"><a href="#1-3-3-三元运算符、字符串连接符" class="headerlink" title="1.3.3 三元运算符、字符串连接符"></a>1.3.3 三元运算符、字符串连接符</h4><pre><code class="java">//字符串连接符  +
int a = 10;
int b = 20;
System.out.println(&quot;a+b&quot;+a+b); //输出a+b1020,因为a+b在String类型的&quot;a+b&quot;之后，会将a和b的值直接在其后面进行拼接
System.out.println(a+b+&quot;a+b&quot;); //输出30a+b，因为a+b在String类型的&quot;a+b&quot;之前，会先将a+b进行运算后再拼接


//三元运算符  x ? y : z
//如果x=true，结果为y；如果x=false，结果为z
</code></pre>
<h4 id="1-3-4-运算符优先级"><a href="#1-3-4-运算符优先级" class="headerlink" title="1.3.4 运算符优先级"></a>1.3.4 运算符优先级</h4><p>所有的数学运算都认为是从左向右运算的，<a target="_blank" rel="noopener" href="http://c.biancheng.net/java/">Java</a> 语言中大部分运算符也是从左向右结合的，只有单目运算符、赋值运算符和三目运算符例外，其中，单目运算符、赋值运算符和三目运算符是从右向左结合的，也就是从右向左运算</p>
<p> 乘法和加法是两个可结合的运算，也就是说，这两个运算符左右两边的操作数可以互换位置而不会影响结果。运算符有不同的优先级，所谓优先级就是在表达式运算中的运算顺序</p>
<p> 一般而言，单目运算符优先级较高，赋值运算符优先级较低。算术运算符优先级较高，关系和逻辑运算符优先级较低。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性</p>
<p> Java 语言中运算符的优先级共分为 14 级，其中 1 级最高，14 级最低。在同一个表达式中运算符优先级高的先执行。表 1 列出了所有的运算符的优先级以及结合性</p>
<p><strong>运算符优先级：</strong></p>
<table>
<thead>
<tr>
<th>优先级</th>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>()、[]、{}</td>
<td>从左向右</td>
</tr>
<tr>
<td>2</td>
<td>!、+、-、~、++、–</td>
<td>从右向左</td>
</tr>
<tr>
<td>3</td>
<td>*、/、%</td>
<td>从左向右</td>
</tr>
<tr>
<td>4</td>
<td>+、-</td>
<td>从左向右</td>
</tr>
<tr>
<td>5</td>
<td>«、»、&gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>6</td>
<td>&lt;、&lt;=、&gt;、&gt;=、instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>7</td>
<td>==、!=</td>
<td>从左向右</td>
</tr>
<tr>
<td>8</td>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>9</td>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>10</td>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>11</td>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>12</td>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>13</td>
<td>?:</td>
<td>从右向左</td>
</tr>
<tr>
<td>14</td>
<td>=、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;=</td>
<td>从右向左</td>
</tr>
</tbody></table>
<p><strong>使用优先级为 1 的小括号可以改变其他运算符的优先级</strong>，即如果需要将具有较低优先级的运算符先运算，则可以使用小括号将该运算符和操作符括起来</p>
<h2 id="二、Java流程控制"><a href="#二、Java流程控制" class="headerlink" title="二、Java流程控制"></a>二、Java流程控制</h2><h3 id="2-1-Scanner对象"><a href="#2-1-Scanner对象" class="headerlink" title="2.1 Scanner对象"></a>2.1 Scanner对象</h3><p>java.util.Scanner是Java5的新特征，我们可以通过Scanner类来获取用户的输入。</p>
<p>基本语法：</p>
<pre><code class="java">Scanner s = new Scanner(System.in);
</code></pre>
<p>通过Scanner类的<strong>next()与nextLine()方法获取输入的字符串</strong>，在读取前我们一般需要<strong>使用hasNext()与hasNextLine()判断是否还有输入的数据</strong></p>
<p><strong>next()：</strong></p>
<p>1、一定要读取到有效字符后才可以结束输入。</p>
<p>2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉</p>
<p>3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。</p>
<p>4、next()不能得到带有空格的字符串。</p>
<p><strong>nextLine()：</strong></p>
<p>1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。</p>
<p>2、可以获得空白。</p>
<h3 id="2-2顺序结构"><a href="#2-2顺序结构" class="headerlink" title="2.2顺序结构"></a>2.2顺序结构</h3><p>Java本身执行代码的结构就是顺序结构，除非特别指明，否则就是按照顺序一句一句执行代码；它是由若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构</p>
<h3 id="2-3选择结构"><a href="#2-3选择结构" class="headerlink" title="2.3选择结构"></a>2.3选择结构</h3><h4 id="2-3-1-if单选择结构"><a href="#2-3-1-if单选择结构" class="headerlink" title="2.3.1 if单选择结构"></a>2.3.1 if单选择结构</h4><pre><code class="java">if(布尔表达式) &#123;
    如果布尔表达式为真，则执行的代码语句
&#125;
</code></pre>
<h4 id="2-3-2-if…else双选择结构"><a href="#2-3-2-if…else双选择结构" class="headerlink" title="2.3.2 if…else双选择结构"></a>2.3.2 if…else双选择结构</h4><pre><code class="java">if(布尔表达式) &#123;
    如果布尔表达式为真，则执行的代码语句
&#125; else &#123;
    如果布尔表达式为假，则执行的代码语句
&#125;
</code></pre>
<h4 id="2-3-3-if…else-if…else多选择结构"><a href="#2-3-3-if…else-if…else多选择结构" class="headerlink" title="2.3.3 if…else if…else多选择结构"></a>2.3.3 if…else if…else多选择结构</h4><pre><code class="java">if(布尔表达式1) &#123;
    如果布尔表达式1为真，则执行的代码语句
&#125; else if(布尔表达式2) &#123;
    如果布尔表达式2为真，则执行的代码语句
&#125; else &#123;
    如果上面的布尔表达式都不为真，则执行的代码语句
&#125;
//只要有一个else if的布尔表达式为true，就会跳过其余所有的else if和else
</code></pre>
<h4 id="2-3-4-嵌套的if选择结构"><a href="#2-3-4-嵌套的if选择结构" class="headerlink" title="2.3.4 嵌套的if选择结构"></a>2.3.4 嵌套的if选择结构</h4><pre><code class="java">if(布尔表达式1) &#123;
    如果布尔表达式1为真，则执行的代码语句
    if(布尔表达式2) &#123;
    如果布尔表达式2为真，则执行的代码语句
    &#125;     
&#125; 
//也就是说可以另一个if或者else if里面使用if或else if语句；可以像if语句那样嵌套eles if ...else
</code></pre>
<h4 id="2-3-5-Switch多选择结构"><a href="#2-3-5-Switch多选择结构" class="headerlink" title="2.3.5 Switch多选择结构"></a>2.3.5 Switch多选择结构</h4><pre><code class="java">switch(expression) &#123;  
    case value : 
        //语句
        break;//可选
    case value :
        //语句
        break;//可选
    default : //可选
        //语句
&#125;
//expression变量类型可以是byte、short、int或者char；从Java SE7开始，switch支持String类型了；同时case标签必须为字符串常量或字面量
</code></pre>
<h3 id="2-4-循环结构"><a href="#2-4-循环结构" class="headerlink" title="2.4 循环结构"></a>2.4 循环结构</h3><p>循环结构分为while循环结构、do…while结构、for循环结构，JDK5中引入了一种主要用于数组的增强型for循环</p>
<h4 id="2-4-1-while循环结构"><a href="#2-4-1-while循环结构" class="headerlink" title="2.4.1 while循环结构"></a>2.4.1 while循环结构</h4><pre><code class="java">while(布尔表达式) &#123;
    //需要先判断布尔表达式再执行语句。只要布尔表达式为true，就会一直执行；要使其停止循环需要改变布尔表达式的值
&#125;
</code></pre>
<h4 id="2-4-2-do…while循环结构"><a href="#2-4-2-do…while循环结构" class="headerlink" title="2.4.2 do…while循环结构"></a>2.4.2 do…while循环结构</h4><pre><code class="java">do &#123;
    //先执行一次循环体语句，再判断布尔表达式
&#125; while(布尔表达式)
</code></pre>
<h4 id="2-4-3-for循环结构"><a href="#2-4-3-for循环结构" class="headerlink" title="2.4.3 for循环结构"></a>2.4.3 for循环结构</h4><p>for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构</p>
<p>for循环执行的次数是在执行前就确定的</p>
<pre><code class="java">for(初始化循环变量; 布尔表达式 ; 更新循环变量) &#123;
    //代码语句
&#125;

//打印九九乘法表
for (int i=1;i&lt;10;i++) &#123;
            for(int j=1;j&lt;=i;j++) &#123;
                System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j);
                System.out.print(&quot;   &quot;);
            &#125;
            System.out.println();
        &#125;
</code></pre>
<pre><code class="java">//打印三角形
for(int i=1;i&lt;=5;i++) &#123; //打印第i行
    for(int j=5;j&gt;=i;j--) &#123; //第i行首先打印j-i+1个空格
        System.out.print(&quot; &quot;);
    &#125;
    for(int j=1;j&lt;=i;j++) &#123; //第i行再打印一个*号
        System.out.print(&quot;*&quot;);
    &#125;
    for(int j=1;j&lt;i;j++) &#123; //最后第i行打印i-1个*号
        System.out.print(&quot;*&quot;);
    &#125;
    System.out.println(); //打印完一行换行
&#125;
</code></pre>
<h4 id="2-4-4-增强for循环"><a href="#2-4-4-增强for循环" class="headerlink" title="2.4.4 增强for循环"></a>2.4.4 增强for循环</h4><p>JDK5引入了一种主要应用于数组的增强for循环</p>
<pre><code class="java">for(声明语句 : 表达式) &#123;
    //代码语句
&#125;
//声明语句:声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。
//表达式:表达式是要访问的数组名，或者是返回值为数组的方法。
int[] numbers = &#123;10,20,30,40,50&#125;;
for(int x:numbers) &#123;
    System.out.println(x);
&#125;
</code></pre>
<h4 id="2-4-5-break、continue、goto"><a href="#2-4-5-break、continue、goto" class="headerlink" title="2.4.5 break、continue、goto"></a>2.4.5 break、continue、goto</h4><p>break：break在任何循环语句的主体部分，均可用break控制循环的流程。<strong>break用于强行退出循环，不执行循环中剩余的语句</strong>(break语句也在switch语句中使用)</p>
<p>continue：continue语句用在循环语句体中，用于终止某次循环过程，即<strong>跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定</strong></p>
<p>goto：</p>
<ul>
<li><p>goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用;Java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子—带标签的break和continue.</p>
</li>
<li><p>“标签”是指后面跟一个冒号的标识符，例如: label:</p>
</li>
<li><p>对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是:<strong>我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方</strong></p>
</li>
</ul>
<h2 id="三、Java方法"><a href="#三、Java方法" class="headerlink" title="三、Java方法"></a>三、Java方法</h2><p>Java方法是语句的集合，它们在一起执行一个功能。</p>
<ul>
<li><p>方法是解决一类问题的步骤的有序组合</p>
</li>
<li><p>方法包含于类或对象中</p>
</li>
<li><p>方法在程序中被创建，在其他地方被引用</p>
</li>
</ul>
<p><strong>设计方法的原则</strong>:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是<strong>一个方法只完成1个功能，这样利于我们后期的扩展</strong></p>
<h3 id="3-1-方法的定义和调用"><a href="#3-1-方法的定义和调用" class="headerlink" title="3.1 方法的定义和调用"></a>3.1 方法的定义和调用</h3><h4 id="3-1-1-方法的定义"><a href="#3-1-1-方法的定义" class="headerlink" title="3.1.1 方法的定义"></a>3.1.1 方法的定义</h4><p>Java的方法类似于其它语言的函数，是<strong>一段用来完成特定功能的代码片段</strong>，一般情况下，定义一个方法包含以下语法:</p>
<p>方法包含一个方法头和一个方法体。下面是一个方法的所有部分:</p>
<ul>
<li><p>访问修饰符：这是<strong>可选的</strong>，告诉编译器如何调用该方法。<strong>定义了该方法的访问类型</strong></p>
<ul>
<li><p>Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限：</p>
<ul>
<li><p><code>default</code> (即默认，什么也不写）: 在<strong>同一包内可见</strong>，不使用任何修饰符。使用对象：类、接口、变量、方法。</p>
</li>
<li><p><code>private</code> : 在<strong>同一类内可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p>
</li>
<li><p><code>public</code> : 对<strong>所有类可见</strong>。使用对象：类、接口、变量、方法</p>
</li>
<li><p><code>protected</code> : 对<strong>同一包内的类和所有子类可见</strong>。使用对象：变量、方法。 <strong>注意：不能修饰类（外部类）</strong></p>
</li>
</ul>
<table>
<thead>
<tr>
<th>修饰符</th>
<th>当前类</th>
<th>同一包内</th>
<th>子孙类(同一包)</th>
<th>子孙类(不同包)</th>
<th>其他包</th>
</tr>
</thead>
<tbody><tr>
<td>public</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
</tr>
<tr>
<td>protected</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>Y/N</td>
<td>N</td>
</tr>
<tr>
<td>default</td>
<td>Y</td>
<td>Y</td>
<td>Y</td>
<td>N</td>
<td>N</td>
</tr>
<tr>
<td>private</td>
<td>Y</td>
<td>N</td>
<td>N</td>
<td>N</td>
<td>N</td>
</tr>
</tbody></table>
</li>
</ul>
</li>
<li><p>返回值类型∶方法可能会返回值。<strong>returnValueType是方法返回值的数据类型</strong>；有些方法执行所需的操作，但没有返回值，在这种情况下,returnValueType是关键字void</p>
</li>
<li><p>方法名:是方法的实际名称。<strong>方法名和参数表共同构成方法签名</strong></p>
</li>
<li><p>参数类型:参数像是一个占位符。<strong>当方法被调用时，传递值给参数</strong>。<strong>这个值被称为实参或变量</strong>。参数列表是指方法的参数类型、顺序和参数的个数。<strong>参数是可选的，方法可以不包含任何参数</strong></p>
<ul>
<li>形式参数:在方法被调用时用于接收外界输入的数据</li>
<li>实参:调用方法时实际传给方法的数据</li>
</ul>
</li>
<li><p>方法体:方法体包含具体的语句，定义该方法的功能。</p>
</li>
</ul>
<pre><code class="java">修饰符 返回值类型 方法名(参数类型 参数名) &#123;
    ...
    方法体
    ...
    return 返回值;
&#125;
</code></pre>
<h4 id="3-1-2-方法的调用"><a href="#3-1-2-方法的调用" class="headerlink" title="3.1.2 方法的调用"></a>3.1.2 方法的调用</h4><p><strong>实例方法：</strong></p>
<p>调用方法：无论方法与方法的调用是否在同一个类中,都是先声明定义一个对象,然后通过对象名.方法名（实参列表）进行调用</p>
<ul>
<li>当方法返回一个值时，方法调用通常被当做一个值</li>
<li>当方法返回为void时，方法调用是一条语句</li>
</ul>
<pre><code class="java">Test test = new Test();
//方法有返回值时，如下
int max = test.max(10,20);
//方法返回void时，如下
test.max(10,20);
</code></pre>
<p><strong>类方法（静态方法）：</strong></p>
<p>调用方法：如果方法与方法调用在同一个类中发生，可通过方法名直接调用；如果方法与方法调用没有发生在同一个类中，需要通过类名.方法名（实参列表）进行调用</p>
<ul>
<li>方法返回值的情况与实例方法相同</li>
</ul>
<pre><code class="java">class A &#123;
    public static void test() &#123;
        //代码块
    &#125;
    test(); //方法和方法调用发生在同一个类中
&#125;
class B &#123;
    A.test(); //方法和方法调用发生在不同类中
&#125;
</code></pre>
<h4 id="3-1-3-形参和实参"><a href="#3-1-3-形参和实参" class="headerlink" title="3.1.3 形参和实参"></a>3.1.3 形参和实参</h4><p><strong>形参</strong> 顾名思义:就是形式参数，用于<strong>定义方法</strong>的时候使用的参数，是用来<strong>接收调用者传递的参数</strong>的。 形参只有在<strong>方法被调用的时候，虚拟机才会分配内存单元</strong>，在<strong>方法调用结束之后便会释放所分配的内存单元</strong>。 因此,形参<strong>只在方法内部有效</strong>，所以针对<strong>引用对象的改动也无法影响到方法外</strong></p>
<p><strong>实参</strong> 顾名思义:就是实际参数，用于调用时<strong>传递给方法的参数</strong>。实参在传递给别的方法之前是要<strong>被预先赋值</strong>的</p>
<p>Tips：<br>在 <code>值传递</code>调用过程中，只能把<strong>实参的值传递给形参</strong>，而不能把形参的值反向作用到实参上。在函数调用过程中，形参的值发生改变，而实参的值不会发生改变</p>
<p>在 <code>引用传递</code>调用的机制中，实际上是将<strong>实参引用的地址传递给了形参</strong>，所以任何发生在形参上的改变也会发生在实参变量上</p>
<p><code>值传递</code>和<code>引用传递</code>又是什么呢？参考3.1.4</p>
<h4 id="3-1-4-值传递和引用传递-重点-难点"><a href="#3-1-4-值传递和引用传递-重点-难点" class="headerlink" title="3.1.4 值传递和引用传递(重点\难点)"></a>3.1.4 <strong>值传递和引用传递(重点\难点)</strong></h4><p>参考链接:</p>
<ul>
<li><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_40574571/article/details/90765349">https://blog.csdn.net/qq_40574571/article/details/90765349</a></li>
<li><a target="_blank" rel="noopener" href="https://www.cnblogs.com/zhangshiwen/p/5830062.html">https://www.cnblogs.com/zhangshiwen/p/5830062.html</a></li>
</ul>
<p>值传递是对基本型变量而言的,<strong>传递的是该变量的一个副本,改变副本不影响原变量</strong></p>
<p> 引用传递一般是对于对象型变量而言的,<strong>传递的是该对象地址的一个副本, 并不是原对象本身</strong> </p>
<p> 一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递</p>
<p><strong>值传递：</strong></p>
<ul>
<li>指的是在方法的调用中，传递的参数是按照值的拷贝传递</li>
<li>特点：传递的是值的拷贝，传递后就互不相关了<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633185.png' data-fancybox='default' data-caption='image-20210722170825089'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633185.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633185.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210722170825089"></a><span class='image-caption'>image-20210722170825089</span></div></div></li>
</ul>
<p><strong>引用传递：</strong></p>
<ul>
<li>指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。</li>
<li>特点：传递的是参数的引用值，也就是传递前和传递后都指向同一个引用（即同一个内存空间）</li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633282.png' data-fancybox='default' data-caption='image-20210722172443947'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633282.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633282.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210722172443947"></a><span class='image-caption'>image-20210722172443947</span></div></div>

<p>Tips：</p>
<ul>
<li><p><strong>“在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递</strong></p>
</li>
<li><p>在Java里面只有基本类型和按照直接使用双引号定义字符串方式：String str = “Java私塾”这种定义方式的String是按值传递，其它的都是按引用传递</p>
</li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633598.png' data-fancybox='default' data-caption='image-20210711171056907'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633598.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633598.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210711171056907"></a><span class='image-caption'>image-20210711171056907</span></div></div>

<h3 id="3-2-方法的重载"><a href="#3-2-方法的重载" class="headerlink" title="3.2 方法的重载"></a>3.2 方法的重载</h3><p><strong>重载就是在一个类中，有相同的函数名称，但形参不同的函数</strong></p>
<p>方法的重载的规则:</p>
<ul>
<li><strong>方法名称必须相同</strong></li>
<li><strong>参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等)</strong></li>
<li><strong>方法的返回类型可以相同也可以不相同</strong></li>
<li><strong>仅仅返回类型不同不足以成为方法的重载</strong></li>
</ul>
<p>实现理论:</p>
<p>方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。</p>
<h3 id="3-3-命令行传递参数"><a href="#3-3-命令行传递参数" class="headerlink" title="3.3 命令行传递参数"></a>3.3 命令行传递参数</h3><p>在控制台的命令行进行编译.java文件时传参</p>
<pre><code class="java">public class Test &#123;
    public static void main(String[] args)
    for(int i = 0; i &lt; args.length; i++) &#123;
        System.out.println(&quot;args[&quot; + i + &quot;]:&quot; + args[i]);
    &#125;
&#125;
//如果在命令行编译成功后输入命令：java Test this is test
//则运行程序时命令行会输出：args[0]:this        args[1]:is        args[2]:test
</code></pre>
<h3 id="3-4-可变参数"><a href="#3-4-可变参数" class="headerlink" title="3.4 可变参数"></a>3.4 可变参数</h3><p>JDK5开始，Java支持传递同类型的可变参数给一个方法</p>
<p>在方法声明中，在指定参数类型后加一个省略号(…)</p>
<p>一个方法只能制定一个可变参数，它必须是方法的最后一个参数。任何参数必须在它之前声明</p>
<pre><code class="java">test(1,3,4); //可以随意传n个参数
test(new Double[]&#123;1,2,3&#125;);
public void test(double... numbers) &#123;
    //方法体
&#125;
</code></pre>
<h3 id="3-4-递归"><a href="#3-4-递归" class="headerlink" title="3.4 递归"></a>3.4 递归</h3><p>tips：深度较大的时候运行速度太慢，方便程序员，劳累电脑</p>
<p>递归就是:A方法调用A方法!就是自己调用自己</p>
<p>利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。<strong>递归的能力在于用有限的语句来定义对象的无限集合</strong></p>
<p>递归结构包括两个部分:</p>
<ul>
<li>递归头:什么时候不调用自身方法。如果没有头，将陷入死循环</li>
<li>递归体:什么时候需要调用自身方法</li>
</ul>
<pre><code class="java">//计算阶乘
public static void main(String[] args) &#123;
        System.out.println(test(5));
    &#125;
    public static int test(int i) &#123;
        if(i == 1) &#123;
            return 1; //递归头（尽头）
        &#125; else &#123;
            return i*test(i-1);
        &#125;
    &#125;
</code></pre>
<p>如图：</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633597.png' data-fancybox='default' data-caption='image-20210711182627099'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633597.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201633597.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210711182627099"></a><span class='image-caption'>image-20210711182627099</span></div></div>

<h2 id="四、Java数组"><a href="#四、Java数组" class="headerlink" title="四、Java数组"></a>四、Java数组</h2><p>数组是<strong>相同类型数据的有序集合</strong></p>
<p>数组描述的是<strong>相同类型的若干个数据</strong>,按照一定的先后次序排列组合而成</p>
<p>其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们</p>
<h3 id="4-1-数组的声明创建"><a href="#4-1-数组的声明创建" class="headerlink" title="4.1 数组的声明创建"></a>4.1 数组的声明创建</h3><p>首先必须先声明数组变量，才能在程序中使用数组</p>
<pre><code class="java">dataType[] arrayRefVar; //首选方法
dataType arrayRefVar[]; //效果相同，但不是首选方法

//Java使用new操作符来创建数组
dataType[] arrayRefVar = new dataType[arraySize];
</code></pre>
<p>数组元素通过索引访问，数组索引从0开始</p>
<p>获取数组长度：<code>arrays.length</code></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634738.png' data-fancybox='default' data-caption='image-20210712112802160'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634738.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634738.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712112802160"></a><span class='image-caption'>image-20210712112802160</span></div></div>

<h3 id="4-2-Java内存分析及三种初始化"><a href="#4-2-Java内存分析及三种初始化" class="headerlink" title="4.2 Java内存分析及三种初始化"></a>4.2 Java内存分析及三种初始化</h3><h4 id="4-2-1-Java内存分析"><a href="#4-2-1-Java内存分析" class="headerlink" title="4.2.1 Java内存分析"></a>4.2.1 Java内存分析</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634043.png' data-fancybox='default' data-caption='image-20210712113429404'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634043.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634043.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712113429404"></a><span class='image-caption'>image-20210712113429404</span></div></div>

<p>先申请再创建</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634817.png' data-fancybox='default' data-caption='image-20210712113741570'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634817.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634817.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712113741570"></a><span class='image-caption'>image-20210712113741570</span></div></div>

<h4 id="4-2-2-三种初始化方式"><a href="#4-2-2-三种初始化方式" class="headerlink" title="4.2.2 三种初始化方式"></a>4.2.2 三种初始化方式</h4><p><strong>静态初始化</strong></p>
<pre><code class="java">int[] a = &#123;1,2,3&#125;;
Man[] mans = &#123;new Man(1,1),new Man(2,2)&#125;;
</code></pre>
<p><strong>动态初始化</strong>（包括默认初始化）</p>
<pre><code class="java">int[] a = new int[2];
a[0] = 1;
a[1] = 2;
</code></pre>
<p><strong>数组的默认初始化</strong></p>
<p>数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化（比如int类型的默认值都为0）</p>
<h4 id="4-2-3-下标越界问题"><a href="#4-2-3-下标越界问题" class="headerlink" title="4.2.3 下标越界问题"></a>4.2.3 下标越界问题</h4><p><strong>数组的四个基本特点</strong></p>
<ul>
<li>其长度是确定的。数组一旦被创建，它的大小就是不可以改变的</li>
<li>其元素必须是相同类型,不允许出现混合类型</li>
<li>数组中的元素可以是任何数据类型，包括基本类型和引用类型</li>
<li><strong>数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量</strong>。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，<strong>数组对象本身是在堆中的</strong></li>
</ul>
<p><strong>若对数组下标的操作超过数组声明创建时的下标，就会出现下标越界问题，报ArrayIndexOutOfBounds异常</strong></p>
<h3 id="4-3-数组的使用"><a href="#4-3-数组的使用" class="headerlink" title="4.3 数组的使用"></a>4.3 数组的使用</h3><p><strong>for-each循环</strong></p>
<pre><code class="java">int[] arrays = &#123;1,2,3,4,5&#125;;
for (int array : arrays) &#123;
    //执行语句
&#125;
</code></pre>
<p><strong>数组作方法入参</strong></p>
<pre><code class="java">public static void printArray(int[] arrays) &#123;
    //执行语句
&#125;
</code></pre>
<p><strong>数组作返回值</strong></p>
<pre><code class="java">//反转数组
public static void main(String[] args) &#123;
        int[] arrays = &#123;1,2,3,4,5&#125;;
        for (int array : arrays) &#123;
            System.out.print(array + &quot;  &quot;);
        &#125;
        System.out.println();
        int[] results =  reverse(arrays);
        for (int result : results) &#123;
            System.out.print(result + &quot;  &quot;);
        &#125;
    &#125;

    public static int[] reverse(int[] arrays) &#123;
        int[] result = new int[arrays.length];
        for (int i = 0; i &lt; arrays.length; i++) &#123;
            result[i] = arrays[arrays.length-1-i];
        &#125;
        return result;
    &#125;
</code></pre>
<h3 id="4-4-多维数组"><a href="#4-4-多维数组" class="headerlink" title="4.4 多维数组"></a>4.4 多维数组</h3><p>多维数组可以看成是数组的数组，比如二维数组是一个特殊的一维数组，其每一个元素都是一个一维数组</p>
<p>如，二维数组：<code>int[][] a = new int[2][5]; </code>可以看成一个二行五列的数组</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634508.png' data-fancybox='default' data-caption='image-20210712140511164'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634508.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201634508.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712140511164"></a><span class='image-caption'>image-20210712140511164</span></div></div>

<p>二维数组的arrays.length输出的是第一层数组的长度，比如<code>new int[2][5]</code>的长度就是2；如果要得到第二层数组的长度，应表示为<code>arrays[0].length</code></p>
<h3 id="4-5-Arrays工具类"><a href="#4-5-Arrays工具类" class="headerlink" title="4.5 Arrays工具类"></a>4.5 Arrays工具类</h3><p>由于数组对象本身并没有什么方法可以供我们调用,但API中提供了一个数组的工具类java.util.Arrays供我们使用,从而可以对数据对象进行一些基本的操作（查看JDK帮助文档）</p>
<p>Arrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用,而”不用”使用对象来调用(注意:是”不用”而不是”不能”)</p>
<p>Arrays类具有以下常用功能:</p>
<ul>
<li>给数组<strong>赋值</strong>:通过fill方法</li>
<li>对数组<strong>排序</strong>:通过sort方法,按升序</li>
<li><strong>比较</strong>数组:通过equals 方法比较数组中元素值是否相等</li>
<li><strong>查找</strong>数组元素:通过binarySearch方法能对<strong>排序好</strong>的数组进行<strong>二分查找法</strong>操作</li>
<li><strong>输出</strong>数组信息：toString方法</li>
</ul>
<h3 id="4-6-数组排序"><a href="#4-6-数组排序" class="headerlink" title="4.6 数组排序"></a>4.6 数组排序</h3><p>冒泡排序是最出名的排序算法之一，总共八大排序方法。即直接插入排序、希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序、桶排序/基数排序</p>
<p><strong>冒泡排序：</strong></p>
<ul>
<li>比较数组中，两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置</li>
<li><strong>每一次比较，都会产生出一个最大，或者最小的数字</strong></li>
<li>下一轮则可以少一次排序</li>
<li>依次循环，直到结束</li>
</ul>
<pre><code class="java">//冒泡排序
for(int n=1;n&lt;a.length;n++) &#123; //第n轮排序
    for(int i=0;i&lt;a.length-n;i++) &#123; //调换位置，i&lt;a.length-n是因为每次比较后都会产出一个最大或最小的数，那么下一次就不用再比较它
        if(a[i]&gt;a[i+1]) &#123;
            int temp=a[i];
            a[i]=a[i+1];
            a[i+1]=temp;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>选择排序：</strong></p>
<ul>
<li>选择数组中第i+1个数，依次与其后面的数进行比较，若比后面的数大就调换位置，这样每次都会将这轮比较最小的数放在最前面</li>
</ul>
<pre><code class="java">//选择排序
for(int i=0;i&lt;a.length;i++) &#123; //第i+1轮排序
    for(int j=i+1;j&lt;a.length;j++) &#123; //调换位置
        if(a[j]&lt;a[i]) &#123;
            int temp=a[i];
            a[i]=a[j];
            a[j]=temp;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="4-7-稀疏数组"><a href="#4-7-稀疏数组" class="headerlink" title="4.7 稀疏数组"></a>4.7 稀疏数组</h3><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201635838.png' data-fancybox='default' data-caption='image-20210712152206816'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201635838.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201635838.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712152206816"></a><span class='image-caption'>image-20210712152206816</span></div></div>

<p>例子：</p>
<pre><code class="java">private static int sum = 0; //统计原始数组中有多少个非0数
private static int[][] primary; //声明定义原始数组
private static int[][] sparse; //声明定义稀疏数组
private static int[][] recover; //声明定义恢复数组
public static void main(String[] args) &#123;
    CreateArrays();
    CreateSparse();
    RecoverArrays();
&#125;
//创建一个原始数组
public static void CreateArrays() &#123;
    primary = new int[6][6];
    primary[0][3] = 2;
    primary[1][1] = 3;
    primary[3][5] = 5;
    primary[5][3] = 1;
    System.out.println(&quot;输出原始数组：&quot;);
    for (int[] ints : primary) &#123;
        for (int anInt : ints) &#123;
            System.out.print(anInt + &quot;\t&quot;);
            if(anInt != 0) &#123;
                sum++; //非0数个数加1
            &#125;
        &#125;
        System.out.println();
    &#125;
    System.out.println(&quot;================&quot;);
&#125;

//创建稀疏数组存储原始数组的数据
public static void CreateSparse() &#123;
    int count = 0; //由于稀疏数组中一行存储的是原始数组中非0数的行、列、值，所以需要用到一个count来决定非0数存储在稀疏数组的第几行
    sparse = new int[sum+1][3];
    sparse[0][0] = primary.length; //存放primary的行数
    sparse[0][1] = primary[0].length; //存放primary的列数
    sparse[0][2] = sum; //存放primary中非0数的个数
    for (int i = 0; i &lt; primary.length; i++) &#123;
        for (int j = 0; j &lt; primary[i].length; j++) &#123;
            if (primary[i][j] != 0) &#123; //循环遍历primary数组，将非0数的所在行列和值保存在sparse中
                count++;
                sparse[count][0] = i;
                sparse[count][1] = j;
                sparse[count][2] = primary[i][j];
            &#125;
        &#125;
    &#125;
    System.out.println(&quot;输出稀疏数组：&quot;);
    System.out.println(&quot;行&quot; + &quot;\t&quot; + &quot;列&quot; + &quot;\t&quot; + &quot;值&quot; + &quot;\t&quot;);
    for (int[] ints : sparse) &#123;
        for (int anInt : ints) &#123;
            System.out.print(anInt + &quot;\t&quot;);
        &#125;
        System.out.println();
    &#125;
    System.out.println(&quot;================&quot;);
&#125;

//通过稀疏数组恢复原始数组
public static void RecoverArrays() &#123;
    recover = new int[sparse[0][0]][sparse[0][1]]; //还原数组的行数等于稀疏数组的第一行第一列的数，列数等于稀疏数组第一行第二列的数
    for (int i = 1; i &lt; sparse.length; i++) &#123;
        recover[sparse[i][0]][sparse[i][1]] = sparse[i][2]; //遍历稀疏数组，通过获取到的行列和数将其填充到到还原数组中
    &#125;
    System.out.println(&quot;输出还原数组：&quot;);
    for (int[] ints : recover) &#123;
        for (int anInt : ints) &#123;
            System.out.print(anInt + &quot;\t&quot;);
        &#125;
        System.out.println();
    &#125;
&#125;
</code></pre>
<h2 id="五、Java面向对象"><a href="#五、Java面向对象" class="headerlink" title="五、Java面向对象"></a>五、Java面向对象</h2><h3 id="5-1-什么是面向对象"><a href="#5-1-什么是面向对象" class="headerlink" title="5.1 什么是面向对象"></a>5.1 什么是面向对象</h3><p><strong>（面试：面向过程和面向对象的区别）</strong></p>
<p>面向过程思想（线性思维）：</p>
<ul>
<li>步骤清晰简单，第一步做什么，第二步做什么……</li>
<li>面向过程适合处理一些较为简单的问题</li>
</ul>
<p>面向对象思想：</p>
<ul>
<li>物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索</li>
<li>面向对象适合处理复杂的问题，适合处理需要多人协作的问题</li>
</ul>
<p>对于复杂的事物，从宏观上，从整体上合理分析，需要用到面向对象的思维进行分析；具体到微观的操作上，又需要面向过程的思路去处理</p>
<p>面向对象编程（oop）的本质：<strong>以类的方式组织代码，以对象的方式组织（封装）数据</strong></p>
<p><strong>三大特性：封装、继承、多态</strong></p>
<p><strong>从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象</strong></p>
<p><strong>从代码运行角度考虑是先有类后有对象。类是对象的模板</strong></p>
<h3 id="5-2-方法回顾和加深"><a href="#5-2-方法回顾和加深" class="headerlink" title="5.2 方法回顾和加深"></a>5.2 方法回顾和加深</h3><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636775.png' data-fancybox='default' data-caption='image-20210712210504188'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636775.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636775.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210712210504188"></a><span class='image-caption'>image-20210712210504188</span></div></div>

<p><strong>方法的调用和参数传递见3.1.2和3.1.3</strong></p>
<p>静态方法在类加载时随类一起加载，而非静态方法只有在类被实例化之后才存在</p>
<h3 id="5-3-对象的创建分析"><a href="#5-3-对象的创建分析" class="headerlink" title="5.3 对象的创建分析"></a>5.3 对象的创建分析</h3><h4 id="5-3-1-类与对象的关系"><a href="#5-3-1-类与对象的关系" class="headerlink" title="5.3.1 类与对象的关系"></a>5.3.1 类与对象的关系</h4><p>类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物</p>
<p>对象就是抽象概念的具体化实例</p>
<h4 id="5-3-2-创建对象"><a href="#5-3-2-创建对象" class="headerlink" title="5.3.2 创建对象"></a>5.3.2 创建对象</h4><p><strong>使用new关键字创建对象</strong></p>
<p>使用new关键字创建的时候，除了<strong>分配内存空间</strong>之外，还会<strong>给创建好的对象进行默认的初始化以及对类中构造器的调用</strong>。</p>
<p>类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且<strong>构造器有以下俩个特点:</strong></p>
<ul>
<li><p><strong>必须和类的名字相同</strong></p>
</li>
<li><p><strong>必须没有返回类型,也不能写void</strong></p>
</li>
</ul>
<p>构造器必须要掌握</p>
<h4 id="5-3-3-构造器（构造方法）"><a href="#5-3-3-构造器（构造方法）" class="headerlink" title="5.3.3 构造器（构造方法）"></a>5.3.3 构造器（构造方法）</h4><p>每个类即使没有显式的写出构造方法，Java也会给类写一个默认的构造方法</p>
<p>使用new关键字创建对象的本质是在调用构造器</p>
<p>构造器分为无参构造器和有参构造器，一旦定义了有参构造器，就必须显式的定义无参构造器</p>
<p>构造器的作用是初始化对象的属性</p>
<h4 id="5-3-4-创建对象内存分析"><a href="#5-3-4-创建对象内存分析" class="headerlink" title="5.3.4 创建对象内存分析"></a>5.3.4 创建对象内存分析</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://baijiahao.baidu.com/s?id=1637836912223474691&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1637836912223474691&amp;wfr=spider&amp;for=pc</a></p>
<p>JVM内存结构：</p>
<ul>
<li>虚拟机栈：即平时提到的栈结构，我们将<strong>局部变量</strong>存储在栈结构中（对于main方法来说，对象引用就是一个局部变量，所以会存储在栈中）</li>
<li>堆：我们将new出来的对象结构（比如，数组、对象）加载在堆空间中。对象的非static属性存储在堆空间</li>
<li>方法区：存储类的加载信息、常量池、静态域</li>
</ul>
<pre><code class="java">//实例
public class Application &#123;
    public static void main(String[] args)&#123;
        Pet dog = new Pet();
        dog.name = &quot;旺财&quot;;
        dog.age = 3;
        dog.shout();
    &#125;
&#125;

public class Pet &#123;
    public String name;
    public int age;
    
    public void shout() &#123;
        System.out.println(&quot;叫了一声&quot;);
    &#125;
&#125;
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636541.png' data-fancybox='default' data-caption='image-20210713105310543'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636541.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636541.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210713105310543"></a><span class='image-caption'>image-20210713105310543</span></div></div>

<p><strong>tip：JDK1.8方法区叫做元数据区，方法区（non-heap，非堆）不是在堆中（画图有误）</strong></p>
<p>什么是引用类型：除了8大基本类型都可以叫做引用类型，对象是通过引用来操作的</p>
<p>new的实例对象存放在堆中，而我们操作的是存放在栈中的对象引用，其值就是实例对象在堆中的地址</p>
<h3 id="5-4-面向对象三大特性"><a href="#5-4-面向对象三大特性" class="headerlink" title="5.4 面向对象三大特性"></a>5.4 面向对象三大特性</h3><h4 id="5-4-1-封装"><a href="#5-4-1-封装" class="headerlink" title="5.4.1 封装"></a>5.4.1 封装</h4><p>该露的露，该藏的藏；我们的设计要追求<strong>“高内聚，低耦合”</strong>；高内聚就是类的内部数据操作细节由自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用</p>
<p>封装（数据的隐藏）：通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏；记住：<strong>属性私有，get/set</strong></p>
<pre><code class="java">public class Student &#123;
    private String name;
    private int age;
    private char sex;
    
    public String getName() &#123;
        return name;
    &#125;

    public void setName(String name) &#123;
        this.name = name;
    &#125;

    public int getAge() &#123;
        return age;
    &#125;

    public void setAge(int age) &#123;
        this.age = age;
    &#125;

    public char getSex() &#123;
        return sex;
    &#125;

    public void setSex(char sex) &#123;
        this.sex = sex;
    &#125;
&#125;
</code></pre>
<h4 id="5-4-2-继承"><a href="#5-4-2-继承" class="headerlink" title="5.4.2 继承"></a>5.4.2 继承</h4><p>参考链接：<a target="_blank" rel="noopener" href="https://blog.csdn.net/hxhaaj/article/details/81174764">https://blog.csdn.net/hxhaaj/article/details/81174764</a></p>
<h5 id="1-概述及特点："><a href="#1-概述及特点：" class="headerlink" title="1.概述及特点："></a><strong>1.概述及特点：</strong></h5><ul>
<li>继承关系的俩个类，一个为子类(派生类),一个为父类(超类)。</li>
<li>子类继承父类,使用关键字<code>extends</code>来表示；extends的意思是“扩展”，子类是父类的扩展；</li>
<li>子类和父类之间,从意义上讲应该具有”is a”的关系</li>
<li>继承是<code>从已有类中派生出新的类</code>，新的类能<code>吸收已有类的属性和方法</code>，并且能<code>拓展新的属性和行为</code></li>
<li>子类继承父类，表明<code>子类是一种特殊的父类</code>，子类拥有父类的属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法</li>
<li>子类即是不扩展父类，也能维持拥有父类的操作</li>
<li>Java类只有单继承，没有多继承，但支持多重继承（单继承，多实现，多重继承，即一个子类只能有一个父类，一个父类可以有多个子类，一个子类又可以被一个孙类继承）</li>
<li>继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等</li>
<li>object类是所有类的父类，在Java中即使一个类没有显式继承一个类，但也默认继承了Object类</li>
<li>final类不能被继承</li>
</ul>
<h5 id="2-继承的特性："><a href="#2-继承的特性：" class="headerlink" title="2.继承的特性："></a><strong>2.继承的特性：</strong></h5><ul>
<li><h6 id="成员变量和方法："><a href="#成员变量和方法：" class="headerlink" title="成员变量和方法："></a>成员变量和方法：</h6><ul>
<li><strong>子类拥有父类非 private 的属性、方法</strong>，但是可以通过父类提供的public的setter方法和getter方法进行间接地访问和操作private属性</li>
<li>子类<strong>不能继承父类的静态方法和属性</strong>，因为静态的方法和属性是属于类本身的，但<strong>子类可以访问父类的静态方法和属性</strong></li>
<li>子类可以拥有自己的属性和方法，即<strong>子类可以对父类进行扩展</strong></li>
<li>子类可以用自己的方式实现父类的方法（<strong>方法重写</strong>），但子类和父类中同名的<strong>static变量和方法都是相互独立的，并不存在任何的重写的关系</strong></li>
<li>对于子类可以继承父类中的成员变量和成员方法，如果<strong>子类</strong>中<strong>出现</strong>了<strong>和父类同名的成员变量和成员方法</strong>时，<strong>父类</strong>的<strong>成员变量会被隐藏</strong>，父类的<strong>成员方法会被覆盖</strong>。需要<strong>使用父类的成员变量和方法</strong>时，就需要使用<strong>super</strong>关键字来进行引用（<strong>隐藏是针对成员变量和静态方法，覆盖是针对普通方法</strong>）</li>
<li>父类严格上来说<strong>不能调用子类</strong>的方法和成员变量，但可以从以下几种方法进行考虑：<ul>
<li>在父类中直接new子类相关对象或者通过构造函数传入子类对象，然后调用其方法</li>
<li>将子类相关方法声明为static，在父类中调用子类的static方法</li>
<li>在父类中通过反射调用子类的相关方法</li>
<li>通过注册监听，然后通过回调接口调用子类相关方法</li>
<li>相关链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/204e5d76ec11">https://www.jianshu.com/p/204e5d76ec11</a></li>
</ul>
</li>
<li>当创建一个子类对象时，即使子类定义了与父类中同名的实例变量，<strong>不仅会为该类的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存</strong>。 即依然会为父类中定义的、被隐藏的变量分配内存</li>
<li>如果<strong>子类中的实例变量被私有</strong>了 ，其父类中的<strong>同名</strong>实例变量<strong>没有被私有</strong>，那么子类对象就无法直接调用该变量（子类中的），但可以通过<strong>先将对象变量强制向上转型为父类型</strong>，在通过该对象引用变量来访问那个实例变量，就会得到的是<strong>父类中的</strong>那个实例变量</li>
</ul>
</li>
<li><h6 id="构造器："><a href="#构造器：" class="headerlink" title="构造器："></a>构造器：</h6><ul>
<li>子类<strong>不能继承获得</strong>父类的构造方法，但是可以通过<strong>super关键字来访问父类构造方法</strong></li>
<li>在一个构造器中<strong>调用另一个重载构造器</strong>使用<strong>this</strong>调用完成，在<strong>子类构造器中调用父类构造器</strong>使用<strong>super</strong>调用来完成</li>
<li>super 和 this 的调用都<strong>必须是在第一句</strong>，否则会产生编译错误，this和super<strong>只能存在一个</strong></li>
<li>不能进行<strong>递归构造器调用</strong>，即多个构造器之间互相循环调用。</li>
<li>如果<strong>父类有无参构造</strong>时，<strong>所有</strong>构造方法（包含任意有参构造）<strong>自动默认</strong>都会访问父类中的<strong>空参构造方法</strong>（自带super();）<ul>
<li>因为继承的目的是子类获取和使用父类的属性和行为，所以子类初始化之前，一定要先完成父类数据的初始化</li>
<li>在Java中，每个类都会<strong>默认继承Object超类</strong>，所以每一个构造方法的第一条默认语句都是<strong>super()</strong></li>
</ul>
</li>
<li>如果<strong>父类没有无参构造</strong>，反而<strong>有其他的有参构造方法</strong>时，子类继承父类后，<strong>子类必须显式的创建构造器，不论子类的构造器是否和父类构造器中参数类型是否一致，都必须在子类的构造器中显式的通过super关键字调用和父类构造器相应参数的构造方法</strong>。否则编译都通不过；<strong>也可以使用<code>this</code>先调用子类中的构造方法，再间接调用父类中的有参构造方法</strong></li>
<li>结论：<strong>当父类中没有无参构造器时，子类继承父类，子类中的构造器方法类型可以和父类中的构造器不同，但是必须每个构造器都显式的使用super关键字调用父类中的某个有参构造器，也可以使用this调用子类中的某个有参构造器，但这个有参构造器必须通过super访问父类中的有参构造器</strong></li>
</ul>
</li>
<li><h6 id="super关键字："><a href="#super关键字：" class="headerlink" title="super关键字："></a>super关键字：</h6><ul>
<li>super用于<strong>限定该对象调用它从父类继承得到的实例变量或方法</strong></li>
<li>super和this相同，都<strong>不能出现在静态方法</strong>中，因为静态方法属于类的，调用静态方法的可能是个类，而不是对象，而super和this都是<strong>限定对象调用</strong></li>
<li>super同样也可以在子类中<strong>调用父类中被子类隐藏和覆盖的同名实例变量和同名方法</strong></li>
<li>在构造器中使用super，则super会用于限定于该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。意思就是<strong>调用父类的构造器</strong></li>
<li>super限定：super后紧跟一个点，<code>super.name</code>，<code>super.walk()</code></li>
<li>super调用：super后紧跟圆括号，<code>super(无参或有参);</code></li>
</ul>
</li>
<li><h6 id="this关键字："><a href="#this关键字：" class="headerlink" title="this关键字："></a>this关键字：</h6><ul>
<li>this关键字指向的是<strong>当前对象的引用</strong></li>
<li><code>this.属性名称</code>指的是访问类中的成员变量，用来区分成员变量和局部变量</li>
<li><code>this.方法名称</code>用来访问本类的成员方法</li>
<li><code>this();</code>访问本类的构造方法</li>
<li>this关键字把当前对象传递给其他方法<code>method(this);</code></li>
<li>当需要返回当前对象的引用时，常常使用<code>return this;</code></li>
</ul>
</li>
<li><h6 id="继承的代码执行顺序问题："><a href="#继承的代码执行顺序问题：" class="headerlink" title="继承的代码执行顺序问题："></a>继承的代码执行顺序问题：</h6><ul>
<li><p>构造器执行顺序</p>
<ul>
<li>当调用子类构造器实例化子类对象时，<strong>父类构造器总是在子类构造器之前执行</strong></li>
<li>创建任何对象总是从该类所在<strong>继承树最顶层类的构造器开始执行</strong>，然后依次<strong>向下</strong>执行，最后才执行本类的构造器。如果父类通过this调用了<strong>同类中的重载构造器</strong>，就会<strong>依次执行此父类的多个构造器</strong></li>
</ul>
</li>
<li><p>静态域执行顺序</p>
<ul>
<li>当调用子类构造器实例化子类对象时，<strong>父类优先于子类进行加载到内存</strong>，所以会<strong>先执行父类中的静态域</strong></li>
<li>从该类所在继承树最顶层类开始加载，并执行其静态域，依次向下执行，最后执行本类。</li>
<li>静态域优先于main方法，优先于构造器执行</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="3-方法重写"><a href="#3-方法重写" class="headerlink" title="3.方法重写"></a>3.方法重写</h5><p>前提：需要有继承关系，子类重写父类的方法</p>
<p><strong>方法重写规则：</strong></p>
<ul>
<li><p>两同： <strong>方法名</strong>、<strong>形参列表</strong>相同</p>
</li>
<li><p>两小：</p>
<ul>
<li><p>子类方法<strong>返回值类型</strong>应比父类方法返回值类型<strong>更小或相等</strong></p>
</li>
<li><p>子类方法<strong>声明抛出的异常类</strong>应比父类方法声明抛出的异常类<strong>更小或相等</strong></p>
</li>
</ul>
</li>
<li><p>一大：子类方法的<strong>访问权限</strong>应比父类方法访问权限<strong>更大或相等</strong></p>
</li>
</ul>
<p><strong>方法重写Tips：</strong></p>
<ul>
<li>父类中的<strong>私有方法不能被重写</strong>，该方法对于子类是<strong>隐藏</strong>的，因此其子类<strong>无法访问</strong>该方法，也无法重写</li>
<li><strong>父类静态方法</strong>，子类也<strong>必须</strong>通过静态方法进行覆盖，即<strong>静态只能覆盖静态</strong></li>
<li>子类重写父类方法时，<strong>最好</strong>声明得一模一样</li>
<li>如果<strong>子类中定义</strong>了一个<strong>与父类private方法</strong>具有<strong>相同的方法名、相同的形参列表、相同的返回值类型的方法</strong>，依然<strong>不是重写</strong>，只是在子类中重新定义了一个<strong>新的方法</strong>，所以该新方法<strong>不会受父类方法的任何限制</strong></li>
<li>static方法（属于类，不属于实例）、final方法（常量）、private方法不能被重写</li>
</ul>
<p><strong>重写静态方法</strong>：方法的调用只和左边定义的引用相关</p>
<pre><code class="java">class A &#123;
    private static void test() &#123;
        System.out.println(&quot;A=&gt;test&quot;);
    &#125;
&#125;
class B extends A &#123;
    private static void test() &#123;
        System.out.println(&quot;B=&gt;test&quot;);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        B b = new B();
        b.test(); //输出B=&gt;test
        A a = new B(); //向上转型，a引用指向B对象
        a.test(); //输出A=&gt;test
    &#125;
&#125;
</code></pre>
<p><strong>重写非静态方法</strong>：方法的调用需要看左边的引用指向new的哪个对象</p>
<pre><code class="java">class A &#123;
    public void test() &#123;
        System.out.println(&quot;A=&gt;test&quot;);
    &#125;
&#125;
class B extends A &#123;
    public void test() &#123;
        System.out.println(&quot;B=&gt;test&quot;);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        B b = new B();
        b.test(); //输出B=&gt;test
        A a = new B(); //向上转型，a引用指向B对象
        a.test(); //输出B=&gt;test
    &#125;
&#125;
</code></pre>
<p><strong>方法重写和方法重载：</strong></p>
<ul>
<li><p>Override 和 Overload 的区别？Overload能改变返回值类型吗？</p>
<ul>
<li>Override是重写，Overload是重载。重载可以改变返回值类型，它是方法名相同，参数列表不同，与返回值类型无关</li>
</ul>
</li>
<li><p>方法重写：子类中出现和父类中方法声明一模一样的方法。<strong>返回值类型</strong>相同（或者是子父类，多态），<strong>方法名和参数列表一模一样</strong>。主要发生在<strong>子类和父类</strong>的同名方法之间</p>
</li>
<li><p>方法重载：本类中出现<strong>方法名相同</strong>，<strong>参数列表不同</strong>的方法，和<strong>返回值类型无关</strong>，可以改变。主要发生<strong>同一类</strong>的多个同名方法之间</p>
</li>
<li><p>子类对象调用方法时，先找子类本身的方法，再找父类中的方法</p>
</li>
</ul>
<h4 id="5-4-3-多态"><a href="#5-4-3-多态" class="headerlink" title="5.4.3 多态"></a>5.4.3 多态</h4><h5 id="1-相关规则及概念"><a href="#1-相关规则及概念" class="headerlink" title="1.相关规则及概念"></a>1.相关规则及概念</h5><p>多态即<strong>同一方法</strong>可以根据<strong>发送对象的不同</strong>而采用多种<strong>不同的行为方式</strong>。一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多</p>
<p>多态存在的条件</p>
<ul>
<li><p>有继承关系</p>
</li>
<li><p>子类重写父类方法父类引用指向子类对象</p>
</li>
</ul>
<p>注意:多态是方法的多态，属性没有多态性。</p>
<pre><code class="java">public class Person &#123;
    public void run() &#123;
        System.out.println(&quot;Person&quot;);
    &#125;
&#125;
public class Student extends Person &#123;
    public void run() &#123;
        System.out.println(&quot;Student&quot;);
    &#125;
    public void eat() &#123;
        System.out.println(&quot;Student eat&quot;);
    &#125;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        //一个对象的实际类型是确定的
        //new Person()
        //new Student();
        
        //可以指向的引用类型就不确定了：自身类的引用指向自身，父类的引用指向子类
        
        Student s1 = new Student(); //能调用的都是自己扩展的和继承父类的方法
        Person s2 = new Student(); //父类引用指向子类对象，不能调用子类自身扩展的，只能调用子类重写的实例方法
        Object s3 = new Student();
        
        s1.run(); //输出Student。因为子类重写了父类的方法
        s2.run(); //当子类中没有任何方法时，会输出Person，因为子类继承了父类的run方法
                //当子类中重写了父类方法，会输出Student，因为Person类引用s2指向Student的对象，则会执行Student中的run方法
        s2.eat(); //这个写法是错误的，因为引用s2是作为Student对象的向上转型，不能调用子类Student自身扩展的方法
             //如果要调用eat()方法，需要将s2转换成Student引用类型(向下转型)，即((Student)s2).eat(),此时才能调用eat()方法
    &#125;
&#125;
</code></pre>
<h5 id="2-向上转型和向下转型："><a href="#2-向上转型和向下转型：" class="headerlink" title="2.向上转型和向下转型："></a>2.向上转型和向下转型：</h5><ul>
<li><p><strong>向上转型：</strong>子类对象转为父类，父类可以是接口；注意：向上转型<strong>不要强制转型</strong>。向上转型后<strong>父类的引用所指向的属性是父类的属性</strong>，如果<strong>子类重写了父类的方法，那么父类引用指向的或者调用的方法是子类的方法</strong>,这个叫动态绑定。向上转型后<strong>父类引用不能调用子类自身扩展的方法</strong>，如果调用不能编译通过</p>
<pre><code class="java">public class Human &#123;
    public void sleep() &#123;
        System.out.println(&quot;Human sleep..&quot;);
    &#125;
    public static void main(String[] args) &#123;
        Human h = new Male();// 向上转型
        h.sleep();
        Male m = new Male();
        m.sleep();// h.speak();此方法不能编译，报错说Human类没有此方法
    &#125;
&#125;
class Male extends Human &#123;
    @Override
    public void sleep() &#123;
        System.out.println(&quot;Male sleep..&quot;);
    &#125;
    public void speak() &#123;
        System.out.println(&quot;I am Male&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p><strong>向下转型：</strong>父类对象转为子类，需要进行<strong>强制转换</strong>;  向下转型需要考虑安全性，如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误即能否向下转型，<strong>只有先经过向上转型的对象才能继续向下转型</strong></p>
</li>
<li><p>没有继承关系的两个类，互相转换，一定会失败</p>
</li>
</ul>
<h5 id="3-instanceof"><a href="#3-instanceof" class="headerlink" title="3.instanceof"></a>3.instanceof</h5><pre><code class="java">boolean result = obj instanceof Class
</code></pre>
<p>　　其中 obj 为一个对象，Class 表示一个类或者一个接口；当 obj 为 Class 的对象，或者是<strong>其直接或间接子类的对象</strong>，或者是<strong>其接口的实现类的对象</strong>，结果result 都返回 true，否则返回false。（说明Class只有大于等于obj时为true）</p>
<p>注意：</p>
<ul>
<li>编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定</li>
<li>如果obj为null，那么则返回false</li>
<li>在<strong>编译状态</strong>中，Class可以是obj对象的父类，自身类，子类。在这三种情况下Java编译时不会报错。</li>
<li>在<strong>运行转态</strong>中，Class可以是obj对象的父类，自身类，不能是子类(class小于了obj)。在前两种情况下result的结果为true，最后一种为false。但是class为子类时编译不会报错。运行结果为false。 （大致就是判断表达式：class 变量=(class)object的引用 是否成立）</li>
</ul>
<h3 id="5-5-static和final关键字及代码块"><a href="#5-5-static和final关键字及代码块" class="headerlink" title="5.5 static和final关键字及代码块"></a>5.5 static和final关键字及代码块</h3><h4 id="5-5-1-static关键字详解"><a href="#5-5-1-static关键字详解" class="headerlink" title="5.5.1 static关键字详解"></a>5.5.1 static关键字详解</h4><p><strong>static关键字的使用：</strong></p>
<ol>
<li><p>static：静态的</p>
</li>
<li><p>static可以用来修饰：<strong>属性</strong>、<strong>方法</strong>、<strong>代码块</strong>、<strong>内部类</strong></p>
</li>
<li><p>使用static修饰属性：静态变量(或类变量)</p>
<p>  实例变量：我们创建了类的多个对象，每个对象都<strong>独立</strong>的拥有一套类中的<strong>非静态属性</strong>。当修改其中一个对象中的非静态属性时，<strong>不会导致</strong>其他对象中同样的属性值的修改</p>
<p>  静态变量：我们创建了类的多个对象，多个对象<strong>共享同一个</strong>静态变量。当通过某一个对象修改静态变量时，<strong>会导致</strong>其他对象调用此静态变量时，是修改过了的</p>
<p>  static修饰属性的<strong>其他说明</strong>:</p>
<p>  ①静态变量<strong>随着类的加载而加载</strong>。可以通过<code>类.静态变量</code>的方式进行调用</p>
<p>  ②静态变量的加载要<strong>早于对象</strong>的创建</p>
<p>  ③由于类<strong>只会加载一次</strong>，则静态变量在内存中也只会存在一份：<strong>存在方法区的静态域中</strong></p>
</li>
</ol>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类变量</th>
<th align="center">实例变量</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
<p>​    4.使用static修饰方法：静态方法</p>
<p>​        随着类的加载而加载，可以通过<code>类.静态方法</code>的方式进行调用</p>
<p>​        静态方法中，<strong>只能调用静态</strong>的方法或属性；非静态方法中，<strong>既可以调用非静态</strong>的方法或属性，<strong>也可以调用静态</strong>的方法或属性</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">类方法</th>
<th align="center">实例方法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">类</td>
<td align="center">yes</td>
<td align="center">no</td>
</tr>
<tr>
<td align="center">对象</td>
<td align="center">yes</td>
<td align="center">yes</td>
</tr>
</tbody></table>
<p>​    5.static<strong>注意点</strong>：在静态的方法内，<strong>不能</strong>使用this关键字、super关键字</p>
<pre><code class="java">//静态导入包
import static java.lang.Math.random;
import static java.lang.Math.PI;
//此时random和PI可以直接使用
</code></pre>
<h4 id="5-5-2-final关键字详解"><a href="#5-5-2-final关键字详解" class="headerlink" title="5.5.2 final关键字详解"></a>5.5.2 final关键字详解</h4><p><strong>final关键字的使用：</strong></p>
<ol>
<li><p>final：最终的</p>
</li>
<li><p>final修饰一个类：此类<strong>不能被继承</strong>，比如String类，System类，StringBuffer类</p>
</li>
<li><p>final修饰方法：表明该方法<strong>不能被重写</strong>，比如Object类中的getClass方法</p>
</li>
<li><p>final修饰变量：此时的“变量”就<strong>是一个常量</strong></p>
</li>
<li><p>1 final修饰属性：赋值的位置：显示初始化、代码块中初始化、构造器中初始化</p>
</li>
<li><p>2 final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值</p>
</li>
<li><p>static final修饰一个属性：表示它是一个全局常量</p>
</li>
</ol>
<pre><code class="java">//面试题：排错
//1
public class Something &#123;
    public int add0ne(final int x) &#123;
        return ++X; //错误，因为返回X前对它进行了改变
        //return X + 1; //可以编译通过，因为X没有变化，只是返回的是X加1后的值
    &#125;
&#125;
//2
public class Something &#123;
    public static void main(String[] args) &#123;
        Other o = new Other();
        new Something().add0ne(o); 
    &#125;
    public void add0ne(final 0ther o) &#123;
        //o = new other();      //错误，因为传入的引用被final修饰，所以不能被改变
        o.i++;        //正确，引用o没变，只是改变其中的变量
    &#125;
&#125;
class Other &#123;
    public int i;
&#125;
</code></pre>
<h4 id="5-5-3-代码块"><a href="#5-5-3-代码块" class="headerlink" title="5.5.3 代码块"></a>5.5.3 代码块</h4><p>代码块的作用：用来<strong>初始化类、对象</strong></p>
<p>代码块如果有修饰的话，只能使用static</p>
<p>分类：静态代码块、非静态代码块</p>
<p><strong>静态代码块</strong></p>
<ul>
<li>内部可以有输出语句</li>
<li>随着<strong>类的加载而执行</strong>,而且<strong>只执行一次</strong></li>
<li>作用：初始化类的信息</li>
<li>如果类中声明了多个静态代码块，则按声明的先后顺序执行</li>
<li>静态代码块优先于非静态代码块执行</li>
<li>不能调用非静态属性和方法，只能调用静态属性和方法</li>
</ul>
<p><strong>非静态代码块</strong></p>
<ul>
<li>内部可以有输出语句</li>
<li>随着<strong>对象的创建而执行</strong></li>
<li>每<strong>创建一个对象</strong>，就<strong>执行一次</strong>非静态代码块</li>
<li>作用：可以在创建对象时，对对象的属性等进行初始化</li>
<li>如果类中声明了多个非静态代码块，则按声明的先后顺序执行</li>
<li>既可以调用静态属性和方法，又可以调用非静态属性和方法</li>
</ul>
<p><strong>类加载的执行顺序</strong>：静态代码块&gt;匿名代码块&gt;构造器</p>
<pre><code class="java">public static void main(String[] args) &#123;
        new Leaf();                         
&#125;
class Root &#123;
    static &#123;
        System.out.println(&quot;Root的静态代码块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Root的普通代码块&quot;);
    &#125;
    public Root() &#123;
        super();
        System.out.println(&quot;Root的无参构造器&quot;);
    &#125;
&#125;
class Mid extends Root&#123;
    static &#123;
        System.out.println(&quot;Mid的静态代码块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Mid的普通代码块&quot;);
    &#125;
    public Mid() &#123;
        super();
        System.out.println(&quot;Mid的无参构造器&quot;);
    &#125;
&#125;
class Leaf extends Mid &#123;
    static &#123;
        System.out.println(&quot;Leaf的静态代码块&quot;);
    &#125;
    &#123;
        System.out.println(&quot;Leaf的普通代码块&quot;);
    &#125;
    public Leaf() &#123;
        super();
        System.out.println(&quot;Leaf的无参构造器&quot;);
    &#125;
&#125;
/*输出为：Root的静态代码块
         Mid的静态代码块
         Leaf的静态代码块
         Root的普通代码块
            Root的无参构造器
         Mid的普通代码块
         Mid的无参构造器
         Leaf的普通代码块
         Leaf的无参构造器*/
</code></pre>
<h3 id="5-6-抽象类和接口"><a href="#5-6-抽象类和接口" class="headerlink" title="5.6 抽象类和接口"></a>5.6 抽象类和接口</h3><h4 id="5-6-1-抽象类"><a href="#5-6-1-抽象类" class="headerlink" title="5.6.1 抽象类"></a>5.6.1 抽象类</h4><p><strong>abstract</strong>修饰符可以用来修饰方法也可以修饰类,<strong>如果修饰方法,那么该方法就是抽象方法;如果修饰类,那么该类就是抽象类</strong></p>
<p><em><strong>抽象类中可以没有抽象方法,但是有抽象方法的类一定要声明为抽象类</strong></em></p>
<p>抽象类,<strong>不能使用new</strong>关键字来创建对象,它是用来<strong>让子类继承</strong>的（所以抽象类一定有构造器）</p>
<p>抽象方法,<strong>只有方法的声明,没有方法的实现</strong>,它是用来让<strong>子类实现</strong>的</p>
<p>子类继承抽象类,那么就<strong>必须要实现</strong>抽象类<strong>没有实现的抽象方法</strong>,否则该子类也要声明为抽象类</p>
<h5 id="1-抽象类的匿名子类对象"><a href="#1-抽象类的匿名子类对象" class="headerlink" title="1.抽象类的匿名子类对象"></a>1.抽象类的匿名子类对象</h5><pre><code class="java">abstract class Person &#123;
    public abstract void eat();
&#125;
class Worker extends Person &#123;
    @Override
    public void eat() &#123;
    &#125;
&#125;

public static void main(String[] args) &#123;
        method(new Worker());//1.非匿名类的匿名对象
        Worker worker = new Worker();//2.非匿名类的非匿名对象
        //3.创建抽象类匿名子类的非匿名对象
        Person person = new Person() &#123;
            @Override
            public void eat() &#123;
            &#125;
        &#125;;
        method1(person);
        //4.抽象类匿名子类的匿名对象
        method1(new Person()&#123;
            @Override
            public void eat() &#123;
            &#125;
        &#125;);
    &#125;
    public static void method(Worker worker)&#123;
    &#125;
    public static void method1(Person person)&#123;
    &#125;
</code></pre>
<h5 id="2-模板方法设计模式"><a href="#2-模板方法设计模式" class="headerlink" title="2.模板方法设计模式"></a>2.模板方法设计模式</h5><p>抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式</p>
<p>解决的问题：</p>
<ul>
<li>当功能内部<strong>一部分实现是确定的，一部分实现是不确定的</strong>。这时可以把不确定的部分暴露出去，让子类去实现</li>
<li>换句话说，在软件开发中实现一个算法时，<strong>整体步骤很固定、通用</strong>，这些步骤已经在父类中写好了。但是某些部分易变，<strong>易变部分可以抽象出来，供不同子类实现</strong>。这就是一种模板模式</li>
</ul>
<pre><code class="java">public static void main(String[] args) &#123;
    SubTemplate t = new SubTemplate();
    t.spendTime();
&#125;
abstract class Templatet &#123;
    //计算某段代码执行所需要花费的时间
    public void spendTime()&#123;
        long start = System. currentTimeMillis();
        this.code();//不确定的部分、易变的部分
        long end = System.currentTimeMillis();
        System.out.println(&quot;花费的时间为:&quot;+ (end - start));
    &#125;
    public abstract void code();
&#125;
class SubTemplate extends Template&#123;
    @Override
    public void code() &#123;
        //要执行的代码
    &#125;
&#125;
</code></pre>
<h4 id="5-6-2-接口"><a href="#5-6-2-接口" class="headerlink" title="5.6.2 接口"></a>5.6.2 接口</h4><p><strong>普通类:只有具体实现</strong></p>
<p><strong>抽象类:具体实现和规范(抽象方法)都有</strong></p>
<p><strong>接口:只有规范，没有构造器，意味着不能被实例化</strong></p>
<p>接口就是规范，定义的是一组规则。接口的本质是契约，就像我们人类的法律一样。制定好后大家都遵守</p>
<p>声明类的关键字是class,声明接口的关键字是<strong>interface</strong></p>
<p>OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象</p>
<p>Tips：</p>
<ul>
<li>接口中的方法定义<strong>都是public abstract</strong>，书写时可以省略</li>
<li>接口中的属性<strong>都是常量，public static final修饰</strong>的，书写时可以省略</li>
<li>实现接口（<strong>implements</strong>）的类<strong>必须重写</strong>接口中的<strong>所有方法</strong>，否则这个实现类还是一个抽象类</li>
<li>接口的<strong>实现允许多实现</strong>（弥补类不能多继承的局限性，格式class A extends B implements C,D）</li>
<li><strong>接口之间可以继承，而且可以多继承</strong></li>
<li>接口的具体使用，体现出多态性</li>
<li><strong>JDK7及以前</strong>接口中只能定义全局常量和抽象方法；<strong>JDK8及之后</strong>还可以定义静态方法和默认方法</li>
</ul>
<h5 id="1-Java8中接口的新特性"><a href="#1-Java8中接口的新特性" class="headerlink" title="1.Java8中接口的新特性"></a>1.Java8中接口的新特性</h5><pre><code class="java">//首先定义一个接口
public interface CompareA &#123;
    //静态方法
    public static void method1() &#123;
        System.out.println(&quot;CompareA:method1&quot;);
    &#125;
    //默认方法
    public default void method2() &#123;
        System.out.println(&quot;CompareA:method2&quot;);
    &#125;
    public default void method3() &#123;
        System.out.println(&quot;CompareA:method3&quot;);
    &#125;
&#125;
</code></pre>
<ul>
<li><p>1.接口中的<strong>静态方法</strong>只能通过<code>接口名.静态方法</code>进行调用</p>
</li>
<li><p>2.接口中的<strong>默认方法</strong>可以通过<strong>实现类的对象</strong>进行调用，如果实现类<strong>重写了</strong>这个默认方法，那么<strong>调用的还是重写后的方法</strong></p>
<pre><code class="java">public class SubClassTest &#123;
    public static void main(String[] args) &#123;
        SubClass s = new SubClass();
        CompareA.method1(); //输出=&gt;CompareA:method1，1.接口中的静态方法只能通过`接口名.静态方法`进行调用
        s.method2();//输出=&gt;CompareA:method2，2.接口中的默认方法可以通过实现类的对象进行调用
        s.method3();//输出=&gt;SubClass:method3，2.如果实现类重写了这个默认方法，那么调用的还是重写后的方法
    &#125;
&#125;
class SubClass implements CompareA&#123;
    @Override
    public void method3() &#123;
        System.out.println(&quot;SubClass:method3&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>3.如果在<strong>子类(或实现类)继承的父类</strong>和<strong>实现的接口</strong>中声明了同名同参数的<strong>默认方法</strong>，那么子类在<strong>没有重写此方法的情况下</strong>，<strong>默认调用的是父类中的</strong>同名同参数的方法—&gt;类优先原则</p>
<pre><code class="java">public class SubClassTest &#123;
    public static void main(String[] args) &#123;
        SubClass s = new SubClass();
        s.method2();//输出=&gt;SuperClass:method2， 3.类优先原则
    &#125;
&#125;
class SubClass extends SuperClass implements CompareA &#123;
&#125;
class SuperClass &#123;
    public void method2() &#123;
        System.out.println(&quot;SuperClass:method2&quot;);
    &#125;
&#125;
</code></pre>
</li>
<li><p>4.如果实现类实现了多个接口，而这<strong>多个接口中定义了同名同参数的默认方法</strong>，那么在<strong>实现类没有重写此方法的情况下</strong>，出现报错 —&gt;<strong>接口冲突</strong>。这就需要我们<strong>必须</strong>在实现类中重写此方法</p>
<pre><code class="java">public class SubClassTest &#123;
    public static void main(String[] args) &#123;
        SubClass s = new SubClass();
        s.method2();//编译出错   4.接口冲突，需要我们必须在实现类中重写此方法
    &#125;
&#125;
public interface CompareB &#123;
    //默认方法
    public default void method2() &#123;
        System.out.println(&quot;CompareB:method2&quot;);
    &#125;
&#125;
class SubClass implements CompareA,CompareB &#123;
&#125;
</code></pre>
</li>
<li><p>5.在<strong>子类 （或实现类）的方法中</strong>调用<strong>父类中被重写</strong>的方法使用<code>super.方法名</code>，调用<strong>接口中被重写</strong>的方法使用<code>接口名.super.方法名</code></p>
<pre><code class="java">class SubClass extends SuperClass implements CompareA &#123;
    public void method2() &#123;
        System.out.println(&quot;SubClass:method2&quot;);
    &#125;
    public void MyMethod() &#123;
        method2(); //在自己的方法中调用自己重写的方法
        super.method2();//在自己的方法中调用父类中被重写的方法使用super.方法名
        CompareA.super.method2();//在自己的方法中调用接口中被重写的方法使用接口名.super.方法名
    &#125;
&#125;
class SuperClass &#123;
    public void method2() &#123;
        System.out.println(&quot;SuperClass:method2&quot;);
    &#125;
&#125;
</code></pre>
</li>
</ul>
<h5 id="2-接口应用实例：代理模式"><a href="#2-接口应用实例：代理模式" class="headerlink" title="2.接口应用实例：代理模式"></a>2.接口应用实例：代理模式</h5><p>代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问</p>
<p>应用场景：</p>
<ul>
<li>安全代理：屏蔽对真实角色的直接访问</li>
<li>远程代理：通过代理类处理远程方法调用( RMI)</li>
<li>延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象</li>
</ul>
<p>分类：</p>
<ul>
<li>静态代理(静态定义代理类)</li>
<li>动态代理(动态生成代理类)；JDK自带的动态代理，需要反射等知识</li>
</ul>
<pre><code class="java">public static void main(String[] args)&#123;
    Server server = new Server();
    ProxyServer proxyserver = new ProxyServer(server);
    proxyServer.browse();
&#125;
interface NetWork &#123;
    public void browse();
&#125;
//被代理类
class Server implements NetWork&#123;
    @Override
    public void browse() &#123;
        System.out.println(&quot;真实的服务器访问网络&quot;);
    &#125;
&#125;
//代理类
class ProxyServer implements NetWork&#123;
    private NetWork work;
    public ProxyServer(NetWork work)&#123;
        this.work = work;
    &#125;
    public void check()&#123;
        System.out.println(&quot;联网之前的检查工作&quot;);
    &#125;
       @Override
    public void browse()&#123;
        check();
        work.browse();
    &#125;
&#125;
</code></pre>
<h5 id="3-接口应用实例：工厂模式"><a href="#3-接口应用实例：工厂模式" class="headerlink" title="3.接口应用实例：工厂模式"></a>3.接口应用实例：工厂模式</h5><p>工厂模式：实现了<strong>创建者与调用者的分离</strong>，即将<strong>创建对象的具体过程屏蔽隔离</strong>起来，达到提高灵活性的目的</p>
<p><strong>分类：</strong></p>
<ul>
<li>简单工厂模式：用来生产<strong>同一等级结构</strong>中的<strong>任意产品</strong>。(对于增加新的产品，需要修改已有代码) <ul>
<li>缺点：对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则（对扩展开放，对修改封闭)</li>
</ul>
</li>
<li>工厂方法模式：用来生产<strong>同一等级结构</strong>中的<strong>固定产品</strong>。(支持增加任意产品)</li>
<li>抽象工厂模式：用来生产<strong>不同产品族</strong>的<strong>全部产品</strong>。(对于增加新的产品，无能为力;支持增加产品族)</li>
</ul>
<h3 id="5-7-内部类"><a href="#5-7-内部类" class="headerlink" title="5.7 内部类"></a>5.7 内部类</h3><p>内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类</p>
<p>成员内部类(静态、非静态) VS 局部内部类(方法内、代码块内、构造器内)</p>
<p>参考链接：<a target="_blank" rel="noopener" href="https://www.jianshu.com/p/79f6d2aca1d8">https://www.jianshu.com/p/79f6d2aca1d8</a></p>
<h4 id="5-7-1-成员内部类"><a href="#5-7-1-成员内部类" class="headerlink" title="5.7.1 成员内部类"></a>5.7.1 成员内部类</h4><p>一方面，作为外部类的成员：</p>
<ul>
<li><p>调用外部类的结构</p>
</li>
<li><p>可以被static修饰</p>
</li>
<li><p>可以被4种不同的权限修饰</p>
</li>
</ul>
<p>另一方面，作为一个类：</p>
<ul>
<li><p>类内可以定义属性、方法、构造器等</p>
</li>
<li><p>可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承</p>
</li>
<li><p>可以被abstract修饰</p>
<pre><code class="java">//获取内部类对象实例
public class Test &#123;
    public static void main(String[] args) &#123;    
        Person ricky = new Person();
        //获取成员内部类对象实例，方式1：new 外部类.new 内部类
        Person.Heart heart = new Person().new Heart();
        System.out.println(heart.beat());
        //获取成员内部类对象实例，方式1：外部类对象.new 内部类
        heart = ricky.new Heart();
        //获取成员内部类对象实例，方式2：外部类对象.获取方法
        Person.Heart heart2 = ricky.getHeart();
        System.out.println(heart2.beat());
    &#125;
&#125;
//成员内部类的使用
public class Person &#123;
    String name = &quot;大大&quot;;
    //获取内部类对象方法
    public Heart getHeart()&#123;
        //外部类访问内部类信息，需要通过内部类实例，无法直接访问name
        new Heart().name = &quot;明明&quot;;
        return new Heart();
    &#125;
    public void eat()&#123;
        System.out.println(&quot;人会吃东西&quot;);
    &#125;
    //访问修饰符可以任意，设置为private则只能在此外部类中创建实例
    private class Heart &#123;
        String name = &quot;小小&quot;;
        public String beat()&#123;
            //同名属性这里优先访问的是内部类中的name
            String str = name + &quot;的心脏在跳动&quot;;
            //访问外部类中的同名属性
            str = Person.this.name + &quot;的心脏在跳动&quot;;
            eat();//直接调用eat()优先访问的是内部类中定义的
            Person.this.eat(); //调用外部类的同名方法
            return str;
        &#125;
        //同名方法
        public void eat()&#123;
            System.out.println(&quot;吃东西&quot;);
        &#125;
    &#125;
&#125;
</code></pre>
<ul>
<li><p><strong>成员内部类可以无条件访问外部类的属性和方法</strong></p>
</li>
<li><p><strong>外部类想要访问内部类</strong>属性或方法时，必须要<strong>创建一个内部类对象</strong>，然后通过该对象访问内部类的属性或方法</p>
</li>
<li><p><strong>成员内部类里面不能含静态属性或方法</strong></p>
</li>
<li><p>如果成员<strong>内部类的属性或者方法与外部类的同名</strong>，将导致外部类的这些属性与方法在内部类<strong>被隐藏</strong></p>
</li>
<li><p>访问同名属性和方法时<strong>优先访问内部类中</strong>定义的；<strong>访问外部类</strong>中的同名属性和方法可按照<strong>该格式调用</strong>，<code>外部类.this.属性/方法</code></p>
</li>
<li><p>成员内部类访问权限：成员内部类前可加上四种访问修饰符。</p>
<p>   private：仅外部类可访问<br>   protected：同包下或继承类可访问<br>   default：同包下可访问<br>   public：所有类可访问</p>
</li>
<li><p>内部类编译后<code>.class</code>文件的名称：外部类$内部类.class</p>
</li>
</ul>
</li>
</ul>
<h4 id="5-7-2-静态内部类"><a href="#5-7-2-静态内部类" class="headerlink" title="5.7.2 静态内部类"></a>5.7.2 静态内部类</h4><pre><code class="java">//定义格式
class U &#123;
    static class I &#123;       
    &#125;
&#125;
//使用实例
public class Person &#123;
    String name = &quot;大大&quot;;
    public static int age = 22;
    //获取内部类对象方法
    public Heart getHeart()&#123;
        return new Heart();
    &#125;
    public void eat()&#123;
        System.out.println(&quot;人会吃东西&quot;);
    &#125;
    //静态内部类
    public static class Heart &#123;
        String name = &quot;小小&quot;;
        public static int age = 12;
        public String beat()&#123;
            //静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例
            //直接访问eat()会报错
            new Person().eat();
            //内部类中的成员方法可以直接访问内部类中的非静态成员和静态成员
            String str = name + age + &quot;岁的心脏在跳动&quot;;
            //访问外部类中的非静态成员和同名静态成员
            return new Person().name + Person.age + &quot;的心脏在跳动&quot;;
        &#125;
    &#125;
    //测试
    public static void main(String[] args) &#123;
        //获取静态内部类对象实例
        Person.Heart heart = new Person.Heart();
        System.out.println(heart.beat());
        //可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员
        Person.Heart.age = 15;
    &#125;
&#125;
</code></pre>
<ul>
<li>静态内部类和成员内部类相比多了一个<strong>static</strong>修饰符，它与类的静态成员变量一样，<strong>不依赖于外部类对象</strong></li>
<li>获取静态内部类对象实例：<code>new 外部类名.静态类()</code></li>
<li>静态内部类中，只能直接访问外部类的<strong>静态成员</strong>，如果需要调用非静态成员，可以通过<strong>外部类对象实例</strong>访问</li>
<li>可以通过<code>外部类.内部类.静态成员</code>的方式，访问<strong>内部类中的静态成员</strong></li>
<li>当内部类中静态成员与外部类静态成员同名时，<strong>默认直接调用内部类中的成员</strong>，可以通过 <code>外部类.成员</code> 的方式访问外部类的同名静态成员，而对于<strong>外部类中的非静态成员</strong>，不管同不同名，都需要<strong>通过外部类实例访问</strong></li>
<li>静态内部类也有它的特殊性，因为外部类加载时只会加载静态域，所以<strong>静态内部类中不能使用外部类的非静态变量与方法</strong></li>
</ul>
<h4 id="5-7-3-局部内部类"><a href="#5-7-3-局部内部类" class="headerlink" title="5.7.3 局部内部类"></a>5.7.3 局部内部类</h4><pre><code class="java">//定义格式
class K&#123;
    public void say()&#123;
        class J&#123;           
        &#125;
    &#125;
&#125;
//使用实例
public class Person &#123;
    String name = &quot;大大&quot;;
    public static int age = 22;

    public Object getHeart()&#123;
        int num = 10;
        //方法内部类：不能使用任何访问修饰符，不能使用static修饰
        class Heart &#123;
            String name = &quot;小小&quot;;
            //类成员可以使用访问修饰符、final、abstract，但不能使用static修饰
            public final int age = 12;
            
            public String beat()&#123;
                System.out.println(num);//内部类想要使用所在方法的局部变量时，该变量必须被声明为final（JDK8及之后不用显示声明）
                new Person().eat(); //访问外部类的非静态方法，通过实例对象
                return name + Person.age + &quot;的心脏在跳动&quot;; //Person.age访问外部类的静态变量
            &#125;
        &#125;
         return new Heart().beat();//调用内部类的非静态方法
    &#125;
    public void eat()&#123;
        System.out.println(&quot;人会吃东西&quot;);
    &#125;
    //测试
    public static void main(String[] args) &#123;
        Person ricky = new Person();
        //调用包含方法内部类的方法
        System.out.println(ricky.getHeart());   
    &#125;
&#125;
</code></pre>
<ul>
<li>局部内部类存在于方法中，它与成员内部类的区别在于局部内部类的<strong>访问权限和作用范围仅限于方法或作用域内</strong></li>
<li>方法内部类不能使用任何访问修饰符，不能使用<code>static</code>修饰</li>
<li>类中不能包含静态成员，但可以包含<code>final</code>、<code>abstract</code>修饰的成员</li>
</ul>
<h4 id="5-7-4-匿名内部类"><a href="#5-7-4-匿名内部类" class="headerlink" title="5.7.4 匿名内部类"></a>5.7.4 匿名内部类</h4><pre><code class="java">//完成一个不同的人进行阅读的操作
//定义抽象父类
public abstract class Person &#123;
    //阅读方法
    public abstract void read();
&#125;
//定义子类
public class Man extends Person&#123;
    @Override
    public void read() &#123;
        System.out.println(&quot;男生喜欢看科幻类书籍&quot;);       
    &#125;
&#125;
public class Women extends Person&#123;
    @Override
    public void read() &#123;
        System.out.println(&quot;女生喜欢读言情小说&quot;);        
    &#125;
&#125;
</code></pre>
<pre><code class="java">//使用传统的多态方式实现以及匿名内部类实现
public class Test &#123;
    //需求：根据传入的不同的人的类型，调用对应的read方法
    public void getRead(Person person)&#123;
        person.read();
    &#125;
    public static void main(String[] args) &#123;
        //方案一：利用多态调用对应子类的实现
        Test test = new Test();
        Man one=new Man();
        Woman two=new Woman();
        test.getRead(one);
        test.getRead(two);  
        //方案二：不定义任何子类，使用匿名内部类完成具体的read方法实现
        test.getRead(new Person()&#123;
            @Override
            public void read() &#123;
                System.out.println(&quot;男生喜欢看科幻类书籍&quot;);
            &#125;
        &#125;);
        test.getRead(new Person()&#123;
            @Override
            public void read() &#123;
                System.out.println(&quot;女生喜欢读言情小说&quot;);
            &#125;
        &#125;);
    &#125;
&#125;
//匿名内部类在合适的场景下对于内存的损耗和对系统的性能影响就会相对较小，弊端就是只能使用一次，无法重复使用
</code></pre>
<h4 id="5-7-5-适用场景"><a href="#5-7-5-适用场景" class="headerlink" title="5.7.5 适用场景"></a>5.7.5 适用场景</h4><ul>
<li><p>只用到类的一个实例</p>
</li>
<li><p>类在定义后马上用到</p>
</li>
<li><p>给类命名并不会导致代码更容易被理解</p>
</li>
</ul>
<pre><code class="java">//1.继承式的匿名内部类
public class Demo &#123;
    public static void main(String[] args) &#123;
        //继承式的匿名内部类(相当于定义了一个匿名的Thread子类,目的是重写其方法)
        Thread thread = new Thread() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 5; i++) &#123;
                    System.out.println(i + &quot; &quot;);
                &#125;
            &#125;
        &#125;;
        thread.start();
    &#125;
&#125;
//2.接口式的匿名内部类
public class Demo &#123;
    public static void main(String[] args) &#123;
        //接口式的匿名内部类(相当于创建了一个实现了接口的匿名类)
        Runnable r = new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 5; i++) &#123;
                    System.out.println(i + &quot; &quot;);
                &#125;
            &#125;
        &#125;;
        Thread thread = new Thread(r);
        thread.start();
    &#125;
&#125;
//3.参数式的匿名内部类
public class Demo &#123;
    public static void main(String[] args) &#123;
        //参数式的匿名内部类
        Thread thread = new Thread(new Runnable() &#123;
            @Override
            public void run() &#123;
                for (int i = 0; i &lt;= 5; i++) &#123;
                    System.out.println(i + &quot; &quot;);
                &#125;
            &#125;
        &#125;);
        thread.start();
    &#125;
&#125;
</code></pre>
<p><strong>结论：</strong>由上面三个例子可以看出，匿名内部类可以继承一个具体的父类，也可以实现某个接口。只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现</p>
<p><strong>注意：</strong></p>
<ul>
<li>匿名内部类没有类型名称、实例对象名称</li>
<li>编译后的文件命名：外部类$数字.class</li>
<li>无法使用访问修饰符、也无法使用<code>abstract</code>、<code>static</code>修饰</li>
<li>无法编写构造方法，也是唯一没有构造方法的内部类，可以添加构造代码块，通过代码块完成匿名内部类的初始化</li>
<li>不能出现静态成员，不能出现抽象方法</li>
<li>匿名内部类可以实现接口也可以继承父类，但是不可兼得</li>
<li><strong>匿名内部类和局部内部类只能访问外部类的final变量</strong></li>
</ul>
<p><strong>内部类的好处：</strong></p>
<ul>
<li>完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响</li>
<li>方便写事件驱动程序</li>
</ul>
<h3 id="5-8-Object类浅析"><a href="#5-8-Object类浅析" class="headerlink" title="5.8 Object类浅析"></a>5.8 Object类浅析</h3><p>Object类是所有Java类的根父类</p>
<p>如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类</p>
<p>Object类中的功能（属性、方法）具有通用性</p>
<p>Object类只声明了一个空参构造器</p>
<p><code>public class Person &#123;...&#125;</code>等价于<code>public class Person extends Object &#123;...&#125;</code></p>
<pre><code class="java">//例: method(Object obj)&#123;...&#125;可以接收任何类作为其参数
//Person o=new Person();
//method(o);
</code></pre>
<h4 id="5-8-1-Object类中的方法"><a href="#5-8-1-Object类中的方法" class="headerlink" title="5.8.1 Object类中的方法"></a>5.8.1 Object类中的方法</h4><ul>
<li>Object类没有属性</li>
<li> clone()：克隆一个对象并返回</li>
<li>equals()：比较两个对象是否相等</li>
<li>finalize()：JVM进行垃圾回收前要执行的方法，通常情况都是垃圾回收器自动调用，程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，但是系统是否进行依然不确定（垃圾回收机制只回收JVM中堆内存中的对象空间）（面试题：final、finally、finalize的区别）</li>
<li>getClass()：获取当前对象的所属类 </li>
<li>hashcode()：返回当前对象的哈希值</li>
<li>toString()：对象打印时调用，在Object中是返回当前对象的类名和引用地址，如果被其他类（如String类、Date类、File类、包装类等）重写就会执行重写后的方法</li>
<li>notify()、notifyAll()、wait()：线程相关方法</li>
</ul>
<h4 id="5-8-2-和equals-方法的区别"><a href="#5-8-2-和equals-方法的区别" class="headerlink" title="5.8.2 ==和equals()方法的区别"></a>5.8.2 ==和equals()方法的区别</h4><ol>
<li><p><strong>既可以比较基本类型也可以比较引用类型</strong>。对于<strong>基本类型</strong>就是比较<strong>值</strong>，对于<strong>引用类型</strong>就是比较<strong>内存地址</strong></p>
</li>
<li><p>equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是;我们可以看到<strong>string等类的equals方法是被重写</strong>过的，而且String类在日常开发中用的比较多，久而久之,形成了equals是比较值的错误观点（比如String类、Date类、File类、包装类等都重写了Object类的equals方法，重写后，不是比较的两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同）</p>
</li>
<li><p>具体要看自定义类里<strong>有没有重写</strong>Object的equals方法来判断</p>
</li>
<li><p>通常情况下，<strong>重写</strong>equals方法，会<strong>比较类中的相应属性是否都相等</strong></p>
</li>
<li><p>Object类中equals()方法和==的作用一样，都是比较两个对象的地址值是否相同</p>
<pre><code class="java">//Object类中的equals方法，比较引用地址
public boolean equals(Object obj) &#123;
    return (this == obj);
&#125;
//String类中的equals方法，首先比较引用是否相同，如不同再比较两个对象的各个属性值是否相同
public boolean equals(Object anObject) &#123;
        if (this == anObject) &#123;
            return true;
        &#125;
        if (anObject instanceof String) &#123;
            String anotherString = (String)anObject;
            int n = value.length;
            if (n == anotherString.value.length) &#123;
                char v1[] = value;
                char v2[] = anotherString.value;
                int i = 0;
                while (n-- != 0) &#123;
                    if (v1[i] != v2[i])
                        return false;
                    i++;
                &#125;
                return true;
            &#125;
        &#125;
        return false;
    &#125;
</code></pre>
</li>
</ol>
<h4 id="5-8-3-toString-方法"><a href="#5-8-3-toString-方法" class="headerlink" title="5.8.3 toString()方法"></a>5.8.3 toString()方法</h4><p><code>toString()</code>方法在<strong>Object类</strong>中定义，其返回值是<strong>String</strong>类型，返回类名和它的引用地址</p>
<p>在进行String与其它类型数据的连接操作时，自动调用toString()方法（与基本类型的连接可参考1.3.3）</p>
<pre><code class="java">Date now=new Date();
system.out.printIn(&quot;now=&quot;+now);//相当于system.out.printIn(&quot;now=+now.toString());输出=&gt;now=当前时间
</code></pre>
<p>可以根据需要在用户自定义类型中**重写toString()**方法如String 类重写了toString()方法，返回字符串的值。</p>
<pre><code class="java">s1=&quot;hello&quot;;
system.out.printIn(s1);//相当于System.out.printIn(s1.toString());输出=&gt;hello
</code></pre>
<p>基本类型数据转换为String类型时，调用了对应包装类的toString()方法</p>
<pre><code class="java">int a=10;
system.out.printIn(&quot;a=&quot;+a);
</code></pre>
<h3 id="5-9-包装类"><a href="#5-9-包装类" class="headerlink" title="5.9 包装类"></a>5.9 包装类</h3><h4 id="5-9-1-装箱和拆箱"><a href="#5-9-1-装箱和拆箱" class="headerlink" title="5.9.1 装箱和拆箱"></a>5.9.1 装箱和拆箱</h4><pre><code class="java">int num = 10;
//装箱
Integer i = new Integer(num);
//拆箱
int num1 = Integer.intValue(i);

//其他其中基本类型的装箱和拆箱操作也如上
</code></pre>
<h4 id="5-9-2-自动拆箱和自动装箱（JDK5版本之后的新特性）"><a href="#5-9-2-自动拆箱和自动装箱（JDK5版本之后的新特性）" class="headerlink" title="5.9.2 自动拆箱和自动装箱（JDK5版本之后的新特性）"></a>5.9.2 自动拆箱和自动装箱（JDK5版本之后的新特性）</h4><pre><code class="java">int i = 0;
//自动装箱
Integer num = i;
//自动拆箱
int m = num;

//基本数据类型的自动装箱和拆箱只适用于变量的值在相应包装类中缓冲区范围内，超出范围则需要通过5.8.1的方式来进行拆箱和装箱
//比如，int类型对应的Integer包装类中缓冲区的数组范围为-128~127，如果一个int i= 130需要进行装箱，则需要new Integer(i)来进行装箱

//其他几种基本数据类型也能进行装箱拆箱
</code></pre>
<p>通过将基本数据类型进行装箱操作后可以调用封装类中的方法和变量，常量</p>
<p>将一个基本数据类型的变量进行封装后可以判断这个变量的值是否为null</p>
<h4 id="5-9-3-基本数据类型和String类型的相互转换"><a href="#5-9-3-基本数据类型和String类型的相互转换" class="headerlink" title="5.9.3 基本数据类型和String类型的相互转换"></a>5.9.3 基本数据类型和String类型的相互转换</h4><pre><code class="java">//包装类---&gt;String
//方法一：连接运算
int num = 10；
String str1 = num + &quot;&quot;;
//方法二：调用String的ValueOf方法
float f = 12.3f;
String str2 = String.ValueOf(f);
//String---&gt;基本数据类型、包装类
String str3 = &quot;123&quot;;
int num1 = Integer.parseInt(Str3);
//错误情况：int num1 = (int)str3;或者Integer i = (Integer)str3;
</code></pre>
<h3 id="5-10-单例设计模式"><a href="#5-10-单例设计模式" class="headerlink" title="5.10 单例设计模式"></a>5.10 单例设计模式</h3><p>设计模式是<strong>在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式</strong></p>
<p>设计模式分类：</p>
<ul>
<li>创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式</li>
<li>结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式</li>
<li>行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式</li>
</ul>
<p>所谓类的单例设计模式，就是采取一定的方法保证在<strong>整个的软件系统</strong>中，对某个类<strong>只能存在一个对象实例</strong>，并且该类<strong>只提供一个取得其对象实例的方法</strong>。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将<strong>类的构造器</strong>的访问权限设置为<strong>private</strong>，这样，就不能用new在类的外部创建类的对象了，但在<strong>类内部</strong>仍可以<strong>产生该类的对象</strong>。因为在类的外部开始还无法得到类的对象，只能<strong>调用该类的某个静态方法以返回类内部创建的对象</strong>，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的<strong>该类对象的变量也必须定义成静态的</strong>（简单来说，单例模式（Singleton模式）指的是<strong>一个类，在一个JVM里，只有一个实例存在；且构造方法私有化</strong>）</p>
<p>单例模式<strong>优点</strong>：由于单例模式只生成一个实例，<strong>减少了系统性能开销</strong>，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决</p>
<h4 id="5-10-1-单例模式饿汉式"><a href="#5-10-1-单例模式饿汉式" class="headerlink" title="5.10.1 单例模式饿汉式"></a>5.10.1 单例模式饿汉式</h4><p>饿汉式是无论如何都会创建一个实例对象</p>
<pre><code class="java">class Bank &#123;
    //1.内部创建类的对象
    //2.由于静态方法只能访问静态属性，所以这个对象属性必须为static
    priavte static Bank instance = new Bank();
    //3.构造方法私有化
    private Bank() &#123;
    &#125;
    //4.提供公共的静态方法返回类的对象
    public static Bank getInstance() &#123;
        return instance;
    &#125;
&#125;
</code></pre>
<h4 id="5-10-2-单例模式懒汉式"><a href="#5-10-2-单例模式懒汉式" class="headerlink" title="5.10.2 单例模式懒汉式"></a>5.10.2 单例模式懒汉式</h4><p>懒汉式只有在调用getInstance的时候，才会创建实例 </p>
<pre><code class="java">class Bank &#123;
    //1.准备一个属性，用于指向一个实例化对象，但是暂时指向null
    //2.由于静态方法只能访问静态属性，所以这个对象属性必须为static
    priavte static Bank instance;
    //3.构造方法私有化
    private Bank() &#123;
    &#125;
    //4.提供公共的静态方法返回类的对象
    public static Bank getInstance() &#123;
        if(null == instance) &#123; //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象
            instance = new Bank();
        &#125;
        return instance; //返回instance指向的实例对象
    &#125;
&#125;
</code></pre>
<h4 id="5-10-3-饿汉式和懒汉式的区分"><a href="#5-10-3-饿汉式和懒汉式的区分" class="headerlink" title="5.10.3 饿汉式和懒汉式的区分"></a>5.10.3 饿汉式和懒汉式的区分</h4><p>饿汉式：</p>
<ul>
<li>好处：线程安全，只能创建出一个实例对象</li>
<li>坏处：对象加载时间过长</li>
</ul>
<p>懒汉式：</p>
<ul>
<li>好处：延迟对象的创建</li>
<li>坏处：线程不安全，有创建出多个实例对象的可能—-&gt;到多线程时再修改</li>
</ul>
<h3 id="5-11-MVC设计模式"><a href="#5-11-MVC设计模式" class="headerlink" title="5.11 MVC设计模式"></a>5.11 MVC设计模式</h3><p>MVC是常用的设计模式之一，将整个程序分为三个层次：<strong>视图模型层</strong>，<strong>控制器层</strong>，与<strong>数据模型层</strong>。这种将<code>程序输入输出</code>、<code>数据处理</code>，以及<code>数据的展示</code>分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性</p>
<p><strong>模型层 model主要处理数据</strong></p>
<blockquote>
<p>数据对象封装 model.bean/domain</p>
<p>数据库操作类 model.dao</p>
<p>数据库 model.db</p>
</blockquote>
<p><strong>视图层 view显示数据</strong></p>
<blockquote>
<p>相关工具类 view.utils<br>自定义view view.ui</p>
</blockquote>
<p><strong>控制层 controller处理业务逻辑</strong></p>
<blockquote>
<p>应用界面相关 controller.activity</p>
<p>存放fragment controller.fragment</p>
<p>显示列表的适配器 controller.adapter</p>
<p>服务相关的 controller.service</p>
<p>抽取的基类 controller.base</p>
</blockquote>
<h2 id="六、Java异常和错误"><a href="#六、Java异常和错误" class="headerlink" title="六、Java异常和错误"></a>六、Java异常和错误</h2><h3 id="6-1-什么是异常"><a href="#6-1-什么是异常" class="headerlink" title="6.1 什么是异常?"></a>6.1 什么是异常?</h3><p>软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是:<strong>Exception</strong>，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃</p>
<p>异常指<strong>程序运行中出现的不期而至的各种状况</strong>,如:文件找不到、网络连接失败、非法参数等；异常发生在程序运行期间,它影响了正常的程序执行流程。</p>
<h4 id="6-1-1-异常分类"><a href="#6-1-1-异常分类" class="headerlink" title="6.1.1 异常分类"></a>6.1.1 异常分类</h4><p><strong>检查性异常</strong>:最具代表的检查性异常是用户错误或问题引起的异常,这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略</p>
<p><strong>运行时异常</strong>:运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在<br>编译时被忽略</p>
<p><strong>错误(ERROR)</strong>:错误不是异常, 而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢<br>出时，一个错误就发生了，它们在编译也检查不到的</p>
<h4 id="6-1-2-异常体系结构"><a href="#6-1-2-异常体系结构" class="headerlink" title="6.1.2 异常体系结构"></a>6.1.2 异常体系结构</h4><p>Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类</p>
<p>在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636198.png' data-fancybox='default' data-caption='image-20210717185030151'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636198.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201636198.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210717185030151"></a><span class='image-caption'>image-20210717185030151</span></div></div>

<h4 id="6-2-3-Error"><a href="#6-2-3-Error" class="headerlink" title="6.2.3 Error"></a>6.2.3 Error</h4><p>Error类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关</p>
<p>Java虚拟机运行错误(Virtual MachineError) , 当JVM不再有继续执行操作所需的内存资源<br>时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM) - -般会选择线程终<br>止</p>
<p>还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError) 、链接错误<br>(LinkageError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外,而且<br>绝大多数是程序运行时不允许出现的状况</p>
<h4 id="6-2-4-Exception"><a href="#6-2-4-Exception" class="headerlink" title="6.2.4 Exception"></a>6.2.4 Exception</h4><p>在Exception分支中有一个重要的子类RuntimeException (运行时异常)：</p>
<ul>
<li><p>ArrayIndexOutOfBoundsException (数组下标越界)</p>
</li>
<li><p>NullPointerException (空指针异常)</p>
</li>
<li><p>ArithmeticException (算术异常)</p>
</li>
<li><p>MissingResourceException (丢失资源)</p>
</li>
<li><p>ClassNotFoundException (找不到类)等异常，这些异常是不检查异常，程序中可以选<br>  择捕获处理，也可以不处理</p>
</li>
</ul>
<p>这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生</p>
<p><strong>Error和Exception的区别</strong>: Error通常是<strong>灾难性的致命的错误</strong>，是程序<strong>无法控制和处理</strong>的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程; Exception通常情况下是<strong>可以被程序处理</strong>的，并且在程序中应该尽可能的去处理这些异常</p>
<h3 id="6-2-异常处理机制"><a href="#6-2-异常处理机制" class="headerlink" title="6.2 异常处理机制"></a>6.2 异常处理机制</h3><p>分为：<strong>抛出异常</strong>、<strong>捕获异常</strong></p>
<p><strong>子类重写的方法抛出的异常不大于父类被重写的方法抛出的异常</strong></p>
<p>异常处理的5个关键字：<strong>try</strong>、<strong>catch</strong>、<strong>finally</strong>、<strong>throw</strong>、<strong>throws</strong></p>
<pre><code class="java">//捕获异常
try &#123;
    //将要执行，被捕获异常的语句，放在try语句块中
&#125; catch(Exception e) &#123;
    //如果上方语句出现相应异常，则执行catch语句块中的语句
&#125; finally &#123;
    //无论try中的代码语句是否有被捕获到异常，然后转到catch块进行处理，finally中的语句都会执行
    //finally语句块是否使用为可选，可以使用，也可以不使用
&#125;
//一个try代码块后面可跟随多个catch代码块，这种情况叫做多重捕获
//若需要捕获多个异常，需要从小到大
</code></pre>
<pre><code class="java">//抛出异常
//如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。
//也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的
public class Test &#123;
    //假设方法中处理不了这个异常，则在方法上进行抛出
    //一个方法可以抛出多个异常，中间用逗号隔开
    public void test() throws Exception &#123;
        throw new Exception(); //主动抛出异常，一般在方法中使用
    &#125;
&#125;
</code></pre>
<p><strong>开发中如何选择使用try-catch- finally还是使用throws?</strong></p>
<p>①如果<strong>父类</strong>中被重写的方法<strong>没有</strong>throws方式处理异常，则<strong>子类</strong>重写的方法<strong>也不能</strong>使用throws，意味着如果子类重写的方法中有异常，必须使用try- catch- finally方式处理</p>
<p>②执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try- catch-finally方式进行处理</p>
<h3 id="6-3-自定义异常"><a href="#6-3-自定义异常" class="headerlink" title="6.3 自定义异常"></a>6.3 自定义异常</h3><p>使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类,只需继承Exception类即可</p>
<p>编写自己的异常时，需要注意几点：</p>
<ul>
<li>所有异常都必须是 Throwable 的子类</li>
<li>如果希望写一个检查性异常类，则需要继承 Exception 类</li>
<li>如果你想写一个运行时异常类，那么需要继承 RuntimeException 类</li>
</ul>
<p>在程序中使用自定义异常类，大体可分为以下几个步骤:</p>
<ol>
<li>创建自定义异常类</li>
<li>在方法中通过throw关键字抛出异常对象。</li>
<li>如果在当前抛出异常的方法中处理异常,可以使用try-catch语句捕获并处理;否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作</li>
<li>在出现异常方法的调用者中捕获并处理异常</li>
</ol>
<pre><code class="java">//自定义异常
public class MyException extends Exception&#123;
    //传递数字
    private int number;

    public MyException(int a) &#123;
        this.number = a;
    &#125;
    //toString:异常的打印信息
    @Override
    public String toString() &#123;
        return &quot;MyException&#123;&quot; + &quot;number=&quot; + number + &#39;&#125;&#39;;
    &#125;
&#125;
//使用自定义异常
public class test06 &#123;
    public static void main(String[] args) &#123;
        try &#123;
            addNumber(11); //因为传给addNumbers方法的值为11，所以 报错输出MyException=&gt;MyException&#123;number=11&#125;
        &#125; catch (Exception e) &#123;
            System.out.println(&quot;MyException=&gt;&quot; + e);
        &#125;
    &#125;

    private static void addNumber(int a) throws MyException&#123;
        if (a &gt; 10) &#123;
            throw new MyException(a);
        &#125;
        System.out.println(a);
    &#125;
&#125;
//为什么第21行输出e会自动调用toString方法？
//因为在MyException中重写了父类中的toString方法，System.out.println则会调用子类重写的这个toString方法，否则他就会调用父类中的toS 方法
</code></pre>
<h2 id="七、Java多线程"><a href="#七、Java多线程" class="headerlink" title="七、Java多线程"></a>七、Java多线程</h2><h3 id="7-1-基本概念：程序、进程、线程"><a href="#7-1-基本概念：程序、进程、线程" class="headerlink" title="7.1 基本概念：程序、进程、线程"></a>7.1 基本概念：程序、进程、线程</h3><p><strong>程序(program)<strong>是</strong>为完成特定任务、用某种语言编写的一组指令的集合</strong>。即指<strong>一段静态的代码</strong>，静态对象</p>
<p><strong>进程(process)<strong>是</strong>程序的一次执行过程</strong>，或是<strong>正在运行的一个程序</strong>。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期</p>
<ul>
<li>如:运行中的QQ，运行中的MP3播放器</li>
<li><strong>程序是静态的，进程是动态的</strong></li>
<li><strong>进程作为资源分配的单位</strong>，系统在运行时会为每个进程分配不同的内存区域</li>
</ul>
<p><strong>线程(thread)<strong>，进程可进一步细化为线程，是</strong>一个程序内部的一条执行路径</strong></p>
<ul>
<li>若一个进程同一时间<strong>并行执行</strong>多个线程，就是支持多线程的</li>
<li>**线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小</li>
<li>一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来<strong>安全的隐患</strong></li>
</ul>
<p><strong>JVM结构：</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637101.png' data-fancybox='default' data-caption='image-20210724213734378'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637101.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637101.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210724213734378"></a><span class='image-caption'>image-20210724213734378</span></div></div>

<h4 id="7-1-1-CPU、并行与并发的理解"><a href="#7-1-1-CPU、并行与并发的理解" class="headerlink" title="7.1.1 CPU、并行与并发的理解"></a>7.1.1 CPU、并行与并发的理解</h4><p><strong>单核CPU和多核CPU的理解</strong></p>
<ul>
<li>单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”(晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来</li>
<li>如果是多核的话，才能更好的发挥多线程的效率(现在的服务器都是多核的）</li>
<li>一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程</li>
</ul>
<p><strong>并行与并发</strong></p>
<ul>
<li>并行：<strong>多个CPU同时执行多个任务</strong>（多个人同时做不同的事(多对多)，如，篮球场上的人(多个CPU)同时在做不同的事(多个任务)）</li>
<li>并发：<strong>一个CPU(采用时间片)同时执行多个任务</strong>（一个人同时做不同的事(一对多)，比如，篮球场(一个CPU)上每个人做的事(多个任务)）</li>
</ul>
<h4 id="7-1-2-多线程的优点"><a href="#7-1-2-多线程的优点" class="headerlink" title="7.1.2 多线程的优点"></a>7.1.2 多线程的优点</h4><ol>
<li><strong>提高应用程序的响应</strong>。对图形化界面更有意义，可增强用户体验</li>
<li><strong>提高计算机系统CPU的利用率</strong></li>
<li><strong>改善程序结构</strong>。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改</li>
</ol>
<h4 id="7-1-3-什么时候需要多线程"><a href="#7-1-3-什么时候需要多线程" class="headerlink" title="7.1.3 什么时候需要多线程"></a>7.1.3 什么时候需要多线程</h4><ol>
<li>程序需要<strong>同时执行两个或多个任务</strong></li>
<li>程序需要<strong>实现一些需要等待的任务</strong>时，如用户输入、文件读写操作、网络操作、搜索等</li>
<li>需要一些<strong>后台运行的程序</strong>时</li>
</ol>
<h4 id="7-1-4-线程的分类"><a href="#7-1-4-线程的分类" class="headerlink" title="7.1.4 线程的分类"></a>7.1.4 线程的分类</h4><p>Java中的线程分为两类：一种是<strong>守护线程</strong>，一种是<strong>用户线程</strong></p>
<ul>
<li>它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开</li>
<li>守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程</li>
<li>Java垃圾回收就是一个典型的守护线程</li>
<li>若JVM中都是守护线程，当前JVM将退出</li>
</ul>
<h3 id="7-2-线程的创建和使用"><a href="#7-2-线程的创建和使用" class="headerlink" title="7.2 线程的创建和使用"></a>7.2 线程的创建和使用</h3><h4 id="7-2-1-线程的调度"><a href="#7-2-1-线程的调度" class="headerlink" title="7.2.1 线程的调度"></a>7.2.1 线程的调度</h4><p><strong>调度策略：</strong></p>
<ul>
<li><p>时间片：每个线程占用CPU一段时间</p>
</li>
<li><p>抢占式：高优先级的线程抢占CPU</p>
</li>
</ul>
<p><strong>Java的调度方法</strong></p>
<ul>
<li>同优先级线程组成先进先出队列（先到先服务），使用时间片策略</li>
<li>对高优先级，使用优先调度的抢占式策略</li>
</ul>
<p><strong>线程的优先级等级</strong></p>
<ul>
<li>MAX_PRIORITY：10</li>
<li>MIN_PRIORITY：1</li>
<li>NORM_PRIORITY：5</li>
</ul>
<p><strong>涉及的方法</strong></p>
<ul>
<li>getPriority()：返回线程优先值</li>
<li>setPriority(int newPriority)：改变线程的优先级</li>
</ul>
<p><strong>说明</strong></p>
<ul>
<li>线程创建时<strong>继承父线程的优先级</strong></li>
<li>低优先级只是获得调度的<strong>概率低</strong>，并非一定是在高优先级线程之后才被调用</li>
</ul>
<p><strong>线程通信：</strong>wait()、notify()、notifyAll()此三个方法定义在Object类中</p>
<h4 id="7-2-2-多线程的创建"><a href="#7-2-2-多线程的创建" class="headerlink" title="7.2.2 多线程的创建"></a>7.2.2 多线程的创建</h4><h5 id="1-方法一：继承Thread类"><a href="#1-方法一：继承Thread类" class="headerlink" title="1.方法一：继承Thread类"></a>1.方法一：继承Thread类</h5><ol>
<li>创建一个继承于Thread类的子类</li>
<li>重写Thread类的run() —&gt;将此线程要执行的操作声明在run()中</li>
<li>创建Thread类的子类的对象</li>
<li>通过此对象调用start()  —&gt;①启动当前线程  ②调用当前线程的run()方法  ③每个线程只能start一次</li>
<li>不能直接调用run()方法，否则相当于普通方法的调用在main线程中执行，不会有线程之间的交互进行</li>
</ol>
<pre><code class="java">public class ThreadTest01  &#123;
    public static void main(String[] args) &#123;
        MyThread myThread = new MyThread(); //3.在main线程中创建一个新的线程
        myThread.start(); //4.调用start()方法，开始执行这个线程的操作，此时会从主线程另外分出一个线程执行命令
        System.out.println(&quot;**************&quot;); //下面是主线程需要执行的操作，从输出结果可以看出两个线程的交互执行
        for (int i = 0; i &lt; 100; i++) &#123; //遍历100以内的奇数
            if(i % 2 != 0) System.out.println(i + &quot;main()&quot;);
        &#125;
    &#125;
&#125;
class MyThread extends Thread &#123; //1.继承Thread类
    @Override
    public void run() &#123; //2.重写run()方法
        for (int i = 0; i &lt; 100; i++) &#123; //遍历100以内的偶数
            if(i % 2 == 0) System.out.println(i);
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//创建两个分线程，一个打印100以内的偶数，一个打印100以内的奇数
public static void main(String[] args) &#123;
    //方法一：创建两个线程子类，再分别创建一个对象，在各自的run方法中重写不同操作
    //方法二：创建两个线程的匿名子类对象，如下：
    new Thread()&#123;
        @Override
        public void run() &#123;
            for (int i = 0; i &lt; 100; i++) &#123;
                if(i % 2 == 0) System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);
            &#125;
        &#125;
    &#125;.start();
    new Thread()&#123;
        @Override
        public void run() &#123;
            for (int i = 0; i &lt; 100; i++) &#123;
                if(i % 2 != 0) System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);
            &#125;
        &#125;
    &#125;.start();
&#125;
</code></pre>
<h5 id="2-方法二：实现Runnable接口"><a href="#2-方法二：实现Runnable接口" class="headerlink" title="2.方法二：实现Runnable接口"></a>2.方法二：实现Runnable接口</h5><ol>
<li>创建一个实现了Runnable接口的类</li>
<li>实现类去实现Runnable中的抽象方法: run( )</li>
<li>创建实现类的对象</li>
<li>将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象</li>
<li>通过Thread类的对象调用start(）</li>
</ol>
<pre><code class="java">class  MyThread implements Runnable &#123; //1.创建一个实现了Runnable接口的类
    @Override
    public void run() &#123;  //2.实现类去实现Runnable中的抽象方法: run()
        for (int i = 0; i &lt; 100; i++) &#123;
            if(i%2==0) &#123;
                System.out.println(i);
            &#125;
        &#125;
    &#125;
&#125;
public class ThreadTest03 &#123;
    public static void main(String[] args) &#123;
        MyThread myThread = new MyThread();  //3.创建实现类的对象
        Thread t1 = new Thread(myThread);  //4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象
        t1.start();  //5.通过Thread类的对象调用start(）
    &#125;
&#125;
</code></pre>
<pre><code class="java">//多窗口抢票实例
//目前存在线程安全问题，即第100张票可能被多个窗口同时卖出，等到7.4节得以解决
class window extends Thread &#123;
    private static int stick = 100; //必须加上static才能让三个线程共享100张票，否则会出现每个线程都有100张票的情况
    @Override                   //因为这种线程创建的方式是一个线程为一个对象，而实现接口的方式是一个对象创建三个线程
    public void run() &#123;
        while (true) &#123;
            if(stick &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + stick);
                stick--;
            &#125; else &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
class window implements Runnable &#123;
    private int stick = 100; //不用加上static也能让三个线程共享100张票，因为这三个线程都是由同一个对象创建的
    @Override
    public void run() &#123;
        while (true) &#123;
            if(stick &gt; 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + stick);
                stick--;
            &#125; else &#123;
                break;
            &#125;
        &#125;
    &#125;
&#125;
public class ThreadTest02 &#123;
    public static void main(String[] args) &#123;
        //继承Thread类的方式实现
        window t1 = new window();
        window t2 = new window();
        window t3 = new window();
        t1.setName(&quot;窗口1&quot;);
        t2.setName(&quot;窗口2&quot;);
        t3.setName(&quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
        //实现Runnable接口的方式
        window window = new window();
        Thread t1 = new Thread(window);
        Thread t2 = new Thread(window);
        Thread t3 = new Thread(window);
        t1.setName(&quot;窗口1&quot;);
        t2.setName(&quot;窗口2&quot;);
        t3.setName(&quot;窗口3&quot;);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<h5 id="3-两种线程创建方式的比较"><a href="#3-两种线程创建方式的比较" class="headerlink" title="3.两种线程创建方式的比较"></a>3.两种线程创建方式的比较</h5><p>开发中<strong>优先选择：实现Runnable接口的方式</strong></p>
<p><strong>原因</strong>：</p>
<ol>
<li>实现的方式<strong>没有类的单继承性的局限性</strong></li>
<li>实现的方式更适合来<strong>处理多个线程有共享数据的情况</strong></li>
</ol>
<p><strong>联系</strong>: public class Thread implements Runnable</p>
<p><strong>相同点</strong>：两种方式都需要重写run()，将线程要执行的逻辑声明在run( )中</p>
<h4 id="7-2-3-Thread类中的有关方法（使用）"><a href="#7-2-3-Thread类中的有关方法（使用）" class="headerlink" title="7.2.3 Thread类中的有关方法（使用）"></a>7.2.3 Thread类中的有关方法（使用）</h4><ul>
<li>void start()：启动线程，并执行对象的run()方法</li>
<li>run()：线程在被调度时执行的操作</li>
<li>String getName()：返回线程的名称</li>
<li>void setName(String name)：设置该线程名称</li>
<li>static Thread currentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类</li>
<li>static void yield()：线程让步<ul>
<li><strong>暂停当前正在执行的线程</strong>，把执行机会让给优先级相同或更高的线程</li>
<li>若队列中没有同优先级的线程，忽略此方法</li>
</ul>
</li>
<li>join()：当某个程序执行流中调用其他线程的 join()方法时，<strong>调用线程将被阻塞</strong>，直到join()方法加入的<strong>join 线程执行完为止</strong><ul>
<li>低优先级的线程也可以获得执行</li>
</ul>
</li>
<li>static void sleep(long millis)：(指定时间:毫秒)<ul>
<li>令当前活动线程在<strong>指定时间段内放弃对CPU控制</strong>，使其他线程有机会被执行，<strong>时间到后重排队</strong></li>
<li>抛出InterruptedException异常</li>
</ul>
</li>
<li>stop()：<strong>强制线程生命期结束</strong>，不推荐使用，已过时</li>
<li>boolean isAlive()：返回boolean，判断线程是否还活着</li>
</ul>
<h3 id="7-3-线程的生命周期"><a href="#7-3-线程的生命周期" class="headerlink" title="7.3 线程的生命周期"></a>7.3 线程的生命周期</h3><p>JDK中用Thread.State类定义了线程的几种状态</p>
<p>要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态：</p>
<ul>
<li>新建：当一个Thread类或其子类的对象<strong>被声明并创建时</strong>，新生的线程对象<strong>处于新建状态</strong></li>
<li>就绪：处于新建状态的线程被<strong>start()后，将进入线程队列等待CPU时间片</strong>，此时它已具备了运行的条件，只是还没分配到CPU资源</li>
<li>运行：当就绪的线程<strong>被调度并获得CPU资源时,便进入运行状态</strong>，run()方法定义了线程的操作和功能</li>
<li>阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，<strong>让出CPU并临时中止自己的执行，进入阻塞状态</strong></li>
<li>死亡：线程<strong>完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束</strong></li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637238.png' data-fancybox='default' data-caption='image-20210726120906987'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637238.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637238.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210726120906987"></a><span class='image-caption'>image-20210726120906987</span></div></div>

<h3 id="7-4-线程的同步"><a href="#7-4-线程的同步" class="headerlink" title="7.4 线程的同步"></a>7.4 线程的同步</h3><h4 id="7-4-1-线程的安全问题"><a href="#7-4-1-线程的安全问题" class="headerlink" title="7.4.1 线程的安全问题"></a>7.4.1 线程的安全问题</h4><p>问题提出：</p>
<ul>
<li>多个线程执行的<strong>不确定性</strong>引起执行结果的不稳定</li>
<li>多个线程对账本的共享，会造成操作的<strong>不完整性</strong>，会破坏数据</li>
</ul>
<p><strong>如，7.2.2中多窗口卖票实例若run()中加了sleep()的可能会出现：</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637531.png' data-fancybox='default' data-caption='image-20210726152643935'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637531.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637531.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210726152643935"></a><span class='image-caption'>image-20210726152643935</span></div></div>

<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637008.png' data-fancybox='default' data-caption='image-20210726152750501'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637008.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201637008.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210726152750501"></a><span class='image-caption'>image-20210726152750501</span></div></div>

<h4 id="7-4-2-线程安全问题的解决办法-同步和Lock"><a href="#7-4-2-线程安全问题的解决办法-同步和Lock" class="headerlink" title="7.4.2 线程安全问题的解决办法(同步和Lock)"></a>7.4.2 线程安全问题的解决办法(同步和Lock)</h4><p>7.2.2实例出现的问题：<strong>卖票过程中，出现了重票、错票</strong>–&gt;出现了线程的安全问题</p>
<p><strong>问题出现的原因</strong>：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票</p>
<p><strong>如何解决</strong>：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，ticket也不能被改变</p>
<p>在Java中，我们<strong>通过同步机制和Lock来解决线程安全问题</strong></p>
<p><strong>利用同步机制解决线程安全问题的优缺点：</strong></p>
<ol>
<li>同步的方式，解决了线程的安全问题 —好处</li>
<li>操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低 —缺点</li>
</ol>
<h5 id="1-方式一：同步代码块"><a href="#1-方式一：同步代码块" class="headerlink" title="1.方式一：同步代码块"></a>1.方式一：同步代码块</h5><pre><code class="java">synchronized(同步监视器)&#123;
    //需要被同步的代码
&#125;
//1.操作共享数据的代码，即为需要同步的代码  ---&gt;不能包含代码多了，也不能包含少了
//2.共享数据：多个线程共同操作的变量，比如ticket就是共享数据
//3.同步监视器，俗称：锁;任何一个类的对象，都可以充当锁
//    要求：多个线程必须要公用同一个锁

//补充：在实现Runnable接口实现创建多线程的方式中，我们可以考虑使用this充当同步监视器
//        在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类作为同步监视器
</code></pre>
<p>①解决实现Runnable的线程安全问题</p>
<pre><code class="java">class window implements Runnable &#123;
    private int ticket = 100;
    Object obj = new Object();
    @Override
    public void run() &#123;
        while (true) &#123;
            synchronized(obj)&#123;  //synchronized(this)这种方式在实现Runnable的方式中也可以，因为这个this代表的是
                 if(ticket &gt; 0) &#123;   //window的对象window，此时仍然是三个线程公用一把锁
                    System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);
                    ticket--;
                &#125; else &#123;
                    break;
                &#125;   
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>②解决继承Thread的线程安全问题</p>
<pre><code class="java">class window extends Thread &#123;
    private static int ticket = 100; 
    private static Object obj = new Object();//必须用static修饰，因为继承Thread的方式需要每创建一个线程就声明一个
    @Override                   //对象，如果不加static就会让每个对象都有一把锁，就违背了多个线程必须共用一把锁的要求
    public void run() &#123;
        while (true) &#123;
            synchronized(obj) &#123;  //synchronized(this)这种方式在继承Thread的方式中就不可以，因为这个this代表的是当
                if(ticket &gt; 0) &#123;  //前线程的对象t1、t2、t3，即一个线程一把锁
//但我们可使用synchronized(window.class)作为锁的方式来实现，因为window.class也是一个对象，此时三个线程也是公用一把锁
                    System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);
                    ticket--;
                &#125; else &#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2-方式二：同步方法"><a href="#2-方式二：同步方法" class="headerlink" title="2.方式二：同步方法"></a>2.方式二：同步方法</h5><p>如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的</p>
<p>①解决实现Runnable接口的线程安全问题</p>
<pre><code class="java">class  MyThread implements Runnable &#123;
    private int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            show();
            if(ticket &lt;= 0) break;
        &#125;
    &#125;
    public synchronized void show() &#123; //同步方法
        if(ticket &gt; 0) &#123;              //同步监视器：this
            System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);
            ticket--;
        &#125;
    &#125;
&#125;
public class ThreadTest03 &#123;
    public static void main(String[] args) &#123;
        MyThread myThread = new MyThread();
        Thread t1 = new Thread(myThread);
        Thread t2 = new Thread(myThread);
        Thread t3 = new Thread(myThread);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<p>②解决继承Thread类的线程安全问题</p>
<pre><code class="java">class  MyThread extends Thread &#123;
    private static int ticket = 100;
    @Override
    public void run() &#123;
        while (true) &#123;
            show();
            if (ticket &lt;= 0) break;
        &#125;
    &#125;
    public static synchronized void show() &#123; //若不加static，同步监视器：t1、t2、t3
        if(ticket &gt; 0) &#123;      //加上static，同步监视器：MyThread.Class即这个类本身充当对象作为锁（反射机制）
            System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket);
            ticket--;
        &#125;
    &#125;
&#125;
public class ThreadTest03 &#123;
    public static void main(String[] args) &#123;
        MyThread t1 = new MyThread();
        MyThread t2 = new MyThread();
        MyThread t3 = new MyThread();
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
</code></pre>
<p><strong>关于同步方法的总结：</strong></p>
<ol>
<li>同步方法仍然涉及到同步监视器，只是<strong>不需要我们显式的声明</strong></li>
<li><strong>非静态</strong>的同步方法，同步监视器是: <strong>this</strong><br> <strong>静态</strong>的同步方法，同步监视器是：<strong>当前类本身</strong></li>
</ol>
<h5 id="3-方式三：Lock锁-—JDK5-0新增"><a href="#3-方式三：Lock锁-—JDK5-0新增" class="headerlink" title="3.方式三：Lock锁 —JDK5.0新增"></a>3.方式三：Lock锁 —JDK5.0新增</h5><p>从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用<strong>Lock对象充当</strong></p>
<p>java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。<strong>锁提供了对共享资源的独占访问</strong>，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象</p>
<p>ReentrantLock类实现了Lock ，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁</p>
<pre><code class="java">public class ThreadTest06 &#123;
    public static void main(String[] args) &#123;
        Window window = new Window();
        Thread t1 = new Thread(window);
        Thread t2 = new Thread(window);
        Thread t3 = new Thread(window);
        t1.start();
        t2.start();
        t3.start();
    &#125;
&#125;
class Window implements Runnable &#123;
    private int ticket = 100;
    //1.实例化ReentrantLock
    private ReentrantLock lock = new ReentrantLock(true);

    @Override
    public void run() &#123;
        while(true) &#123;
            try&#123; //使用try-finally代码块是为了让同步代码无论是否执行完最终都要释放锁，否则会出现执行的某一次没有解锁
                //2.调用lock()上锁
                lock.lock();
                if (ticket &gt; 0) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;:售票,票号为:&quot; + ticket);
                    ticket--;
                &#125; else &#123;
                    break;
                &#125;
            &#125; finally &#123;
                //3.调用unlock()解锁
                lock.unlock();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p><strong>synchronized和Lock的对比：</strong></p>
<ul>
<li><strong>Lock是显式锁</strong>（手动开启和关闭锁，别忘记关闭锁），<strong>synchronized是隐式锁</strong>，出了作用域自动释放</li>
<li><strong>Lock只有代码块锁</strong>，<strong>synchronized有代码块锁和方法锁</strong></li>
<li>使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类）</li>
<li>优先使用顺序：<strong>Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外)</strong></li>
</ul>
<p><strong>面试题: synchronized 与Lock的异同?</strong></p>
<ul>
<li><p>相同：二者都可以解决线程安全问题</p>
</li>
<li><p>不同：synchronized机制在执行完相应的同步代码以后，<strong>自动的释放同步监视器</strong></p>
<p>  ​        Lock需要<strong>手动的启动</strong>同步(上锁Lock() )，同时也需要<strong>手动的结束</strong>同步(解锁unlock() )</p>
</li>
</ul>
<p><strong>面试题：如何解决线程安全问题？有几种方式？</strong></p>
<ul>
<li>使用synchronized关键字<ul>
<li>使用synchronized修饰代码块，使其成为同步代码块（包住操作共享数据的代码）</li>
<li>使用synchronized修饰方法，使其成为同步方法（方法体是操作共享数据的代码块）</li>
</ul>
</li>
<li>使用Lock锁的方式（常用ReentrantLock类）</li>
</ul>
<h4 id="7-4-3-线程安全的单例模式之懒汉式"><a href="#7-4-3-线程安全的单例模式之懒汉式" class="headerlink" title="7.4.3 线程安全的单例模式之懒汉式"></a>7.4.3 线程安全的单例模式之懒汉式</h4><pre><code class="java">Class Bank &#123;
    private Bank()&#123;&#125;
    private static Bank instance = null;
    public static Bank getInstance() &#123;
        //方式一：效率稍差
        synchronized(Bnak.class) &#123;
            if(instance == null) &#123;
                instance = new Bank();
            &#125;
            return instance;
         &#125;
        //方式二：效率更高
        if(instance == null) &#123; //第一个if是为了后面的线程可以直接返回instance，而不用进入同步方法块里再进行判断，以此来提高效率
            synchronized(Bnak.class) &#123;
                if(instance == null) &#123;  //这个if不能删除，如果删除仍然存在线程安全问题，因为可能存在多个线程同时调用这个方法，就会同时进入第一个if语句内，这样这些线程就会逃过判空的环节等待进入同步代码块，等到自己使用CPU时又会new一个新的bank对象，那么这个第二个if判断就是第二重保险
                    instance = new Bank();
                &#125;
             &#125;
        &#125;
        return instance;
    &#125;
&#125;
</code></pre>
<h4 id="7-4-4-线程的死锁问题"><a href="#7-4-4-线程的死锁问题" class="headerlink" title="7.4.4 线程的死锁问题"></a>7.4.4 线程的死锁问题</h4><p>死锁：</p>
<ul>
<li><strong>不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源</strong>，就形成了线程的死锁</li>
<li>出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续</li>
<li>我们使用同步时要避免出现死锁</li>
</ul>
<p>死锁产生的四个必要条件：</p>
<ul>
<li> 1、<strong>互斥使用</strong>，即当资源被一个线程使用(占有)时，别的线程不能使用</li>
<li>2、<strong>不可抢占</strong>，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放</li>
<li>3、<strong>请求和保持</strong>，即当资源请求者在请求其他的资源的同时保持对原有资源的占有</li>
<li>4、<strong>循环等待</strong>，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路</li>
<li>当上述四个条件<strong>都成立</strong>的时候，便形成死锁。当然，死锁的情况下如果<strong>打破上述任何一个条件，便可让死锁消失</strong></li>
</ul>
<p>解决方法：</p>
<ul>
<li>专门的算法、原则</li>
<li>尽量减少同步资源的定义</li>
<li>尽量避免嵌套同步</li>
</ul>
<pre><code class="java">//死锁实例
public static void main(String[] args) &#123;
    StringBuffer s1 = new StringBuffer();
    StringBuffer s2 = new StringBuffer();

    new Thread()&#123; //第一个线程
        @Override
        public void run() &#123;
            synchronized (s1) &#123; //以对象s1作为第一把锁
                s1.append(&quot;a&quot;);
                s2.append(&quot;1&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (s2) &#123; //以对象s2作为第二把锁
                    s1.append(&quot;b&quot;);
                    s2.append(&quot;2&quot;);
                    System.out.println(s1);
                    System.out.println(s2);
                &#125;
            &#125;
        &#125;
    &#125;.start();
    new Thread(new Runnable() &#123; //第二个线程
        @Override
        public void run() &#123;
            synchronized (s2) &#123; ////以对象s2作为第一把锁
                s1.append(&quot;c&quot;);
                s2.append(&quot;3&quot;);
                try &#123;
                    Thread.sleep(100);
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
                &#125;
                synchronized (s1) &#123; //以对象s1作为第二把锁
                    s1.append(&quot;d&quot;);
                    s2.append(&quot;4&quot;);
                    System.out.println(s1);
                    System.out.println(s2);
                &#125;
            &#125;
        &#125;
    &#125;).start();
&#125;
//该程序形成死锁原因：
//第一个线程执行拿到第一把锁s1，然后会执行sleep进行睡眠，同时第二个线程也开始执行，拿到第一把锁s2
//第一个线程睡眠结束，需要第二把锁s2，但是第二个线程正在占用s2，s2得不到释放，则第一个线程就会一直等待第二个线程释放s2
//但是，此时第二个线程睡眠结束，需要用到锁s1，但第一个线程又因为无法使用锁s2，会一直占用s1导致s1得不到释放，那么第二个线程也就需要等待第一个线程释放锁s1
//由此便产生了第一个线程拿不到s2的同时又不释放s1，而第二个线程拿不到s1的同时也不释放s2，这样就使两个线程都不到互相需要的锁，进入无限循环等待资源的死锁状态
</code></pre>
<h3 id="7-5-线程的通信"><a href="#7-5-线程的通信" class="headerlink" title="7.5 线程的通信"></a>7.5 线程的通信</h3><h4 id="7-5-1-线程通信的介绍"><a href="#7-5-1-线程通信的介绍" class="headerlink" title="7.5.1 线程通信的介绍"></a>7.5.1 线程通信的介绍</h4><p><strong>涉及到的三个方法：</strong></p>
<ul>
<li><p>wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器</p>
</li>
<li><p>notify()：一旦执行此方法，就会唤醒<strong>被wait()的一个线程</strong>。如果有多个线程被wait，就唤醒优先级高的线程</p>
</li>
<li><p>notifyAll()：一旦执行此方法，就会唤醒**所有被wait()**的线程</p>
</li>
</ul>
<p><strong>说明：</strong></p>
<ul>
<li>wait()，notify()，notifyAll()三个方法<strong>必须使用在同步代码块或同步方法中</strong></li>
<li>wait()，notify()，notifyAll()三个方法的<strong>调用者必须是同步代码块或同步代码中的同步监视器</strong>，否则，会出现IllegalMonitorStateException异常</li>
<li>wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中在·</li>
</ul>
<p><strong>面试题：sleep()和wait()的异同？</strong></p>
<ul>
<li>相同点：一旦执行方法，都可以使得<strong>当前的线程进入阻塞状态</strong></li>
<li>不同点：<ul>
<li>两个方法<strong>声明的位置不同</strong>：sleep()声明在Thread类中，wait()声明在object类中</li>
<li><strong>调用的要求不同</strong>: sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中</li>
<li>关于**是否释放同步监视器(锁)**：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，而wait()会释放同步监视器</li>
</ul>
</li>
</ul>
<pre><code class="java">//线程通信的例子：使用两个线程打印1-100，线程1和线程2交替打印
public class ThreadTest08 &#123;
    public static void main(String[] args) &#123;
        Number number = new Number();
        Thread t1 = new Thread(number);
        Thread t2 = new Thread(number);
        t1.setName(&quot;线程1&quot;);
        t2.setName(&quot;线程2&quot;);
        t1.start();
        t2.start();
    &#125;
&#125;
class Number implements Runnable &#123;
    private int number = 1;
    @Override
    public void run() &#123;
        while(true) &#123;
            synchronized (this)&#123;
                notify(); //唤醒被阻塞的
                if(number &lt;= 100) &#123;
                    System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number);
                    number++;
                    try &#123;
                        wait(); //使调用wait()方法的线程进入阻塞状态，且释放锁(sleep阻塞但不会释放锁)
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;else&#123;
                    break;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="7-5-2-线程通信的应用"><a href="#7-5-2-线程通信的应用" class="headerlink" title="7.5.2 线程通信的应用"></a>7.5.2 线程通信的应用</h4><p>经典例题：生产者/消费者问题</p>
<p>生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品</p>
<p>这里可能出现两个问题：</p>
<ul>
<li>生产者比消费者快时，消费者会漏掉一些数据没有取到</li>
<li>消费者比生产者快时，消费者会取同样的数据</li>
</ul>
<pre><code class="java">/*
生产者和消费者问题
生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），
如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，
如果店中有产品了再通知消费者来取走产品
 */
public class ThreadTest09 &#123;
    public static void main(String[] args) &#123;
        Clerk clerk = new Clerk();
        Productor productor1 = new Productor(clerk); //定义生产者线程
        Productor productor2 = new Productor(clerk);
        Customer customer1 = new Customer(clerk); //定义消费者线程
        Customer customer2 = new Customer(clerk);
        Customer customer3 = new Customer(clerk);
        productor1.setName(&quot;生产者1&quot;);
        productor2.setName(&quot;生产者2&quot;);
        customer1.setName(&quot;消费者1&quot;);
        customer2.setName(&quot;消费者2&quot;);
        customer3.setName(&quot;消费者3&quot;);
        productor1.start();
        productor2.start();
        customer1.start();
        customer2.start();
        customer3.start();
    &#125;
&#125;
class Clerk &#123;
    private int product = 0; //店员拥有的产品数
    public int getProduct() &#123;
        return product;
    &#125;
    public void addProduct() &#123;
        product++;
    &#125;
    public void reduceProduct() &#123;
        product--;
    &#125;
&#125;
class Productor extends Thread &#123;
    private Clerk clerk; //声明Clerk对象，方便对于产品数的操作
    public Productor(Clerk clerk) &#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        while(true) &#123;
            try &#123;
                Thread.sleep(100); //阻塞线程，让其他线程有争夺的时间
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            synchronized(Clerk.class) &#123;
                if(clerk.getProduct() &lt; 20)&#123; //如果商品的数量小于20，则生产者会持续生产
                    System.out.println(Thread.currentThread().getName() + &quot;开始生产......&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot;正在准备生产第&quot; + (clerk.getProduct()+1) + &quot;个产品&quot;);
                    clerk.addProduct();
                    System.out.println(Thread.currentThread().getName() + &quot;已经完成生产第&quot; + clerk.getProduct() + &quot;个产品&quot;);
                    Clerk.class.notify(); //唤醒因一些原因被执行wait()的线程
                &#125; else &#123;
                    //生产者生产过快，店员让生产者等待
                    try &#123;
                        Clerk.class.wait(); //生产者生产太快，商品数量过多，被店员叫停休息
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
class Customer extends Thread &#123;
    private Clerk clerk; //声明Clerk对象，方便对于产品数的操作
    public Customer(Clerk clerk) &#123;
        this.clerk = clerk;
    &#125;
    @Override
    public void run() &#123;
        while(true) &#123;
            try &#123;
                Thread.sleep(500); //阻塞线程，让其他线程有争夺的时间
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            synchronized(Clerk.class) &#123;
                if(clerk.getProduct() &gt; 0)&#123; //如果商品数量大于0，则消费者可以进行消费
                    System.out.println(Thread.currentThread().getName() + &quot;开始消费......&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot;正在准备消费第&quot; + clerk.getProduct() + &quot;个产品&quot;);
                    System.out.println(Thread.currentThread().getName() + &quot;已经完成消费第&quot; + clerk.getProduct() + &quot;个产品&quot;);
                    clerk.reduceProduct();
                    Clerk.class.notify(); //唤醒因一些原因被执行wait()的线程
                &#125; else &#123;
                    //消费者消费过快，店员让消费者等待
                    try &#123;
                        Clerk.class.wait(); //消费者消费过快，商品数量不足，店员告诉消费者稍等
                    &#125; catch (InterruptedException e) &#123;
                        e.printStackTrace();
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
&#125;
/*
此实例实现过程中遇到的问题：
1.因为使用while循环，会导致一个线程一旦抢到CPU使用权后就不易被其他线程抢占，所以在进入同步代码块或同步方法前加上sleep来让其他线程有抢占CPU的机会
2.在同步代码块或同步方法中使用notify()和wait()时要注意调用者一定要是同步监视器，否则会报错IllegalMonitorStateException异常
*/
</code></pre>
<h4 id="7-5-3-哪些操作会释放锁，哪些不会释放锁？"><a href="#7-5-3-哪些操作会释放锁，哪些不会释放锁？" class="headerlink" title="7.5.3 哪些操作会释放锁，哪些不会释放锁？"></a>7.5.3 哪些操作会释放锁，哪些不会释放锁？</h4><h6 id="1-释放锁的操作"><a href="#1-释放锁的操作" class="headerlink" title="1.释放锁的操作"></a>1.释放锁的操作</h6><ul>
<li>当前线程的同步方法、同步代码块<strong>执行结束</strong></li>
<li>当前线程在同步代码块、同步方法中遇到<strong>break、return终止了该代码块、该方法的继续执行</strong></li>
<li>当前线程在同步代码块、同步方法中出现了<strong>未处理的Error或Exception</strong>，导致异常结束</li>
<li>当前线程在同步代码块、同步方法中<strong>执行了线程对象的wait()方法</strong>，当前线程暂停，并释放锁</li>
</ul>
<h6 id="2-不会释放锁的操作"><a href="#2-不会释放锁的操作" class="headerlink" title="2.不会释放锁的操作"></a>2.不会释放锁的操作</h6><ul>
<li>线程执行同步代码块或同步方法时，程序调用**Thread.sleep()<strong>、</strong>Thread.yield()**方法暂停当前线程的执行</li>
<li>线程执行同步代码块时，其他线程调用了该线程的<strong>suspend()方法将该线程挂起</strong>，该线程不会释放锁（同步监视器）<ul>
<li>应尽量避免使用suspend()和resume()来控制线程</li>
</ul>
</li>
</ul>
<h3 id="7-6-JDK5新增的线程创建方式"><a href="#7-6-JDK5新增的线程创建方式" class="headerlink" title="7.6 JDK5新增的线程创建方式"></a>7.6 JDK5新增的线程创建方式</h3><h4 id="7-6-1-方法一：实现Callable接口"><a href="#7-6-1-方法一：实现Callable接口" class="headerlink" title="7.6.1 方法一：实现Callable接口"></a>7.6.1 方法一：实现Callable接口</h4><p>与使用Runnable相比，Callable功能更强大些</p>
<ul>
<li>相比run()方法，可以<strong>有返回值</strong></li>
<li>方法可以<strong>抛出异常</strong></li>
<li><strong>支持泛型</strong>的返回值</li>
<li>需要<strong>借助FutureTask类</strong>，比如获取返回结果</li>
</ul>
<p>Future接口：</p>
<ul>
<li>可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等</li>
<li><strong>FutrueTask是Futrue接口的唯一的实现类</strong></li>
<li>FutureTask同时实现了Runnable，Future接口。它既可以<strong>作为Runnable被线程执行</strong>，又可以<strong>作为Future得到Callable的返回值</strong></li>
</ul>
<pre><code class="java">/*
* 实现Callable接口创建线程
*
* 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大?
* 1. calL()可以有返回值的
* 2. calL()可以抛出异常，被外面的操作捕获，获取异常的信息
* 3. Callable是支持泛型的
*/
//1.创建一个实现Callable接口的实现类
class NumThread implements Callable &#123;
    //2.实现call方法，将此线程需要执行的操作声明在call()中
    @Override
    public Object call() throws Exception &#123; //相当于run()方法
        int sum = 0;
        for (int i = 1; i &lt;= 100; i++) &#123;
            if(i % 2 == 0) &#123;
                System.out.println(i);
                sum += i;
            &#125;
        &#125;
        return sum;
    &#125;
&#125;
public class ThreadTest10 &#123;
    public static void main(String[] args) &#123;
        //3.创建Callable接口实现类的对象
        NumThread numThread = new NumThread();
        //4.将此Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象
        FutureTask futureTask = new FutureTask(numThread);
        //5.将FutureTask的对象传递到Thread类中，创建线程对象，并调用start()方法
        Thread thread = new Thread(futureTask);
        thread.start();
        try &#123;
            //6.获取Callable中call()的返回值(如果需要的话)
            //get()方法的返回值即为FutureTask构造参数Callable实现类重写的call()的返回值
            Object sum = futureTask.get();
            System.out.println(&quot;总和为：&quot; + sum);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125; catch (ExecutionException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="7-6-2-方法二：线程池"><a href="#7-6-2-方法二：线程池" class="headerlink" title="7.6.2 方法二：线程池"></a>7.6.2 方法二：线程池</h4><p>背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大</p>
<p>思路：<strong>提前创建好多个线程，放入线程池</strong>中，使用时直接获取，使用完放回池中。可以<strong>避免频繁创建销毁、实现重复利用</strong>。类似生活中的公共交通工具</p>
<p>好处：</p>
<ul>
<li><strong>提高响应速度</strong>（减少了创建新线程的时间)</li>
<li><strong>降低资源消耗</strong>（重复利用线程池中线程，不需要每次都创建)</li>
<li><strong>便于线程管理</strong><ul>
<li>corePoolSize：核心池的大小</li>
<li>maximumPoolSize：最大线程数</li>
<li>keepAliveTime：线程没有任务时最多保持多长时间后会终止</li>
</ul>
</li>
</ul>
<p><strong>线程池相关的API：</strong></p>
<ul>
<li>JDK5.0起提供了线程池相关API：ExecutorService和 Executors</li>
<li>ExecutorService：真正的<strong>线程池接口</strong>。常见子类ThreadPoolExecutor<ul>
<li>void execute(Runnable command)：执行任务/命令，<strong>没有返回值</strong>，一般用来<strong>执行Runnable</strong></li>
<li><T>  Future<T>  submit(Callable<T> task)：执行任务，<strong>有返回值</strong>，一般用来<strong>执行Callable</strong></li>
<li>void shutdown()：<strong>关闭连接池</strong></li>
</ul>
</li>
<li>Executors：<strong>工具类、线程池的工厂类</strong>，用于<strong>创建并返回不同类型的线程池</strong><ul>
<li>Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池</li>
<li>Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池</li>
<li>Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池</li>
<li>Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行</li>
</ul>
</li>
</ul>
<pre><code class="java">/*
    创建新线程方式四：使用线程池
    面试题：创建多线程的几种方法？四种
 */
class NumberThread implements Runnable &#123;
    @Override
    public void run() &#123;
        for (int i = 1; i &lt;= 100; i++) &#123;
            if(i % 2 == 0) &#123;
                System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i);
            &#125;
        &#125;
    &#125;
&#125;
public class ThreadTest11 &#123;
    public static void main(String[] args) &#123;
        //1.提供指定线程数量的线程池
        ExecutorService service = Executors.newFixedThreadPool(10); //创建出一个ThreadPoolExecutor类型的线程池，返回一个ExecutorService接口，从源码关系可以看出这儿相当于向上转型
        //如果想设置线程池的一些相关属性,需要将接口对象service向下转成实现类ThreadPoolExecutor对象才能调用其自身拥有的方法
        ThreadPoolExecutor service1 = (ThreadPoolExecutor)service;
        service1.setCorePoolSize(15);//比如设置最大连接数
        //2.执行指定的线程的操作，需要提供实现Runnable或Callable接口的实现类的对象
        service.execute(new NumberThread());//适合使用于Runnable //执行的是创建出的线程池类型对应类中的execute()方法
        //service.submit(Callable callable);//适合适用于Callable
        //3.关闭线程池
        service.shutdown();
    &#125;
&#125;
</code></pre>
<h2 id="八、Java常用类"><a href="#八、Java常用类" class="headerlink" title="八、Java常用类"></a>八、Java常用类</h2><h3 id="8-1-字符串相关的类"><a href="#8-1-字符串相关的类" class="headerlink" title="8.1 字符串相关的类"></a>8.1 字符串相关的类</h3><h4 id="8-1-1-String类"><a href="#8-1-1-String类" class="headerlink" title="8.1.1 String类"></a>8.1.1 String类</h4><h5 id="1-String的特性"><a href="#1-String的特性" class="headerlink" title="1.String的特性"></a>1.String的特性</h5><ul>
<li>String类：代表字符串。Java程序中的所有<strong>字符串字面值</strong>（如 “abc”)都<strong>作为此类的实例实现</strong></li>
<li>String是一个final类，代表<strong>不可变</strong>的字符序列</li>
<li>字符串是<strong>常量</strong>，用双引号引起来表示。它们的值在<strong>创建之后不能更改</strong></li>
<li>String对象的<strong>字符内容是存储在一个字符数组value[]中</strong>的</li>
<li>String实现了serializable接口：表示字符串是<strong>支持序列化</strong>的</li>
<li>String实现了Comparable接口：表示String<strong>可以比较大小</strong></li>
<li>String内部定义了final char[ ] <strong>value用于存储字符串数据</strong></li>
<li>String：代表不可变的字符序列。简称：<strong>不可变性</strong><ul>
<li>当<strong>对字符串重新赋值</strong>时，会<strong>重写指定内存区域赋值</strong>，<strong>不能</strong>使用原有的value进行赋值</li>
<li>当<strong>对现有的字符串进行连接操作</strong>时，也<strong>会重新指定内存区域赋值</strong>，<strong>不能</strong>使用原有的value进行赋值</li>
<li>当调用String的<strong>replace()方法修改指定字符或字符串</strong>时，也<strong>会重新指定内存区域赋值</strong></li>
</ul>
</li>
<li>通过<strong>字面量的方式</strong>(区别于new）给一个字符串赋值，此时的<strong>字符串值声明在字符串常量池中</strong></li>
<li>字符串常量池中是不会存储已有<strong>相同内容</strong>的字符串的</li>
</ul>
<pre><code class="java">String s1 = &quot;abc&quot;; //字面量的定义方式
String s2 = &quot;abc&quot;;
System.out.println(s1 == s2);//返回true
s2 = &quot;hello&quot;;
System.out.println(s1 == s2);//返回false
System.out.println(s1);//abc
System.out.println(s2);//hello
String s3 = &quot;abc&quot;;
System.out.print1n(s3);//abc
s3 += &quot;def&quot;;
System.out.print1n(s3);//abcdef
String s4 = &quot;abc&quot;;
String s5 = s4.replace(&#39;a&#39;,&#39;m&#39;);
System.out.println(s4); //abc
System.out.println(s5); //mbc
</code></pre>
<h5 id="2-String-对象的创建"><a href="#2-String-对象的创建" class="headerlink" title="2.String 对象的创建"></a>2.String 对象的创建</h5><p>面试题：String s = new String(“abc”)方式创建对象，在内存中创建了几个对象?<br><strong>两个</strong>：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc”</p>
<pre><code class="java">String str = &quot;he1lo&quot;; //字面量定义
String s1 = new String(); //本质上this.value = new char[0];
String s2 = new String(String original); //this.value = original.value;
//this.value = Arrays.copy0f(value, value.length);
String s3 = new String(char[] a);
String s4 = new String(char[] a,int startIndex , int count) ;
</code></pre>
<pre><code class="java">Person p1 = new Person(&quot;Tom&quot;,12);
Person p2 = new Person(&quot;Tom&quot;,12);
System.out.println(p1.name.equals(p2.name));//true
System.out.println(p1.name == p2.name);//true
//如果想改变名字，如p1.name = &quot;Jerry&quot;,还在常量池中又新开辟一个空间存储&quot;Jerry&quot;
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638158.png' data-fancybox='default' data-caption='image-20210729172439917'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638158.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638158.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210729172439917"></a><span class='image-caption'>image-20210729172439917</span></div></div>

<h5 id="3-String不同拼接操作的比较"><a href="#3-String不同拼接操作的比较" class="headerlink" title="3.String不同拼接操作的比较"></a>3.String不同拼接操作的比较</h5><pre><code class="java">String s1 = &quot;javaEE&quot;;
String s2 = &quot;hadoop&quot;;
String s3 = &quot;javaEEhadoop&quot; ;
String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;;
String s5 = s1 + &quot;hadoop&quot; ;
String s6 = &quot;javaEE&quot; + s2;
String s7 = s1 + s2;
final String s8 = &quot;javaEE&quot;;//常量
String s9 = s9 + &quot;hadoop&quot;;
System.out.println(s3 == s4);//true
System.out.println(s3 == s5);//false
System.out.println(s3 == s6);//false
System.out.print1n(s3 == s7);//false
System.out.println(s5 == s6);//false
System.out.print1n(s5 == s7);//false
System.out.println(s6 == s7);//false
System.out.println(s3 == s9);//true，s8为final修饰，所以s9是常量加常量，也存储在常量池，所以为true

String s8 = s5.intern();//返回值得到的s8使用的是常量池中已经存在的javaEEhadoop&quot;
//str5调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用
System.out.println(s3 == s8);//true
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638514.png' data-fancybox='default' data-caption='image-20210729173652497'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638514.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201638514.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210729173652497"></a><span class='image-caption'>image-20210729173652497</span></div></div>

<p><strong>结论：</strong></p>
<ul>
<li><strong>常量与常量的拼接结果在常量池</strong>。且常量池中不会存在相同内容的常量</li>
<li>只要<strong>其中有一个是变量，结果就在堆中</strong></li>
<li>如果<strong>拼接的结果调用intern(方法，返回值就在常量池中</strong></li>
</ul>
<pre><code class="java">//练习：面试题
String str = new String(&quot;good&quot;); //此时str指向堆中的new String(&quot;good&quot;)
char[] ch = &#123; &#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39; &#125;;//同样，ch指向堆中的test
public void change(String str, char ch[]) &#123;//传入str和ch指向的对象的引用值
    str = &quot;test ok&quot;; //此时是字面量创建，所以会创建在常量池中，但change外的str指向并没有变，所以输出仍是good
    ch[0] = &#39;b&#39;;//根据传入的数组的引用值，将其ch[0]的值改变了，所以输出best
public static void main(String[] args) &#123;
    StringTest ex = new StringTest();
    ex.change(ex.str, ex.ch);
    System.out.println(ex.str);//good
    System.out.println(ex.ch);//best
&#125;
</code></pre>
<h5 id="4-JVM中涉及字符串的内存结构"><a href="#4-JVM中涉及字符串的内存结构" class="headerlink" title="4.JVM中涉及字符串的内存结构"></a>4.JVM中涉及字符串的内存结构</h5><p>JDK1.6：字符串常量池在方法区（具体实现：永生代）中</p>
<p>JDK1.7：字符串常量池在堆中</p>
<p>JDK1.8：字符串常量池在方法区（具体实现：元空间）中</p>
<h5 id="5-String常用方法"><a href="#5-String常用方法" class="headerlink" title="5.String常用方法"></a>5.String常用方法</h5><ul>
<li><p>int length()：返回<strong>字符串的长度</strong>: return value.length</p>
</li>
<li><p>char charAt(int index)：返回<strong>某索引处的字符</strong>return value[index]</p>
</li>
<li><p>boolean isEmpty()：判断<strong>是否是空字符串</strong>: return value.length == 0</p>
</li>
<li><p>String tol owerCase()：使用默认语言环境，将String中的所有字符<strong>转换为小写</strong></p>
</li>
<li><p>String toUpperCase()：使用默认语言环境，将String中的所有字符<strong>转换为大写</strong></p>
</li>
<li><p>String trim()：返回字符串的副本，<strong>忽略前导空白和尾部空白</strong></p>
</li>
<li><p>boolean equals(Object obj)：比较字符串的<strong>内容是否相同</strong></p>
</li>
<li><p>boolean equalslgnoreCase(String anotherString)：与equals方法类似， <strong>忽略大小写</strong></p>
</li>
<li><p>String concat(String str)：将<strong>指定字符串连接到此字符串的结尾</strong>。等价于用 “+”</p>
</li>
<li><p>int compare To(String anotherString)：<strong>比较两个字符串的大小</strong></p>
</li>
<li><p>String substring(int beginlndex)：返回一个新的字符串，它是此字符串的<strong>从beginIndex开始截取到最后的一个子字符串</strong></p>
</li>
<li><p>String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串<strong>从beginlndex开始截取到endIndex(不包含)的一个子字符串</strong></p>
</li>
<li><p>String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过<strong>用newChar替换此字符串中出现的<em>所有</em>oldChar</strong>得到的</p>
</li>
<li><p>String replace(CharSequence target, CharSequence replacement)：使用<strong>指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串</strong></p>
</li>
<li><p>String replaceAll(String regex, String replacement)：使用<strong>给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串</strong></p>
</li>
<li><p>String replaceFirst(String regex, String replacement)：使用<strong>给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串</strong></p>
</li>
<li><p>boolean matches(String regex)：告知此字符串<strong>是否匹配给定的正则表达式</strong></p>
</li>
<li><p>String[] split(String regex)：根据给定正则表达式的匹配<strong>拆分此字符串</strong></p>
</li>
<li><p>String[] split(String regex, int limit)：<strong>根据匹配给定的正则表达式来拆分此字符串</strong>，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中</p>
</li>
<li><p>boolean endsWith(String suffix)：测试此字符串<strong>是否以指定的后缀结束</strong></p>
</li>
<li><p>boolean startsWith(String prefix)：测试此字符串<strong>是否以指定的前缀开始</strong></p>
</li>
<li><p>boolean startsWith(String prefix, int toffset)：测试此字符串<strong>从指定索引开始的子字符串是否以指定前缀开始</strong></p>
</li>
<li><p>boolean contains(CharSequence s)：当且仅当<strong>此字符串包含指定的char值序列</strong>时，返回true</p>
<pre><code class="java">//调用此方法的字符串是否含有传入的字符串
String str1 = &quot;helloworld&quot;;
String str2 = &quot;wo&quot;;
System.out.println(str1.contains(str2));//true
</code></pre>
</li>
<li><p>int indexOf(String str)：返回<strong>指定子字符串在此字符串中第一次出现处的索引</strong></p>
</li>
<li><p>int indexOf(String str, int fromlndex)：返回指定子字符串在此字符串中第一次出现处的索引，<strong>从指定的索引开始</strong></p>
</li>
<li><p>int lastlndexOf(String str)：返回<strong>指定子字符串在此字符串中最右边出现处的索引</strong></p>
</li>
<li><p>int lastlndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，<strong>从指定的索引开始反向搜索</strong></p>
</li>
<li><p>注：indexOf和lastIndexOf方法如果<strong>未找到都是返回-1</strong>，如果只出现一次该子字符串，返回值相同</p>
</li>
</ul>
<h5 id="6-String与其他结构之间的转换"><a href="#6-String与其他结构之间的转换" class="headerlink" title="6.String与其他结构之间的转换"></a>6.String与其他结构之间的转换</h5><h6 id="①String与基本数据类型、包装类之间的转换"><a href="#①String与基本数据类型、包装类之间的转换" class="headerlink" title="①String与基本数据类型、包装类之间的转换"></a>①String与基本数据类型、包装类之间的转换</h6><pre><code class="java">//String --&gt;基本数据类型、包装类:调用包装类的静态方法: parseXx(str)
String str1 = &quot;123&quot;;
int num = (int)str1;//错误的
int num = Integer.parseInt(str1);
//基本数据类型、包装类--&gt; String: 调用String重载的value0f(xxx)
String str2 = String.valueOf(num);//&quot;123&quot;
String str3 = num + &quot;&quot;;
System.out.println(str1 == str3);//false，str1在常量池中，str3在堆中
</code></pre>
<h6 id="②String与char-之间的转换"><a href="#②String与char-之间的转换" class="headerlink" title="②String与char[]之间的转换"></a>②String与char[]之间的转换</h6><pre><code class="java">//String --&gt; char[]: 调用String的toCharArray()
String str1 = &quot;abc123&quot;;
char[] charArray = str1. toCharArray();
for (int i = 0; i &lt; charArray.1ength; i++) &#123;
    System.out.print1n( charArray[i]);
&#125;
//char[] --&gt; String: 调用String的构造器
char[] arr = new char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;1&#39;,&#39;1&#39;,&#39;o&#39;&#125;;
String str2 = new String(arr);
System.out.println(str2);
</code></pre>
<h6 id="③String与byte-之间的转换"><a href="#③String与byte-之间的转换" class="headerlink" title="③String与byte[]之间的转换"></a>③String与byte[]之间的转换</h6><pre><code class="java">//编码:字符串--&gt;字节 (看得懂 ---&gt;  看不懂的二进制数据)
//解码:字节--&gt;字符串(看不懂的二进制数据 ---&gt;看得懂)
//编码: String --&gt; byte[]:调用String的getBytes()
//说明:解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码
String str1 = &quot;abc123中国&quot;;
byte[] bytes = str1.getBytes();//使用默认的字符集，进行转换
System.out.println(Arrays.toString(bytes));
byte[] gbks = str1.getBytes(charsetName: &quot;gbk&quot; );//使用gbk字符集进行编码
System.out.println(Arrays.toString(gbks));
//解码: byte[] --&gt; String:调用String的构造器
String str2 = new String(bytes);//使用默认的字符集（UTF-8），进行解码
System. out. println(str2);
String str3 = new String(gbks) ;
System.out.println(str3);//出现乱码。原因:编码集和解码集不一致
</code></pre>
<h5 id="7-String常见的算法题目"><a href="#7-String常见的算法题目" class="headerlink" title="7.String常见的算法题目"></a>7.String常见的算法题目</h5><ol>
<li>模拟一个trim()方法，去除字符串两端的空格</li>
<li>将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg”</li>
<li>获取一个字符串在另一个字符串中出现的次数，比如：获取”ab”在”abkkcadkabkebfkabkskab”中出现的次数</li>
<li>获取两个字符串中最大相同子串。比如：str1 = “abcwerthelloyuiodef”；str2 = “cvhellobnm”<br> 提示：将短的那个串进行长度依次递减的子串与较长的串比较</li>
<li>对字符串中字符进行自然顺序排序<br> 提示：①字符串变成字符数组 ②对数组排序，选择，冒泡，Arrays sor() ③将排序后的数组变成字符串</li>
</ol>
<h4 id="8-1-2-StringBuffer和StringBuilder"><a href="#8-1-2-StringBuffer和StringBuilder" class="headerlink" title="8.1.2 StringBuffer和StringBuilder"></a>8.1.2 StringBuffer和StringBuilder</h4><h5 id="1-StringBuffer类"><a href="#1-StringBuffer类" class="headerlink" title="1.StringBuffer类"></a>1.StringBuffer类</h5><p>java.lang.StringBuffer代表<strong>可变的字符序列</strong>，JDK1.0中声明，可以对字符串内容进行增删，此时<strong>不会产生新的对象</strong></p>
<p>很多方法都和String相同</p>
<p>作为参数传递时，<strong>方法内部可以改变值</strong></p>
<p>在StringBuffer类中<code>char[] value</code>没有用final声明，value可以不断扩容；<code>int count</code>有效字符的个数</p>
<pre><code class="java">//源码分析
String str = new String();// &lt;=&gt; char[] value = new char[0];
String str1 = new String( &quot;abc&quot;);// &lt;=&gt; char[] value = new char[]&#123;&#39;a&#39;, &#39;b&#39;,&#39;c&#39;&#125;;
StringBuffer sb1 = new StringBuffer();// &lt;=&gt; char[] value = new char[16]; 底层创建了一个长度是16的字符数组
System.out.println(sb1.Length());//输出0，因为该类的length()方法是返回数组中有效字符的个数即return count;
sb1.append(&#39;a&#39;);//value[0] = &#39;a&#39;;
sb1.append(&#39;b&#39;)://value[1] = &#39;b&#39;;
StringBuffer sb2 = new StringBuffer( &quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.Length()+16]
//问题1. System.out.println(sb2.Length());//3
//问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。
//默认情况下，扩容为原来容量的2倍+ 2,同时将原有数组中的元素复制到新的数组中。
//指导意义:开发中建议大家使用: StringBuffer(int capacity) 或StringBuilder(int capacity)
</code></pre>
<pre><code class="java">String str = nu1l;
StringBuffer sb = new StringBuffer();
sb.append(str);//源码抽象类AbstractStringBuilder中会判断str是否为null，如果是则会调用appendNull()方法将null当作字符串拼接在sb后面
System.out.println(sb.1ength());//输出4
System.out.print1n(sb);//输出字符串&quot;null&quot;
StringBuffer sb1 = new StringBuffer(str);//抛出NullPointerException异常
System.out.println(sb1);
</code></pre>
<h5 id="2-StringBuilder类"><a href="#2-StringBuilder类" class="headerlink" title="2.StringBuilder类"></a>2.StringBuilder类</h5><p>StringBuilder和StringBuffer非常类似，均代表<strong>可变的字符序列</strong>，而且提供<strong>相关功能的方法也一样</strong></p>
<p><strong>面试题：对比String、StringBuffer、 StringBuilder三者的异同</strong><br>String(JDK1.0)：<strong>不可变</strong>字符序列<br>StringBuffer(JDK1.0)：<strong>可变</strong>字符序列、<strong>效率低</strong>、<strong>线程安全</strong><br>StringBuilder(JDK5.0)：<strong>可变</strong>字符序列、<strong>效率高</strong>、<strong>线程不安全</strong></p>
<p>注意：作为参数传递的话，<strong>方法内部String不会改变其值</strong>，<strong>StringBuffer和StringBuilder会改变其值</strong></p>
<h5 id="3-StringBuffer和StringBuilder中的一些方法："><a href="#3-StringBuffer和StringBuilder中的一些方法：" class="headerlink" title="3.StringBuffer和StringBuilder中的一些方法："></a>3.StringBuffer和StringBuilder中的一些方法：</h5><ul>
<li>StringBuffer append(xxx)：提供了很多的append()方法， 用于进行字符串拼接</li>
<li>StringBuffer delete(int start,int end)：删除指定位置的内容</li>
<li>StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str</li>
<li>StringBuffer insert(int offset, xxX)：在指定位置插入xxx</li>
<li>StringBuffer reverse()：把当前字符序列逆转</li>
<li>public int index0f(String str)</li>
<li>public String substring(int start, int end)</li>
<li>public int Length( )</li>
<li>public char charAt(int n)</li>
<li>public void setCharAt(int n , char ch)</li>
</ul>
<p><strong>总结：</strong></p>
<p>增：append(xxx)<br>删：delete(int start, int end)<br>改：setCharAt(int n ,char ch) / replace(int start, int end, String str)<br>查：charAt(int n )<br>插：insert(int offset, xxx) .<br>长度：Length();<br>遍历：for() + charAt() / toString() </p>
<h5 id="4-String、StringBuffer、StringBuilder三者的效率对比"><a href="#4-String、StringBuffer、StringBuilder三者的效率对比" class="headerlink" title="4.String、StringBuffer、StringBuilder三者的效率对比"></a>4.String、StringBuffer、StringBuilder三者的效率对比</h5><pre><code class="java">//初始设置
long startTime = 0L;
long endTime = 0L;
String text = &quot;&quot;;
StringBuffer buffer = new StringBuffer(&quot;&quot;);
StringBuilder builder = new StringBuilder(&quot;&quot;);
//开始对比
startTime = System.currentTimeMillis();
for(int i=0; i&lt;20000; i++)&#123;
    buffer.append(String.valueOf(i));
&#125;
endTime = System.currentTimeMillis();
System.out.println(&quot;StringBuffer的执行时间: &quot; + (endTime - startTime));
startTime = System.currentTimeMillis();
for(int i=0; i&lt;20000; i++)&#123;
    builder.append(String.valueOf(i));
&#125;
endTime = System.currentTimeMillis();
System.out.println(&quot;StringBuilder的执行时间: &quot; + (endTime - startTime));
startTime = System.currentTimeMillis();
for(int i=0; i&lt;20000; i++)&#123;
    text = text + i;
&#125;
endTime = System.currentTimeMillis();
System.out.println(&quot;String的执行时间: &quot; + (endTime - startTime));
//StringBuilder&gt;StringBuffer&gt;String
</code></pre>
<h3 id="8-2-日期时间相关的类"><a href="#8-2-日期时间相关的类" class="headerlink" title="8.2 日期时间相关的类"></a>8.2 日期时间相关的类</h3><h4 id="8-2-1-java-lang-System类（JDK8之前）"><a href="#8-2-1-java-lang-System类（JDK8之前）" class="headerlink" title="8.2.1 java.lang.System类（JDK8之前）"></a>8.2.1 java.lang.System类（JDK8之前）</h4><p>System类提供的public static <strong>long</strong> currentTimeMillis()用来返回<strong>当前时间</strong>与<strong>1970年1月1日0时0分0秒</strong>之间以<strong>毫秒为单位的时间差</strong>（此方法适于计算时间差）</p>
<pre><code class="java">long time = System.currentTimeMillis();
//返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差
//称为时间戳
System.out.println(time);
</code></pre>
<p>计算世界时间的主要标准有：</p>
<ul>
<li>UTC(Coordinated Universal Time)</li>
<li>GMT(Greenwich Mean Time)</li>
<li>CST(Central Standard Time)</li>
</ul>
<h4 id="8-2-2-java-util-Date类（JDK8之前）"><a href="#8-2-2-java-util-Date类（JDK8之前）" class="headerlink" title="8.2.2 java.util.Date类（JDK8之前）"></a>8.2.2 java.util.Date类（JDK8之前）</h4><p>表示<strong>特定的瞬间，精确到毫秒</strong></p>
<p><strong>构造器：</strong></p>
<ul>
<li>Date():使用无参构造器创建的对象可以<strong>获取本地当前时间</strong></li>
<li>Date(long date)</li>
</ul>
<p><strong>常用方法：</strong></p>
<ul>
<li>getTime()：返回自 1970 年1月1日00:00:00 GMT 以来此Date对象表示的毫秒数</li>
<li>toString()：把此 Date对象转换为以下形式的String: dow mon dd hh:mm:ss zzz yyyy 其中: dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准</li>
<li>其它很多方法都过时了</li>
</ul>
<pre><code class="java">//构造器一：Date()，返回当前时间的Date对象
Date date = new Date();
System.out.println(date.toString());//Fri Jul 30 11:20:58 CST 2021
System.out.println(date.getTime());//1627615258490
//构造器二：Date(long date)，返回指定毫秒数的Date对象
Date date1 = new Date(372846236919L);
System.out.println(date1);//Sun Oct 25 16:23:56 CST 1981
</code></pre>
<p><strong>java.sql.Date对应着数据库中的日期类型的变量</strong></p>
<ul>
<li>如何实例化</li>
</ul>
<pre><code class="java">java.sql.Date date2 = new java.sql.Date(9837592502580L);
System.out.println(date2);//2281-09-28
</code></pre>
<ul>
<li>如何将java.util.Date对象转换为java.sql.Date对象</li>
</ul>
<pre><code class="java">//情况一:
Date date4 = new java.sql.Date(2343243242323L); //子类转父类
java.sql.Date date5 = (java.sql.Date)date4; //可以赋值给子类对象
//情况二:
Date date6 = new Date();
java.sq1.Date date7 = (java.sql.Date)date6 //父类直接向下转成子类，报错
java.sq1.Date date7 = new java.sq1.Date(date6.getTime()); //先将获得父类对象的毫秒数再利用构造器转换成sql中的日期
</code></pre>
<h4 id="8-2-3-java-text-SimpleDateFormat类（JDK8之前）"><a href="#8-2-3-java-text-SimpleDateFormat类（JDK8之前）" class="headerlink" title="8.2.3 java.text.SimpleDateFormat类（JDK8之前）"></a>8.2.3 java.text.SimpleDateFormat类（JDK8之前）</h4><p>Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类</p>
<p>它允许进行格式化：日期 -&gt; 文本、 解析：文本 -&gt; 日期</p>
<p>格式化：<br>SimpleDateFormat()：<strong>默认的模式</strong>和语言环境创建对象<br>public SimpleDateFormat(String pattern)：该构造方法可以用<strong>参数pattern指定的格式</strong>创建一个对象， 该对象调用:<br>public String format(Date date)方法<strong>格式化</strong>时间对象date</p>
<p>解析：public Date parse(String source)：从给定字符串的开始<strong>解析文本</strong>，以<strong>生成一个日期</strong></p>
<pre><code class="java">//使用默认构造器实例化SimpleDateFormat对象
SimpleDateFormat simpleDateFormat = new SimpleDateFormat();
//格式化：日期 --&gt; 字符串
Date date = new Date();
String format = simpleDateFormat.format(date);
System.out.println(format);
//解析：字符串 --&gt; 日期
String str = &quot;21-7-31 上午10:23&quot;;//使用SimpleDateFormat默认构造器实例化的对象必须使用这种这种格式，否则会抛出异常
Date date1 = simpleDateFormat.parse(str);
System.out.println(date1);
//按照指定格式进行格式化和解析：调用带参的构造器
System.out.println(&quot;============指定格式==============&quot;);
SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//传入的参数即为日期要格式化和解析的格式
//格式化
Date date2 = new Date();
String format1 = sdf.format(date2);
System.out.println(format1);
//解析：要求字符串必须是符合SimpleDateFormat的格式
String str1 = &quot;2021-07-31 10:34:45&quot;;
Date date3 = sdf.parse(str1);
System.out.println(date3);
</code></pre>
<h4 id="8-2-4-java-utils-Calendar-日历-类（JDK8之前）"><a href="#8-2-4-java-utils-Calendar-日历-类（JDK8之前）" class="headerlink" title="8.2.4 java.utils.Calendar(日历)类（JDK8之前）"></a>8.2.4 java.utils.Calendar(日历)类（JDK8之前）</h4><p>Calendar是一个<strong>抽象基类</strong>，主用用于完成日期字段之间相互操作的功能</p>
<p><strong>获取Calendar实例的方法：</strong></p>
<ul>
<li>使用**Calendar.getInstance()**方法</li>
<li>调用它的子类<strong>GregorianCalendar的构造器</strong></li>
</ul>
<p>一个Calendar的实例是系统时间的抽象表示，通过<strong>get(int field)方法来取得想要的时间信息</strong>。比如YEAR、MONTH、DAY_OF_ _WEEK、HOUR_OF_DAY 、MINUTE、SECOND</p>
<ul>
<li>public void set(int field,int value)</li>
<li>public void add(int field,int amount)</li>
<li>public final Date getTime()</li>
<li>public final void setTime(Date date)</li>
</ul>
<p><strong>注意：</strong></p>
<ul>
<li>获取月份时：一月是0，二月是1，以此类推，12月是11</li>
<li>获取星期时：周日是1，周二是2，。。。。周六是7</li>
</ul>
<pre><code class="java">//1.实例化
//方式一：创建其子类（GregorianCalendar）的对象
//方式二：调用其静态方法getInstance()
Calendar calendar = Calendar.getInstance();//返回的其实还是子类GregorianCalendar的对象

//2.常用方法
int days = calendar.get(Calendar.DAY_OF_MONTH);//get(),获取当前calendar对象对应字段的值
System.out.println(days);
System.out.println(&quot;==============&quot;);
calendar.set(Calendar.DAY_OF_MONTH,22);//set(),设置当前calendar对象的属性字段值，
days = calendar.get(Calendar.DAY_OF_MONTH);
System.out.println(days);
System.out.println(&quot;==============&quot;);
calendar.add(Calendar.DAY_OF_MONTH,4);//add(),在当前calendar对象对应字段值的基础上加减
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));
System.out.println(&quot;==============&quot;);
Date date = calendar.getTime();//getTime(),日历类 --&gt; Date
System.out.println(date);
System.out.println(&quot;==============&quot;);
Date date1 = new Date();
calendar.setTime(date1);//setTime(),Date --&gt; 日历类
System.out.println(calendar.get(Calendar.DAY_OF_MONTH));
</code></pre>
<h4 id="8-2-5-java-time（JDK8中）"><a href="#8-2-5-java-time（JDK8中）" class="headerlink" title="8.2.5 java.time（JDK8中）"></a>8.2.5 java.time（JDK8中）</h4><p>Java8吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的API</p>
<p>新的<strong>java.time</strong>中包含了所有关于<strong>本地日期(LocalDate)</strong> 、<strong>本地时间(LocalTime)<strong>、</strong>本地日期时间(LocalDateTime)</strong> 、<strong>时区( ZonedDate Time)<strong>和</strong>持续时间(Duration)<strong>的类。历史悠久的Date类新增了</strong>tolnstant() 方法, 用于把Date转换成新的表示形式</strong></p>
<p>LocalDate、LocalTime、LocalDateTime类是其中较重要的几个类，它们的实例是<strong>不可变的对象</strong>，分别表示使用ISO-8601日历系统的<strong>日期</strong>、<strong>时间</strong>、<strong>日期和时间</strong>。它们提供了简单的<strong>本地日期或时间</strong>，并不包含当前的时间信息，也不包含与时区相关的信息</p>
<ul>
<li>LocalDate<strong>代表IOS格式(yyyy-MM-dd) 的日期</strong>，可以存储生日、纪念日等日期</li>
<li>LocalTime<strong>表示一个时间， 而不是日期</strong></li>
<li>LocalDateTime是用来<strong>表示日期和时间</strong>的，这是一个最常用的类之一</li>
</ul>
<p>注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是<strong>公历</strong></p>
<h5 id="1-LocalDate、LocalTime、LocalDateTime类"><a href="#1-LocalDate、LocalTime、LocalDateTime类" class="headerlink" title="1.LocalDate、LocalTime、LocalDateTime类"></a>1.LocalDate、LocalTime、LocalDateTime类</h5><table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">now() / * now(Zoneld zone)</td>
<td align="center">静态方法，<strong>根据当前时间创建对象/指定时区的对象</strong></td>
</tr>
<tr>
<td align="center">of()</td>
<td align="center">静态方法，<strong>根据指定日期/时间创建对象</strong></td>
</tr>
<tr>
<td align="center">getDayOfMonth()/getDayOfYear()</td>
<td align="center"><strong>获得</strong>月份天数(1-31) /获得年份天数(1-366)</td>
</tr>
<tr>
<td align="center">getDayOfWeek()</td>
<td align="center">获得星期几(返回一个DayOfWeek枚举值)</td>
</tr>
<tr>
<td align="center">getMonth()</td>
<td align="center">获得月份，返回一个Month枚举值</td>
</tr>
<tr>
<td align="center">getMonthValue()/getYear()</td>
<td align="center">获得月份(1-12)/获得年份</td>
</tr>
<tr>
<td align="center">getHour()/getMinute()/getSecond()</td>
<td align="center">获得当前对象对应的小时、分钟、秒</td>
</tr>
<tr>
<td align="center">withDayOfMonth()/withDayOfYear()/withMonth()/withYear()</td>
<td align="center">将月份天数、年份天数、月份、年份修改为指定的值并<strong>返回新的对象</strong></td>
</tr>
<tr>
<td align="center">plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours()</td>
<td align="center"><strong>向当前对象添加</strong>几天、几周、几个月、几年、几小时</td>
</tr>
<tr>
<td align="center">minusMonths()/minusWeeks()/minusDays()/minus Years()/minusHours</td>
<td align="center"><strong>从当前对象减去</strong>几月、几周、几天、几年、几小时</td>
</tr>
</tbody></table>
<pre><code class="java">//jdk8中的时间API
//LocalDate、LocalTime、LocalDateTime获取当前的日期、时间、日期+时间，LocalDateTime使用最多
//方法一：now()实例化对象
LocalDate now = LocalDate.now();
LocalTime now1 = LocalTime.now();
LocalDateTime now2 = LocalDateTime.now();
System.out.println(now);
System.out.println(now1);
System.out.println(now2);
//方法二：of()实例化对象，可指定具体的日期和时间年、月、日、时、分、秒,没有偏移量
LocalDateTime of = LocalDateTime.of(2021, 7, 31, 16, 30, 34);
System.out.println(of);
//getXxx()
System.out.println(of.getDayOfMonth());
System.out.println(of.getDayOfWeek());
System.out.println(of.getMonth());
System.out.println(of.getMonthValue());
System.out.println(of.getMinute());
//withXxxx(),返回新的对象，原对象仍然保存，体现出不可变性
LocalDateTime localDateTime = of.withDayOfMonth(20);
System.out.println(localDateTime);
//plusXxxx(),返回新的对象，原对象仍然保存，体现出不可变性
LocalDateTime localDateTime1 = of.plusMonths(2);
System.out.println(localDateTime1);
//minusXxxx(),返回新的对象，原对象仍然保存，体现出不可变性
LocalDateTime localDateTime2 = of.minusHours(2);
System.out.println(localDateTime2);
</code></pre>
<h5 id="2-Instant类"><a href="#2-Instant类" class="headerlink" title="2.Instant类"></a>2.Instant类</h5><p>Instant：<strong>时间线上的一个瞬时点</strong>。这可能被用来记录应用程序中的事件时间戳</p>
<p>在处理时间和日期的时候，我们通常会想到年，月，日，时，分，秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始， 以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位</p>
<p>javatime包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。<strong>Instant表示时间线上的一点</strong>，而不需要任何上下文信息，例如，时区。概念上讲，<strong>它只是简单的表示自1970年1月1日0时0分0秒(UTC)开始的秒数</strong>。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级</p>
<p>(1ns= 10^-9s) 1秒= 1000毫秒=10^6微秒=10^9纳秒</p>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">now()</td>
<td align="center">静态方法，<strong>返回默认UTC时区的Instant类的对象</strong></td>
</tr>
<tr>
<td align="center">ofEpochMill(long epochMili)</td>
<td align="center">静态方法，返回<strong>在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象</strong></td>
</tr>
<tr>
<td align="center">atOffset(ZoneOffset offset)</td>
<td align="center">结合即时的偏移来创建一个<strong>OffsetDateTime</strong></td>
</tr>
<tr>
<td align="center">toEpochMilli()</td>
<td align="center"><strong>返回1970-01-01 00:00:00到当前时间的毫秒数</strong>，即为时间戳</td>
</tr>
</tbody></table>
<p>时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数</p>
<pre><code class="java">//now(),本初子午线的标准时间
Instant now = Instant.now();
System.out.println(now);//2021-07-31T09:15:43.844Z
//atOffset(),添加时间偏移量
OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8));
System.out.println(offsetDateTime);//2021-07-31T17:15:43.844+08:00
//toEpochMilli(),获取自1970年1月1日0时0分0秒（UTC）开始到当前的毫秒数，类似于getTime()
long milli = now.toEpochMilli();
System.out.println(milli);//1627722943844
//ofEpochMilli(),创建在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象，类似于new Date(long milli)
Instant instant = Instant.ofEpochMilli(1627722943844L);
System.out.println(instant);//2021-07-31T09:15:43.844Z
</code></pre>
<h5 id="3-java-time-format-DateTimeFormpatter类"><a href="#3-java-time-format-DateTimeFormpatter类" class="headerlink" title="3.java.time.format.DateTimeFormpatter类"></a>3.java.time.format.DateTimeFormpatter类</h5><p>java.time.format.DateTimeFormpatter类类似于SimpleDateFormat类，都是格式化或解析日期、时间的类</p>
<p>该类提供了三种格式化方法：</p>
<ul>
<li><strong>预定义的标准格式</strong>。如:ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME</li>
<li><strong>本地化相关的格式</strong>。 如：ofLocalizedDateTime(FormatStyle.LONG/FormatStyle.MEDIUM/FormatStyLe.SHORT)、ofLocalizedDate(FormatStyLe.FULL/FormatStyLe.LONG/FormatStyLe.MEDIUM/FormatStyLe.SHORT)</li>
<li><strong>自定义的格式</strong>。如：ofPattern(“yyyy-MM-dd hh:mm:ss E”)</li>
</ul>
<table>
<thead>
<tr>
<th align="center">方法</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">ofPattern(String pattern)</td>
<td align="center">静态方法，<strong>返回一个指定字符串格式的DateTimeFormatter</strong></td>
</tr>
<tr>
<td align="center">format(TemporalAccessor t)</td>
<td align="center"><strong>格式化一个日期、 时间，返回字符串</strong></td>
</tr>
<tr>
<td align="center">parse(CharSequence text)</td>
<td align="center"><strong>将指定格式的字符序列解析为一个日期、时间</strong></td>
</tr>
</tbody></table>
<pre><code class="java">//方法一：预定义的标准格式。如:ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME
DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME;
//格式化:日期 ---&gt; 字符串
LocalDateTime now = LocalDateTime.now();
String str = formatter.format(now);
System.out.println(now);//2021-07-31T18:00:04.243
System.out.println(str);//2021-07-31T18:00:04.243
//解析:字符串 ---&gt; 日期
TemporalAccessor parse = formatter.parse(&quot;2021-07-31T17:38:27.063&quot;);
System.out.println(parse);//&#123;&#125;,ISO resolved to 2021-07-31T17:38:27.063
//方法二：
//本地化相关的格式。 如：ofLocalizedDateTime(FormatStyle.LONG)
LocalDateTime now1 = LocalDateTime.now();
DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG);
//格式化
String str1 = formatter1.format(now1);
System.out.println(now1);//2021-07-31T18:00:04.251
System.out.println(str1);//2021年7月31日 下午06时00分04秒
//解析
TemporalAccessor parse1 = formatter1.parse(&quot;2021年7月31日 下午05时52分08秒&quot;);
System.out.println(parse1);//&#123;&#125;,ISO resolved to 2021-07-31T17:52:08
//本地化相关的格式。 如：ofLocalizedDate(FormatStyle.FULL)
LocalDate now2 = LocalDate.now();
DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL);
//格式化
String str2 = formatter2.format(now2);
System.out.println(now2);//2021-07-31
System.out.println(str2);//2021年7月31日 星期六
//解析
TemporalAccessor parse2 = formatter2.parse(&quot;2021年7月31日 星期六&quot;);
System.out.println(parse2);//&#123;&#125;,ISO resolved to 2021-07-31
//方法三：重点：自定义的格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss E&quot;)
DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;);
//格式化
String str3 = formatter3.format(LocalDateTime.now());
System.out.println(str3);//2021-07-31 06:06:53
//解析
TemporalAccessor parse3 = formatter3.parse(&quot;2021-07-31 06:06:37&quot;);
System.out.println(parse3);//&#123;SecondOfMinute=37, HourOfAmPm=6, MicroOfSecond=0, NanoOfSecond=0, MinuteOfHour=6, MilliOfSecond=0&#125;,ISO resolved to 2021-07-31
</code></pre>
<h5 id="4-其他API"><a href="#4-其他API" class="headerlink" title="4.其他API"></a>4.其他API</h5><p>ZoneId：该类中包含了<strong>所有的时区信息，一个时区的ID</strong>，如Europe/Paris</p>
<p>ZonedDateTime：一个在IS0-8601日历系统时区的日期时间，如2007-12-03T10:15:30+01:00 Europe/Paris</p>
<ul>
<li>其中每个时区都对应着ID，<strong>地区ID都为“{区域}{城市}”</strong>的格式，例如：Asia/Shanghai等</li>
</ul>
<p>Clock：使用时区提供<strong>对当前即时、日期和时间的访问的时钟</strong></p>
<ul>
<li>持续时间: Duration, 用于计算两个“时间”间隔</li>
<li>日期间隔: Period， 用于计算两个“日期”间隔</li>
</ul>
<p>TemporalAdjuster：<strong>时间校正</strong>器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作</p>
<p>TemporalAdjusters：该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster的实现</p>
<h3 id="8-3-Java比较器"><a href="#8-3-Java比较器" class="headerlink" title="8.3 Java比较器"></a>8.3 Java比较器</h3><p>Java实现对象排序的方式有两种：</p>
<ul>
<li>自然排序：java.lang.Comparable</li>
<li>定制排序：java.util.Comparator</li>
</ul>
<p>说明：Java中的对象，正常情况下，只能进行比较：==或!=。不能使用&gt;或&lt;的，但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小</p>
<p>如何实现呢?使用两个接口中的任何一个: Comparable 或Comparator</p>
<h4 id="8-3-1-Comparable接口-自然排序"><a href="#8-3-1-Comparable接口-自然排序" class="headerlink" title="8.3.1 Comparable接口(自然排序)"></a>8.3.1 Comparable接口(自然排序)</h4><p>Comparable接口<strong>强行对实现它的每个类的对象进行整体排序</strong>。这种排序被称为类的自然排序</p>
<p>实现Comparable的类必须实现compare To(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小。<strong>如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零</strong></p>
<p>实现Comparable接口的对象列表(和数组)可以通过Collections.sort或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器</p>
<p>对于类C的每一个e1和e2来说，当且仪当e1.compareTo(e2) == 0与e1.equals(e2)具有相同的boolean值时，类C的自然排序才叫做与equals一致。<strong>建议(虽然不是必需的)最好使自然排序与equals一致</strong></p>
<pre><code class="java">//Comparable接口的使用实例：
//1.String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方法
//2.String、包装类重写compareTo()方法以后，进行了从小到大的排列
//3.重写compareTo(obj)的规则:
//  如果当前对象上his大于形参对象obj,则返回正整数，
//  如果当前对象this小于形参对象obj,则返回负整数，
//  如果当前对象this等于形参对象obj,则返回零。
String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;;
Arrays.sort(arr);//sort方法底层是通过Comparable接口实现的，即传入数组的元素的类型必须要实现Comparable接口，然后会调用ComparableTo()方法进行各元素间的比较
System.out.println(Arrays.toString(arr));//[AA, CC, DD, GG, JJ, KK, MM]
//4.对于自定义类来说,如果需要排序,我们可以让自定义类实现Comparable接口,重写compareTo(obj)方法,在方法中指明如何排序，从另一方面说明了需要进行比较的数组元素类型对应的类必须实现Comparable接口
public class Goods implements Comparable &#123;
    private String name;
    private double price;
    public Goods() &#123;
    &#125;
    public Goods(String name, double price) &#123;
        this.name = name;
        this.price = price;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public double getPrice() &#123;
        return price;
    &#125;
    public void setPrice(double price) &#123;
        this.price = price;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Goods&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, price=&quot; + price +
                &#39;&#125;&#39;;
    &#125;
    //指明商品比较大小的方式：按价格从低到高
    @Override
    public int compareTo(Object o) &#123;
        if(o instanceof Goods) &#123;
            Goods goods = (Goods) o;
            //方式一：
            if(this.price &gt; goods.price)
                return 1;
            else if(this.price &lt; goods.price)
                return -1;
            else
                return 0;
            //方式二：
            //return Double.compare(this.price,goods.price);
        &#125;
        throw new RuntimeException(&quot;传入的数据类型不正确&quot;);
    &#125;
&#125;
main()&#123;
    Goods[] goods = new Goods[4];
    goods[0] = new Goods(&quot;lenovoMouse&quot;,34);
    goods[1] = new Goods(&quot;dellMouse&quot;,43);
    goods[2] = new Goods(&quot;xiaomiMouse&quot;,20);
    goods[3] = new Goods(&quot;huaweiMouse&quot;,65);
    Arrays.sort(goods);
    System.out.println(Arrays.toString(goods));//[Goods&#123;name=&#39;xiaomiMouse&#39;, price=20.0&#125;, Goods&#123;name=&#39;lenovoMouse&#39;, price=34.0&#125;, Goods&#123;name=&#39;dellMouse&#39;, price=43.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=65.0&#125;]
&#125;
</code></pre>
<h4 id="8-3-2-Comparator接口-定制排序"><a href="#8-3-2-Comparator接口-定制排序" class="headerlink" title="8.3.2 Comparator接口(定制排序)"></a>8.3.2 Comparator接口(定制排序)</h4><p>当元素的类型<strong>没有实现java.lang.Comparable接口而又不方便修改代码</strong>，或者<strong>实现了java.lang.Comparable接口的排序规则不适合当前的操作</strong>，那么可以考虑使用Comparator 的对象来排序，<strong>强行对多个对象进行整体排序的比较</strong></p>
<p>重写compare(Object o1,Object o2)方法，比较o1和o2的大小：<strong>如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2</strong></p>
<p>可以<strong>将Comparator传递给sort方法</strong>(如Collections.sort或Arrays.sort)，从而允许在排序顺序上实现精确控制</p>
<p>还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序</p>
<pre><code class="java">//Comparator接口
//String类测试
String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;;
Arrays.sort(arr,new Comparator()&#123;
    //字符串从大到小进行排列
    @Override
    public int compare(Object o1, Object o2) &#123;
        if(o1 instanceof String &amp;&amp; o2 instanceof String) &#123;
            String s1 = (String) o1;
            String s2 = (String) o2;
            return -s1.compareTo(s2);
        &#125;
        throw new RuntimeException(&quot;输入的数据类型不一致&quot;);
    &#125;
&#125;);
System.out.println(Arrays.toString(arr));//[MM, KK, JJ, GG, DD, CC, AA]
//自定义类测试
Goods[] goods = new Goods[5];
goods[0] = new Goods(&quot;lenovoMouse&quot;,34);
goods[1] = new Goods(&quot;dellMouse&quot;,43);
goods[2] = new Goods(&quot;xiaomiMouse&quot;,20);
goods[3] = new Goods(&quot;huaweiMouse&quot;,65);
goods[4] = new Goods(&quot;huaweiMouse&quot;,165);
Arrays.sort(goods,new Comparator() &#123;
    //商品先按商品名从低到高排，如果商品名一样则按价格从高到低排
    @Override
    public int compare(Object o1, Object o2) &#123;
        if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods) &#123;
            Goods goods1 = (Goods) o1;
            Goods goods2 = (Goods) o2;
            if(goods1.getName().equals(goods2.getName()))&#123;
                return -Double.compare(goods1.getPrice(),goods2.getPrice());//价格从高到低排
            &#125;else&#123;
                return goods1.getName().compareTo(goods2.getName());//商品名字从低到高排序
            &#125;
        &#125;
        throw new RuntimeException(&quot;比较的类型不一样&quot;);
    &#125;
&#125;);
System.out.println(Arrays.toString(goods));//[Goods&#123;name=&#39;dellMouse&#39;, price=43.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=165.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=65.0&#125;, Goods&#123;name=&#39;lenovoMouse&#39;, price=34.0&#125;, Goods&#123;name=&#39;xiaomiMouse&#39;, price=20.0&#125;]
</code></pre>
<h4 id="8-3-3-Comparable接口与Comparator接口的简单对比"><a href="#8-3-3-Comparable接口与Comparator接口的简单对比" class="headerlink" title="8.3.3 Comparable接口与Comparator接口的简单对比"></a>8.3.3 Comparable接口与Comparator接口的简单对比</h4><p>Comparable接口的方式一旦一定，保证<strong>Comparable接口实现类的对象在任何位置都可以比较大小</strong></p>
<p>Comparator接口属于<strong>临时性的比较</strong></p>
<h3 id="8-4-System类"><a href="#8-4-System类" class="headerlink" title="8.4 System类"></a>8.4 System类</h3><p>System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包</p>
<p>由于该类的<strong>构造器是private</strong>的，所以无法创建该类的对象，也就是无法实例化该类。其<strong>内部的成员变量和成员方法都是static</strong>的，所以也可以很方便的进行调用。</p>
<p>成员变量</p>
<ul>
<li>System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器)</li>
</ul>
<p>成员方法</p>
<ul>
<li><p>native long currentTimeMillis()：该方法的作用是<strong>返回当前的计算机时间</strong>，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数</p>
</li>
<li><p>void exit(int status)：该方法的<strong>作用是退出程序</strong>。其中status的值为<strong>0代表正常退出</strong>，<strong>非零代表异常退出</strong>。使用<strong>该方法可以在图形界面编程中实现程序的退出功能</strong>等</p>
</li>
<li><p>void gc()：该方法的作用是<strong>请求系统进行垃圾回收</strong>。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况</p>
</li>
<li><p>String getProperty(String key)：该方法的作用是<strong>获得系统中属性名为key的属性对应的值</strong>。系统中常见的属性名以及属性的作用如下表所示：</p>
<table>
<thead>
<tr>
<th align="center">属性名</th>
<th align="center">属性说明</th>
</tr>
</thead>
<tbody><tr>
<td align="center">java.version</td>
<td align="center">Java运行时环境版本</td>
</tr>
<tr>
<td align="center">java.home</td>
<td align="center">Java安装目录</td>
</tr>
<tr>
<td align="center">os.name</td>
<td align="center">操作系统的名称</td>
</tr>
<tr>
<td align="center">os.version</td>
<td align="center">操作系统的版本</td>
</tr>
<tr>
<td align="center">user.name</td>
<td align="center">用户的账户名称</td>
</tr>
<tr>
<td align="center">user.home</td>
<td align="center">用户的主目录</td>
</tr>
<tr>
<td align="center">user.dir</td>
<td align="center">用户的当前工作目录</td>
</tr>
</tbody></table>
<pre><code class="java">String javaVersion = System.getProperty(&quot;java.version&quot;);
System.out.println(&quot;java的version:&quot; + javaVersion);//java的version:1.8.0_291
String javaHome = System.getProperty(&quot;java.home&quot;);
System.out.println(&quot;java的home:&quot; + javaHome);//java的home:C:\ProgramFiles\Java\jdk1.8.0_291\jre
String osName = System.getProperty(&quot;os.name&quot;);
System.out.println(&quot;os的name:&quot; + osName );//os的name:Windows 10
String osVersion = System.getProperty(&quot;os.version&quot;);
System.out.println(&quot;os的version:&quot; + osVersion);//os的version: 10.0
String userName = System.getProperty(&quot;user.name&quot; );
System.out.println(&quot;user的name:&quot; + userName);//user的name:Administrator
String userHome = System.getProperty(&quot;user.home&quot;);
System.out.println(&quot;user的home:&quot; + userHome);//user的home:C:\Users\Administrator
String userDir = System.getProperty(&quot;user.dir&quot;);
System.out.println(&quot;user的dir:&quot; + userDir);//user的dir:E:\JavaProject\IDEAProject\自主练习\Demo
</code></pre>
</li>
</ul>
<h3 id="8-5-Math类"><a href="#8-5-Math类" class="headerlink" title="8.5 Math类"></a>8.5 Math类</h3><p>java.lang.Math提供了一系列<strong>静态方法</strong>用于科学计算。其方法的参数和返回值类型一般为double型</p>
<table>
<thead>
<tr>
<th align="center">方法名</th>
<th align="center">用法</th>
</tr>
</thead>
<tbody><tr>
<td align="center">abs</td>
<td align="center">绝对值</td>
</tr>
<tr>
<td align="center">acos,asin,atan,cos,sin,tan</td>
<td align="center">三角函数</td>
</tr>
<tr>
<td align="center">sqrt</td>
<td align="center">平方根</td>
</tr>
<tr>
<td align="center">pow(double a,doble b)</td>
<td align="center">a的b次幂</td>
</tr>
<tr>
<td align="center">log</td>
<td align="center">自然对数</td>
</tr>
<tr>
<td align="center">exp</td>
<td align="center">e为底指数</td>
</tr>
<tr>
<td align="center">max(double a,double b)</td>
<td align="center">取a与b之间的最大值</td>
</tr>
<tr>
<td align="center">min(double a,double b)</td>
<td align="center">取a与b之间的最小值</td>
</tr>
<tr>
<td align="center">random()</td>
<td align="center">返回0.0到1.0的随机数</td>
</tr>
<tr>
<td align="center">long round(double a)</td>
<td align="center">double型数据a转换为long型(四舍五入)</td>
</tr>
<tr>
<td align="center">toDegrees(double angrad)</td>
<td align="center">弧度 –&gt; 角度</td>
</tr>
<tr>
<td align="center">toRadians(double angdeg)</td>
<td align="center">角度 –&gt; 弧度</td>
</tr>
</tbody></table>
<h3 id="8-6-BigInteger与BigDecimal"><a href="#8-6-BigInteger与BigDecimal" class="headerlink" title="8.6 BigInteger与BigDecimal"></a>8.6 BigInteger与BigDecimal</h3><h4 id="8-6-1-BigInteger类"><a href="#8-6-1-BigInteger类" class="headerlink" title="8.6.1 BigInteger类"></a>8.6.1 BigInteger类</h4><p>java.math包的<strong>BigInteger可以表示不可变的任意精度的整数</strong>。BigInteger提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作</p>
<p><strong>构造器</strong>：BigInteger(String val)：<strong>根据字符串构建BigInteger对象</strong></p>
<p><strong>常用方法：</strong></p>
<ul>
<li>public BigInteger <strong>abs</strong>()：返回此BigInteger的<strong>绝对值</strong>的BigInteger</li>
<li>BigInteger <strong>add</strong>(BigInteger val)：返回其值为**(this + val)**的BigInteger</li>
<li>BigInteger <strong>subtract</strong>(BigInteger val)：返回其值为**(this - val)**的BigInteger</li>
<li>BigInteger <strong>multiply</strong>(BigInteger val)：返回其值为**(this * val)**的BigInteger</li>
<li>BigInteger <strong>divide</strong>(BigInteger val)：返回其值为**(this / val)<strong>的BigInteger。</strong>整数相除只保留整数部分**</li>
<li>BigInteger <strong>remainder</strong>(BigInteger val)：返回其值为**(this % val)**的BigInteger</li>
<li>BigInteger[] <strong>divideAndRemainder</strong>(BigInteger val)：返回包含**(this / val)<strong>后跟</strong>(this % val)**的两个BigInteger的数组</li>
<li>BigInteger <strong>pow</strong>(int exponent)：返回其值为**(this^exponent)**的BigInteger</li>
</ul>
<h4 id="8-6-2-BigDecimal类"><a href="#8-6-2-BigDecimal类" class="headerlink" title="8.6.2 BigDecimal类"></a>8.6.2 BigDecimal类</h4><p>一般的<strong>Float</strong>类和<strong>Double</strong>类可以用来<strong>做科学计算或工程计算</strong>，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类</p>
<p>BigDecimal类支持<strong>不可变的</strong>、<strong>任意精度</strong>的有符号十进制定点数</p>
<p>构造器</p>
<ul>
<li>public BigDecimal(double val)</li>
<li>public BigDecimal(String val)</li>
</ul>
<p>常用方法</p>
<ul>
<li>public BigDecimal add(BigDecimal augend)</li>
<li>public BigDecimal subtract(BigDecimal subtrahend)</li>
<li>public BigDecimal multiply(BigDecimal multiplicand)</li>
<li>public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode)</li>
</ul>
<pre><code class="java">BigInteger bi = new BigInteger(&quot;12433241123&quot;);
BigDecimal bd = new BigDecimal(&quot;12435.351&quot;);
BigDecimal bd2 = new BigDecimal(&quot;11&quot;);
System.out.println(bi);//12433241123
//System.out.println(bd.divide(bd2)); //除不尽就必须要告诉保留多少位
System.out.println(bd.divide(bd2,BigDecimal.ROUND_HALF_UP));//1130.486
System.out.println(bd.divide(bd2,15,BigDecimal.ROUND_HALF_UP));//1130.486454545454545
</code></pre>
<h2 id="九、枚举类和注解"><a href="#九、枚举类和注解" class="headerlink" title="九、枚举类和注解"></a>九、枚举类和注解</h2><h3 id="9-1-枚举-enum"><a href="#9-1-枚举-enum" class="headerlink" title="9.1 枚举(enum)"></a>9.1 枚举(enum)</h3><p>Java 枚举是一个<strong>特殊的类</strong>，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。当需要定义<strong>一组</strong>常量时，强烈建议使用枚举类</p>
<p>Java 枚举类使用 enum 关键字来定义，类的<strong>对象只有有限个，确定的</strong>；<strong>各个常量使用逗号 , 来分割</strong></p>
<p><strong>JDK5之前</strong>自定义一个季节枚举类</p>
<pre><code class="java">class Season&#123;
    //1.声明Season属性：private final修饰
    private final String seasonName;
    private final String seasonDesc;
    //2.私有化类的构造器，并给对象赋值
    private Season(String seasonName,String seasonDesc)&#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &#125;
    //3.提供当前枚举类的多个对象
    public static final Season SPRING = new Season(&quot;春天&quot; ,&quot;春暖花开&quot;);
    public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;);
    public static final Season AUTUMN = new Season(&quot;秋天&quot; ,&quot;秋高气爽&quot;);
    public static final Season WINTER = new Season(&quot;冬天&quot; ,&quot;冰天雪地&quot;);
    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() &#123;
        return seasonName;
    &#125;
    public String getSeasonDesc() &#123;
        return seasonDesc;
    &#125;
    //其他诉求2：提供toString()方法
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;seasonName=&#39;&quot; + seasonName + &#39;\&#39;&#39; +
                &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<p><strong>JDK5之后</strong>自定义一个季节枚举类</p>
<pre><code class="java">//使用enum定义的枚举类默认继承java.lang.Enum类
enum Season  &#123; 
    //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，最后用&quot;;&quot;结束
    SPRING(&quot;春天&quot; ,&quot;春暖花开&quot;),
    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;),
    AUTUMN(&quot;秋天&quot; ,&quot;秋高气爽&quot;),
    WINTER(&quot;冬天&quot; ,&quot;冰天雪地&quot;);
    //2.声明Season属性：private final修饰
    private final String seasonName;
    private final String seasonDesc;
    //3.私有化类的构造器，并给对象赋值
    private Season(String seasonName,String seasonDesc)&#123;
        this.seasonName = seasonName;
        this.seasonDesc = seasonDesc;
    &#125;
    //4.其他诉求1：获取枚举类对象的属性
    public String getSeasonName() &#123;
        return seasonName;
    &#125;
    public String getSeasonDesc() &#123;
        return seasonDesc;
    &#125;
    //其他诉求2：提供toString()方法，此时的toString方法可不提供，因为这个枚举类继承自Enum类，打印输出的仍是这个枚举类对象的对象名
    @Override
    public String toString() &#123;
        return &quot;Season&#123;&quot; +
                &quot;seasonName=&#39;&quot; + seasonName + &#39;\&#39;&#39; +
                &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125; 
&#125; 
</code></pre>
<h4 id="9-1-1-枚举类成员"><a href="#9-1-1-枚举类成员" class="headerlink" title="9.1.1 枚举类成员"></a>9.1.1 枚举类成员</h4><p>枚举跟普通类一样可以<strong>用自己的变量、方法和构造函数</strong>，构造函数<strong>只能使用 private</strong> 访问修饰符，所以外部无法调用</p>
<p>枚举类<strong>既可以包含具体方法，也可以包含抽象方法</strong>。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它</p>
<pre><code class="java">enum Color &#123;
    RED, GREEN, BLUE;
    // 构造函数
    private Color() &#123;
        System.out.println(&quot;Constructor called for : &quot; + this.toString());
    &#125;
    public void colorInfo() &#123;
        System.out.println(&quot;Universal Color&quot;);
    &#125;
&#125;
 
public class Test &#123;    
    // 输出
    public static void main(String[] args) &#123;
        Color c1 = Color.RED;
        System.out.println(c1);
        c1.colorInfo();
    &#125;
&#125;
</code></pre>
<p><strong>枚举类中抽象方法的实现：</strong></p>
<pre><code class="java">enum Color &#123;
    RED &#123;
        public String getColor()&#123;//枚举对象实现抽象方法
            return &quot;红色&quot;;
        &#125;
    &#125;,
    GREEN&#123;
        public String getColor()&#123;//枚举对象实现抽象方法
            return &quot;绿色&quot;;
        &#125;
    &#125;,
    BLUE&#123;
        public String getColor()&#123;//枚举对象实现抽象方法
            return &quot;蓝色&quot;;
        &#125;
    &#125;;
    public abstract String getColor();//定义抽象方法
&#125;
</code></pre>
<h4 id="9-1-2-values-，ordinal-和valueOf-方法"><a href="#9-1-2-values-，ordinal-和valueOf-方法" class="headerlink" title="9.1.2 values()，ordinal()和valueOf()方法"></a>9.1.2 values()，ordinal()和valueOf()方法</h4><p>enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。</p>
<p>values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中：</p>
<ul>
<li>values()：枚举类中<strong>所有的值</strong></li>
<li>ordinal()：可以找到<strong>每个枚举常量的索引</strong>，就像数组索引一样</li>
<li>valueOf()：返回<strong>指定字符串值的枚举常量</strong></li>
<li>toString()：返回<strong>当前枚举类对象常量的名称</strong></li>
</ul>
<pre><code class="java">enum Color &#123;
    RED, GREEN, BLUE;
&#125;
public class Test &#123;
    public static void main(String[] args) &#123;
        // 调用 values()
        Color[] arr = Color.values();
        // 迭代枚举
        for (Color col : arr) &#123;
            // 查看索引
            System.out.println(col + &quot; at index &quot; + col.ordinal());
        &#125;
        // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException
        System.out.println(Color.valueOf(&quot;RED&quot;));
        // System.out.println(Color.valueOf(&quot;WHITE&quot;));
    &#125;
&#125;
</code></pre>
<h4 id="9-1-3-使用Enum关键字定义的枚举类实现接口"><a href="#9-1-3-使用Enum关键字定义的枚举类实现接口" class="headerlink" title="9.1.3 使用Enum关键字定义的枚举类实现接口"></a>9.1.3 使用Enum关键字定义的枚举类实现接口</h4><p>情况一：实现接口，在enum类中实现抽象方法</p>
<p>情况二：让枚举类的对象分别实现接口中的抽象方法</p>
<pre><code class="java">interface Info&#123;
    void show();
&#125;
enum Season implements Info&#123;
    //枚举类实现接口情况一：实现接口中的抽象方法
    @Override
    public void show() &#123;
        System.out.println(&quot;这一个季节&quot;);
    &#125;
    //枚举类实现接口情况二：每个枚举类对象独立实现抽象方法
    SPRING(&quot;春天&quot; ,&quot;春暖花开&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是春天&quot;);
        &#125;
    &#125;,
    SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是夏天&quot;);
        &#125;
    &#125;,
    AUTUMN(&quot;秋天&quot; ,&quot;秋高气爽&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是秋天&quot;);
        &#125;
    &#125;,
    WINTER(&quot;冬天&quot; ,&quot;冰天雪地&quot;)&#123;
        @Override
        public void show() &#123;
            System.out.println(&quot;这是冬天&quot;);
        &#125;
    &#125;;
&#125;
</code></pre>
<h4 id="9-1-4-内部类中使用枚举"><a href="#9-1-4-内部类中使用枚举" class="headerlink" title="9.1.4 内部类中使用枚举"></a>9.1.4 内部类中使用枚举</h4><p>枚举类可以声明在内部类中：</p>
<pre><code class="java">public class Test &#123;
    enum Color &#123;
        RED, GREEN, BLUE;
    &#125;
 
    // 执行输出结果
    public static void main(String[] args) &#123;
        Color c1 = Color.RED;
        System.out.println(c1); //输出为RED
    &#125;
&#125;
</code></pre>
<p><strong>每个枚举都是通过 Class 在内部实现的</strong>，且所有的<strong>枚举值都是 public static final</strong> 的。</p>
<p>以上的枚举类 Color 转化在内部类实现：</p>
<pre><code class="java">class Color &#123;
     public static final Color RED = new Color();
     public static final Color BLUE = new Color();
     public static final Color GREEN = new Color();
&#125;
</code></pre>
<h4 id="9-1-5-迭代枚举元素"><a href="#9-1-5-迭代枚举元素" class="headerlink" title="9.1.5 迭代枚举元素"></a>9.1.5 迭代枚举元素</h4><p>可以使用for语句来迭代枚举元素：</p>
<pre><code class="java">enum Color &#123;
    RED, GREEN, BLUE;
&#125;
public class MyClass &#123;
  public static void main(String[] args) &#123;
    for (Color myVar : Color.values()) &#123;
      System.out.println(myVar);
    &#125;
  &#125;
&#125;
</code></pre>
<h4 id="9-1-6-在switch中使用枚举类"><a href="#9-1-6-在switch中使用枚举类" class="headerlink" title="9.1.6 在switch中使用枚举类"></a>9.1.6 在switch中使用枚举类</h4><p>枚举类常运用于switch语句中：</p>
<pre><code class="java">enum Color &#123;
    RED, GREEN, BLUE;
&#125;
public class MyClass &#123;
  public static void main(String[] args) &#123;
    Color myVar = Color.BLUE;
    switch(myVar) &#123;
      case RED:
        System.out.println(&quot;红色&quot;);
        break;
      case GREEN:
         System.out.println(&quot;绿色&quot;);
        break;
      case BLUE:
        System.out.println(&quot;蓝色&quot;);
        break;
    &#125;
  &#125;
&#125;
</code></pre>
<h3 id="9-2-注解-Annotation"><a href="#9-2-注解-Annotation" class="headerlink" title="9.2 注解(Annotation)"></a>9.2 注解(Annotation)</h3><p><strong>从JDK5.0开始</strong>，Java增加了对元数据(MetaData)的支持，也就是Annotation(注解)</p>
<p>Annotation其实就是代码里的<strong>特殊标记</strong>，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署</p>
<p>Annotation可以像修饰符一样被使用，<strong>可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明</strong>，这些信息被保存在Annotation的“name=value”对中</p>
<p>JavaSE中，注解的使用目的比较简单，例如<strong>标记过时的功能，忽略警告等</strong>。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，<strong>代替JavaEE旧版中所遗留的繁冗代码和XML配置等</strong></p>
<p>未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，<strong>一定程度上可以说：框架=注解＋反射＋设计模式</strong></p>
<h4 id="9-2-1-常见的Annotation示例"><a href="#9-2-1-常见的Annotation示例" class="headerlink" title="9.2.1 常见的Annotation示例"></a>9.2.1 常见的Annotation示例</h4><p>使用Annotation时要在其前面增加**@**符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素</p>
<h5 id="示例一：生成文档相关的注解"><a href="#示例一：生成文档相关的注解" class="headerlink" title="示例一：生成文档相关的注解"></a>示例一：生成文档相关的注解</h5><p><code>@author</code> <strong>标明开发该类模块的作者</strong>，多个作者之间使用”,”分割</p>
<p><code>@version</code> 标明该类模块的<strong>版本</strong></p>
<p><code>@see </code><strong>参考转向</strong>，也就是相关主题</p>
<p><code>@since</code> 从<strong>哪个版本开始增加</strong>的</p>
<p><code>@param</code> 对方法中<strong>某参数的说明</strong>，如果<strong>没有参数就不能写</strong></p>
<p><code>@return</code> 对<strong>方法返回值的说明</strong>，如果方法的返回值类型是<strong>void就不能写</strong></p>
<p><code>@exception</code> 对方法<strong>可能抛出的异常进行说明</strong>，如果方法<strong>没有用throws显式抛出的异常就不能写</strong></p>
<p>其中@param、@return和@exception这三个标记都是<strong>只用于方法</strong>的</p>
<p>@param的格式要求：<code>@param 形参名 形参类型 形参说明</code></p>
<p>@return的格式要求：<code>@return 返回值类型 返回值说明</code></p>
<p>@exception的格式要求：<code>@exception 异常类型 异常说明</code></p>
<p>@param和@exception<strong>可以并列多个</strong></p>
<h5 id="示例二：在编译时进行格式检查-JDK内置的三个基本注解"><a href="#示例二：在编译时进行格式检查-JDK内置的三个基本注解" class="headerlink" title="示例二：在编译时进行格式检查(JDK内置的三个基本注解)"></a>示例二：在编译时进行格式检查(JDK内置的三个基本注解)</h5><p><code>@Override</code> <strong>限定重写父类方法</strong>，该注解<strong>只能用于方法</strong></p>
<p><code>@Deprecated</code> 用于表示<strong>所修饰的元素(类，方法等)已过时</strong>。通常是因为所修饰的结构危险或存在更好的选择</p>
<p><code>@suppressWarnings</code> <strong>抑制编译器警告</strong></p>
<h5 id="示例三：跟踪代码依赖性，实现替代配置文件功能"><a href="#示例三：跟踪代码依赖性，实现替代配置文件功能" class="headerlink" title="示例三：跟踪代码依赖性，实现替代配置文件功能"></a>示例三：跟踪代码依赖性，实现替代配置文件功能</h5><p><code>@WebServlet</code> <strong>Servlet3.0</strong>提供了注解(annotation)，使得<strong>不再需要在web.xml文件中进行Servlet的部署</strong></p>
<p><code>@Transactional</code> <strong>spring框架中关于“事务”的管理</strong></p>
<h5 id="示例四：Junit单元测试中的注解"><a href="#示例四：Junit单元测试中的注解" class="headerlink" title="示例四：Junit单元测试中的注解"></a>示例四：Junit单元测试中的注解</h5><p>Junit<strong>单元测试</strong>中也有大量注解的使用。简单罗列到下面，这里不再赘述<br><code>@Test</code> 标记在<strong>非静态的测试方法</strong>上。只有<strong>标记@Test的方法才能被作为一个测试方法单独测试</strong>。<strong>一个类中可以有多个@Test标记的方法</strong>，运行时如果只想运行共中一个@Test标记的方法，那么<strong>选择这个方法名，然后单独运行</strong>，否则整个类的所有标记了@Test的方法都会被执行</p>
<ul>
<li>@Test(timeout=1000)：设置超时时间，如果<strong>测试时间超过了你定义的timeout，测试失败</strong></li>
<li>@Test(expected)：<strong>申明出会发生的异常</strong>，比如@Test ( expected = Exception.class )</li>
</ul>
<p><strong>了解:</strong></p>
<p><code>@BeforeClass</code> 标记在<strong>静态方法上</strong>。因为这个方法只执行一次。在<strong>类初始化时执行</strong></p>
<p><code>@AfterClass</code> 标记在<strong>静态方法上</strong>。因为这个方法只执行一次。在<strong>所有方法完成后执行</strong></p>
<p><code>@Before</code> 标记在<strong>非静态方法上</strong>。在@Test方法前面执行，而且是<strong>在每一个@Test方法前面都执行</strong></p>
<p><code>@After</code> 标记在<strong>非静态方法上</strong>。在@Test方法后面执行，而且是<strong>在每一个@Test方法后面都执行</strong></p>
<p><code>@Ignore</code> 标记在<strong>本次不参与测试的方法上</strong>。这个注解的含义就是”<strong>某些方法尚未完成，暂不参与此次测试</strong>“</p>
<p>@BeforeClass、@AfterClass、@Before、@After、@Ignore都是配合@Test它使用的，<strong>单独使用没有意义</strong></p>
<h4 id="9-2-2-自定义注解"><a href="#9-2-2-自定义注解" class="headerlink" title="9.2.2 自定义注解"></a>9.2.2 自定义注解</h4><p>①注解声明为<code>@interface</code>，并且都会指明两个元注解（Retention、Target）</p>
<p>②自定义注解<strong>自动继承了java.lang.annotation.Annotation接口</strong></p>
<p>③Annotation的<strong>成员变量在 Annotation定义中以无参数方法的形式来声明</strong>。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。<strong>类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型以上所有类型的数组</strong></p>
<p>④可以在定义 Annotation的成员变量时为其指定初始值，指定成员变量的<strong>初始值可使用default关键字</strong></p>
<p>⑤如果<strong>只有一个参数成员，建议使用参数名为value</strong></p>
<p>⑥如果定义的注解<strong>含有配置参数，那么使用时必须指定参数值</strong>，除非它有默认值。<strong>格式是“参数名=参数值”</strong>，如果<strong>只有一个参数成员，且名称为value，可以省略“value=”</strong></p>
<p>⑦<strong>没有成员定义的Annotation称为标记；包含成员变量的 Annotation称为元数据Annotation</strong></p>
<p>注意：<strong>自定义注解必须配上注解的信息处理流程才有意义</strong></p>
<pre><code class="java">public @interface MyAnnotation &#123;
    //自定义注解：以@suppressWarnings为例
    String value() default &quot;hello&quot;;
&#125;
@MyAnnotation(value = &quot;hi&quot;)
class Test&#123;

&#125;
</code></pre>
<h4 id="9-2-3-JDK中的元注解"><a href="#9-2-3-JDK中的元注解" class="headerlink" title="9.2.3 JDK中的元注解"></a>9.2.3 JDK中的元注解</h4><p>JDK的元Annotation用于<strong>修饰其他Annotation定义</strong>，即对现有的注解进行解释说明的注解</p>
<p>JDK5.0提供了4个标准的meta-annotation类型， 分别是：</p>
<ul>
<li>Retention：<strong>指定该Annotation的生命周期</strong>，只有声明为RUNTIME的注解才能通过反射获取</li>
<li>Target：<strong>指定被修饰的Annotation能用于修饰哪些程序元素</strong></li>
<li>Documented：<strong>指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档</strong></li>
<li>Inherited：<strong>被它修饰的Annotation将具有继承性</strong></li>
</ul>
<h5 id="1-Retention"><a href="#1-Retention" class="headerlink" title="1.Retention"></a>1.Retention</h5><p>@Retention：只能用于修饰一个Annotation定义，用于<strong>指定该Annotation的生命周期</strong>，@Rentention包含一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值：</p>
<ul>
<li><strong>RetentionPolicy.SOURCE</strong>：在<strong>源文件中有效</strong>(即源文件保留)，<strong>编译器直接丢弃</strong>这种策略的注释</li>
<li><strong>RetentionPolicy.CLASS</strong>：在<strong>class文件中有效</strong>(即class保留)，当<strong>运行 Java程序时，JVM不会保留注解</strong>。这是默认值</li>
<li><strong>RetentionPolicy.RUNTIME</strong>：在<strong>运行时有效</strong>(即运行时保留)，当<strong>运行 Java程序时, JVM会保留注释</strong>。程序可<strong>以通过反射获取该注释</strong></li>
</ul>
<h5 id="2-Target"><a href="#2-Target" class="headerlink" title="2.Target"></a>2.Target</h5><p>@Target：用于修饰Annotation定义，用于<strong>指定被修饰的Annotation能用于修饰哪些程序元素</strong>。</p>
<p>@Target也包含一个名为value的成员变量：</p>
<ul>
<li>CONSTRUCTOR ：用于<strong>描述构造器</strong></li>
<li>FIELD：用于<strong>描述域</strong></li>
<li>LOCAL_VARIABLE：用于<strong>描述局部变量</strong></li>
<li>METHOD：用于<strong>描述方法</strong></li>
<li>PACKAGE：用于<strong>描述包</strong></li>
<li>PARAMETER：用于<strong>描述参数</strong></li>
<li>TYPE：用于<strong>描述类、接口(包括注解类型)或enum声明</strong></li>
</ul>
<h5 id="3-Documented"><a href="#3-Documented" class="headerlink" title="3.Documented"></a>3.Documented</h5><p>@Documented：用于<strong>指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档</strong>。默认情况下，javadoc 是不包括注解的</p>
<ul>
<li><strong>定义为Documented的注解必须设置Retention值为RUNTIME</strong></li>
</ul>
<h5 id="4-Inherited"><a href="#4-Inherited" class="headerlink" title="4.Inherited"></a>4.Inherited</h5><p>@Inherited：<strong>被它修饰的Annotation将具有继承性</strong>。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解</p>
<ul>
<li>比如：如果<strong>把标有@Inherited注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解</strong></li>
<li>实际应用中，使用较少</li>
</ul>
<h4 id="9-2-4-JDK8中注解的新特性"><a href="#9-2-4-JDK8中注解的新特性" class="headerlink" title="9.2.4 JDK8中注解的新特性"></a>9.2.4 JDK8中注解的新特性</h4><h5 id="1-可重复注解"><a href="#1-可重复注解" class="headerlink" title="1.可重复注解"></a>1.可重复注解</h5><pre><code class="java">//JDK8及以后：
//①在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class
//②MyAnotation的Target和Retention要与MyAnnotations相同
@Repeatable(value = MyAnnotations.class)
@Target(&#123;ElementType.TYPE,ElementType.PARAMETER,ElementType.FIELD,ElementType.METHOD,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE&#125;)
@Retention(RetentionPolicy.RUNTIME)
public @interface MyAnnotation &#123;
    String value();
&#125;
@Target(&#123;ElementType.TYPE,ElementType.PARAMETER,ElementType.FIELD,ElementType.METHOD,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE&#125;)
@Retention(RetentionPolicy.RUNTIME)
pubilc @interface MyAnnotations &#123;
    MyAnnotation[] value();
&#125;
//可重复注解JDK8之前的写法:新建一个容器注解来保存这多个相同类型的注解
//@MyAnnotations(&#123;@MyAnnotation(value = &quot;hi&quot;),@MyAnnotation(value = &quot;hello&quot;)&#125;)
@MyAnnotation(value = &quot;hello&quot;)
@MyAnnotation(value = &quot;hi&quot;)
public class AnnotationTest&#123;
&#125;
</code></pre>
<h5 id="2-类型注解"><a href="#2-类型注解" class="headerlink" title="2.类型注解"></a>2.类型注解</h5><p>JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_ PARAMETER，TYPE_ USE</p>
<p>在Java8之前，注解只能是在声明的地方所使用，<strong>Java8开始，注解可以应用在任何地方</strong></p>
<ul>
<li>ElementType.TYPE_PARAMETER表示<strong>该注解能写在类型变量的声明语句中</strong>(如：泛型声明)</li>
<li>ElementType.TYPE_USE表示<strong>该注解能写在使用类型的任何语句中</strong></li>
</ul>
<pre><code class="java">@Target(&#123;ElementType.TYPE_PARAMETER,ElementType.TYPE_USE&#125;)
public @interface MyAnnotation1 &#123;
&#125;

class Generic&lt;@MyAnnotation1 T&gt;&#123;
    public void show()&#123;
        ArrayList&lt;@MyAnnotation1 String&gt; list = new ArrayList&lt;&gt;();
        int num = (@MyAnnotation1 int)10L;
    &#125;
&#125;
</code></pre>
<h2 id="十、Java集合"><a href="#十、Java集合" class="headerlink" title="十、Java集合"></a>十、Java集合</h2><h3 id="10-1-Java结合框架概述"><a href="#10-1-Java结合框架概述" class="headerlink" title="10.1 Java结合框架概述"></a>10.1 Java结合框架概述</h3><p>一方面，面向对象语言对事物的体现都是以对象的形式，为了方便<strong>对多个对象的操作</strong>，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合可以<strong>动态地把多个对象的引用放入容器中</strong></p>
<p>集合、数组都是<strong>对多个数据进行存储操作</strong>的结构，简称Java容器（此时的存储主要<strong>指内存层面的存储</strong>，不涉及到持久化的存储）</p>
<ul>
<li>数组在内存存储方面的特点：<ul>
<li>数组初始化以后，长度就确定了（<strong>长度确定</strong>）</li>
<li>数组声明的类型，就决定了进行元素初始化时的类型（<strong>元素类型确定</strong>）</li>
</ul>
</li>
<li>数组在存储数据方面的弊端：<ul>
<li>数组初始化以后，<strong>长度就不可变了，不便于扩展</strong></li>
<li>数组中提供的属性和方法少，<strong>不便于进行添加、删除、插入等操作，且效率不高</strong>。同时<strong>无法直接获取存储元素的个数</strong></li>
<li>数组存储的<strong>数据是有序的、可以重复</strong>的。—&gt;存储数据的特点单一</li>
</ul>
</li>
</ul>
<p>Java集合类可以用于<strong>存储数量不等的多个对象</strong>，还可用于<strong>保存具有映射关系的关联数组</strong></p>
<h4 id="10-1-1-集合框架的使用场景"><a href="#10-1-1-集合框架的使用场景" class="headerlink" title="10.1.1 集合框架的使用场景"></a>10.1.1 集合框架的使用场景</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639409.png' data-fancybox='default' data-caption='image-20210802145115189'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639409.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639409.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210802145115189"></a><span class='image-caption'>image-20210802145115189</span></div></div>

<h4 id="10-1-2-Java集合可分为Collection和Map两种体系"><a href="#10-1-2-Java集合可分为Collection和Map两种体系" class="headerlink" title="10.1.2 Java集合可分为Collection和Map两种体系"></a>10.1.2 Java集合可分为Collection和Map两种体系</h4><ul>
<li>Collection接口：<strong>单列数据</strong>，定义了存取一组对象的方法的集合<ul>
<li>List：<strong>元素有序、可重复</strong>的集合  —&gt;”动态”数组<ul>
<li>实现类：ArrayList、LinkedList、Vector</li>
</ul>
</li>
<li>Set：<strong>元素无序、不可重复</strong>的集合  —&gt;高中学的”集合”<ul>
<li>实现类：HashSet、LinkedHashSet、TreeSet</li>
</ul>
</li>
</ul>
</li>
<li>Map接口：<strong>双列数据</strong>，保存具有映射关系“<strong>key-value对</strong>”的集合 —&gt;高中函数：y=f(x)，<strong>x相当于key，y相当于value</strong>，可以有多个key指向同一个value（<strong>key-&gt;value多对一</strong>），不能有一个key指向多个value（<strong>value-&gt;key一对一</strong>）<ul>
<li>实现类：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties</li>
</ul>
</li>
</ul>
<p><strong>1.Collection接口继承树：</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639220.png' data-fancybox='default' data-caption='image-20210802145632177'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639220.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201639220.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210802145632177"></a><span class='image-caption'>image-20210802145632177</span></div></div>

<p><strong>2.Map接口继承树：</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641823.png' data-fancybox='default' data-caption='image-20210802145827415'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641823.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641823.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210802145827415"></a><span class='image-caption'>image-20210802145827415</span></div></div>

<h3 id="10-2-Collection接口"><a href="#10-2-Collection接口" class="headerlink" title="10.2 Collection接口"></a>10.2 Collection接口</h3><h4 id="10-2-1-Collection接口中常用方法的使用"><a href="#10-2-1-Collection接口中常用方法的使用" class="headerlink" title="10.2.1 Collection接口中常用方法的使用"></a>10.2.1 Collection接口中常用方法的使用</h4><p><strong>添加元素</strong>：add(Object obj)、addAlI(Collection coll)</p>
<p><strong>获取有效元素的个数</strong>：int size()</p>
<p><strong>清空集合</strong>：void clear()</p>
<p><strong>是否是空集合</strong>：boolean isEmpty()</p>
<pre><code class="java">Collection collection = new ArrayList();
//1.add(Object e):将元素e添加到集合collection中
collection.add(&quot;AA&quot;);
collection.add(&quot;AA&quot;);
collection.add(123);//自动装箱
collection.add(new Date());
//2.size():获取添加的元素个数
System.out.println(collection.size());//4
//3.addAll(Collection collection):将collection集合中的元素添加到当前集合中
Collection collection1 = new ArrayList();
collection1.add(456);
collection1.add(&quot;CC&quot;);
collection.addAll(collection1);
System.out.println(collection.size());//6
System.out.println(collection);
//4.clear():清空集合元素
collection.clear();//对象依然存在，只是元素被清空了
//5.isEmpty():判断当前集合是否为空
System.out.println(collection.isEmpty());
</code></pre>
<p><strong>是否包含某个元素</strong>：</p>
<ul>
<li>boolean contains(Object obj)：是通过<strong>元素的equals方法来判断</strong>是否是同一个对象</li>
<li>boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素<strong>挨个比较</strong></li>
</ul>
<pre><code class="java">//6.contains(Object obj):判断当前集合是否包含obj
//在判断时会调用obj对象所在类的equals()方法，如果所在类没有重写equals()，则会调用Object类的equals()比较两个对象的引用地址，所以，如果我们要比较两个对象的内容，必须重写equals()
Collection collection = new ArrayList();
collection.add(123);
collection.add(456);
collection.add(false);
collection.add(new String(&quot;Jerry&quot;));
collection.add(new Person(&quot;Tom&quot;,20));
//Person p = new Person(&quot;Tom&quot;, 20);
//collection.add(p);
//System.out.println(collection.contains(p));//true
boolean contains = collection.contains(123);
System.out.println(contains);//true
System.out.println(collection.contains(new String(&quot;Jerry&quot;)));//true，因为String类重写了equals方法，所以这里比较的是内容
System.out.println(collection.contains(new Person(&quot;Tom&quot;, 20)));//false，因为我们的自定义类Person没有重写equals方法，所以是相当于用“==”比较的地址值

//7.containsAll(Collection collection):判断形参collection中的所有元素是否都存在于当前集合中
Collection collection1 = Arrays.asList(123,456);//返回一个List，也是一种创建集合的方式
System.out.println(collection.containsAll(collection1));//true
</code></pre>
<p><strong>删除元素：</strong></p>
<ul>
<li>boolean remove(Object obj)：通过元素所属类的<strong>equals方法判断是否是要删除的那个元素</strong>。只会<strong>删除找到的第一个元素</strong></li>
<li>boolean removeAll(Collection coll)：<strong>取当前集合的差集</strong></li>
</ul>
<pre><code class="java"> //8.remove(Object obj):从当前集合移除obj元素，返回true、false,移除元素后的集合仍保存在当前集合
 Collection collection = new ArrayList();
 collection.add(123);
 collection.add(456);
 collection.add(false);
 collection.add(new String(&quot;Jerry&quot;));
 collection.add(new Person(&quot;Tom&quot;,20));
boolean remove = collection.remove(123);
System.out.println(remove);//true
System.out.println(collection);//[456, false, Jerry, Collection.Person@4ee285c6]

//9.removeAll(Collection collection):从当前集合中移除collection中的所有元素
Collection collection1 = Arrays.asList(123,456);
collection.removeAll(collection1);
System.out.println(collection);//[false, Jerry, Collection.Person@4ee285c6]
</code></pre>
<p><strong>取两个集合的交集：</strong>boolean retainAll(Collection c)：把交集的结果存在当前集合中，<strong>不影响c</strong></p>
<p><strong>集合是否相等：</strong>boolean equals(Object obj)：如果两个<strong>List</strong>(有序)集合中的元素内容一样，顺序不一样，则会返回false(List的情况)；如果是<strong>Set</strong>(无序)集合，顺序不一样内容一样仍为true</p>
<pre><code class="java">//10.retainAll(Collection collection):获取当前集合和collection的交集，并将交集保留在当前集合
Collection collection = new ArrayList();
collection.add(123);
collection.add(456);
collection.add(false);
collection.add(new String(&quot;Jerry&quot;));
collection.add(new Person(&quot;Tom&quot;,20));
Collection collection1 = Arrays.asList(123,456);
collection.retainAll(collection1);
System.out.println(collection);//[123, 456]
System.out.println(collection1);//[123, 456]

//11.equals():判断当前集合与collection是否相等（比较内容）
System.out.println(collection.equals(collection1));//true，因为上方用retainAll取了这两个集合的交集。保存在collection中，而collection1不变，所以这里比较就返回true
</code></pre>
<p><strong>转成对象数组：</strong>Object[] toArray()</p>
<p><strong>获取集合对象的哈希值：</strong>hashCode()</p>
<pre><code class="java">Collection collection = new ArrayList();
collection.add(123);
collection.add(456);
collection.add(false);
collection.add(new String(&quot;Jerry&quot;));
collection.add(new Person(&quot;Tom&quot;,20));

//12.HashCode():返回当前对象的Hash值
System.out.println(collection.hashCode());

//13.toArray():集合  --&gt;  数组
Object[] objects = collection.toArray();
for (int i = 0; i &lt; objects.length; i++) &#123;
System.out.println(objects[i]);
&#125;
//扩展:数组  --&gt;  集合:调用Arrays类的静态方法asList()
List&lt;String&gt; strings = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;);
System.out.println(strings);
List&lt;int[]&gt; ints = Arrays.asList(new int[]&#123;123, 456&#125;);
System.out.println(ints.size());//1，因为int是一个基本数据类型，集合中只能是引用类型，如果用基本数据类型这儿会把它认为是一个元素，而下方使用包装类数据建立的集合就是两个元素
List&lt;Integer&gt; integers = Arrays.asList(new Integer[]&#123;123, 456&#125;);
System.out.println(integers.size());//2
</code></pre>
<p><strong>遍历：</strong>iterator()：返回<strong>迭代器对象，用于集合遍历</strong>，内部方法：hasNext()，next()，remove()</p>
<p>Iterator对象称为迭代器(设计模式的一种)，主要<strong>用于遍历Collection集合中的元素</strong></p>
<p>GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是<strong>为容器而生</strong></p>
<p>Collection接口继承了java.lang.lterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个<strong>iterator()方法， 用以返回一个实现了iterator接口的对象</strong></p>
<p>Iterator<strong>仅用于遍历集合</strong>，Iterator 本身并<strong>不提供承装对象的能力</strong>。如果需要<strong>创建terator对象，则必须有一个被迭代的集合</strong></p>
<p>集合对象<strong>每次调用</strong>iterator()方法都<strong>得到一个全新的迭代器对象</strong>，默认游标都在集合的<strong>第一个元素之前</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641040.png' data-fancybox='default' data-caption='image-20210803100049690'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641040.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641040.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210803100049690"></a><span class='image-caption'>image-20210803100049690</span></div></div>

<pre><code class="java">//集合元素的遍历操作，使用迭代器Iterator接口
Collection collection = new ArrayList();
collection.add(123);
collection.add(456);
collection.add(false);
collection.add(new String(&quot;Jerry&quot;));
collection.add(new Person(&quot;Tom&quot;,20));
Iterator iterator = collection.iterator();
//遍历方式一：
//System.out.println(iterator.next());
//System.out.println(iterator.next());
//System.out.println(iterator.next());
//System.out.println(iterator.next());
//System.out.println(iterator.next());
//System.out.println(iterator.next());//超出集合元素个数范围，抛出NoSuchElementException异常
//遍历方式二：不推荐
for (int i = 0; i &lt; collection.size(); i++) &#123;
    System.out.println(iterator.next());
&#125;
//遍历方式三：推荐
while(iterator.hasNext()) &#123;
    System.out.println(iterator.next());
&#125;

//错误写法一：
Iterator iterator = collection.iterator();
while(iterator.next() != null) &#123;
    System.out.println(iterator.next());//隔空遍历输出，判断时迭代器指针往下移，输出时又往下移，所以造成隔空输出
&#125;
//错误写法二：
while(collection.iterator().hasNext())&#123;
    System.out.println(collection.iterator().next());//每次都是输出123，因为每次调用iterator()都会返回一个新的迭代器对象，所以每次都是在遍历第一个元素
&#125;

//迭代器移除元素：remove()
while(iterator.hasNext())&#123;
    Object obj = iterator.next();
    if(obj.equals(&quot;Jerry&quot;))&#123;
         iterator.remove();   
    &#125;
&#125;
//注意：Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法
//如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllgalStateException
</code></pre>
<p><strong>JDK5新增了一个增强for循环foreach，用于遍历集合和数组</strong></p>
<pre><code class="java">Collection collection = new ArrayList();
collection.add(123);
collection.add(456);
collection.add(false);
collection.add(new String(&quot;Jerry&quot;));
collection.add(new Person(&quot;Tom&quot;,20));
//集合中元素的类型  局部变量 : 需要遍历的集合或数组对象
//内部仍是使用迭代器
for(Object obj : collection)&#123;
    System.out.println(obj);
&#125;
</code></pre>
<h4 id="10-2-2-Collection的子接口List"><a href="#10-2-2-Collection的子接口List" class="headerlink" title="10.2.2 Collection的子接口List"></a>10.2.2 Collection的子接口List</h4><p>鉴于Java中数组用来存储数据的局限性，我们通常使用<strong>List替代数组</strong></p>
<p>List集合类中<strong>元素有序、且可重复</strong>，集合中的每个元素都有其对应的顺序索引</p>
<p>List容器中的<strong>元素都对应一个整数型的序号</strong>记载其在容器中的位置，可以<strong>根据字号存取容器中的元素</strong></p>
<p>JDK API中List接口的<strong>实现类</strong>常用的有: <strong>ArrayList、 LinkedList和Vector</strong>（list的古老实现类）</p>
<pre><code class="java">面试题：ArrayList、LinkedList、Vector三者的异同？
同：三个类都实现List接口，存储数据的特点：存储有序、可重复的数据；ArrayList和Vector底层使用Object[]存储，LinkedList使用双向链表
异：
|--ArrayList：作为list接口的主要实现类，使用最多；线程不安全，效率高；对于数据的查询效率高，但频繁的插入和删除效率低；底层数组扩容一次为1.5倍
|--LinkedList：线程不安全，效率高；对于频繁的插入、删除操作效率高，但查询效率低；底层使用双向链表存储
|--Vector：作为list接口的古老实现类；线程安全，效率低；底层数组扩容一次2倍
</code></pre>
<h5 id="1-ArrayList类"><a href="#1-ArrayList类" class="headerlink" title="1.ArrayList类"></a>1.ArrayList类</h5><p>ArrayList是List接口的典型实现类、主要实现类</p>
<p>本质上，ArrayList是对象引用的一个”变长”数组</p>
<p>ArrayList的JDK1.8之前与之后的实现区别?</p>
<ul>
<li>JDK1.7：ArrayList像饿汉式，<strong>直接创建一个初始容量为10的数组</strong></li>
<li>JDK1.8：ArrayList像懒汉式，<strong>一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组</strong></li>
</ul>
<p>Arrays.asList(…)方法<strong>返回的List集合</strong>，既不是ArrayList实例，也不是Vector 实例。Arrays.asList(…)返回值<strong>是一个固定长度的List集合</strong></p>
<h6 id="源码分析：JDK7"><a href="#源码分析：JDK7" class="headerlink" title="源码分析：JDK7"></a>源码分析：JDK7</h6><pre><code class="java">底层存储数据：Object[] elementData
ArrayList list = new ArrayList();//底层创建一个初始长度为10的Object数组
//无参构造器源码
public ArrayList() &#123;
    this(10);//调用有参构造器，传入容量值为10，直接创建this.elementData = new Object[10];
&#125;
//add()方法
public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  // 判断是否超出list范围，若超出则会调用扩容的方法grow，grow的内容可参考下方JDK8中的grow方法
    elementData[size++] = e;//将数据e添加到扩容后的list
    return true;
&#125;
List.add(123);//elementData[0] = new Integer(123);
...
list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容
默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中
结论:建议开发中使用带参的构造器: ArrayList list = new ArrayList(int capacity)
</code></pre>
<h6 id="源码分析：JDK8中ArrayList的变化"><a href="#源码分析：JDK8中ArrayList的变化" class="headerlink" title="源码分析：JDK8中ArrayList的变化"></a>源码分析：JDK8中ArrayList的变化</h6><pre><code class="java">底层存储数据：仍为Object[] elementData
ArrayList list = new ArrayList();//底层object[] eLementData初始化为&#123;&#125;，并没有创建长度为10的Object数组
//无参构造器源码
public ArrayList() &#123;
    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//DEFAULTCAPACITY_EMPTY_ELEMENTDATA=&#123;&#125;
&#125;
list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData
...
后续的添加和扩容操作与jdk7无异
//add()方法添加数据及调用的一系列方法
public boolean add(E e) &#123;
    ensureCapacityInternal(size + 1);  // 判断是否超出list范围
    elementData[size++] = e;//将数据e添加到扩容后的list
    return true;
&#125;
private void ensureCapacityInternal(int minCapacity) &#123;
    ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));//将calculateCapacity返回的容量值传入
&#125;
private static int calculateCapacity(Object[] elementData, int minCapacity) &#123;
    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;//判断添加的这个数据是否是第一个数据
        return Math.max(DEFAULT_CAPACITY, minCapacity);//如果是则返回Object数组默认容量10和添加这个数据后的数组中需要的容量中更大的那个值，第一次添加其实返回的就是默认容量10
    &#125;
    return minCapacity;
&#125;
private void ensureExplicitCapacity(int minCapacity) &#123;//传入需要的容量值，第一次添加传入的是10
    modCount++;

    // overflow-conscious code
    if (minCapacity - elementData.length &gt; 0)//传入的需要容量的值是否比数组elementData现有长度大
        grow(minCapacity);//如果是，则进行扩容
&#125;
private void grow(int minCapacity) &#123;//传入需要用到的容量10
    // overflow-conscious code
    int oldCapacity = elementData.length;//第一次添加数据，length为0
    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//扩容1.5倍
    if (newCapacity - minCapacity &lt; 0)//若扩容后的容量值还是需要的小
        newCapacity = minCapacity;//则把需要的容量值赋给这个新容量来进行扩容
    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//若扩容后这个需要用到的容量值比Integer.MAX_VALUE-8还大，则调用hugeCapacity()
        newCapacity = hugeCapacity(minCapacity);
    //扩容后将原数组的值复制到扩容过后的数组
    elementData = Arrays.copyOf(elementData, newCapacity);
&#125;
</code></pre>
<p><strong>小结：</strong>jdk7中的ArrayList的对象的创建<strong>类似于单例的饿汉式</strong>，而jdk8中的ArrayList的对象的创建<strong>类似于单例的懒汉式</strong>，<strong>延迟了数组的创建，节省内存</strong></p>
<h5 id="2-LinkedList类"><a href="#2-LinkedList类" class="headerlink" title="2.LinkedList类"></a>2.LinkedList类</h5><p>对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高</p>
<p>新增方法：</p>
<ul>
<li>void addFirst(Object obj)</li>
<li>void addLast(Object obj)</li>
<li>Object getFirst()</li>
<li>Object getLast()</li>
<li>Object removeFirst()</li>
<li>Object removeLast()</li>
</ul>
<h6 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h6><pre><code class="java">底层存储数据：双向链表
LinkedList linkedList = new LinkedList();//内部声明了Node类型的first和last属性，默认值为null
last.add(123);//将123封装在Node中，创建了Node对象
其中，Node定义为：
private static class Node&lt;E&gt; &#123;
    E item;//要添加的数据本身
    Node&lt;E&gt; next;//该结点需要指向的下一个结点的地址值
    Node&lt;E&gt; prev;//该结点需要指向的上一个结点的地址值

    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;
    this.item = element;
    this.next = next;
    this.prev = prev;
    &#125;
&#125;
添加数据时调用的`add()`方法中调用的方法(尾插)：
void linkLast(E e) &#123;
    final Node&lt;E&gt; l = last;//将l和last指向同一个结点
    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建一个新结点，保存新数据，再把新结点的prev指向添加新结点前的最后一个结点
    last = newNode;//将新结点作为该链表的最后一个结点
    if (l == null)//判断新添加的结点是否是这个链表的第一个结点
        first = newNode;//如果是，就让first指向新结点
    else
        l.next = newNode;//如果不是，则让添加新结点前的最后一个结点的next指向新结点
    size++;//链表数据数量加1
    modCount++;
&#125;
</code></pre>
<h5 id="3-Vector类"><a href="#3-Vector类" class="headerlink" title="3.Vector类"></a>3.Vector类</h5><h6 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h6><pre><code class="java">jdk7和jdk8中通过`Vector()`构造器创建对象时，底层都创建了长度为10的数在扩容方面，默认扩容为原来的数组长度的2倍
该类已经不用了，尽管线程安全，但是现有Collections工具类也能把ArrayList变成线程安全的，所以仍用ArrayList替代Vector
</code></pre>
<h5 id="4-List接口中的常用方法"><a href="#4-List接口中的常用方法" class="headerlink" title="4.List接口中的常用方法"></a>4.List接口中的常用方法</h5><p>List除了从Collection集合继承的方法外，List集合里添加了一些<strong>根据索引来操作集合元素的方法</strong></p>
<ul>
<li>void add(int index，Object ele)：在<strong>index位置插入ele元素</strong></li>
<li>boolean addAll(int index，Collection eles)：<strong>从index位置开始将eles中的所有元素添加进来</strong></li>
<li>Object get(int index)：<strong>获取指定index位置的元素</strong></li>
<li>int indexOf(Object obj)：返回<strong>obj在集合中首次出现的位置</strong></li>
<li>int lastIndexOf(Object obj)：返回<strong>obj在当前集合中末次出现的位置</strong></li>
<li>Object remove(int index)：<strong>移除指定index位置的元素</strong>，并<strong>返回此元素</strong></li>
<li>Object set(int index，Object ele)：<strong>设置指定index位置的元素为ele</strong></li>
<li>List subList(int fromIndex，int tolndex)：<strong>返回从fromIndex到tolndex位置的子集合</strong></li>
</ul>
<pre><code class="java">ArrayList arrayList = new ArrayList();
arrayList.add(123);
arrayList.add(456);
arrayList.add(&quot;AA&quot;);
arrayList.add(new Person(&quot;Tom&quot;,20));
arrayList.add(456);
System.out.println(arrayList);//[123, 456, AA, Collection.Person@4ee285c6, 456]
//1.void add(int index，Object ele)：在index位置插入ele元素
arrayList.add(1,&quot;BB&quot;);
System.out.println(arrayList);//[123, BB, 456, AA, Collection.Person@4ee285c6, 456]
//2.boolean addAll(int index，Collection eles)：从index位置开始将eles中的所有元素添加进来
List list = Arrays.asList(1,2,3);
arrayList.addAll(1,list);
System.out.println(arrayList);//[123, 1, 2, 3, BB, 456, AA, Collection.Person@4ee285c6, 456]
//3.Object get(int index)：获取指定index位置的元素
System.out.println(arrayList.get(4));//BB
//4.int indexOf(Object obj)：返回obj在集合中首次出现的位置
System.out.println(arrayList.indexOf(456));//5
//5.int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置
System.out.println(arrayList.lastIndexOf(456));//8
//6.Object remove(int index)：移除指定index位置的元素，并返回此元素
Object remove = arrayList.remove(8);
System.out.println(arrayList);//[123, 1, 2, 3, BB, 456, AA, Collection.Person@4ee285c6]
System.out.println(remove);//456
//7.Object set(int index，Object ele)：设置指定index位置的元素为ele
arrayList.set(5,4567);
System.out.println(arrayList);//[123, 1, 2, 3, BB, 4567, AA, Collection.Person@4ee285c6]
//8.List subList(int fromIndex，int tolndex)：返回从fromIndex到tolndex位置的左闭右开区间的子集合
List list1 = arrayList.subList(3,6);
System.out.println(list1);//[3, BB, 4567]
System.out.println(arrayList);//[123, 1, 2, 3, BB, 4567, AA, Collection.Person@4ee285c6]，原list没变
</code></pre>
<h5 id="5-List的一道面试笔试题"><a href="#5-List的一道面试笔试题" class="headerlink" title="5.List的一道面试笔试题"></a>5.List的一道面试笔试题</h5><pre><code class="java">@Test
public void test1() &#123;
    //区分List中remove(int index)和remove(0bject obj)
    List list = new ArrayList();
    list.add(1);
    list.add(2);
    list.add(3);
    updateList(list);
    System.out.println(list);
&#125;
private void updateList(List list)&#123;
    //list.remove(2);//移除索引为2的元素
    list.remove(new Integer(2));//移除值为2的元素
&#125;
</code></pre>
<h4 id="10-2-3-Collection子接口Set"><a href="#10-2-3-Collection子接口Set" class="headerlink" title="10.2.3 Collection子接口Set"></a>10.2.3 Collection子接口Set</h4><p>Set接口是Collection的子接口，set接口<strong>没有提供额外的方法</strong>（即Set中使用的都是Collection接口中声明过的方法）</p>
<p>Set集合<strong>不允许包含相同的元素</strong>，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败</p>
<p><strong>（HashSet和LinkedHashSet）判断两个对象是否相同不是使用==运算符，而是根据equals()方法和hashCode()方法</strong>，所以<strong>添加的数据所在类一定要重写equals()和hashCode()方法</strong>，<strong>而（TreeSet）判断对象是否相同通过Comparable接口和Comparator接口</strong></p>
<pre><code class="java">|--Set接口:存储无序的、不可重复的数据--&gt; 高中讲的“集合”
    |--HashSet:作为Set接口的主要实现类;线程不安全的;可以存储null值
        |--LinkedHashSet:作为HashSet的子类; 遍历其内部数据时，可以按照添加的顺序遍历;
            在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据
            对于频繁的遍历操作，LinkedHashSet 效率高于HashSet
    |--TreeSet:可以按照添加对象的指定属性，进行排序
</code></pre>
<p><strong>Set的无序性和不重复性的理解</strong></p>
<pre><code class="java">/*
    Set:存储无序、不可重复的数据
    以HashSet为例说明：
    1、无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序进行添加，而是根据数据的Hash值确定
    2、不可重复性：保证添加的元素按照equals()判断时，不能返回true。即:相同的元素只能添加一个
*/
Set set = new HashSet();
set.add(456);
set.add(123);
set.add(123);
set.add(&quot;AA&quot;);
set.add(&quot;CC&quot;);
set.add(new User(&quot;Tom&quot;,20));
set.add(new User(&quot;Tom&quot;,20));
set.add(129);
Iterator iterator = set.iterator();
while(iterator.hasNext())&#123;
    System.out.println(iterator.next());//AA CC 129 User&#123;name=&#39;Tom&#39;, age=20&#125; 456 123
&#125;
</code></pre>
<h5 id="1-HashSet类"><a href="#1-HashSet类" class="headerlink" title="1.HashSet类"></a>1.HashSet类</h5><p>HashSet是Set接口的典型实现，<strong>大多数时候使用Set集合时都使用这个实现类</strong></p>
<p>HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能</p>
<p>HashSet具有以下特点：</p>
<ul>
<li><strong>不能保证元素的排列顺序</strong></li>
<li><strong>HashSet不是线程安全的</strong></li>
<li><strong>集合元素可以是null</strong></li>
</ul>
<p>HashSet集合<strong>判断两个元素相等的标准</strong>：两个对象通过<strong>hashCode()方法比较相等</strong>，并且<strong>两个对象的equals()方法返回值也相等</strong></p>
<p>对于<strong>存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法</strong>，以实现对象相等规则。即:“ <strong>相等的对象必须具有相等的散列码</strong>”</p>
<p><strong>重写HashCode()方法的基本原则：</strong></p>
<ul>
<li>在程序运行时，<strong>同一个对象多次调用hashCode()方法应该返回相同的值</strong></li>
<li>当两个对象的<strong>equals()方法比较返回true时</strong>，这两个对象的<strong>hashCode()方法的返回值也应相等</strong></li>
<li><strong>对象中用作equals()方法比较的Field（属性）, 都应该用来计算hashCode值</strong></li>
</ul>
<p><strong>HashSet中元素的添加过程：</strong></p>
<pre><code>HashSet底层：数组+链表
1.我们向HashSet中添加元素a,首先调用元素a所在类的`hashCode()`方法，计算元素a的哈希值，通过此哈希值再由某种算法计算出元素a应该在HashSet底层数组中的存放位置(即为:索引位置)
2.判断数组此位置上是否已经有元素:
    (1)如果此位置上没有其他元素，则元素a直接添加到底层数组的此位置上  --&gt;添加成功的情况1
    (2)如果此位置上已有其他元素b(或以链表形式存在了多个元素)，则比较元素a与元素b(或这些元素)的hash值:
        ①如果hash值不相同，则元素a添加成功  --&gt;添加成功的情况2
        ②如果hash值相同，进而需要调用元素a所在类的equals()方法:
            equals()返回true,元素a添加失败
            equals()返回false,则元素a添加成功  --&gt;添加成功的情况3
3.说明:对于添加成功的情况2和情况3而言:元素a与已经存在在指定索引位置上的数据以链表的方式存储
    jdk7:元素a放到数组中，指向原来的元素
    jdk8:原来的元素在数组中，指向元素d
总结：七上八下（JDK7：新元素以头插法放在所有链表数据前面，即数组中；JDK8：新元素以尾插法放在链表数据后面，即链表尾部）
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641735.png' data-fancybox='default' data-caption='image-20210803204939848'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641735.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201641735.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210803204939848"></a><span class='image-caption'>image-20210803204939848</span></div></div>

<h5 id="2-LinkedHashSet类"><a href="#2-LinkedHashSet类" class="headerlink" title="2.LinkedHashSet类"></a>2.LinkedHashSet类</h5><p><strong>LinkedHashSet是HashSet的子类</strong></p>
<p>LinkedHashSet根据元素的<strong>hashCode值来决定元素的存储位置</strong>，但它同时<strong>使用双向链表维护元素的次序</strong>，这使得元素看起来是以插入顺序保存的</p>
<p><strong>LinkedHashSet插入性能略低于HashSet</strong>, 但<strong>在迭代访问Set里的全部元素时有很好的性能</strong></p>
<p>LinkedHashSet<strong>不允许集合元素重复</strong></p>
<pre><code class="java">//LinkedHashSet的使用
Set set = new LinkedHashSet();
set.add(456);
set.add(new String(&quot;AA&quot;));
set.add(456);
set.add(new User(&quot;Tom&quot;,30));
Iterator iterator = set.iterator();
while(iterator.hasNext())&#123;
    System.out.println(iterator.next());//456 AA User&#123;name=&#39;Tom&#39;, age=30&#125;
&#125;
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642753.png' data-fancybox='default' data-caption='image-20210804101418488'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642753.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642753.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210804101418488"></a><span class='image-caption'>image-20210804101418488</span></div></div>

<h5 id="3-TreeSet类"><a href="#3-TreeSet类" class="headerlink" title="3.TreeSet类"></a>3.TreeSet类</h5><p><strong>TreeSet是SortedSet接口的实现类</strong>，TreeSet可以<strong>确保集合元素处于排序状态</strong></p>
<p>TreeSet<strong>两种排序方法：自然排序(Comparable)和定制排序(Comparator)<strong>。</strong>默认情况下，TreeSet采用自然排序</strong></p>
<p>TreeSet底层<strong>使用红黑树结构存储数据</strong>，向TreeSet中<strong>添加的数据要求必须是相同类的对象</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642570.png' data-fancybox='default' data-caption='image-20210804113159347'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642570.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642570.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210804113159347"></a><span class='image-caption'>image-20210804113159347</span></div></div>

<p><strong>新增的方法</strong>如下：(了解)</p>
<ul>
<li>Comparator comparator()</li>
<li>Object first()</li>
<li>Object last()</li>
<li>Object lower(Object e)</li>
<li>Object higher(Object e)</li>
<li>SortedSet subSet(fromElement, toElement)</li>
<li>SortedSet headSet(toElement)</li>
<li>SortedSet tailSet(fromElement)</li>
</ul>
<p><strong>TreeSet默认情况下添加数据：</strong></p>
<pre><code class="java">默认情况（自然排序）下，TreeSet调用add()添加数据时会调用该数据对象的所属类中的compareTo()方法对这些对象数据进行强制排序，所以向TreeSet中添加的数据其所属类必须要实现Comparable接口，重写compareTo()方法，并在其中指明该类型的对象以哪种方法进行排序
自然排序中，比较两个对象是否相同的标准为: compareTo()返回值为0而不再是equals()和hashCode()的比较结果
TreeSet set = new TreeSet();
//添加失败，TreeSet中不能添加不同类的元素
set.add(456);
set.add(new String(&quot;AA&quot;));
set.add(456);
set.add(new User(&quot;Tom&quot;,30));
//添加成功，举例一：Integer包装类实现了Comparable接口并重写了compareTo()方法，所以添加成功后数据顺序为-34、34、44、65
set.add(34);
set.add(-34);
set.add(44);
set.add(65);
//添加成功，举例二：
set.add(new User(&quot;Tom&quot;,10));
set.add(new User(&quot;Jack&quot;,50));
set.add(new User(&quot;Jerry&quot;,20));
set.add(new User(&quot;Eric&quot;,25));
/*添加成功后数据顺序为：
User&#123;name=&#39;Tom&#39;, age=10&#125;
User&#123;name=&#39;Jerry&#39;, age=20&#125;
User&#123;name=&#39;Jack&#39;, age=50&#125; 
User&#123;name=&#39;Eric&#39;, age=25&#125;
*/
//User类重写的compareTo方法
@Override
public int compareTo(Object o) &#123;
    //先按姓名从大到小排，再按年龄从小到大排
    if(o instanceof User)&#123;
        User user = (User) o;
        //return -this.name.compareTo(user.name);
        int compare = -this.name.compareTo(user.name);
        if(compare != 0)&#123;
            return compare;
        &#125;else&#123;
            return Integer.compare(this.age,user.age);
        &#125;
    &#125;else&#123;
        throw new RuntimeException(&quot;输入的类型不匹配&quot;);
    &#125;
&#125;
</code></pre>
<p><strong>TreeSet定制排序下添加数据：</strong></p>
<pre><code class="java">定制排序情况下，TreeSet调用add()添加数据时会调用`new TreeSet(comparator)`中传入的Comparator实现类对象重写的compare()方法对这些对象数据进行对应的强制排序
定制排序中，比较两个对象是否相同的标准为: compare()返回值为0而不再是equals()和hashCode()的比较结果
Comparator comparator = new Comparator() &#123;
    //只考虑年龄的情况下从小到大排序
    @Override
    public int compare(Object o1, Object o2) &#123;
        if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;
        User user1 = (User) o1;
        User user2 = (User) o2;
        return Integer.compare(user1.getAge(),user2.getAge());
        &#125;
        throw new RuntimeException(&quot;比较的类型不正确&quot;);
    &#125;
&#125;;
TreeSet set = new TreeSet(comparator);
set.add(new User(&quot;Tom&quot;,10));
set.add(new User(&quot;Jack&quot;,50));
set.add(new User(&quot;Jerry&quot;,20));
set.add(new User(&quot;Mary&quot;,20));//年龄相等，但是由于Jerry先被添加到TreeSet中，所以Mary进不能再被添加到其中
set.add(new User(&quot;Eric&quot;,25));
Iterator iterator = set.iterator();
while(iterator.hasNext())&#123;
System.out.println(iterator.next());
&#125;
/*
添加数据后的顺序为：
User&#123;name=&#39;Tom&#39;, age=10&#125;
User&#123;name=&#39;Jerry&#39;, age=20&#125;
User&#123;name=&#39;Eric&#39;, age=25&#125;
User&#123;name=&#39;Jack&#39;, age=50&#125;
*/
</code></pre>
<h5 id="4-Set两道相关面试题"><a href="#4-Set两道相关面试题" class="headerlink" title="4.Set两道相关面试题"></a>4.Set两道相关面试题</h5><pre><code class="java">//练习:在List内去除重复数字值，要求尽量简单
public static List duplicateList(List list) &#123;
    HashSet set = new HashSet( ) ;
    set.addA1l(list);
    return new ArrayList(set);
&#125;
public static void main(String[] args)&#123;
    List list = new ArrayList();
    list.add(new Integer(1));
    list.add(new Integer(2));
    list.add(new Integer(2));
    list.add(new Integer(4));
    list.add(new Integer(4));
    List list2 = duplicatelist(list);
    for (bject integer : list2) &#123;
        System.out.println(integer);
    &#125;
&#125;
</code></pre>
<pre><code class="java">HashSet set = new HashSet();
Person p1 = new Person(1001,&quot;AA&quot;); 
Person p2 = new Person(1002,&quot;BB&quot;);
set.add(p1);
set.add(p2);
System.out.println(set);//1002,&quot;BB&quot;  1001,&quot;AA&quot; //根据重写后的hashCode()计算出对应存储位置添加到set中后

p1.name = &quot;CC&quot;;//修改p1的name属性,此时set中的p1变为1001,&quot;CC&quot;，但其存储的地址是由1001,&quot;AA&quot;经过重写后的hashCode()和equals()得到的
set.remove(p1); //此时的p1为1001,&quot;CC&quot;，则会使用此时的1001,&quot;CC&quot;通过重写后的hashCode()计算得到其在set中对应的位置，显然计算出的位置是不同的，所以移除1001,&quot;CC&quot;失败
System.out.println(set);//1002,&quot;BB&quot;  1001,&quot;CC&quot; 此时&quot;CC&quot;是&quot;AA&quot;被修改后的数据

set.add(new Person(1001,&quot;CC&quot;));//能添加成功，因为能由上方解释得出1001,&quot;CC&quot;和1001,&quot;AA&quot;经由重写后的hashCode()计算出的存储位置是不同的
System.out.println(set);//1002,&quot;BB&quot;  1001,&quot;CC&quot;  1001,&quot;CC&quot;

set.add(new Person(1001,&quot;AA&quot;));//能添加成功，虽然此时新添加的这个1001,&quot;AA&quot;经由重写后的hashCode()计算出的位置和p1相同，但此时会通过equals()判断他们的内容是不是都相等，显然&quot;AA&quot;不等于&quot;CC&quot;，所以这个数据会以链表的形式与p1存储在一起
System.out.println(set);//1002,&quot;BB&quot;  1001,&quot;CC&quot;  1001,&quot;CC&quot;  1001,&quot;AA&quot;
//其中Person类中写了hashCode()和equal()方法
</code></pre>
<h3 id="10-3-Map接口"><a href="#10-3-Map接口" class="headerlink" title="10.3 Map接口"></a>10.3 Map接口</h3><pre><code class="java">|--Map:双列数据,存储key-value对的数据   ---类似于高中的函数: y = f(x)
    |--HashMap:作为Map的主要实现类,使用最多;线程不安全,效率高;能存储null的key-value对;
        HashMap的底层:数组+链表(jdk7及之前)   数组+链表+红黑树(jdk8)
        |--LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历
            原因:在原有的HashMap底层结构基础上添加了一对指针，指向前一个和后一个元素
            对于频繁的遍历操作，此类执行效率高于HashMap
    |-- TreeMap:保证按照添加的key-value对进行排序,实现排序遍历。此时考虑key的自然排序或定制排序
            底层采用红黑树结构存储数据
    |--Hashtable:作为Map的古老实现类;线程安全,效率低;不能存储null的key-value对
        |--Properties:常用来处理配置文件。key和value都是String类型
        
        
面试题:
1. HashMap的底层实现原理?
2. HashMap和Hashtable的异同?
3. CurrentHashMap与Hashtable的异同? (暂时不讲)
4. 谈谈你对HashMap中put/get方法的认识?如果了解再谈谈HashMap的扩容机制?默认大小是多少?什么是负载因子(或填充比)?什么是吞吐临界值(或阈值、threshold)?
</code></pre>
<p><strong>Map结构的理解：</strong></p>
<p>Map中的key：<strong>无序的、不可重复</strong>的，使用Set 存储所有的key —&gt; key所在的类要重写equals()和hashCode() (以HashMap为例)，因为会利用这两个方法<strong>决定key的存储位置</strong></p>
<p>Map中的value：<strong>无序的、可重复</strong>的，使用Collection存储所有的value —&gt;value所在的类要重写equals()，因为以后可能会<strong>涉及到value的比较</strong></p>
<p>一个键值对：<strong>key-value构成了一个Entry对象</strong>，key和value相当于Entry的两个属性</p>
<p>Map中的entry：<strong>无序的、不可重复</strong>的，使用Set存储所有的entry</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642180.png' data-fancybox='default' data-caption='image-20210804175628724'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642180.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201642180.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210804175628724"></a><span class='image-caption'>image-20210804175628724</span></div></div>

<h4 id="10-3-1-Map接口中的常用方法"><a href="#10-3-1-Map接口中的常用方法" class="headerlink" title="10.3.1 Map接口中的常用方法"></a>10.3.1 Map接口中的常用方法</h4><p><strong>添加、删除、修改操作：</strong></p>
<ul>
<li>Object put(Object key,Object value)：将指定<strong>key-value添加到(或修改)当前map对象</strong>中</li>
<li>void putAll(Map m)：将<strong>m中的所有key-value对存放到当前map</strong>中</li>
<li>Object remove(Object key)：<strong>移除指定key的key-value对，并返回value</strong></li>
<li>void clear()：<strong>清空当前map中的所有数据</strong></li>
</ul>
<pre><code class="java">Map map = new HashMap();
//Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中
map.put(&quot;AA&quot;,123);
map.put(45,123);
map.put(&quot;BB&quot;,56);
//修改
map.put(&quot;AA&quot;,87);
System.out.println(map);//&#123;AA=87, BB=56, 45=123&#125;
//void putAll(Map m)：将m中的所有key-value对存放到当前map中
Map map1 = new HashMap();
map1.put(&quot;CC&quot;,123);
map1.put(&quot;DD&quot;,432);
map.putAll(map1);
System.out.println(map);//&#123;AA=87, BB=56, CC=123, DD=432, 45=123&#125;
//Object remove(Object key)：移除指定key的key-value对，并返回value
System.out.println(map.remove(&quot;AA&quot;));//87
System.out.println(map);//&#123;BB=56, CC=123, DD=432, 45=123&#125;
//void clear()：清空当前map中的所有数据
map.clear();//与map=null不同，只是清除map中的元素，map对象还在
System.out.println(map.size());//0
System.out.println(map);//&#123;&#125;
</code></pre>
<p><strong>元素查询的操作：</strong></p>
<ul>
<li>Object get(Object key)：<strong>获取指定key对应的value</strong></li>
<li>boolean containsKey(Object key)：<strong>是否包含指定的key</strong></li>
<li>boolean containsValue(Object value)：<strong>是否包含指定的value</strong></li>
<li>int size()：返回<strong>map中key-value对的个数</strong></li>
<li>boolean isEmpty()：判断<strong>当前map是否为空</strong></li>
<li>boolean equals(Object obj)：判断<strong>当前map和参数对象obj是否相等</strong></li>
</ul>
<pre><code class="java">Map map = new HashMap();
map.put(&quot;AA&quot;,123);
map.put(45,123);
map.put(&quot;BB&quot;,56);
//Object get(Object key)：获取指定key对应的value
System.out.println(map.get(45));//123
System.out.println(map.get(456));//null(不存在)
//boolean containsKey(Object key)：是否包含指定的key
System.out.println(map.containsKey(&quot;AA&quot;));//true
System.out.println(map.containsKey(&quot;CC&quot;));//false
//boolean containsValue(Object value)：是否包含指定的value
System.out.println(map.containsValue(123));//true
System.out.println(map.containsValue(456));//false
//int size()：返回map中key-value对的个数
System.out.println(map.size());//3
//boolean isEmpty()：判断当前map是否为空
System.out.println(map.isEmpty());//false
map.clear();
System.out.println(map.isEmpty());//true
//boolean equals(Object obj)：判断当前map和参数对象obj是否相等
Map map1 = new HashMap();
map1.put(&quot;AA&quot;,123);
map1.put(45,123);
//map1.put(&quot;BB&quot;,56);
System.out.println(map.equals(map1));//false
//System.out.println(map.equals(map1));//true
</code></pre>
<p><strong>元视图操作的方法(遍历key-value对)：</strong></p>
<ul>
<li>Set keySet()：返回<strong>所有key构成的Set集合</strong></li>
<li>Collection values()：返回<strong>所有value构成的Collection集合</strong></li>
<li>Set entrySet()：返回<strong>所有key-value对构成的Set集合</strong></li>
</ul>
<pre><code class="java">Map map = new HashMap();
map.put(&quot;AA&quot;,123);
map.put(45,1234);
map.put(&quot;BB&quot;,56);
//Set keySet()：返回所有key构成的Set集合
Set set = map.keySet();
Iterator iterator = set.iterator();
while(iterator.hasNext()) &#123;
    System.out.println(iterator.next());//AA  BB  45
&#125;
//Collection values()：返回所有value构成的Collection集合
Collection values = map.values();
for (Object value : values) &#123;
    System.out.println(value);//123  56  1234
&#125;
//Set entrySet()：返回所有key-value对构成的Set集合
Set set1 = map.entrySet();
Iterator iterator1 = set1.iterator();
while(iterator1.hasNext()) &#123;
    Object obj = iterator1.next();
    Map.Entry entry = (Map.Entry) obj;
    System.out.println(entry);
    System.out.print(entry.getKey() + &quot;  --&gt;  &quot;);
    System.out.println(entry.getValue());
    //AA=123
    //AA  --&gt;  123
    //BB=56
    //BB  --&gt;  56
    //45=1234
    //45  --&gt;  1234
    //System.out.println(iterator1.next());
&#125;
</code></pre>
<h4 id="10-3-2-HashMap类"><a href="#10-3-2-HashMap类" class="headerlink" title="10.3.2 HashMap类"></a>10.3.2 HashMap类</h4><h5 id="1-底层实现原理"><a href="#1-底层实现原理" class="headerlink" title="1.底层实现原理"></a>1.底层实现原理</h5><p><strong>JDK7</strong></p>
<pre><code>HashMap map = new HashMap():
在实例化以后，底层创建了长度是16的一维数组Entry[] table
...可能已经执行过多次put后...
map.put(key1, value1):
首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置
    如果此位置上的数据为空,此时的entry1（key1-value1）添加成功  ----添加成功情况1
    如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据
    的哈希值:
        如果key1的哈希值与已经存在的数据的哈希值都不相同,此时key1-value1添加成功  ----添加成功情况2
        如果key1的哈希值和已经存在的某一个数据(key2-value2) 的哈希值相同，继续比较:调用key1所在类的equals(key2)
            如果equals()返回false:此时key1-value1添加成功  ----添加成功情况3
            如果equals()返回true:使用value1替换value2
补充:关于情况2和情况3:此时key1-value1和原来的数据以链表的方式存储（JDK7：新元素以头插法放在所有链表数据前面，即数组中；JDK8：新元素以尾插法放在链表数据后面，即链表尾部）
另外，在不断的添加过程中，会涉及到扩容问题，默认的打容方式:扩容为原来容量的2倍，并将原有的数据复制过来
</code></pre>
<p><strong>JDK8</strong></p>
<pre><code>jdk8相较于jdk7在底层实现方面的不同:
1. new HashMap():底层没有创建一个长度为16的数组,当首次调用put()方法时，底层才创建长度为16的数组
2. jdk8底层的数组是: Node[],而非Entry[]
3. jdk7底层结构只有:数组+链表。jdk8中底层结构:数组+链表+红黑树。
当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储
</code></pre>
<h5 id="2-源码分析"><a href="#2-源码分析" class="headerlink" title="2.源码分析"></a>2.源码分析</h5><p><strong>HashMap源码中的重要常量：</strong></p>
<ul>
<li>DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16</li>
<li>MAXIMUM_CAPACITY : HashMap的最大支持容量， 2^30</li>
<li>DEFAULT_LOAD_FACTOR : HashMap的默认加载因子</li>
<li>TREEIFY_THRESHOLD : Bucket中链表长度大于该默认值，转化为红黑树</li>
<li>UNTREEIFY_THRESHOLD : Bucket中红黑树存储的Node小于该默认值，转化为链表</li>
<li>MIN_TREEIFY_CAPACITY : 桶中的Node被树化时最小的hash表容量。( 当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作，这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_ _THRESHOLD的4倍）</li>
<li>table : 存储元素的数组，总是2的n次幂</li>
<li>entrySet : 存储具体元素的集</li>
<li>size : HashMap中存储的键值对的数量</li>
<li>modCount : HashMap扩容和结构改变的次数</li>
<li>threshold : 扩容的临界值，= 容量 * 填充因子</li>
<li>loadFactor : 填充因子</li>
</ul>
<pre><code class="java">面试题：负载因子值的大小，对HashMap有什么影响
1.负载因子的大小决定了HashMap的数据密度
2.负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降
3.负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间
4.按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数
</code></pre>
<p><strong>JDK7</strong></p>
<pre><code class="java">//无参构造器
public HashMap() &#123;
    this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);//传入16  0.75到有参构造器
&#125;
//有参构造器
public HashMap(int initialCapacity, float loadFactor) &#123;
    if (initialCapacity &lt; 0)//判断传入的初始化容量是否小于0
        throw new IllegalArgumentException(&quot;Illegal initial capacity:&quot; + initialCapacity);
    if (initialCapacity &gt; MAXIMUM_ CAPACITY)//判断传入的初始化容量是否大于HashMap中预先定义的最大容量
        initialCapacity = MAXIMUM_ CAPACITY;
    if (1oadFactor &lt;= 0 || Float.isNaN(loadFactor))//判断填充因子是否小于等于0或是否为负数
        throw new IllegalArgumentException(&quot;Illegal load factor:&quot; + loadFactor);
    // Find a power of 2 &gt;= initialCapacity
    int capacity = 1;//定义一个容量变量
    while (capacity &lt; initialCapacity)//如果容量值比给定的初始化容量小，则扩大为原来的2倍
        capacity &lt;&lt;= 1;
    this.1oadFactor = loadFactor;//将传入的填充因子赋值给这个新定义的HashMap对象（或是说Entry数组）
    threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//设置扩容临界值，默认16*0.75=12
    table = new Entry[capacity];//定义存放entry对象的Entry数组
    useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); 
    init();
&#125;
//从上方就可看出JDK7在实例化后就创建好了一个容量为16的Entry数组
//put方法添加数据
public V put(K key, V value) &#123;
    if (key == null)//如果key是null，HashMap单独处理放入HashMap中
        return putForNullKey(value);
    int hash = hash(key);//调用hash()计算得到当前key的哈希值
    int i = indexFor(hash, table.1ength);//调用indexFor()并传入hash值和Entry数组table的长度计算key-value存放在数组中的哪个位置
    for(Entry&lt;K,V&gt; e = table[i]; e != nu1l; e = e.next) &#123;//判断计算出的位置上有没有已存在的数据，如果能进入循环说明该位置上已经有数据了    e.next是指向下一条数据，准备与下一条数据进行比较
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
        //if(比较已存在数据和新添加数据的hash值是否相同  且  比较已存在数据和新添加数据的key是否相同)
        //若其中一个条件为false，则不满足两条数据相同，跳出循环，将新数据添加到HashMap中
        //若两个条件都为true，说明两条数据确实相同。则执行下方操作替换掉已存在数据的value
            V oldValue = e.value; //将已存在数据的value赋值给oldValue
            e.value = value; //将新添加的数据的value赋值给已存在的数据的value实现覆盖替换
            e.recordAccess(this);
            return oldValue;//将被覆盖替换的值返回，不再执行下方添加数据的代码
        &#125;
    &#125;
    modCount++;
    addEntry(hash, key, value, i);//若经过判断后新数据能被添加，则调用addEntry()传入hash值、key-value对和要添加到的位置，将这个需要添加的数据添加到HashMap中
    return null;
&#125;
//计算hash值的方法
final int hash(Object k) &#123;
    int h=0;
    if (useAltHashing) &#123;//默认false
        if (k instanceof String) &#123;
            return sun.misc.Hashing.stringHash32((String) k);
        &#125;
        h = hashSeed;
    &#125;
    h ^= k.hashCode();//调用hashCode()得到key的哈希值，然后进行异或计算
    // This function ensures that hashCodes that differ only by
    // constant multiples at each bit position have a bounded
    // number of collisions (approximately 8 at default Load factor).
    h ^= (h&gt;&gt;&gt;20) ^ (h&gt;&gt;&gt;12);
    return h ^ (h&gt;&gt;&gt;7) ^ (h&gt;&gt;&gt;4);//返回经过一些计算后的hash值
&#125;
//计算存放位置
static int indexFor(int h, int 1ength) &#123;
    return h &amp; (1ength-1);
&#125;
//添加数据Entry对象到HashMap中的具体方法
void addEntry(int hash, K key, V value, int bucketIndex) &#123;
    if ((size &gt;= threshold) &amp;&amp; (nu1l != table[bucketIndex])) &#123;//判断是否将数组table进行扩容
    //if(判断数组table中已存有的key-value对个数是否超过扩容临界值  且  确认需要添加新数据的位置是否已存有其他数据)
    //如果已存有key-value对个数大于等于扩容临界值，但新数据将要添加到的位置上为null，则不需要进行扩容
    //或者如果需要添加新数据的位置上不为null，但已存有key-value对个数不大于等于扩容临界值，也不进行扩容
    //即既当需要添加新数据的位置上不为null，又已存有key-value对个数大于等于扩容临界值时才进行扩容
        resize(2 * table.length);//扩容为原来容量的2倍，并将原有的数据进行重新计算hash值，然后放入新数组的新位置
        hash = (nu1l != key) ? hash(key) : 0;//将这个需要新添加的数据的hash值进行重新计算
        bucketIndex = indexFor(hash, table.length);//重新计算存放位置
    &#125;
    //不需要进行扩容或扩容后添加新数据
    createEntry(hash, key, value, bucketIndex);
&#125;
//添加新数据
void createEntry(int hash, K key, V value, int bucketIndex) &#123;
    Entry&lt;K,V&gt; e = table[bucketIndex];//把此位置上原有的数据取出来
    table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);//然后在此位置上new一个新的存放新数据的Entry对象，并将原来的数据传入，以新数据.next=原数据的方式让新数据指向原来的数据
    size++;//key-value对的个数加1
&#125;
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643610.png' data-fancybox='default' data-caption='image-20210804211433602'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643610.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643610.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210804211433602"></a><span class='image-caption'>image-20210804211433602</span></div></div>

<p><strong>JDK8</strong></p>
<pre><code class="java">//无参构造器
public HashMap() &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR; //负载因子（填充因子），默认0.75
&#125;
//有参构造器
public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;
    this.loadFactor = DEFAULT_LOAD_FACTOR;
    putMapEntries(m, false);
&#125;
//从上方可看出实例化HashMap后没有创建好长度为16的Node数组，而是等到下方第一次调用put方法后才创建的
//新增数据调用的方法
public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);//将计算好后的hash值、新数据的key、value等传入putVal()
&#125;
//计算hash值的方法
static final int hash(Object key) &#123;
    int h;
    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
&#125;
//新增数据时内部调用的方法
final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; 
    Node&lt;K,V&gt; p; 
    int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)//判断是否首次添加数据，若是则给当前HashMap对象创建新数组
        n = (tab = resize()).length;//调用resize()给当前HashMap对象创建新数组进行初始化
    if ((p = tab[i = (n - 1) &amp; hash]) == null)//经过(n-1)&amp;hash计算后得到新数据存放的位置，并判断此处是否为null
        tab[i] = newNode(hash, key, value, null);//若是为null，添加成功
    else &#123;//不是首次添加且新数据需要的存放位置不为null
        Node&lt;K,V&gt; e; 
        K k;
        if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
        //比较已存在的数据的hash值、key值地址和新数据的hash值、key值地址 || 若hash值一样，key值地址不一样，则比较key值的具体内容
            e = p;//若hash值和key值都一样，说明两条数据一样，则将已存在的数据取出赋给e，到下方进行key-value对的value替换操作
        else if (p instanceof TreeNode)//若已存在数据和新数据的hash值和key值不一样，判断已存在该位置上的数据是否是以红黑树结构存在
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//若是，将已存在的数据
        else &#123;
            //已存在数据和新数据的hash值和key值不一样，且已存在该位置上的数据不是以红黑树结构存在
            for (int binCount = 0; ; ++binCount) &#123;
                if ((e = p.next) == null) &#123;//寻找该位置上以链表形式存在的最后一个数据
                    p.next = newNode(hash, key, value, null);//让新数据添加到该链表已存在的最后一个数据后面
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);//如果添加该新数据后，该链表上的数据个数大于等于树化临界值-1，则将该条链表转换为红黑树进行存储
                    break;//跳出循环
                &#125;
                //寻找该位置上以链表形式存在的最后一个数据时会与该链表上的每个数据进行比较hash值、key值和value值
                if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;//如果发现有一样的数据，跳出循环
                p = e;//若正在进行比较的数据既不是该链表的最后一个也不和新数据一样，则将正在比较的数据赋给p，执行下一次循环p.next，即继续遍历判断下一个数据(p是当前数据，e是下一个数据)
            &#125;
        &#125;
        if (e != null) &#123; // existing mapping for key  
            V oldValue = e.value;//新value替换旧value
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    if (++size &gt; threshold)//添加完新数据后判断key-value对的个数是否大于扩容临界值
        resize();//若大于扩容临界值，执行扩容操作
    afterNodeInsertion(evict);
    return null;
&#125;
//扩容的方法
final Node&lt;K,V&gt;[] resize() &#123;
    Node&lt;K,V&gt;[] oldTab = table;//第一次添加数据时，table=null
    int oldCap = (oldTab == null) ? 0 : oldTab.length;//改变容量前的数组的容量，第一次调用则为0
    int oldThr = threshold;//改变容量前的数组的扩容临界值，第一次调用默认为0
    int newCap, newThr = 0;//声明新容量，新扩容临界值
    if (oldCap &gt; 0) &#123;//判断旧数组的容量是否大于0，即是不是第一次调用resize()
        if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//若旧数组的容量大于等于设置的最大容量
            threshold = Integer.MAX_VALUE;//设置扩容临界值为Integer类中的最大值
            return oldTab;//返回重新设置了扩容临界值的旧数组
        &#125;
        //旧数组容量小于设置的最大容量，对旧数组进行扩容
        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY)
        //if(扩容为原来2倍后的新容量小于最大容量  且  旧数组容量大于等于默认初始化容量16)
            newThr = oldThr &lt;&lt; 1; //新数组的扩容临界值扩大为原来的2倍
    &#125;
    else if (oldThr &gt; 0) //initial capacity was placed in threshold
    //判断如果旧数组的容量=0但扩容临界值大于0的情况
    //(能到这儿说明是设置了初始化的扩容临界值，未设置容量)
        newCap = oldThr;//若是，则数组的新容量就为旧的扩容临界值
    else &#123;               // zero initial threshold signifies using defaults
        //实例化数组时，容量为0，扩容临界值也为0，进行下方数组的初始化操作
        newCap = DEFAULT_INITIAL_CAPACITY;//容量设置为16
        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//扩容临界值设置为12
    &#125;
    if (newThr == 0) &#123;//判断新的扩容临界值是否还是等于0
        float ft = (float)newCap * loadFactor;
        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE);
    &#125;
    //新的扩容临界值不为0，新容量也已设置，准备条件已就绪
    threshold = newThr;//将得到的新扩容临界值赋值给当前HashMap对象的扩容临界值
    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;)
    Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//根据新的容量创建一个新数组
    table = newTab;//将新数组赋给当前HashMap对象的数组，自此就已创建好新数组，若是实例化第一次调用该方法，到此已结束，只需将新数组返回即可
    if (oldTab != null) &#123; //不是第一次时调用该方法的话，扩容后会将原来的数据复制到新数组中
        for (int j = 0; j &lt; oldCap; ++j) &#123;
            Node&lt;K,V&gt; e;
            if ((e = oldTab[j]) != null) &#123;
                oldTab[j] = null;
                if (e.next == null)
                    newTab[e.hash &amp; (newCap - 1)] = e;
                else if (e instanceof TreeNode)
                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);
                else &#123; // preserve order
                    Node&lt;K,V&gt; loHead = null, loTail = null;
                    Node&lt;K,V&gt; hiHead = null, hiTail = null;
                    Node&lt;K,V&gt; next;
                    do &#123;
                        next = e.next;
                        if ((e.hash &amp; oldCap) == 0) &#123;
                            if (loTail == null)
                                loHead = e;
                            else
                                loTail.next = e;
                            loTail = e;
                        &#125;
                        else &#123;
                            if (hiTail == null)
                                hiHead = e;
                            else
                                hiTail.next = e;
                            hiTail = e;
                        &#125;
                    &#125; while ((e = next) != null);
                    if (loTail != null) &#123;
                        loTail.next = null;
                        newTab[j] = loHead;
                    &#125;
                    if (hiTail != null) &#123;
                        hiTail.next = null;
                        newTab[j + oldCap] = hiHead;
                    &#125;
                &#125;
            &#125;
        &#125;
    &#125;
    return newTab;
&#125;
//添加新数据后该链表的数据个数大于等于树化临界值-1则转换为红黑树
final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;//传入HashMap对象底层的数组table和新数据的hash值
    int n, index;
    Node&lt;K,V&gt; e;
    if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY)
        resize();//判断table是否为null(一般不可能),或者table的长度是否小于最小树化容量，若比它小，则选择进行扩容操作，而不是树化
    else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;//否则，执行下方代码将该链表进行树化
        //判断根据新数据的hash值计算出的table中对应的位置上是否为null，不为null则将该位置上的链表进行树化操作
        TreeNode&lt;K,V&gt; hd = null, tl = null;
        do &#123;
            TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null);
            if (tl == null)
                hd = p;
            else &#123;
                p.prev = tl;
                tl.next = p;
            &#125;
            tl = p;
        &#125; while ((e = e.next) != null);
        if ((tab[index] = hd) != null)
            hd.treeify(tab);
    &#125;
&#125;
</code></pre>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643558.png' data-fancybox='default' data-caption='image-20210804211515316'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643558.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643558.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210804211515316"></a><span class='image-caption'>image-20210804211515316</span></div></div>

<h4 id="10-3-3-LinkedHashMap类"><a href="#10-3-3-LinkedHashMap类" class="headerlink" title="10.3.3 LinkedHashMap类"></a>10.3.3 LinkedHashMap类</h4><h5 id="底层实现原理"><a href="#底层实现原理" class="headerlink" title="底层实现原理"></a>底层实现原理</h5><pre><code class="java">Map map = new HashMap();
Map map1 = new LinkedHashMap();
map.put(123,&quot;AA&quot;);
map.put(456,&quot;BB&quot;);
map.put(789,&quot;CC&quot;);
map1.put(123,&quot;AA&quot;);
map1.put(456,&quot;BB&quot;);
map1.put(789,&quot;CC&quot;);
System.out.println(map);//&#123;789=CC, 456=BB, 123=AA&#125;
System.out.println(map1);//&#123;123=AA, 456=BB, 789=CC&#125;
</code></pre>
<p>LinkedHashMap中没有put方法，而是继承自HashMap，在put方法中又调用HashMap的putVal方法，但是在这个putVal方法中有一个newNode方法，而LinkedHashMap重写了这个方法，从此处就能区别开HashMap与LinkedHashMap的存储结构差异</p>
<pre><code class="java">//HashMap中的Node类(仅包括定义的属性)
static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
        final int hash;
        final K key;
        V value;
        Node&lt;K,V&gt; next;
&#125;
//继承自HashMap的Entry类
static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123;
    Entry&lt;K,V&gt; before, after;//新增的属性，用来指明一个数据结点的上一个数据和下一个数据。记录增添数据的先后顺序
    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        super(hash, key, value, next);
    &#125;    
&#125;
//覆盖重写HashMap中的newNode方法。所以LinkedHashMap创建的存储数据的结点会不一样，即多了before和after属性
Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);
    linkNodeLast(p);
    return p;
&#125;
//指明新数据结点的上一个和下一个数据
private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123;
    LinkedHashMap.Entry&lt;K,V&gt; last = tail;
    tail = p;
    if (last == null)
        head = p;
    else &#123;
        p.before = last;
        last.after = p;
    &#125;
&#125;
</code></pre>
<h4 id="10-3-4-TreeMap类"><a href="#10-3-4-TreeMap类" class="headerlink" title="10.3.4 TreeMap类"></a>10.3.4 TreeMap类</h4><pre><code class="java">//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象
//因为要按照key进行排序:自然排序、定制排序
//具体细节可看10.2.3中的第3点TreeSet，因为TreeSet的实现底层就是TreeMap。两者相差不大，只是存放的数据类型不同
</code></pre>
<pre><code class="java">//自然排序，User类中重写的compareTo()方法是按名字从大到小，再按年龄从小到大排序
TreeMap treeMap = new TreeMap();
User user1 = new User(&quot;Tom&quot;,10);
User user2 = new User(&quot;Jack&quot;,50);
User user3 = new User(&quot;Jerry&quot;,25);
User user4 = new User(&quot;Eric&quot;,20);
User user5 = new User(&quot;Eric&quot;,23);
treeMap.put(user1,98);
treeMap.put(user2,94);
treeMap.put(user3,89);
treeMap.put(user4,87);
treeMap.put(user5,98);
Set users = treeMap.entrySet();
Iterator iterator = users.iterator();
while(iterator.hasNext()) &#123;
    Object obj = iterator.next();
    Map.Entry entry = (Map.Entry) obj;
    System.out.print(entry.getKey() + &quot;  --&gt;  &quot;);
    System.out.println(entry.getValue());
    //User&#123;name=&#39;Tom&#39;, age=10&#125;  --&gt;  98
    //User&#123;name=&#39;Jerry&#39;, age=25&#125;  --&gt;  89
    //User&#123;name=&#39;Jack&#39;, age=50&#125;  --&gt;  94
    //User&#123;name=&#39;Eric&#39;, age=20&#125;  --&gt;  87
    //User&#123;name=&#39;Eric&#39;, age=23&#125;  --&gt;  98
&#125;
//定制排序
Comparator comparator = new Comparator() &#123;
    //按年龄从小到大排序
    @Override
    public int compare(Object o1, Object o2) &#123;
        if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123;
            User user1 = (User) o1;
            User user2 = (User) o2;
            return Integer.compare(user1.getAge(),user2.getAge());
        &#125;
        throw new RuntimeException(&quot;比较的类型不正确&quot;);
    &#125;
&#125;;
TreeMap treeMap = new TreeMap(comparator);
User user1 = new User(&quot;Tom&quot;,10);
User user2 = new User(&quot;Jack&quot;,50);
User user3 = new User(&quot;Jerry&quot;,25);
User user4 = new User(&quot;Eric&quot;,20);
User user5 = new User(&quot;Eric&quot;,23);
treeMap.put(user1,98);
treeMap.put(user2,94);
treeMap.put(user3,89);
treeMap.put(user4,87);
treeMap.put(user5,98);
Set users = treeMap.entrySet();
Iterator iterator = users.iterator();
while(iterator.hasNext()) &#123;
    Object obj = iterator.next();
    Map.Entry entry = (Map.Entry) obj;
    System.out.print(entry.getKey() + &quot;  --&gt;  &quot;);
    System.out.println(entry.getValue());
    //User&#123;name=&#39;Tom&#39;, age=10&#125;  --&gt;  98
    //User&#123;name=&#39;Eric&#39;, age=20&#125;  --&gt;  87
    //User&#123;name=&#39;Eric&#39;, age=23&#125;  --&gt;  98
    //User&#123;name=&#39;Jerry&#39;, age=25&#125;  --&gt;  89
    //User&#123;name=&#39;Jack&#39;, age=50&#125;  --&gt;  94
&#125;
</code></pre>
<h4 id="10-3-5-Properties类"><a href="#10-3-5-Properties类" class="headerlink" title="10.3.5 Properties类"></a>10.3.5 Properties类</h4><p>对于HashTable来说，Hashtable是个古老的Map实现类，JDK1.0就提供了，也是Map接口的第四个实现类 。不同于HashMap，<strong>Hashtable是线程安全的</strong></p>
<p>Hashtable<strong>实现原理和HashMap相同，功能相同</strong>。<strong>底层都使用哈希表结构，查询速度快</strong>，很多情况下可以互用</p>
<ul>
<li>与HashMap不同，<strong>Hashtable不允许使用null作为key和value</strong></li>
<li>与HashMap一样，<strong>Hashtable 也不能保证其中Key-Value对的顺序</strong></li>
<li>Hashtable<strong>判断两个key相等、两个value相等的标准，与HashMap一致</strong></li>
</ul>
<p><strong>Properties类是Hashtable的子类</strong>，该对象<strong>用于处理属性文件</strong>，由于属性文件里的key、value都是字符串类型，所以Properties 里的<strong>key和value都是字符串类型</strong></p>
<p><strong>存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法</strong></p>
<pre><code class="java">Properties pros = new Properties();
FileInputStream in = new FileInputStream(&quot;jdbc.properties&quot;);
pros.load(in);
String name = pros.getProperty(&quot;name&quot;);
String password = pros.getProperty(&quot;password&quot;);
System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);//name = Tom, password = abc123
</code></pre>
<h3 id="10-4-Collections工具类"><a href="#10-4-Collections工具类" class="headerlink" title="10.4 Collections工具类"></a>10.4 Collections工具类</h3><p>面试题：Collection 和Collections的区别?</p>
<pre><code class="java">Collection是一个存储单列数据集合的接口，List、Set都继承自它
Collections是一个操作List、Set和Map的工具类
</code></pre>
<p>Collections 是一个<strong>操作Set、 List和Map</strong>等集合的工具类，Collections中提供了一系列静态的方法<strong>对集合元素进行排序、查询和修改等操作</strong>，还提供了<strong>对集合对象设置不可变、对集合对象实现同步控制等方法</strong></p>
<h4 id="10-4-1-Collections中的常用方法"><a href="#10-4-1-Collections中的常用方法" class="headerlink" title="10.4.1 Collections中的常用方法"></a>10.4.1 Collections中的常用方法</h4><h5 id="1-排序："><a href="#1-排序：" class="headerlink" title="1.排序："></a>1.排序：</h5><ul>
<li>reverse(List)：<strong>反转List中元素的顺序</strong></li>
<li>shuffle(List)：对<strong>List集合元素进行随机排序</strong></li>
<li>sort(List)：根据<strong>元素的自然顺序对指定List集合元素按升序排序</strong></li>
<li>sort(List, Comparator)：<strong>根据指定的Comparator产生的顺序对List 集合元素进行排序</strong></li>
<li>swap(List list，int i，int j)：将<strong>指定list集合中的i处元素和j处元素进行交换</strong></li>
</ul>
<pre><code class="java">List list = new ArrayList();
list.add(123);
list.add(43);
list.add(765);
list.add(-97);
list.add(0);
System.out.println(list);//[123, 43, 765, -97, 0]
//reverse(List)：反转List中元素的顺序
Collections.reverse(list);
System.out.println(list);//[0, -97, 765, 43, 123]
//shuffle(List)：对List集合元素进行随机排序
Collections.shuffle(list);
System.out.println(list);//第一次[0, 123, 43, -97, 765]  第二次[123, 765, 43, -97, 0]
//sort(List)：根据元素的自然顺序对指定List集合元素按升序排序
Collections.sort(list);
System.out.println(list);//[-97, 0, 43, 123, 765]
//swap(List list，int i，int j)：将指定list集合中的i处元素和j处元素进行交换
Collections.swap(list,1,3);
System.out.println(list);//[-97, 123, 43, 0, 765]
</code></pre>
<h5 id="2-查找、替换："><a href="#2-查找、替换：" class="headerlink" title="2.查找、替换："></a>2.查找、替换：</h5><ul>
<li>Object max(Collection)：根据元素的<strong>自然顺序</strong>，返回给定集合中的<strong>最大元素</strong></li>
<li>Object max(Collection，Comparator): 根据<strong>Comparator指定的顺序</strong>，返回给定集合中的<strong>最小元素</strong></li>
<li>Object min(Collection)：根据元素的<strong>自然顺序</strong>，返回给定集合中的<strong>最大元素</strong></li>
<li>Object min(Collection，Comparator)：根据<strong>Comparator指定的顺序</strong>，返回给定集合中的<strong>最小元素</strong></li>
<li>int frequency(Collection, Object)：返回指定集合中指定元素的<strong>出现次数</strong></li>
<li>void copy(List dest,List src)：<strong>将src中的内容复制到dest中</strong></li>
<li>boolean replaceAll(List list, Object oldVal, Object newVal)：<strong>使用新值newVal替换List对象的所有旧值oldVal</strong></li>
</ul>
<pre><code class="java">List list = new ArrayList();
list.add(123);
list.add(43);
list.add(765);
list.add(765);
list.add(-97);
list.add(765);
list.add(0);
System.out.println(list);//[123, 43, 765, 765, -97, 765, 0]
//Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
System.out.println(Collections.max(list));//765
//Object min(Collection)：根据元素的自然顺序，返回给定集合中的最大元素
System.out.println(Collections.min(list));//-97
//int frequency(Collection, Object)：返回指定集合中指定元素的出现次数
System.out.println(Collections.frequency(list, 765));//3
//void copy(List dest,List src)：将src中的内容复制到dest中
//错误写法:
//List list1 = new ArrayList();
//Collections.copy(list1,list);
List list1 = Arrays.asList(new Object[list.size()]);
Collections.copy(list1,list);
System.out.println(list1);//[123, 43, 765, 765, -97, 765, 0]
//boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值newVal替换List对象的所有旧值oldVal
Collections.replaceAll(list,765,567);
System.out.println(list);//[123, 43, 567, 567, -97, 567, 0]
</code></pre>
<h5 id="3-转换为线程安全的集合"><a href="#3-转换为线程安全的集合" class="headerlink" title="3.转换为线程安全的集合"></a>3.转换为线程安全的集合</h5><p>Collections类中提供了<strong>多个synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合</strong>，从而可以<strong>解决多线程并发访问集合时的线程安全问题</strong></p>
<pre><code class="java">在Collections类中有几个定义的SynchronizedXxx的静态内部类，当调用这些SynchronizedXxx()方法时，会在这个方法内部创建一个对应的线程安全的内部类对象，然后返回这个对象。当我们使用返回的对象调用List、Set和Map等的方法时，都会调用到Collections定义的几个静态内部类中重写的相对应的方法，以此来保证线程的安全性
//以List为例
List list = new ArrayList();
List list1 = Collections.synchronizedList(list);//此时返回的list即为线程安全的
//Collections中的synchronizedList()方法
public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123;
    return (list instanceof RandomAccess ?
            new SynchronizedRandomAccessList&lt;&gt;(list) :
            new SynchronizedList&lt;&gt;(list));
&#125;
//定义的SynchronizedList静态内部类类
static class SynchronizedList&lt;E&gt;
    extends SynchronizedCollection&lt;E&gt;
    implements List&lt;E&gt; &#123;
    private static final long serialVersionUID = -7754090372962971524L;

    final List&lt;E&gt; list;

    SynchronizedList(List&lt;E&gt; list) &#123;
        super(list);
        this.list = list;
    &#125;
    SynchronizedList(List&lt;E&gt; list, Object mutex) &#123;
        super(list, mutex);
        this.list = list;
    &#125;

    public boolean equals(Object o) &#123;
        if (this == o)
            return true;
        synchronized (mutex) &#123;return list.equals(o);&#125;
    &#125;
    public int hashCode() &#123;
        synchronized (mutex) &#123;return list.hashCode();&#125;
    &#125;

    public E get(int index) &#123;
        synchronized (mutex) &#123;return list.get(index);&#125;
    &#125;
    public E set(int index, E element) &#123;
        synchronized (mutex) &#123;return list.set(index, element);&#125;
    &#125;
    public void add(int index, E element) &#123;
        synchronized (mutex) &#123;list.add(index, element);&#125;
    &#125;
    public E remove(int index) &#123;
        synchronized (mutex) &#123;return list.remove(index);&#125;
    &#125;

    public int indexOf(Object o) &#123;
        synchronized (mutex) &#123;return list.indexOf(o);&#125;
    &#125;
    public int lastIndexOf(Object o) &#123;
        synchronized (mutex) &#123;return list.lastIndexOf(o);&#125;
    &#125;

    public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;
        synchronized (mutex) &#123;return list.addAll(index, c);&#125;
    &#125;

    public ListIterator&lt;E&gt; listIterator() &#123;
        return list.listIterator(); // Must be manually synched by user
    &#125;

    public ListIterator&lt;E&gt; listIterator(int index) &#123;
        return list.listIterator(index); // Must be manually synched by user
    &#125;

    public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123;
        synchronized (mutex) &#123;
            return new SynchronizedList&lt;&gt;(list.subList(fromIndex, toIndex),
                                          mutex);
        &#125;
    &#125;

    @Override
    public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123;
        synchronized (mutex) &#123;list.replaceAll(operator);&#125;
    &#125;
    @Override
    public void sort(Comparator&lt;? super E&gt; c) &#123;
        synchronized (mutex) &#123;list.sort(c);&#125;
    &#125;

    /**
         * SynchronizedRandomAccessList instances are serialized as
         * SynchronizedList instances to allow them to be deserialized
         * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList).
         * This method inverts the transformation.  As a beneficial
         * side-effect, it also grafts the RandomAccess marker onto
         * SynchronizedList instances that were serialized in pre-1.4 JREs.
         *
         * Note: Unfortunately, SynchronizedRandomAccessList instances
         * serialized in 1.4.1 and deserialized in 1.4 will become
         * SynchronizedList instances, as this method was missing in 1.4.
         */
    private Object readResolve() &#123;
        return (list instanceof RandomAccess
                ? new SynchronizedRandomAccessList&lt;&gt;(list)
                : this);
    &#125;
&#125;
</code></pre>
<h4 id="10-4-2-集合练习题"><a href="#10-4-2-集合练习题" class="headerlink" title="10.4.2 集合练习题"></a>10.4.2 集合练习题</h4><pre><code class="java">1.从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来
2.把学生名与考试分数录入到集合中，并按分数显示前三名成绩学员的名字。TreeSet(Student(name,score,id));
3.姓氏统计:一个文本文件中存储着北京所有高校在校生的姓名，格式如下
每行一个名字，姓与名以空格分隔:
张  三
李  四
王  小五
现在想统计所有的姓氏在文件中出现的次数，请描述一下你的解决方案
4.对一个Java源文件中的关键字进行计数
提示:Java源文件中的每一个单词，需要确定该单词是否是一个关键字。为了高效处理这个问题，将所有的关键字保存在一个HashSet中。用contains()来测试
File file = new File(&quot;Test.java&quot;);
Scanner scanner = new Scanner(file);
while(scanner.hasNext())&#123;
    String word = scanner.next();
    System.out.printIn(word);
&#125;
</code></pre>
<h2 id="十一、Java泛型"><a href="#十一、Java泛型" class="headerlink" title="十一、Java泛型"></a>十一、Java泛型</h2><p>集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在<strong>JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决</strong>。因为这个时候除了<strong>元素的类型不确定，其他的部分是确定</strong>的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把<strong>元素的类型设计成一个参数</strong>，这个类型参数叫做泛型。<code>collection&lt;E&gt;</code>，<code>List&lt;E&gt;</code>，<code>ArrayList&lt;E&gt;</code>这个**<E>就是类型参数，即泛型**</p>
<p>所谓泛型，就是允许<strong>在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型</strong>。<strong>这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参)</strong></p>
<p>从JDK1.5以后，Java引入了“参数化类型( Parameterized type)”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List<String>，这表明该List只能保存字符串类型的对象</p>
<p>JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持从而<strong>可以在声明集合变量、创建集合对象时传入类型实参</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643333.png' data-fancybox='default' data-caption='image-20210806095515537'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643333.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643333.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210806095515537"></a><span class='image-caption'>image-20210806095515537</span></div></div>

<h3 id="11-1-泛型的使用"><a href="#11-1-泛型的使用" class="headerlink" title="11.1 泛型的使用"></a>11.1 泛型的使用</h3><pre><code class="java">泛型的使用
1.jdk 5.0新增的特性
2.在集合中使用泛型:
总结:
① 集合接口或集合类在jdk5.0时都修改为带泛型的结构
② 在实例化集合类时，可以指明具体的泛型类型
③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如:方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如: add(E e) ---&gt; 实例化以后: add(Integer e)
④ 注意点:泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换
⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.object类型
</code></pre>
<pre><code class="java">ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;();
list.add(78);
list.add(87);
list.add(99);
list.add(65);
//编译时，就会进行类型检查，保证数据的安全
//list.add(&quot;Tom&quot;);
//遍历方式一：
for(Integer score : list)&#123;
    //避免了强转操作
    int stuScore = score;
    System.out.println(stuScore);
&#125;
//遍历方式二：
Iterator&lt;Integer&gt; iterator = list.iterator();
while (iterator.hasNext())&#123;
    int stuScore1 = iterator.next();
    System.out.println(stuScore1);
&#125;
</code></pre>
<pre><code class="java"> //以HashMap为例
 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;();
 map.put(&quot;Tom&quot;,87);
 map.put(&quot;Jerry&quot;,87);
 map.put(&quot;Jack&quot;,87);
 //编译报错
 //map.put(123,&quot;Mary&quot;);
 //泛型的嵌套
 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet();
 Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator();
 while (iterator.hasNext())&#123;
     Map.Entry&lt;String, Integer&gt; e = iterator.next();
     String key = e.getKey();
     Integer value = e.getValue();
     System.out.println(key + &quot;  --&gt;  &quot; + value);
 &#125;
</code></pre>
<h3 id="11-2-自定义泛型"><a href="#11-2-自定义泛型" class="headerlink" title="11.2 自定义泛型"></a>11.2 自定义泛型</h3><h4 id="11-2-1-自定义泛型类和接口"><a href="#11-2-1-自定义泛型类和接口" class="headerlink" title="11.2.1 自定义泛型类和接口"></a>11.2.1 自定义泛型类和接口</h4><p><strong>自身定义为泛型类（接口）</strong></p>
<pre><code class="java">//如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型
//要求:如果定义了类是带泛型的，建议在实例化时要指明类的泛型
public class Order&lt;T&gt; &#123;
    String orderName;
    int orderId;
    //类的内部结构可以使用类的泛型
    T orderT;
    public Order() &#123;
    &#125;
    public Order(String orderName, int orderId, T orderT) &#123;
        this.orderName = orderName;
        this.orderId = orderId;
        this.orderT = orderT;
    &#125;
    public T getOrderT() &#123;
        return orderT;
    &#125;
    public void setOrderT(T orderT) &#123;
        this.orderT = orderT;
    &#125;
&#125;
Order order = new Order();
order.setOrderT(123);
order.setOrderT(&quot;ABC&quot;);
//实例化时指明类的泛型
Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;);
order1.setOrderT(&quot;AA:hello&quot;);//此时只能设置String类型
</code></pre>
<p><strong>其他类继承泛型类（实现接口）</strong></p>
<pre><code class="java">public class SubOrder extends Order&lt;Integer&gt;&#123;//非泛型类
&#125;
public class SubOrder1&lt;T&gt; extends Order&lt;T&gt;&#123;//泛型类
&#125;
SubOrder subOrder = new SubOrder();
//由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型
subOrder.setOrderT(1002);//此时传入的类型只能是继承Order&lt;Integer&gt;时指明的Integer类型，若没有像如此指明类型即是继承自Order&lt;T&gt;，则传入的数据类型是Object类型

SubOrder1&lt;String&gt; subOrder = new SubOrder1&lt;String&gt;();//是泛型类
subOrder1.setOrderT(&quot;order2...&quot;);
</code></pre>
<p><strong>自定义类和接口的注意点：</strong></p>
<ol>
<li><p>泛型类<strong>可能有多个参数</strong>，此时应将<strong>多个参数一起放在尖括号内</strong>。比如：&lt;E1,E2,E3&gt;</p>
</li>
<li><p>泛型类的构造器如下：**<code>public GenericClass()&#123;&#125;</code><strong>。而下面是错误的: public GenericClass<E>(){}，而</strong>实例化时需要<code>new Generic&lt;&gt;();</code>**</p>
</li>
<li><p><strong>实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致</strong></p>
</li>
<li><p>泛型不同的引用不能相互赋值。尽管在编译时<code>ArrayList&lt;String&gt;</code>和<code>ArrayList&lt;Integer&gt;</code>是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中</p>
<pre><code class="java">ArrayList&lt;String&gt; list1 = nu1l;
ArrayList&lt;Integer&gt; list2 = nul1;
list1 = list2;//泛型不同的引用不能相互赋值
Person p1 = null;
Person p2=null;
p1 = p2;//而这种普通引用可以
</code></pre>
</li>
<li><p><strong>泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理</strong>，但不等价于Object。 经验：<strong>泛型要使用一路都用。要不用，一路都不要用</strong></p>
</li>
<li><p>如果<strong>泛型结构是一个接口或抽象类，则不可创建泛型类的对象</strong></p>
</li>
<li><p>jdk1.7, 泛型的简化操作: <code>ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;();</code></p>
</li>
<li><p>泛型的指定中<strong>不能使用基本数据类型</strong>，可以使用包装类替换</p>
</li>
<li><p>在类/接口上声明的泛型，在<strong>本类或本接口中即代表某种类型</strong>，可以<strong>作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型</strong>。但<strong>在静态方法中不能使用类的泛型</strong></p>
<pre><code class="java">public static void show(T orderT)&#123;//编译报错
    Systrem.out.println(orderT);
&#125;
//因为泛型是针对实例化对象使用来指定类型的，而静态方法是早于实例化对象创建，在没有实例化对象时也要进行创建和调用
</code></pre>
</li>
<li><p><strong>异常类不能是泛型的</strong></p>
</li>
<li><p>不能使用new E[]。但是可以: E[] elements = (E[])new Object[capacity];<br>参考: ArrayList源码中声明: Object[] elementData，而非泛型参数类型数组</p>
</li>
<li><p><strong>父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型</strong>:</p>
<ul>
<li>子类不保留父类的泛型：按需实现<ul>
<li>没有类型擦除</li>
<li>具体类型</li>
</ul>
</li>
<li>子类保留父类的泛型：泛型子类<ul>
<li>全部保留</li>
<li>部分保留</li>
</ul>
</li>
</ul>
<pre><code class="java">class Father&lt;T1, T2&gt; &#123;
&#125;
//子类不保留父类的泛型
// 1)没有类型 擦除
class Son1 extends Father &#123;//等价于class Son extends Father&lt;Object , 0bject&gt;&#123;
&#125;
// 2)具体类型
class Son2 extends Father&lt;Integer, String&gt; &#123;
&#125;
//子类保留父类的泛型
// 1)全部保留
class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#123;
&#125;
// 2)部分保留
class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; &#123;
&#125;
</code></pre>
<pre><code class="java">class Father&lt;T1, T2&gt; &#123;
&#125;
//子类不保留父类的泛型
// 1)没有类型擦除
class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object , 0bject&gt;&#123;
&#125;
// 2)具体类型
class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123;
&#125;
//子类保留父类的泛型
// 1)全部保留
class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123;
&#125;
// 2)部分保留
class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123;
&#125;
</code></pre>
</li>
<li><p>结论：子类必须是“富二代”，<strong>子类除了指定或保留父类的泛型，还可以增加自己的泛型</strong></p>
</li>
</ol>
<h4 id="11-2-2-自定义泛型方法"><a href="#11-2-2-自定义泛型方法" class="headerlink" title="11.2.2 自定义泛型方法"></a>11.2.2 自定义泛型方法</h4><pre><code class="java">public T getOrderT() &#123;
    return orderT;
&#125;
public void setOrderT(T orderT) &#123;
    this.orderT = orderT;
&#125;
boolean add(E e);
//以上三种不是泛型方法，而是普通方法

&lt;T&gt; T[] toArray(T[] a);//这是一个泛型方法
//泛型方法:在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系，所以在非泛型类中也可以定义使用 
//泛型方法，可以声明为静态的。原因:泛型参数是在调用方法时确定的，并非在实例化类时确定
//定义时需要在前方加上类似&lt;E&gt;的标识来告诉编译器这是一个泛型方法，其泛型和类没有任何关系
public &lt;E&gt; List&lt;E&gt; copyFromArrayTolist(E[] arr)&#123; 
    ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;();
    for(E e : arr)&#123;
    list.add(e);
    return list;
&#125;
Order&lt;String&gt; order = new 0rder&lt;&gt;();
Integer[] arr = new Integer[]&#123;1,2,3,4&#125;;
List&lt;Integer&gt; list = order.copyFromArrayToList(arr);
System.out.println(list);//[1,2,3,4]
</code></pre>
<h3 id="11-3-泛型在继承方面的体现"><a href="#11-3-泛型在继承方面的体现" class="headerlink" title="11.3 泛型在继承方面的体现"></a>11.3 泛型在继承方面的体现</h3><p>虽然类A是类B的父类，但是G<A> 和G<B> 二者不具备子父类关系，二者是并列关系</p>
<p>补充：类A是类B的父类，A<G>是B<G>的父类</p>
<pre><code class="java">Object obj = null;
String str = null;
obj = str;

Object[] arr1 = null;
String[] arr2 = null;

arr1 = arr2;
//编译不通过
//Date date = new Date();
//str = date;

List&lt;Object&gt; list1 = null;
List&lt;String&gt; list2 = null;
//此时的list1和list2的类型不具有父子关系，编译不通过
//list1 = list2;
/*
    反证法:
    假设list1 = list2;
    list1.add(123);导致混入非String的数据。出错。
*/
</code></pre>
<h3 id="11-4-通配符的使用"><a href="#11-4-通配符的使用" class="headerlink" title="11.4 通配符的使用"></a>11.4 通配符的使用</h3><p>使用类型通配符：<code>?</code>，比如：<code>List&lt;?&gt;</code> ，<code>Map&lt;?,?&gt;</code></p>
<p><code>List&lt;?&gt;</code>是<code>List&lt;String&gt;</code>、 <code>List&lt;Object&gt;</code>等各种泛型List的父类。比如，类A是类B的父类，但<code>G&lt;A&gt;</code>和<code>G&lt;B&gt;</code>是没有关系的，二者共同的父类是<code>G&lt;?&gt;</code></p>
<h4 id="11-4-1-使用通配符后对数据的写入和读取"><a href="#11-4-1-使用通配符后对数据的写入和读取" class="headerlink" title="11.4.1 使用通配符后对数据的写入和读取"></a>11.4.1 使用通配符后对数据的写入和读取</h4><h5 id="1-写入数据"><a href="#1-写入数据" class="headerlink" title="1.写入数据"></a>1.写入数据</h5><p><strong>不能</strong>向使用通配符后的集合<strong>写入数据</strong>。因为我们不知道要添加的元素类型，就向其中添加对象</p>
<p>将任意元素加入到其中都不是类型安全的：</p>
<pre><code class="java">Collection&lt;?&gt; c = new ArrayList&lt;String&gt;();
c.add(new Object()); //编译时错误
//add方法有类型参数E作为集合的元素类型，我们传给add的任何参数都必须是这个未知类型的子类。因为我们不知道c的元素类型，自然也就不知道其子类，所以我们无法添加任何东西进去

//唯一的例外的是null，它是所有类型的成员
</code></pre>
<h5 id="2-读取数据"><a href="#2-读取数据" class="headerlink" title="2.读取数据"></a>2.读取数据</h5><p>我们<strong>可以读取</strong>到使用通配符后的集合对象中的数据。比如，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为我们调用get()方法并得到其返回值后，不管其数据的真实类型是什么，它都总是一个Object</p>
<pre><code class="java">List&lt;String&gt; list1 = new ArrayList&lt;&gt;();
List&lt;String&gt; list2 = new ArrayList&lt;&gt;();
List&lt;?&gt; list = null;
list = list1;//能赋值成功
list = list2;//能赋值成功

List&lt;String&gt; list3 = new ArrayList&lt;&gt;();
list3.add(&quot;AA&quot;);
list3.add(&quot;BB&quot;);
list3.add(&quot;CC&quot;);
list = list3;
//添加：对于List&lt;?&gt;就不能向其内部添加数据，除了添加null
//list.add(&quot;DD&quot;);
//获取：允许读取数据，读取的数据类型为Object
Object o =list.get(0);
System.out.println(o);
</code></pre>
<h4 id="11-4-2-有限制的通配符"><a href="#11-4-2-有限制的通配符" class="headerlink" title="11.4.2 有限制的通配符"></a>11.4.2 有限制的通配符</h4><ul>
<li><strong>&lt;?&gt;允许所有泛型的引用调用</strong></li>
<li>通配符指定上限，<strong>上限extends</strong>：使用时<strong>指定的类型必须是继承某个类，或者实现某个接口</strong>，即<code>&lt;=</code></li>
<li>通配符指定下限，<strong>下限super</strong>：使用时<strong>指定的类型不能小于操作的类</strong>，即<code>&gt;=</code></li>
<li>举例：<ul>
<li><? extends Number> (无穷小，Number] ：**只允许泛型为Number及Number子类的引用调用**</li>
<li><? super Number> [Number ，无穷大) ：**只允许泛型为Number及Number父类的引用调用**</li>
<li><? extends Comparable> ：**只允许泛型为实现Comparable接口的实现类的引用调用**</li>
</ul>
</li>
</ul>
<pre><code class="java">//? extends A:
//        G&lt;? extends A&gt;可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类
//? super A:
//        G&lt;? super A&gt;可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类
List&lt;? extends Person&gt; list1 = null;
List&lt;? super Person&gt; list2 = null;

List&lt;Student&gt; list3 = null;
List&lt;Person&gt; list4 = null;
List&lt;Object&gt; list5 = null;

list1 = list3;
list1 = list4;
//list1 = list5;//编译失败，因为Object是Person的父类，而? extends Person指明的集合只能由Person及其子类可以调用

//list2 = list3;//编译失败，因为Student是Person的子类，而? super Person指明的集合只能由Person及其父类可以调用
list2 = list4;
list2 = list5;

//读取数据:
list1 = list3;
Person p = list1.get(0);//Object o = list1.get(0)也可以获取，但声明的类型最小只能是Person，不能是Student
//编译不通过
//Student s = list1.get(0);

list2 = list4;
//编译不通过
//Person p1 = list2.get(0);
Object o = list2.get(0);//可以获取，但声明的类型只能是Object

//写入数据
//编译不通过
//list1.add(new Person());//添加的Person类型有是list1中数据的类型的父类的可能，即?指的数据类型可能比Person更小
//list1.add(new Student());//添加的Student类型也有是list1中数据的类型的父类的可能，即?指的数据类型可能比Student更小

//编译通过
list2.add(new Person());//?指的是Person及其父类，那么list2中存的数据类型最小都是Person类型和其子类，所以Person类型可以添加
list2.add(new Student());//Student是Person的子类，所以也可以添加
//list2.add(new Object());//不能添加因为有可能?指的是Person和Object之间的类型，那么此时Object就是其中数据类型的父类，则添加不成功
</code></pre>
<h3 id="11-5-练习"><a href="#11-5-练习" class="headerlink" title="11.5 练习"></a>11.5 练习</h3><pre><code class="java">定义个泛型类DAO&lt;T&gt;,在其中定义一个Map成员变量，Map的键为String类型，值为T类型。
分别创建以下方法: 
public void save(String id,T entity):保存T类型的对象到Map成员变量中
public T get(Stringid):从map中获取id 对应的对象
public void update(String id,T entity):替换map中key为id的内容，改为entity对象
public List&lt;T&gt; list():返回map中存放的所有T对象
public void delete(String id):删除指定id 对象

定义一个User类:
该类包含: private成员变量(int类型) id, age; (String类型) name

定义一个测试类:
创建DAO类的对象，分别调用其save、get、update、list、 delete方法来操作User对象
使用Junit 单元测试类进行测试
</code></pre>
<pre><code class="java">public class DAO&lt;T&gt; &#123;
    //由于存入map的key是单独的String类型，则key-value的存储位置是String类中的HashCode()和equals()决定
    // 所以就没有必要在User中重写HashCode()，但是equals()有必要重写，因为可能会涉及到判断key对应的value值的一些情况
    public Map&lt;String,T&gt; map = new HashMap&lt;&gt;();

    public void save(String id,T entity)&#123;
        map.put(id,entity);
    &#125;
    public T get(String id)&#123;
        return map.get(id);
    &#125;
    public void update(String id,T entity)&#123;
        if (map.containsKey(id))&#123;
            map.put(id,entity);
        &#125;
        //map.replace(id,entity);//方法二
    &#125;
    public List&lt;T&gt; list()&#123;
        //错误的
        //Collection&lt;T&gt; values = map.values();
        //return (List&lt;T&gt;)values;
        //正确的
        ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;();
        Collection&lt;T&gt; values = map.values();
        for (T value : values) &#123;
            list.add(value);
        &#125;
        return list;
    &#125;
    public void delete(String id)&#123;
        map.remove(id);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class User &#123;
    private int id;
    private int age;
    private String name;

    public User() &#123;
    &#125;
    public User(int id, int age, String name) &#123;
        this.id = id;
        this.age = age;
        this.name = name;
    &#125;
    public int getId() &#123;
        return id;
    &#125;
    public void setId(int id) &#123;
        this.id = id;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;User&#123;&quot; +
                &quot;id=&quot; + id +
                &quot;, age=&quot; + age +
                &quot;, name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &#39;&#125;&#39;;
    &#125;
    @Override
    public boolean equals(Object o) &#123;
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        User user = (User) o;
        if (id != user.id) return false;
        if (age != user.age) return false;
        return name.equals(user.name);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class DAOTest &#123;
    @Test
    public void Test()&#123;
        DAO&lt;User&gt; userDAO = new DAO&lt;&gt;();
        User user1 = new User(1,10,&quot;Tom&quot;);
        User user2 = new User(2,34,&quot;Jerry&quot;);
        User user3 = new User(3,23,&quot;Jack&quot;);
        User user4 = new User(4,14,&quot;Eric&quot;);
        User user5 = new User(5,25,&quot;Mary&quot;);
        userDAO.save(&quot;1001&quot;,user1);//save方法测试
        userDAO.save(&quot;1002&quot;,user2);
        userDAO.save(&quot;1003&quot;,user3);
        userDAO.save(&quot;1004&quot;,user4);
        userDAO.save(&quot;1005&quot;,user5);
        List&lt;User&gt; list = userDAO.list();//list()方法测试
        list.forEach(System.out::println);
        System.out.println(&quot;======================&quot;);
        userDAO.update(&quot;1003&quot;,new User(3,25,&quot;Jack&quot;));//update()方法测试
        List&lt;User&gt; list1 = userDAO.list();
        list1.forEach(System.out::println);
        System.out.println(&quot;======================&quot;);
        User user = userDAO.get(&quot;1002&quot;);//get()方法测试
        System.out.println(user);
        System.out.println(&quot;======================&quot;);
        userDAO.delete(&quot;1004&quot;);//delete()方法测试
        List&lt;User&gt; list2 = userDAO.list();
        list2.forEach(System.out::println);
        //输出结果:
        /*
            User&#123;id=5, age=25, name=&#39;Mary&#39;&#125;
            User&#123;id=4, age=14, name=&#39;Eric&#39;&#125;
            User&#123;id=3, age=23, name=&#39;Jack&#39;&#125;
            User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125;
            User&#123;id=1, age=10, name=&#39;Tom&#39;&#125;
            ======================
            User&#123;id=5, age=25, name=&#39;Mary&#39;&#125;
            User&#123;id=4, age=14, name=&#39;Eric&#39;&#125;
            User&#123;id=3, age=25, name=&#39;Jack&#39;&#125;
            User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125;
            User&#123;id=1, age=10, name=&#39;Tom&#39;&#125;
            ======================
            User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125;
            ======================
            User&#123;id=5, age=25, name=&#39;Mary&#39;&#125;
            User&#123;id=3, age=25, name=&#39;Jack&#39;&#125;
            User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125;
            User&#123;id=1, age=10, name=&#39;Tom&#39;&#125;
         */
    &#125;
&#125;
</code></pre>
<h2 id="十二、Java-IO流"><a href="#十二、Java-IO流" class="headerlink" title="十二、Java IO流"></a>十二、Java IO流</h2><h3 id="12-1-File类的使用"><a href="#12-1-File类的使用" class="headerlink" title="12.1 File类的使用"></a>12.1 File类的使用</h3><p> java.io.File类：<strong>文件和文件目录路径的抽象表示形式</strong>，与平台无关，**File类的一个对象，代表一个文件或一个文件目录(**俗称：文件夹)</p>
<p>File<strong>能新建、删除、重命名文件和目录</strong>，但File<strong>不能访问文件内容本身</strong>。如果需要<strong>访问文件内容本身，则需要使用输入/输出流（Input/Output）</strong>，到时<strong>File对象会经常作为参数传递给流的构造器</strong></p>
<p>想要在<strong>Java程序中</strong>表示<strong>一个真实存在的文件或目录，那么必须有一个File对象</strong>，但是Java程序中的<strong>一个File对象，可能没有一个真实存在的文件或目录</strong></p>
<p>当一个File对象是否有在硬件中对应的文件或文件目录存在或不存在时：</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643400.png' data-fancybox='default' data-caption='image-20210807161256849'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643400.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201643400.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210807161256849"></a><span class='image-caption'>image-20210807161256849</span></div></div>

<h4 id="12-1-1-常用构造器"><a href="#12-1-1-常用构造器" class="headerlink" title="12.1.1 常用构造器"></a>12.1.1 常用构造器</h4><p>public File(String pathname)：<strong>以pathname为路径创建File对象</strong>，可以是绝对路径或者相对路径，<strong>如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储</strong></p>
<ul>
<li>绝对路径：是一个固定的路径，从盘符开始</li>
<li>相对路径：是相对于某个位置开始</li>
</ul>
<p>public File(String parent,String child)：<strong>以parent为父路径，child为子路径创建File对象</strong></p>
<p>public File(File parent,String child)：<strong>根据一个父File对象和子文件路径创建File对象</strong></p>
<pre><code class="java">//实例化：此时实例化出来的File对象都只是内存层面的，还没有真正的创建出一个文件或目录到硬盘层面
//相对路径：相较于某个路径下，指明的路径
//绝对路径：包含盘符在内的文件或文件目录的路径

//创建实例化对象方式一:public File(String pathname)
File file = new File(&quot;hello.txt&quot;);//相对路径，相对于当前项目或模块下
File file1 = new File(&quot;E:\\桌面文件\\IOTest\\hello.txt&quot;);//绝对路径
System.out.println(file);//hello.txt
System.out.println(file1);//E:\桌面文件\IOTest\hello.txt

//创建实例化对象方式二:public File(String parent,String child)
File file2 = new File(&quot;E:\\桌面文件\\IOTest&quot;,&quot;IOHello&quot;);//parent路径指的是我们要创建文件或目录到哪个文件目录下，而child是我们要创建的文件或目录的名字
System.out.println(file2);//E:\桌面文件\IOTest\IOHello

//创建实例化对象方式三:public File(File parent,String child)
File file3 = new File(file2,&quot;hello.txt&quot;);//这里的parent是个File对象，说明是我们预先创建好的一个File对象，然后在这个对象(目录)下再创建一个新的文件或目录
System.out.println(file3);//E:\桌面文件\IOTest\IOHello\hello.txt
</code></pre>
<h4 id="12-1-2-路径分隔符"><a href="#12-1-2-路径分隔符" class="headerlink" title="12.1.2 路径分隔符"></a>12.1.2 路径分隔符</h4><p>路径中的每级目录之间用一个路径分隔符隔开。</p>
<p>路径分隔符和系统有关：</p>
<ul>
<li><p>windows和DOS系统默认使用“\” 来表示</p>
</li>
<li><p>UNIX和URL使用“/”来表示</p>
</li>
</ul>
<p>Java程序支持跨平台运行，因此路径分隔符要慎用。为了解决这个隐患，File类提供了一个常量：public static final String separator。<strong>根据操作系统，动态的提供分隔符</strong></p>
<p>举例：</p>
<pre><code class="java">File file1 = new File(&quot;d: \\atguigu\\info.txt&quot;);
File file2 = new File(&quot;d:&quot; + File.separator + &quot;atguigu&quot; + File.separator + &quot;info.txt&quot;);
File file3 = new File(&quot;d:/atguigu&quot;);
</code></pre>
<h4 id="12-1-3-File类的常用方法"><a href="#12-1-3-File类的常用方法" class="headerlink" title="12.1.3 File类的常用方法"></a>12.1.3 File类的常用方法</h4><h5 id="1-File类的获取功能"><a href="#1-File类的获取功能" class="headerlink" title="1.File类的获取功能"></a>1.File类的获取功能</h5><ul>
<li>public String getAbsolutePath()：<strong>获取绝对路径</strong></li>
<li>public String getPath()：<strong>获取路径</strong></li>
<li>public String getName()：<strong>获取名称</strong></li>
<li>public String getParent()：<strong>获取上层文件目录路径</strong>。若无，返回null</li>
<li>public long length()：**获取文件长度(即:字节数)**。不能获取目录的长度</li>
<li>public long lastModified()：<strong>获取最后次的修改时间</strong>，毫秒值</li>
<li>public String[] list()：<strong>获取指定目录下的所有文件</strong>或者<strong>文件目录的名称数组</strong>（适用于文件目录）</li>
<li>public File[] listFiles()：<strong>获取指定目录下的所有文件</strong>或者<strong>文件目录的File数组</strong>（适用于文件目录）</li>
</ul>
<pre><code class="java">File file1 = new File(&quot;hello.txt&quot;);//相对路径
File file2 = new File(&quot;E:\\桌面文件\\IOTest\\hello.txt&quot;);//绝对路径
//在没有创建实体文件的情况下，length和lastModified都为0
//public String getAbsolutePath()：获取绝对路径
System.out.println(file1.getAbsoluteFile());//E:\JavaProject\IDEAProject\自主练习\Demo\hello.txt
//public String getAbsolutePath()：获取绝对路径
System.out.println(file1.getPath());//hello.txt
//public String getName()：获取名称
System.out.println(file1.getName());//hello.txt
//public String getParent()：获取上层文件目录路径。若无，返回null
System.out.println(file1.getParent());//null
//public long length()：获取文件长度(即:字节数)。不能获取目录的长度
System.out.println(file1.length());//0
//public long lastModified()：获取最后次的修改时间，毫秒值
System.out.println(file1.lastModified());//0
System.out.println();
System.out.println(file2.getAbsoluteFile());//E:\桌面文件\IOTest\hello.txt
System.out.println(file2.getPath());//E:\桌面文件\IOTest\hello.txt
System.out.println(file2.getName());//hello.txt
System.out.println(file2.getParent());//E:\桌面文件\IOTest
System.out.println(file2.length());//0
System.out.println(file2.lastModified());//0
</code></pre>
<pre><code class="java">File file = new File(&quot;E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src&quot;);
//public String[] list()：获取指定目录下的所有文件或者文件目录的名称数组
String[] list = file.list();
for (String s : list) &#123;
    System.out.println(s);//Annotation array Collection CommonClass enumeration Generic IO oop Test Thread
&#125;
//public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File数组
File[] files = file.listFiles();
for (File file1 : files) &#123;
    System.out.println(file1);
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\Annotation
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\array
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\Collection
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\CommonClass
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\enumeration
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\Generic
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\IO
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\oop
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\Test
    //E:\JavaProject\IDEAProject\Exercises\Demo\src\Thread
&#125;
</code></pre>
<h5 id="2-File类的重命名功能"><a href="#2-File类的重命名功能" class="headerlink" title="2.File类的重命名功能"></a>2.File类的重命名功能</h5><p>public boolean renameTo(File dest)：把<strong>文件重命名为指定的文件路径</strong></p>
<pre><code class="java">//比如: file1.renameTo(file2)为例:
//要想保证返回true, 需要file1在硬盘中是存在的，而file2不能在指定路径的硬盘中已经存在
//当file1.renameTo(file2)成功后，再file2.renameTo(file1)也能将文件重新拿回来，说明文件需要被剪切到到的位置也可以用相对路径
File file1 = new File(&quot;hello.txt&quot;);
File file2 = new File(&quot;E:\\桌面文件\\IOTest\\hi.txt&quot;);
boolean b = file1.renameTo(file2);
System.out.println(b);
</code></pre>
<h5 id="3-File类的判断功能"><a href="#3-File类的判断功能" class="headerlink" title="3.File类的判断功能"></a>3.File类的判断功能</h5><ul>
<li>public boolean isDirectory()：判断<strong>是否是文件目录</strong></li>
<li>public boolean isFile()：判断<strong>是否是文件</strong></li>
<li>public boolean exists()：判断<strong>是否存在</strong></li>
<li>public boolean canRead()：判断<strong>是否可读</strong></li>
<li>public boolean canWrite()：判断<strong>是否可写</strong></li>
<li>public boolean isHidden()：判断<strong>是否隐藏</strong></li>
</ul>
<pre><code class="java">
File file = new File(&quot;hello.txt&quot;);
//public boolean isFile()：判断是否是文件目录
System.out.println(file.isDirectory());//false
//public boolean isFile()：判断是否是文件
System.out.println(file.isFile());//true
//public boolean exists()：判断是否存在
System.out.println(file.exists());//true
//public boolean canRead()：判断是否可写
System.out.println(file.canRead());//true
//public boolean canWrite()：判断是否可写
System.out.println(file.canWrite());//true
//public boolean isHidden()：判断是否隐藏
System.out.println(file.isHidden());//false
File file1 = new File(&quot;E:\\桌面文件\\IOTest&quot;);
System.out.println(file1.isDirectory());//true
System.out.println(file1.isFile());//false
System.out.println(file1.exists());//true
System.out.println(file1.canRead());//true
System.out.println(file1.canWrite());//true
System.out.println(file1.isHidden());//false//public boolean isDirectory()：判断是否是文件目录
</code></pre>
<h5 id="4-File类的创建功能"><a href="#4-File类的创建功能" class="headerlink" title="4.File类的创建功能"></a>4.File类的创建功能</h5><ul>
<li>public boolean createNewFile()：<strong>创建文件</strong>。若文件存在， 则不创建，返回false</li>
<li>public boolean mkdir()：<strong>创建文件目录</strong>。如果此<strong>文件目录存在，就不创建</strong>了。如果此文件目录的<strong>上层目录不存在，也不创建</strong></li>
<li>public boolean mkdirs()：<strong>创建文件目录。如果上层文件目录不存在， 一并创建</strong></li>
<li>注意事项：如果你<strong>创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下</strong></li>
</ul>
<h5 id="5-File类的删除功能"><a href="#5-File类的删除功能" class="headerlink" title="5.File类的删除功能"></a>5.File类的删除功能</h5><ul>
<li>public boolean delete()：<strong>删除文件或者文件夹</strong></li>
<li>删除注意事项：<strong>Java中的删除不走回收站</strong></li>
<li>要<strong>删除一个文件目录</strong>，请注意<strong>该文件目录内不能包含文件或者文件目录</strong></li>
</ul>
<pre><code class="java">//文件创建
File file = new File(&quot;hello.txt&quot;);
if(!file.exists())&#123;//文件不存在
    //public boolean createNewFile()：创建文件
    file.createNewFile();
    System.out.println(&quot;创建成功&quot;);
&#125;else&#123;//文件存在
    //public boolean delete()：删除文件或者文件夹
    file.delete();
    System.out.println(&quot;删除成功&quot;);
&#125;
//文件目录的创建
//当要创建的文件目录的上层目录存在时，mkdir和mkdirs的作用效果都一样
//当要创建的文件目录的上层目录不存在时，只有mkdirs能创建成功
File file1 = new File(&quot;E:\\桌面文件\\IOTest\\IOTest01&quot;);
boolean mkdir = file1.mkdir();
if (mkdir)&#123;
    System.out.println(&quot;创建成功1&quot;);
&#125;
File file2 = new File(&quot;E:\\桌面文件\\IOTest\\IOTest02&quot;);
boolean mkdir1 = file2.mkdirs();
if(mkdir1)&#123;
    System.out.println(&quot;创建成功2&quot;);
&#125;
</code></pre>
<h5 id="6-File类练习"><a href="#6-File类练习" class="headerlink" title="6.File类练习"></a>6.File类练习</h5><pre><code class="java">1.利用File构造器，new一个文件目录file
1)在其中创建多个文件和目录
2)编写方法，实现删除file中指定文件的操作

2.判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称

3.遍历指定目录所有文件名称，包括子文件目录中的文件。
拓展1:并计算指定目录占用空间的大小
拓展2:删除指定文件目录及其下的所有文件
</code></pre>
<h3 id="12-2-IO流原理及流的分类"><a href="#12-2-IO流原理及流的分类" class="headerlink" title="12.2 IO流原理及流的分类"></a>12.2 IO流原理及流的分类</h3><p>I/O是Input/Output的缩写，I/O技术是非常实用的技术，<strong>用于处理设备之间的数据传输</strong>。如读/写文件，网络通讯等</p>
<p>Java程序中，对于<strong>数据的输入/输出操作以“流(stream)”的方式进行</strong></p>
<p>java.io包下提供了<strong>各种“流”类和接口，用以获取不同种类的数据</strong>，并<strong>通过标准的方法输入或输出数据</strong></p>
<h4 id="12-2-1-IO流的原理"><a href="#12-2-1-IO流的原理" class="headerlink" title="12.2.1 IO流的原理"></a>12.2.1 IO流的原理</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644370.png' data-fancybox='default' data-caption='image-20210807170244977'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644370.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644370.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210807170244977"></a><span class='image-caption'>image-20210807170244977</span></div></div>

<h4 id="12-2-2-流的分类"><a href="#12-2-2-流的分类" class="headerlink" title="12.2.2 流的分类"></a>12.2.2 流的分类</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644853.png' data-fancybox='default' data-caption='image-20210807170938002'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644853.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644853.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210807170938002"></a><span class='image-caption'>image-20210807170938002</span></div></div>

<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644344.png' data-fancybox='default' data-caption='image-20210807171355287'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644344.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201644344.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210807171355287"></a><span class='image-caption'>image-20210807171355287</span></div></div>

<h4 id="12-2-3-IO流的体系结构"><a href="#12-2-3-IO流的体系结构" class="headerlink" title="12.2.3 IO流的体系结构"></a>12.2.3 IO流的体系结构</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645856.png' data-fancybox='default' data-caption='image-20210807172114754'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645856.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645856.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210807172114754"></a><span class='image-caption'>image-20210807172114754</span></div></div>

<h3 id="12-3-节点流-或文件流"><a href="#12-3-节点流-或文件流" class="headerlink" title="12.3 节点流(或文件流)"></a>12.3 节点流(或文件流)</h3><h4 id="12-3-1-FileReader类"><a href="#12-3-1-FileReader类" class="headerlink" title="12.3.1 FileReader类"></a>12.3.1 FileReader类</h4><p>从硬盘读入数据到内存</p>
<h5 id="1-使用FileReader类read-实现数据的读入"><a href="#1-使用FileReader类read-实现数据的读入" class="headerlink" title="1.使用FileReader类read()实现数据的读入"></a>1.使用FileReader类read()实现数据的读入</h5><pre><code class="java">//说明点:
//1. read()的理解:返回读入的一个字符。如果达到文件末尾，返回-1
//2.异常的处理:为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理
//3.读入的文件一定要存在，否则就会报FileNotFoundException
@Test
public void TestFileReader() &#123;
    FileReader fileReader = null;
    try &#123;
        //1.实例化File类的对象，指明要操作的文件
        File file = new File(&quot;hello.txt&quot;);
        //2.提供具体的流
        fileReader = new FileReader(file);
        //3.数据读入
        //read():返回读入的一个字符，如果达到文件内容末尾，返回-1
        //方式一：
        //int data = fileReader.read();
        //while (data != -1)&#123;
        //    System.out.print((char) data);
        //  data = fileReader.read();
        //&#125;
        //方式二：
        int data;
        while ((data = fileReader.read()) != -1)&#123;
            System.out.print((char) data);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.流的关闭操作
        //(1)一般情况下是：先打开的后关闭，后打开的先关闭
        //(2)另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b
        //(3)可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法
        try &#123;//此处的if和try-catch嵌套，谁在外面都行
            if(fileReader != null)
                fileReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2-使用FileReader类read-char-cbuf-实现数据的读入"><a href="#2-使用FileReader类read-char-cbuf-实现数据的读入" class="headerlink" title="2.使用FileReader类read(char[] cbuf)实现数据的读入"></a>2.使用FileReader类read(char[] cbuf)实现数据的读入</h5><pre><code class="java">//对read()操作升级：使用read重载方法，一次性读取几个字符存入数组
@Test
public void TestFileReader1()&#123;
    FileReader fileReader = null;
    try &#123;
        //1.File类的实例化
        File file = new File(&quot;hello.txt&quot;);
        //2.FileReader流的实例化
        fileReader = new FileReader(file);
        //3.读入的操作
        //read(char cbuf):返回每次读入cbuf数组中的字符的个数，如果达到文件内容末尾，则返回-1
        char[] cbuffer = new char[5];
        int len;
        while ((len = fileReader.read(cbuffer)) != -1)&#123;
            //方法一：
            for (int i = 0; i &lt; len; i++) &#123;//不能写好i&lt;cbuffer.length，因为每次读取数组中的字符都会覆盖上次读取，当最后几个字符的长度不足于填充满数组，那么最后一次遍历就会把没有被覆盖掉的几个字符也输出出来，所以我们应该读取几个字符就遍历输出几个
                System.out.print(cbuffer[i]);
            &#125;
            //方法二：
            //String str = new String(cbuffer);
            //System.out.println(str);//也是错误的,跟上方for循环i&lt;cbuffer.length一样的逻辑
            String str = new String(cbuffer,0,len);
            System.out.println(str);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.资源的关闭
        try &#123;
        if (fileReader != null)
            fileReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-2-FileWriter类"><a href="#12-3-2-FileWriter类" class="headerlink" title="12.3.2 FileWriter类"></a>12.3.2 FileWriter类</h4><p>从内存写出数据到硬盘</p>
<pre><code class="java">//说明:
//1.输出操作，对应的File可以不存在的。不会报异常
//2.File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件
//File对应的硬盘中的文件如果存在:
//        如果流使用的构造器是:Filewriter(file,false)/Filewriter(file):对原有文件进行覆盖
//        如果流使用的构造器是:Filewriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容
@Test
public void TestFileWriter()&#123;
    FileWriter fileWriter = null;
    try &#123;
        //1.实例化File类对象
        File file = new File(&quot;hello1.txt&quot;);
        //2.实例化FileWriter对象
        fileWriter = new FileWriter(file);
        //3.写出操作
        fileWriter.write(&quot;I have a dream!\n&quot;);
        fileWriter.write(&quot;you should have a dream,too!&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.关闭流
        try &#123;
            if (fileWriter != null)
                fileWriter.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-3-FileReader和FileWriter实现文本内容的复制"><a href="#12-3-3-FileReader和FileWriter实现文本内容的复制" class="headerlink" title="12.3.3 FileReader和FileWriter实现文本内容的复制"></a>12.3.3 FileReader和FileWriter实现文本内容的复制</h4><pre><code class="java">@Test
public void TestFileReaderFileWriter()&#123;
    FileReader fileReader = null;
    FileWriter fileWriter = null;
    try &#123;
        //1.创建File类的对象，指明读入和写出的文件
        File in = new File(&quot;hello1.txt&quot;);
        File out = new File(&quot;hello2.txt&quot;);
        //2.创建输入流和输出流的对象
        fileReader = new FileReader(in);
        fileWriter = new FileWriter(out);
        //3.数据的读入和写出操作
        char[] input = new char[5];
        int len;//记录每次读取到的字符个数
        while ((len = fileReader.read(input)) != -1)&#123;
            String output = new String(input,0,len);
            fileWriter.write(output);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.关闭流资源
        //方法一：
        try &#123;
            if (fileReader != null)
                fileReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            try &#123;
                if (fileWriter != null) 
                fileWriter.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        //方法二：
        try &#123;
            if (fileReader != null)
                fileReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (fileWriter != null)
                fileWriter.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-4-字符流不能处理图片的测试"><a href="#12-3-4-字符流不能处理图片的测试" class="headerlink" title="12.3.4 字符流不能处理图片的测试"></a>12.3.4 字符流不能处理图片的测试</h4><pre><code class="java">@Test
public void TestCopyImage()&#123;
    //测试失败，文件能复制，但不能打开。不能用字符流来处理图片等的字节数据
    FileReader fileReader = null;
    FileWriter fileWriter = null;
    try &#123;
        //1.创建File类的对象，指明读入和写出的图片
        File in = new File(&quot;TestImage.jpg&quot;);
        File out = new File(&quot;TestImage1.jpg&quot;);
        //2.创建输入流和输出流的对象
        fileReader = new FileReader(in);
        fileWriter = new FileWriter(out);
        //3.数据的读入和写出操作
        char[] input = new char[5];
        int len;//记录每次读取到的字符个数
        while ((len = fileReader.read(input)) != -1)&#123;
            String output = new String(input,0,len);
            fileWriter.write(output);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (fileReader != null)
                fileReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (fileWriter != null)
                fileWriter.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-5-FileInputStream不能读取文本的测试"><a href="#12-3-5-FileInputStream不能读取文本的测试" class="headerlink" title="12.3.5 FileInputStream不能读取文本的测试"></a>12.3.5 FileInputStream不能读取文本的测试</h4><pre><code class="java">//结论:可以使用字节流FileInputstream处理文本文件，但可能会出现中文乱码
//1．对于文本文件( .txt,.java,.c,.cpp)，使用字符流处理（建议）
//2．对于非文本文件(.jpg,.mp3 , .mp4,.avi,.doc,.ppt,. . .)，使用字节流处理（必须）
@Test
public void TestFileInputStreamText()&#123;
    FileInputStream fileInputStream = null;
    try &#123;
        //1.创建File对象
        File file = new File(&quot;hello.txt&quot;);
        //2.创建FileInputStream对象
        fileInputStream = new FileInputStream(file);
        //3.读取数据
        byte[] data = new byte[5];
        int len;//记录读取的字节个数
        while ((len = fileInputStream.read(data)) != -1)&#123;
            String str = new String(data,0,len);
            System.out.print(str);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.关闭流
        try &#123;
            if (fileInputStream != null)
                fileInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-6-FileInputStream和FileOutputStream读写非文本文件"><a href="#12-3-6-FileInputStream和FileOutputStream读写非文本文件" class="headerlink" title="12.3.6 FileInputStream和FileOutputStream读写非文本文件"></a>12.3.6 FileInputStream和FileOutputStream读写非文本文件</h4><pre><code class="java">//能复制成功
@Test
public void TestFileInputOutputStream()&#123;
    //实现图片的复制
    FileInputStream fileInputStream = null;
    FileOutputStream fileOutputStream = null;
    try &#123;
        //1.创建File类的对象，指明读入和写出的图片
        File in = new File(&quot;TestImage.jpg&quot;);
        File out = new File(&quot;TestImage1.jpg&quot;);
        //2.创建输入流和输出流的对象
        fileInputStream = new FileInputStream(in);
        fileOutputStream = new FileOutputStream(out);
        //3.数据的读入和写出操作
        byte[] input = new byte[5];
        int len;//记录每次读取到的字符个数
        while ((len = fileInputStream.read(input)) != -1)&#123;
            fileOutputStream.write(input,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (fileInputStream != null)
                fileInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (fileOutputStream != null)
                fileOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-3-7-FileInputStream和FileOutputStream复制文件的方法测试"><a href="#12-3-7-FileInputStream和FileOutputStream复制文件的方法测试" class="headerlink" title="12.3.7 FileInputStream和FileOutputStream复制文件的方法测试"></a>12.3.7 FileInputStream和FileOutputStream复制文件的方法测试</h4><pre><code class="java">//此时，复制成功的文本，点开文件查看不会乱码
//而在12.3.5中使用FileInputStream读入文本内容出现乱码是因为我们在读取数据后输出到控制台进行查看，这样会导致中文字符的字节被截断，而现在我们是在文本数据完整地读取和写出过后在文件中查看，此时中文字符的字节就不会被截断，所以就不会出现乱码
public void copy(String srcPath,String destPath)&#123;
    FileInputStream fileInputStream = null;
    FileOutputStream fileOutputStream = null;
    try &#123;
        //1.创建File类的对象，指明读入和写出的图片
        File in = new File(srcPath);
        File out = new File(destPath);
        //2.创建输入流和输出流的对象
        fileInputStream = new FileInputStream(in);
        fileOutputStream = new FileOutputStream(out);
        //3.数据的读入和写出操作
        byte[] input = new byte[1024];
        int len;//记录每次读取到的字符个数
        while ((len = fileInputStream.read(input)) != -1)&#123;
            fileOutputStream.write(input,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (fileInputStream != null)
                fileInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (fileOutputStream != null)
                fileOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
@Test
public void TestCopy()&#123;
    String srcPath = &quot;E:\\桌面文件\\IOTest\\[乒乓球].ts&quot;;
    String destPath = &quot;E:\\桌面文件\\IOTest\\[乒乓球复制版].ts&quot;;
    long start = System.currentTimeMillis();
    copy(srcPath,destPath);
    long end = System.currentTimeMillis();
    System.out.println(&quot;复制用时：&quot; + (end - start));
&#125;
</code></pre>
<h3 id="12-4-缓冲流-处理流之一"><a href="#12-4-缓冲流-处理流之一" class="headerlink" title="12.4 缓冲流(处理流之一)"></a>12.4 缓冲流(处理流之一)</h3><p>作用：<strong>提高流的读取、写入速度</strong></p>
<p>由于缓冲流是作用于节点流上的，只是将节点流读取的数据放入了一个缓存数组中，所以在缓冲流中有一个<strong>flush()<strong>方法来</strong>刷新缓冲区</strong>，但我们不用显示地调用flush来进行刷新，因为在源码中它已经调用此方法来进行自动刷新</p>
<h4 id="12-4-1-字节流型"><a href="#12-4-1-字节流型" class="headerlink" title="12.4.1 字节流型"></a>12.4.1 字节流型</h4><pre><code class="java">//经过测试，缓冲流对文件的复制的确比节点流的速度快
@Test
public void TestBuffer()&#123;
    BufferedInputStream bis = null;
    BufferedOutputStream bos = null;
    try &#123;
        //1.实例化File
        File srcFile = new File(&quot;E:\\桌面文件\\IOTest\\[乒乓球].ts&quot;);
        File destFile = new File(&quot;E:\\桌面文件\\IOTest\\[乒乓球缓冲流复制版].ts&quot;);
        //2.实例化流对象：先实例化内层的流，再实例化外层的流
        //2.1 实例化节点流
        FileInputStream fileInputStream = new FileInputStream(srcFile);
        FileOutputStream fileOutputStream = new FileOutputStream(destFile);
        //2.2 实例化缓冲流
        bis = new BufferedInputStream(fileInputStream);
        bos = new BufferedOutputStream(fileOutputStream);
        //3.文件的赋值
        byte[] buffer = new byte[1024];
        int len;
        while ((len = bis.read(buffer)) != -1)&#123;
            bos.write(buffer,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //4.资源关闭
        //要求：先关闭外层的流，再关闭内层的流
        //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略
        try &#123;
            if (bis != null)
                bis.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (bos != null)
                bos.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-4-2-字符流型"><a href="#12-4-2-字符流型" class="headerlink" title="12.4.2 字符流型"></a>12.4.2 字符流型</h4><pre><code class="java">@Test
public void TestBufferReaderWriter()&#123;
    BufferedReader br = null;
    BufferedWriter bw = null;
    try &#123;
        //1.实例化流和文件对象
        br = new BufferedReader(new FileReader(new File(&quot;hello1.txt&quot;)));
        bw = new BufferedWriter(new FileWriter(new File(&quot;hello2.txt&quot;)));
        //2.复制文件
        //方式一：使用char[]数组
        //char[] cbuf = new char[1024];
        //int len;
        //while ((len = br.read(cbuf)) != -1)&#123;
        //    bw.write(cbuf,0,len);
        //   //bw.flush();
        //&#125;
        //方式二：使用String
        String data;
        while ((data = br.readLine()) != null)&#123;
            bw.write(data + &quot;\n&quot;);//data不包含换行符
            //也可以调用bw.newLine()进行换行
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //3.关闭资源
        try &#123;
            if (br != null)
                br.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (bw != null)
                bw.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-4-3-缓冲流练习"><a href="#12-4-3-缓冲流练习" class="headerlink" title="12.4.3 缓冲流练习"></a>12.4.3 缓冲流练习</h4><pre><code class="java">1.分别使用节点流:FilelnputStream、FileOutputStream和缓冲流:BufferedInputStream、BufferedOutputStream实现文本/文件/图片/视频文件的复制。并比较二者在数据复制方面的效率
2.实现图片加密操作。
提示:
int b = 0;
while((b = fis.read()) != -1)&#123;
    fos.write(b ^ 5);
&#125;
3.获取文本上每个字符出现的次数
提示:遍历文本的每一个字符;字符及出现的次数保存在Map中;将Map中数据写入文件
</code></pre>
<h3 id="12-5-转换流-处理流之二"><a href="#12-5-转换流-处理流之二" class="headerlink" title="12.5 转换流(处理流之二)"></a>12.5 转换流(处理流之二)</h3><p>转换流提供了在<strong>字节流和字符流之间的转换</strong></p>
<p>Java API提供了两个转换流：</p>
<ul>
<li><strong>lnputStreamReader：将lnputStream转换为Reader</strong></li>
<li><strong>OutputStreamWriter:将Writer转换为OutputStream</strong></li>
</ul>
<p>字节流中的数据都是字符时，转成字符流操作更高效</p>
<p>很多时候我们使用<strong>转换流来处理文件乱码</strong>问题。<strong>实现编码和解码的功能</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645264.png' data-fancybox='default' data-caption='image-20210808140840759'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645264.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645264.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210808140840759"></a><span class='image-caption'>image-20210808140840759</span></div></div>

<h4 id="12-5-1-InputStreamReader"><a href="#12-5-1-InputStreamReader" class="headerlink" title="12.5.1 InputStreamReader"></a>12.5.1 InputStreamReader</h4><pre><code class="java">//处理流之二:转换流的使用
//1.转换流:属于字符流
//  InputStreamReader:将一个字节的输入流转换为字符的输入流
//  OutputStreamWriter:将一个字符的输出流转换为字节的输出流
//2.作用:提供字节流与字符流之间的转换
//3.解码:字节、字节数组---&gt;字符数组、字符串
//  编码:字符数组、字符串---&gt;字节、字节数组
//4.字符集
@Test
public void TestInputStreamReader()&#123;
    InputStreamReader inputStreamReader = null;
    try &#123;
        FileInputStream fileInputStream = new FileInputStream(&quot;hello1.txt&quot;);
        //参数2指明了字符集，具体使用哪个字符集，取决于读入文件保存时使用的字符集
        //InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);//使用系统默认的字符集
        inputStreamReader = new InputStreamReader(fileInputStream,&quot;UTF-8&quot;);
        char[] cbuf = new char[20];
        int len;
        while ((len = inputStreamReader.read(cbuf)) != -1)&#123;
            String str = new String(cbuf,0,len);
            System.out.println(str);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (inputStreamReader != null)
                inputStreamReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-5-2-OutputStreamWriter"><a href="#12-5-2-OutputStreamWriter" class="headerlink" title="12.5.2 OutputStreamWriter"></a>12.5.2 OutputStreamWriter</h4><pre><code class="java">//InputStreamReader和OutputStreamWriter实现文件的读入和写出
//文件以UTF-8格式读入，以GBK形式写出
@Test
public void TestOutputStreamWriter()&#123;
    InputStreamReader inputStreamReader = null;
    OutputStreamWriter outputStreamWriter = null;
    try &#123;
        FileInputStream fileInputStream = new FileInputStream(new File(&quot;hello2(UTF-8).txt&quot;));
        FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;hello2(GBK).txt&quot;));
        inputStreamReader = new InputStreamReader(fileInputStream,&quot;UTF-8&quot;);
        outputStreamWriter = new OutputStreamWriter(fileOutputStream,&quot;GBK&quot;);
        //数据读写
        char[] cbuf = new char[1024];
        int len;
        while ((len = inputStreamReader.read(cbuf)) != -1)&#123;
            outputStreamWriter.write(cbuf,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if(inputStreamReader != null)
                inputStreamReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (outputStreamWriter != null)
                outputStreamWriter.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-5-3-多种字符编码集的说明"><a href="#12-5-3-多种字符编码集的说明" class="headerlink" title="12.5.3 多种字符编码集的说明"></a>12.5.3 多种字符编码集的说明</h4><p><strong>编码表的由来</strong></p>
<p>计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表</p>
<p><strong>常见的编码表</strong></p>
<ul>
<li>ASCII：<strong>美国标准信息交换码</strong>。用<strong>一个字节的7位可以表示</strong></li>
<li>ISO8859-1：<strong>拉丁码表</strong>。欧洲码表。用<strong>一个字节的8位表示</strong></li>
<li>GB2312：<strong>中国的中文编码表</strong>。<strong>最多两个字节</strong>编码所有字符</li>
<li>GBK：<strong>中国的中文编码表</strong>升级，融合了更多的中文文字符号。<strong>最多两个字节编码</strong></li>
<li>Unicode：<strong>国际标准码</strong>，融合了<strong>目前人类使用的所有字符</strong>。为每个字符分配唯一的字符码。<strong>所有的文字都用两个字节来表示</strong></li>
<li>UTF-8：<strong>变长的编码方式</strong>，<strong>可用1-4个字节来表示一个字符</strong></li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645521.png' data-fancybox='default' data-caption='image-20210808152050497'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645521.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645521.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210808152050497"></a><span class='image-caption'>image-20210808152050497</span></div></div>

<p>Unicode不完美，这里就有三个问题，一个是，我们已经知道，<strong>英文字母只用一个字节表示就够了</strong>，第二个问题是如何才能<strong>区别Unicode和ASCII</strong>?计算机<strong>怎么知道两个字节表示一个符号，而不是分别表示两个符号</strong>呢?第三个，<strong>如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符</strong>，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现</p>
<p>面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，<strong>UTF-8就是每次8个位传输数据</strong>，而<strong>UTF-16就是每次16个位</strong>。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了</p>
<p><strong>Unicode只是定义了一个庞大的、全球通用的字符集</strong>，并为每个字符规定了唯一确定的编号，具体<strong>存储成什么样的字节流，取决于字符编码方案</strong>。<strong>推荐的Unicode编码是UTF-8和UTF-16</strong></p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645177.png' data-fancybox='default' data-caption='image-20210808151906856'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645177.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201645177.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210808151906856"></a><span class='image-caption'>image-20210808151906856</span></div></div>

<p>说明：在标准UTF-8编码中，超出基本多语言范围(BMP-Basic Multilinqual Plane)的字符被编码为4字节格式，但在修正的UTF-8编码中，他们由代理编码对( surrogatepairs )表示，然后这些代理编码对在序列中分别重新编码。结果标准UTF-8编码中需要4个字节的字符，在修正后的UTF-8编码中将需要6个字节</p>
<h3 id="12-6-标准输入、输出流（处理流之三）"><a href="#12-6-标准输入、输出流（处理流之三）" class="headerlink" title="12.6 标准输入、输出流（处理流之三）"></a>12.6 标准输入、输出流（处理流之三）</h3><p>System.in和System.out<strong>分别代表了系统标准的输入和输出设备</strong></p>
<p>默认输入设备是：键盘，输出设备是：显示器</p>
<p><strong>System.in的类型是InputStream</strong>；<strong>System.out的类型是PrintStream</strong>，其<strong>是OutputStream的子类FilterOutputStream的子类</strong></p>
<p>重定向：通过System类的setIn，setOut方法<strong>对默认设备进行改变</strong></p>
<ul>
<li>public static void setln(InputStream in)</li>
<li>public static void setOut(PrintStream out)</li>
</ul>
<pre><code class="java">//1.标准的输入、输出流
//system.in:标准的输入流，默认从键盘输入
//system.out:标准的输出流，默认从控制台输出
public static void main(String[] args) &#123;
    //从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序
    //方法一：使用Scanner，调用next()
    //方法二：使用System.in。System.in --&gt; 转换流 --&gt; BufferReader的readLine()
    BufferedReader bufferedReader = null;//将节点流的字符流进行包装，变成缓冲流
    try &#123;
        InputStreamReader inputStreamReader = new InputStreamReader(System.in);//将标准输入流转换成字符流
        bufferedReader = new BufferedReader(inputStreamReader);//将字符流传入得到一个缓冲字符流
        while (true)&#123;
            System.out.print(&quot;请输入数据：&quot;);
            String data = bufferedReader.readLine();//调用缓冲字符流的readLine()方法读取一行数据
            if (&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data))&#123;//判断是否退出
                System.out.println(&quot;程序结束&quot;);
                break;
            &#125;
            String upperData = data.toUpperCase();//将数据转换成大写
            System.out.println(upperData);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (bufferedReader != null)
                bufferedReader.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="12-7-打印流-处理流之四"><a href="#12-7-打印流-处理流之四" class="headerlink" title="12.7 打印流(处理流之四)"></a>12.7 打印流(处理流之四)</h3><p><strong>实现将基本数据类型的数据格式转化为字符串输出</strong></p>
<p>打印流(只有输出流)：PrintStream和PrintWriter</p>
<ul>
<li>提供了一系列<strong>重载的print()和println()方法，用于多种数据类型的输出</strong></li>
<li>PrintStream和PrintWriter的输出<strong>不会抛出lOException异常</strong></li>
<li>PrintStream和PrintWriter有<strong>自动flush功能</strong></li>
<li>PrintStream<strong>打印的所有字符都使用平台的默认字符编码转换为字节</strong>。在需要<strong>写入字符而不是写入字节的情况下，应该使用PrintWriter 类</strong></li>
<li><strong>System.out返回的是PrintStream的实例</strong></li>
</ul>
<pre><code class="java">@Test
public void TestPrintStreamWriter()&#123;
    PrintStream ps = null;
    try &#123;
        FileOutputStream fos = new FileOutputStream(new File(&quot;hello3.txt&quot;));
        //创建打印输出流，设置为自动刷新模式(写入换行符或字节‘\n’时都会刷新输出缓冲区)
        ps = new PrintStream(fos,true);
        if (ps != null) &#123;//把标准输出流(控制台输出)改成文件
            System.setOut(ps);
        &#125;
        for (int i = 0; i &lt;= 255; i++) &#123; //输出ASCII字符
            System.out.print((char) i);
            if (i % 50 == 0) &#123;//每50个数据一行
                System.out.println(); //换行
            &#125;
        &#125;
    &#125; catch (FileNotFoundException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        if (ps != null)
            ps.close();
    &#125;
&#125;
</code></pre>
<h3 id="12-8-数据流-处理流之五"><a href="#12-8-数据流-处理流之五" class="headerlink" title="12.8 数据流(处理流之五)"></a>12.8 数据流(处理流之五)</h3><p>为了方便地<strong>操作Java语言的基本数据类型和String的数据，可以使用数据流</strong></p>
<p>数据流有两个类：(<strong>用于读取和写出基本数据类型、String类的数据</strong>)</p>
<ul>
<li><strong>DatalnputStream和 DataOutputStream</strong></li>
<li>分别“套接”在 InputStream和l OutputStream子类的流上</li>
</ul>
<p>DatalnputStream中的方法：</p>
<ul>
<li>boolean readBoolean()</li>
<li>byte readByte()</li>
<li>char readChar()</li>
<li>float readFloat()</li>
<li>double readDouble()</li>
<li>short readShort()</li>
<li>long readLong()</li>
<li>int readlnt()</li>
<li>String readUTF()</li>
<li>void readFully(byte[] b)</li>
</ul>
<p>DataOutputStream中的方法：将上述的方法的read改为相应的write即可</p>
<pre><code class="java">@Test
public void TestDataOutputStream()&#123;
    //将内存中的字符串、基本数据类型的变量写出到文件夹中
    DataOutputStream dataOutputStream = null;
    try &#123;
        dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;));
        dataOutputStream.writeUTF(&quot;张三&quot;);
        dataOutputStream.flush();//刷新操作，将内存中的数据写入文件
        dataOutputStream.writeInt(23);
        dataOutputStream.flush();
        dataOutputStream.writeBoolean(true);
        dataOutputStream.flush();
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (dataOutputStream != null)
                dataOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
@Test
public void TestDataInputStream() &#123;
    //将文件中的字符串、基本数据类型数据读取到到内存中
    //注意点：读取文件数据的顺序必须和保存数据的顺序一致
    DataInputStream dataInputStream = null;
    try &#123;
        dataInputStream = new DataInputStream(new FileInputStream(&quot;data.txt&quot;));
        String name = dataInputStream.readUTF();
        int age = dataInputStream.readInt();
        boolean sex = dataInputStream.readBoolean();
        System.out.println(&quot;name = &quot; + name);
        System.out.println(&quot;age = &quot; + age);
        System.out.println(&quot;sex&quot; + sex);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (dataInputStream != null)
                dataInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="12-9-对象流-处理流之六"><a href="#12-9-对象流-处理流之六" class="headerlink" title="12.9 对象流(处理流之六)"></a>12.9 对象流(处理流之六)</h3><p>ObjectInputStream和OjbectOutputSteam：<strong>用于存储和读取基本数据类型数据或对象的处理流</strong>。它的强大之处就是<strong>可以把Java中的对象写入到数据源中</strong>，也<strong>能把对象从数据源中还原回来</strong></p>
<p>序列化：<strong>用ObjectOutputStream类保存基本类型数据或对象的机制</strong></p>
<p>反序列化：<strong>用ObjectInputStream类读取基本类型数据或对象的机制</strong></p>
<p>ObjectOutputStream和ObjectInputStream<strong>不能序列化static和ltransient修饰的成员变量</strong></p>
<h4 id="12-9-1-对象的序列化"><a href="#12-9-1-对象的序列化" class="headerlink" title="12.9.1 对象的序列化"></a>12.9.1 对象的序列化</h4><p>对象序列化机制允许把内存中的<strong>Java对象转换成平台无关的二进制流</strong>，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当<strong>其它程序获取了这种二进制流，就可以恢复成原来的Java对象</strong></p>
<p>序列化的好处在于<strong>可将任何实现了Serializable接口的对象转化为字节数据</strong>，使其在<strong>保存和传输时可被还原</strong></p>
<p>序列化是RMI(Remote Method lnvoke - 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此<strong>序列化机制是JavaEE 平台的基础</strong></p>
<p>如果需要<strong>让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的</strong>，为了<strong>让某个类是可序列化的，该类必须实现如下两个接口之一</strong>。否则，会抛出NotSerializableException异常</p>
<ul>
<li><strong>Serializable</strong></li>
<li><strong>Externalizable</strong></li>
</ul>
<h4 id="12-9-2-测试ObjectOutputStream和ObjectInputStream"><a href="#12-9-2-测试ObjectOutputStream和ObjectInputStream" class="headerlink" title="12.9.2 测试ObjectOutputStream和ObjectInputStream"></a>12.9.2 测试ObjectOutputStream和ObjectInputStream</h4><pre><code class="java">@Test
public void TestObjectOutputStream() &#123;
    //序列化过程:将内存中的java对象保存到磁盘中或通过网络传输出出去:使用ObjectOutputStream实现
    ObjectOutputStream objectOutputStream = null;
    try &#123;
        objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;Object.dat&quot;));
        objectOutputStream.writeObject(new String(&quot;我爱北京天安门&quot;));
        objectOutputStream.flush();//刷新操作
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if(objectOutputStream != null)
                objectOutputStream.close();//关闭
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
@Test
public void TestObjectInputStream()&#123;
    //反序列化过程:将保存到磁盘文件中的对象还原为内存中的java对象:使用ObjectInputStream实现
    ObjectInputStream objectInputStream = null;
    try &#123;
        objectInputStream = new ObjectInputStream(new FileInputStream(&quot;Object.dat&quot;));
        Object o = objectInputStream.readObject();
        String str = (String) o;
        System.out.println(str);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; catch (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        if(objectInputStream != null) &#123;
            try &#123;
                objectInputStream.close();//关闭
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="12-9-3-自定义类实现序列化和反序列化操作"><a href="#12-9-3-自定义类实现序列化和反序列化操作" class="headerlink" title="12.9.3 自定义类实现序列化和反序列化操作"></a>12.9.3 自定义类实现序列化和反序列化操作</h4><p>自定义类能被序列化的要求：</p>
<ol>
<li>自定义类需要<strong>实现Serializable接口和Externalizable接口之一</strong></li>
<li>当前类<strong>提供一个全局常量: serialVersionUID</strong></li>
<li>除了当前Person类需要实现Serializable接口之外，还必须<strong>保证其内部所有属性(属性的类型也实现接口)也必须是可序列化</strong>的(默认情况下，基本数据类型都可序列化)</li>
</ol>
<pre><code class="java">public class Person implements Serializable &#123;
    public static final long serialVersionUID = 79275029514L;//随便赋值，这是一个标识
    private String name;
    private int age;
    public Person() &#123;
    &#125;
    public Person(String name, int age) &#123;
        this.name = name;
        this.age = age;
    &#125;
    public String getName() &#123;
        return name;
    &#125;
    public void setName(String name) &#123;
        this.name = name;
    &#125;
    public int getAge() &#123;
        return age;
    &#125;
    public void setAge(int age) &#123;
        this.age = age;
    &#125;
    @Override
    public String toString() &#123;
        return &quot;Person&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Test
public void TestCustomizeObject()&#123;
    //将java对象序列化
    ObjectOutputStream objectOutputStream = null;
    try &#123;
        objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;Object.dat&quot;));
        objectOutputStream.writeObject(new Person(&quot;张三&quot;,20));
        objectOutputStream.flush();//刷新操作
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if(objectOutputStream != null)
                objectOutputStream.close();//关闭
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<pre><code class="java">@Test
public void TestCustomizeObject()&#123;
    //将java对象反序列化
    ObjectInputStream objectInputStream = null;
        try &#123;
            objectInputStream = new ObjectInputStream(new FileInputStream(&quot;Object.dat&quot;));
            Object obj = objectInputStream.readObject();
            Person p = (Person) obj;
            System.out.println(p);
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125; catch (ClassNotFoundException e) &#123;
            e.printStackTrace();
        &#125; finally &#123;
            if(objectInputStream != null) &#123;
                try &#123;
                    objectInputStream.close();
                &#125; catch (IOException e) &#123;
                    e.printStackTrace();
                &#125;
            &#125;
        &#125;
&#125;
</code></pre>
<h4 id="12-9-4-序列化时serialVersionUID的理解"><a href="#12-9-4-序列化时serialVersionUID的理解" class="headerlink" title="12.9.4 序列化时serialVersionUID的理解"></a>12.9.4 序列化时serialVersionUID的理解</h4><p>凡是实现Serializable接口的类都有一个<strong>表示序列化版本标识符的静态变量：private static final long serialVersionUID</strong></p>
<ul>
<li>serialVersionUID用来<strong>表明类的不同版本间的兼容性</strong>。简言之，其<strong>目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容</strong></li>
<li>如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故<strong>建议，显式声明</strong></li>
</ul>
<p>简单来说，<strong>Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的</strong>。在<strong>进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较</strong>，如果相同就认为是一致的，可以进行反序列化，否则就会出现<strong>序列化版本不一致的异常(InvalidCastException)</strong></p>
<p>（自己的理解）首先假设Person类的serialVersionUID被显式声明，此时对Person类的person对象进行序列化，然后我们对这个Person类内部进行一些比如属性个数增加，方法增多，属性值变化等的修改，然后我们对对象person进行反序列化，此时由于serialVersionUID的显式声明，即被唯一确定，那么这个对象依然能携带着被修改的部分被还原；再假设Person类的serialVersionUID没有被显式声明，则person对象在进行序列化时Java运行环境会自动生成一个serialVersionUID，但当我们做了一些修改后，Java运行环境为Person类自动生成的serialVersionUID就可能会发生变化，那么我们进行反序列化时，JVM就会因为serialVersionUID的不同无法判断被序列化的对象person是哪个类的对象，从而就无法还原</p>
<h3 id="12-10-随机存取文件流"><a href="#12-10-随机存取文件流" class="headerlink" title="12.10 随机存取文件流"></a>12.10 随机存取文件流</h3><p>RandomAccessFile声明在java.io包下，但<strong>直接继承于java.lang.Object类</strong>。并且它<strong>实现了Datalnput、DataOutput这两个接口</strong>，也就意味着<strong>这个类既可以读也可以写</strong></p>
<p>RandomAccessFile类<strong>支持“随机访问”的方式</strong>，程序可以直接<strong>跳到文件的任意地方来读、写文件</strong></p>
<ul>
<li><strong>支持只访问文件的部分内容</strong></li>
<li><strong>可以向已存在的文件后追加内容</strong></li>
</ul>
<p>RandomAccessFile对象<strong>包含一个记录指针，用以标示当前读写处的位置</strong></p>
<p>RandomAccessFile 类<strong>对象可以自由移动记录指针</strong>：</p>
<ul>
<li>long getFilePointer()：<strong>获取文件记录指针的当前位置</strong></li>
<li>void seek(long pos)：<strong>将文件记录指针定位到pos位置</strong></li>
</ul>
<p><strong>构造器:</strong></p>
<ul>
<li>public RandomAccessFile(File file, String mode)</li>
<li>public RandomAccessFile(String name, String mode)</li>
</ul>
<p><strong>创建RandomAccessFile类实例需要指定一个mode参数</strong>，该参数<strong>指定RandomAccessFile的访问模式</strong>：</p>
<ul>
<li>r：<strong>以只读方式打开</strong></li>
<li>rw：<strong>打开以便读取和写入</strong></li>
<li>rwd：<strong>打开以便读取和写入；同步文件内容的更新</strong></li>
<li>rws：<strong>打开以便读取和写入；同步文件内容和元数据的更新</strong></li>
</ul>
<p>如果模式为<strong>只读r</strong>，则<strong>不会创建文件</strong>，而是会去<strong>读取一个已经存在的文件</strong>，如果<strong>读取的文件不存在则会出现异常</strong></p>
<p>如果模式为<strong>rw读写</strong>。如果<strong>文件不存在则会去创建文件</strong>；如果<strong>存在则不会创建</strong>，但是<strong>会对原有文件的内容进行覆盖</strong>(默认从头覆盖)</p>
<p>补充：JDK1.6上面写的每次write数据时，**”rw”模式，数据不会立即写到硬盘中<strong>；而</strong>“rwd”，数据会被立即写入硬盘<strong>。如果写数据过程发生异常，</strong>“rwd”模式中已被wite的数据被保存到硬盘<strong>，而</strong>“rw”则全部丢失**</p>
<h4 id="12-10-1-RandomAccessFile的使用"><a href="#12-10-1-RandomAccessFile的使用" class="headerlink" title="12.10.1 RandomAccessFile的使用"></a>12.10.1 RandomAccessFile的使用</h4><h5 id="1-RandomAccessFile对文件数据的读取和写入"><a href="#1-RandomAccessFile对文件数据的读取和写入" class="headerlink" title="1.RandomAccessFile对文件数据的读取和写入"></a>1.RandomAccessFile对文件数据的读取和写入</h5><pre><code class="java">//RandomAccessFiLe的使用
//1.RandomAccessFile直接继承于java.Lang.object类，实现了DataInput和DataOutput接口
//2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流
@Test
public void TestRandomAccessFile()&#123;
    //对数据进行读取和写入（复制）
    RandomAccessFile randomAccessFile1 = null;
    RandomAccessFile randomAccessFile2 = null;
    try &#123;
        randomAccessFile1 = new RandomAccessFile(new File(&quot;TestImage.jpg&quot;),&quot;r&quot;);
        randomAccessFile2 = new RandomAccessFile(new File(&quot;TestImage2.jpg&quot;),&quot;rw&quot;);

        byte[] buffer = new byte[1024];
        int len;
        while ((len = randomAccessFile1.read(buffer)) != -1)&#123;
            randomAccessFile2.write(buffer,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        if (randomAccessFile1 != null) &#123;
            try &#123;
                randomAccessFile1.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (randomAccessFile2 != null) &#123;
            try &#123;
                randomAccessFile2.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="2-RandomAccessFile对文件原有数据的覆盖效果"><a href="#2-RandomAccessFile对文件原有数据的覆盖效果" class="headerlink" title="2.RandomAccessFile对文件原有数据的覆盖效果"></a>2.RandomAccessFile对文件原有数据的覆盖效果</h5><pre><code class="java">@Test
public void Test()&#123;
    //向文件添加新数据时默认从头开始覆盖原有内容
    RandomAccessFile randomAccessFile = null;
    try &#123;
        randomAccessFile = new RandomAccessFile(new File(&quot;hello.txt&quot;),&quot;rw&quot;);
        randomAccessFile.write(&quot;xyz&quot;.getBytes());//write展示出的效果是对原有内容的覆盖
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (randomAccessFile != null)
                randomAccessFile.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h5 id="3-RandomAccessFile实现对文件数据的插入"><a href="#3-RandomAccessFile实现对文件数据的插入" class="headerlink" title="3.RandomAccessFile实现对文件数据的插入"></a>3.RandomAccessFile实现对文件数据的插入</h5><pre><code class="java">//实现数据的插入
@Test
public void TestRandomAccessFileInsert() throws FileNotFoundException &#123;
    RandomAccessFile randomAccessFile = null;
    try &#123;
        randomAccessFile = new RandomAccessFile(new File(&quot;hello.txt&quot;),&quot;rw&quot;);
        randomAccessFile.seek(3);//将角标移动到3的位置(角标从0开始)
        //将指针3后面的数据内容保存到StringBuilder中
        StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length());
        byte[] buffer = new byte[20];
        int len;
        while ((len = randomAccessFile.read(buffer)) != -1)&#123;
            builder.append(new String(buffer,0,len));
        &#125;
        //将指针重新定位到3处
        randomAccessFile.seek(3);
        randomAccessFile.write(&quot;abc&quot;.getBytes());
        //将StringBuilder中数据写入文件中
        randomAccessFile.write(builder.toString().getBytes());
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (randomAccessFile != null)
                randomAccessFile.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
//思考：将StringBuilder替换为ByteArrayOutputStream
</code></pre>
<h3 id="12-11-NIO-2中Path、Paths、Files类的使用"><a href="#12-11-NIO-2中Path、Paths、Files类的使用" class="headerlink" title="12.11 NIO.2中Path、Paths、Files类的使用"></a>12.11 NIO.2中Path、Paths、Files类的使用</h3><h4 id="12-11-1-NIO的介绍"><a href="#12-11-1-NIO的介绍" class="headerlink" title="12.11.1 NIO的介绍"></a>12.11.1 NIO的介绍</h4><p>Java NlO (New lO，Non-Blocking lO)是从Java 1.4版本开始引入的一套新的IO APl，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，<strong>NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作</strong>。NIO将以<strong>更加高效</strong>的方式进行文件的读写操作</p>
<p>JavaAPI中提供了两套NIO，<strong>一套是针对标准输入输出NIO，另一套就是网络编程NIO</strong></p>
<ul>
<li>java.nio.channels.Channel<ul>
<li>FileChannel：<strong>处理本地文件</strong></li>
<li>SocketChannel：<strong>TCP网络编程的客户端的Channel</strong></li>
<li>ServerSocketChannel：<strong>TCP网络编程的服务器端的Channel</strong></li>
<li>DatagramChannel：<strong>UDP网络编程中发送端和接收端的Channel</strong></li>
</ul>
</li>
</ul>
<p>随着JDK7的发布，Java对NIO进行了极大的扩展，<strong>增强了对文件处理和文件系统特性的支持</strong>，以至于我们称他们为NIO.2。因为NIO提供的一些功能，NIO已经成为文件处理中越来越重要的部分</p>
<h4 id="12-11-2-Path、Paths、Files核心API"><a href="#12-11-2-Path、Paths、Files核心API" class="headerlink" title="12.11.2 Path、Paths、Files核心API"></a>12.11.2 Path、Paths、Files核心API</h4><p>早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息</p>
<p>NIO. 2为了弥补这种不足，<strong>引入了Path接口， 代表一个平台无关的平台路径，描述了目录结构中文件的位置</strong>。Path可以看成是File类的升级版本， <strong>实际引用的资源也可以不存在</strong></p>
<p>在以前IO操作都是这样写的：<br><code>import java.io.File;</code><br><code>File file = new File(&quot;index.html&quot;);</code><br>但在Java7中，可以这样写:<br><code>import java.nio.file.Path;</code><br><code>import java.nio.file.Paths;</code><br><code>Path path = Paths.get(&quot;index.html&quot;);</code></p>
<p>同时，NIO.2在java.nio.file包下还提供了Files、Paths 工具类，<strong>Files包含了大量静态的工具方法来操作文件</strong>; <strong>Paths则包含了两个返回Path的静态工厂方法</strong></p>
<p>Paths类提供的静态get()方法用来获取Path对象：</p>
<ul>
<li>static Path get(String first, String…more)：<strong>用于将多个字符串串连成路径</strong></li>
<li>static Path get(URI uri)：<strong>返回指定uri对应的Path路径</strong></li>
</ul>
<h5 id="1-Path接口"><a href="#1-Path接口" class="headerlink" title="1.Path接口"></a>1.Path接口</h5><p><strong>Path常用方法：</strong></p>
<ul>
<li>String toString()：<strong>返回调用Path对象的字符串表示形式</strong></li>
<li>boolean startsWith(String path)：<strong>判断是否以path路径开始</strong></li>
<li>boolean endsWith(String path)：<strong>判断是否以path路径结束</strong></li>
<li>boolean isAbsolute()：<strong>判断是否是绝对路径</strong></li>
<li>Path getParent()：<strong>返回Path对象包含整个路径，不包含Path对象指定的文件路径</strong></li>
<li>Path getRoot()：<strong>返回调用Path对象的根路径</strong></li>
<li>Path getFileName()：<strong>返回与调用Path对象关联的文件名</strong></li>
<li>int getNameCount()：<strong>返回Path根目录后面元素的数量</strong></li>
<li>Path getName(int idx)：<strong>返回指定索引位置idx的路径名称</strong></li>
<li>Path toAbsolutePath()：<strong>作为绝对路径返回调用Path 对象</strong></li>
<li>Path resolve(Path p)：<strong>合并两个路径，返回合并后的路径对应的Path对象</strong></li>
<li>File toFile()：<strong>将Path转化为File类的对象</strong></li>
</ul>
<h5 id="2-Files类"><a href="#2-Files类" class="headerlink" title="2.Files类"></a>2.Files类</h5><p>java.nio.file.Files<strong>用于操作文件或目录的工具类</strong></p>
<p><strong>Files常用方法：</strong></p>
<ul>
<li>Path copy(Path src, Path dest, CopyOption…how)：<strong>文件的复制</strong></li>
<li>Path createDirectory(Path path, FileAttribute&lt;?&gt;…attr)：<strong>创建一个目录</strong></li>
<li>Path createFile(Path path, FileAttribute&lt;?&gt;…arr)：<strong>创建一个文件</strong></li>
<li>void delete(Path path)：<strong>删除一个文件/目录</strong>，如果<strong>不存在，执行报错</strong></li>
<li>void deletelfExists(Path path)：<strong>Path对应的文件/目录如果存在，执行删除</strong></li>
<li>Path move(Path src, Path dest, CopyOption…how)：<strong>将src移动到dest位置</strong></li>
<li>long size(Path path)：<strong>返回path指定文件的大小</strong></li>
</ul>
<p><strong>用于判断：</strong></p>
<ul>
<li><p>boolean exists(Path path, LinkOption…opts)：<strong>判断文件是否存在</strong></p>
</li>
<li><p>boolean isDirectory(Path path, LinkOption…opts)：<strong>判断是否是目录</strong></p>
</li>
<li><p>boolean isRegularFile(Path path, LinkOption…opts)：<strong>判断是否是文件</strong></p>
</li>
<li><p>boolean isHidden(Path path)：<strong>判断是否是隐藏文件</strong></p>
</li>
<li><p>boolean isReadable(Path path)：<strong>判断文件是否可读</strong></p>
</li>
<li><p>boolean isWritable(Path path)：<strong>判断文件是否可写</strong></p>
</li>
<li><p>boolean notExists(Path path, LinkOption…opts)：<strong>判断文件是否不存在</strong></p>
</li>
</ul>
<p><strong>用于操作内容：</strong></p>
<ul>
<li>SeekableByteChannel newByteChannel(Path path, OpenOption…how)：<strong>获取与指定文件的连接,how指定打开方式</strong></li>
<li>DirectoryStream<Path> newDirectoryStream(Path path)：<strong>打开path指定的目录</strong></li>
<li>InputStream newlnputStream(Path path, OpenOption… how)：<strong>获取InputStream 对象</strong></li>
<li>OutputStream newOutputStream(Path path, OpenOptin… how)：<strong>获取OutputStream对象</strong></li>
</ul>
<h2 id="十三、Java网络编程"><a href="#十三、Java网络编程" class="headerlink" title="十三、Java网络编程"></a>十三、Java网络编程</h2><h3 id="13-1-网络编程概述"><a href="#13-1-网络编程概述" class="headerlink" title="13.1 网络编程概述"></a>13.1 网络编程概述</h3><p>Java是Internet上的语言，它从语言级上<strong>提供了对网络应用程序的支持</strong>，程序员能够很容易开发常见的网络应用程序</p>
<p>Java提供的网络类库，可以实现无痛(不用关注底层)的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库，<strong>程序员面对的是一个统一的网络编程环境</strong></p>
<h4 id="13-1-1-网络基础"><a href="#13-1-1-网络基础" class="headerlink" title="13.1.1 网络基础"></a>13.1.1 网络基础</h4><p>计算机网络：<strong>把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源</strong></p>
<p>网络编程的目的：<strong>直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯</strong></p>
<p>网络编程中有两个主要的问题：①<strong>如何准确地定位网络上一台或多台主机；定位主机上的特定的应用</strong>②<strong>找到主机后如何可靠高效地进行数据传输</strong></p>
<h4 id="13-1-2-如何实现网络中的主机互相通信-网络编程的两个要素"><a href="#13-1-2-如何实现网络中的主机互相通信-网络编程的两个要素" class="headerlink" title="13.1.2 如何实现网络中的主机互相通信(网络编程的两个要素)"></a>13.1.2 如何实现网络中的主机互相通信(网络编程的两个要素)</h4><p><strong>通信双方地址</strong>：</p>
<ul>
<li><strong>IP</strong></li>
<li><strong>端口号</strong></li>
</ul>
<p>一定的规则(即：<strong>网络通信协议</strong>。有两套参考模型)</p>
<ul>
<li><strong>OSI参考模型：模型过于理想化</strong>，未能在因特网上进行广泛推广</li>
<li>**TCP/IP参考模型(或TCP/IP协议)**：事实上的国际标准</li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646631.png' data-fancybox='default' data-caption='image-20210809110936920'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646631.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646631.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210809110936920"></a><span class='image-caption'>image-20210809110936920</span></div></div>

<h5 id="1-TCP-IP参考模型各层的作用"><a href="#1-TCP-IP参考模型各层的作用" class="headerlink" title="1.TCP/IP参考模型各层的作用"></a>1.TCP/IP参考模型各层的作用</h5><p><strong>应用层：提供应用程序的网络接口</strong></p>
<p><strong>传输层：</strong>为<strong>两台主机间的应用程序提供端到端的通信</strong>。传输层<strong>从应用层接受数据</strong>，并且在必要的时候<strong>把它分成较小的单元</strong>，<strong>传递给网络层</strong>，并<strong>确保到达对方的各段信息正确无误</strong></p>
<p><strong>网络层：</strong>主要协议有IP (Internet protocol) 、ICMP (Internet Control Message Protocol ，互联网控制报文协议)、IGMP ( Internet Group Management Protocol，互联网组管理协议)、ARP (Address Resolution Protocol ,地址解析协议)和RARP (Reverse Address Resolution Protocol ，反向地址解析协议)等。<strong>涉及寻址和路由选择</strong></p>
<p><strong>物理层和数据链路层：涉及物理介质访问和二进制数据流传输</strong></p>
<h5 id="2-各层涉及到的具体协议："><a href="#2-各层涉及到的具体协议：" class="headerlink" title="2.各层涉及到的具体协议："></a>2.各层涉及到的具体协议：</h5><p><strong>TCP/IP是基于TCP和IP这两个最初的协议之上的不同的通信协议的大集合</strong>。又称为<strong>TCP/IP协议簇</strong></p>
<table>
<thead>
<tr>
<th>协议名称</th>
<th>协议作用</th>
</tr>
</thead>
<tbody><tr>
<td>TCP-传输控制协议</td>
<td>TCP用于从应用程序到网络的数据传输控制<br/>TCP负责在数据传送之前将它们分割为IP包，然后在它们到达的时候将它们重组</td>
</tr>
<tr>
<td>IP-网际协议</td>
<td>IP负责计算机之间的通信<br/>IP负责在因特网上发送和接收数据包</td>
</tr>
<tr>
<td>HTTP-超文本传输协议</td>
<td>HTTP负责web服务器与web浏览器之间间的通信<br/>HTTP用于从web客户端(浏览器)与web服务器发送请求，并从web服务器向web客户端返回内容(网页)</td>
</tr>
<tr>
<td>HTTPS-安全的HTTP</td>
<td>HTTPS负责在web服务器和web浏览器之间的安全通信<br/>作为有代表性的应用, HTTPS会用于处理信用卡交易和其他的敏感数据</td>
</tr>
<tr>
<td>SSL-安全套接字层</td>
<td>SSL协议用于为安全数据传输加密数据</td>
</tr>
<tr>
<td>SMTP-简易邮件传输协议</td>
<td>SMTP用于电子邮件的传输</td>
</tr>
<tr>
<td>MIME-多用途因特网邮件扩展</td>
<td>MIME协议使SMTP有能力通过TCP/IP网络传输多媒体文件 ，包括声音、 视频和二进制数据</td>
</tr>
<tr>
<td>IMAP-因特网消息访问协议</td>
<td>IMAP用于存储和取回电子邮件</td>
</tr>
<tr>
<td>POP-邮局协议</td>
<td>POP用于从电子邮件服务器向个人电脑下载电子邮件</td>
</tr>
<tr>
<td>FTP-文件传输协议</td>
<td>FTP负责计算机之间的文件传输</td>
</tr>
<tr>
<td>NTP-网络时间协议</td>
<td>NTP用于在计算机之间同步时间(钟)</td>
</tr>
<tr>
<td>DHCP-动态主机配置协议</td>
<td>DHCP用于向网络中的计算机分配动态IP地址</td>
</tr>
<tr>
<td>SNMP-简单网络管理协议</td>
<td>SNMP用于计算机网络的管理</td>
</tr>
<tr>
<td>LDAP-轻量级的目录访问协议</td>
<td>LDAP用于从因特网搜集关于用户和电子邮件地址的信息</td>
</tr>
<tr>
<td>ICMP-因特网消息控制协议</td>
<td>ICMP负责网络中的错误处理</td>
</tr>
<tr>
<td>ARP-Address Resolution Protocol</td>
<td>ARP-用于通过IP来查找基于IP地址的计算机网卡的硬件地址</td>
</tr>
<tr>
<td>BOOTP-Boot Protocol</td>
<td>BOOTP用于从网络启动计算机</td>
</tr>
<tr>
<td>PPTP-点对点隧道协议</td>
<td>PPTP用于私人网络之间的连接(隧道)</td>
</tr>
</tbody></table>
<h5 id="3-网络通信示例图"><a href="#3-网络通信示例图" class="headerlink" title="3.网络通信示例图"></a>3.网络通信示例图</h5><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646935.png' data-fancybox='default' data-caption='image-20210809114126991'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646935.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646935.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210809114126991"></a><span class='image-caption'>image-20210809114126991</span></div></div>

<h3 id="13-2-通信要素1：IP和端口号"><a href="#13-2-通信要素1：IP和端口号" class="headerlink" title="13.2 通信要素1：IP和端口号"></a>13.2 通信要素1：IP和端口号</h3><h4 id="13-2-1-IP地址"><a href="#13-2-1-IP地址" class="headerlink" title="13.2.1 IP地址"></a>13.2.1 IP地址</h4><p>IP地址：InetAddress（Java中一个InetAddress对象就代表一个IP地址）</p>
<ul>
<li><strong>唯一的标识Internet上的计算机</strong>(通信实体)</li>
<li><strong>本地回环地址(hostAddress)：127.0.0.1      主机名(hostName)：localhost</strong></li>
<li>IP地址分类方式1: IPV4 和IPV6<ul>
<li>IPV4：<strong>4个字节组成</strong>，4个0-255。 大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1</li>
<li>VIPV6：128位(16个字节)，<strong>写成8个无符号整数，每个整数用四个十六进制位表示</strong>，数之间用冒号(:)分开，如: 3ffe:3201:1401:1280:c8ff.fe4d:db39:1984</li>
</ul>
</li>
<li>IP地址分类方式2：**公网地址(万维网使用)<strong>和</strong>私有地址(局域网使用)**。192.168.开头的就是私有址址，范围即为192.168.0.0——192.168.255.255，专门为组织机构内部使用</li>
<li>特点：不易记忆</li>
</ul>
<h5 id="1-通过域名访问对应的IP地址的网址"><a href="#1-通过域名访问对应的IP地址的网址" class="headerlink" title="1.通过域名访问对应的IP地址的网址"></a>1.通过域名访问对应的IP地址的网址</h5><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646648.png' data-fancybox='default' data-caption='image-20210809144629029'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646648.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646648.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210809144629029"></a><span class='image-caption'>image-20210809144629029</span></div></div>

<h5 id="2-InetAddress类的使用"><a href="#2-InetAddress类的使用" class="headerlink" title="2.InetAddress类的使用"></a>2.InetAddress类的使用</h5><pre><code class="java">//如何实例化InetAddress:两个方法getByName(String host)、getLocalHost()
//两个常用方法:getHostName()、getHostAddress()
InetAddress address = InetAddress.getByName(&quot;192.168.9.59&quot;);//通过字符串生成一个IP地址
System.out.println(address);///192.168.9.59
InetAddress address1 = InetAddress.getByName(&quot;www.baidu.com&quot;);//通过域名然后内部解析后生成一个IP地址
System.out.println(address1);//www.baidu.com/14.215.177.39
System.out.println(address1.getHostName());//获取主机名字
System.out.println(address1.getHostAddress());//获取主机地址

InetAddress address2 = InetAddress.getByName(&quot;127.0.0.1&quot;);//通过字符串获取本机IP地址
System.out.println(address2);
InetAddress address3 = InetAddress.getLocalHost();//另一种获取本机IP地址的方法
System.out.println(address3);
</code></pre>
<h4 id="13-2-2-端口号"><a href="#13-2-2-端口号" class="headerlink" title="13.2.2 端口号"></a>13.2.2 端口号</h4><p><strong>端口号标识正在计算机上运行的进程(程序)</strong></p>
<ul>
<li><strong>不同的进程有不同的端口号</strong></li>
<li>被规定为一个<strong>16位的整数0~65535</strong></li>
<li>端口分类：<ul>
<li><strong>公认端口：0~1023</strong>。 被<strong>预先定义的服务通信占用</strong>(如: HTTP占用端口<br>  80，FTP占用端口21，Telnet占用端口23)</li>
<li><strong>注册端口：1024~49151</strong>。 <strong>分配给用户进程或应用程序</strong>。( 如: Tomcat占<br>  用端口8080，MySQL占用端口3306，Oracle 占用端口1521等)</li>
<li><strong>动态/私有端口：49152~65535</strong></li>
</ul>
</li>
</ul>
<p><strong>端口号与IP地址的组合得出一个网络套接字：Socket</strong></p>
<h5 id="1-两台主机间同一应用的通信："><a href="#1-两台主机间同一应用的通信：" class="headerlink" title="1.两台主机间同一应用的通信："></a>1.两台主机间同一应用的通信：</h5><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646269.png' data-fancybox='default' data-caption='image-20210809150824749'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646269.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646269.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210809150824749"></a><span class='image-caption'>image-20210809150824749</span></div></div>

<h3 id="13-3-通信要素2：网络通信协议"><a href="#13-3-通信要素2：网络通信协议" class="headerlink" title="13.3 通信要素2：网络通信协议"></a>13.3 通信要素2：网络通信协议</h3><p>网络通信协议：计算机网络中实现通信必须有一些约定，即通信协议，<strong>对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准</strong></p>
<p>计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，这就产生了如何实现如此复杂的网络协议的问题</p>
<p><strong>通信协议分层的思想</strong>：在制定协议时，把<strong>复杂成份分解成一些简单的成份，再将它们复合起来</strong>。最常用的复合方式是层次方式，即<strong>同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系</strong>。<strong>各层互不影响，利于系统的开发和扩展</strong></p>
<h4 id="13-3-1-TCP-IP协议簇"><a href="#13-3-1-TCP-IP协议簇" class="headerlink" title="13.3.1 TCP/IP协议簇"></a>13.3.1 TCP/IP协议簇</h4><p>涉及到<strong>传输层和网络层</strong>的协议</p>
<p><strong>传输层协议</strong>中有两个非常重要的协议:</p>
<ul>
<li><strong>传输控制协议TCP</strong>(Transmission Control Protocol)</li>
<li><strong>用户数据报协议UDP</strong>(User Datagram Protocol)</li>
</ul>
<p><strong>TCP/IP以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)<strong>而得名，实际上是一组协议，</strong>包括多个具有不同功能且互为关联的协议</strong></p>
<ul>
<li>IP(Internet Protocol)协议是<strong>网络层</strong>的主要协议，<strong>支持网间互连的数据通信</strong></li>
<li>TCP/IP协议模型从更实用的角度出发，<strong>形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层</strong></li>
</ul>
<h4 id="13-3-2-传输层的TCP和UDP协议主要区别"><a href="#13-3-2-传输层的TCP和UDP协议主要区别" class="headerlink" title="13.3.2 传输层的TCP和UDP协议主要区别"></a>13.3.2 传输层的TCP和UDP协议主要区别</h4><p>TCP协议：</p>
<ul>
<li><strong>使用TCP协议前，须先建立TCP连接</strong>，形成传输数据通道</li>
<li>传输前，<strong>采用“三次握手”方式，点对点通信，是可靠的</strong></li>
<li>TCP协议进行通信的两个应用进程：<strong>客户端、服务端</strong></li>
<li>在连接中可进行<strong>大数据量的传输</strong></li>
<li>传输完毕，<strong>需释放已建立的连接，效率低</strong></li>
</ul>
<p>UDP协议：</p>
<ul>
<li>将数据、源、目的封装成数据包，<strong>不需要建立连接</strong></li>
<li><strong>每个数据报的大小限制在64K内</strong></li>
<li>发送不管对方是否准备好，接收方收到也不确认，故是<strong>不可靠的</strong></li>
<li><strong>可以广播发送</strong></li>
<li>发送数据结束时<strong>无需释放资源，开销小，速度快</strong></li>
</ul>
<p>TCP生活案例：打电话<br>UDP生活案例：发送短信、发电报</p>
<h5 id="1-TCP三次握手和四次挥手"><a href="#1-TCP三次握手和四次挥手" class="headerlink" title="1.TCP三次握手和四次挥手"></a>1.TCP三次握手和四次挥手</h5><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646649.png' data-fancybox='default' data-caption='undefined'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646649.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646649.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></a><span></span></div></div>

<p>第一次握手：建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers）</p>
<p>第二次握手：服务器收到SYN包，必须确认客户端的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态</p>
<p>第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手</p>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646957.png' data-fancybox='default' data-caption='image-20210809153742315'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646957.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201646957.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210809153742315"></a><span class='image-caption'>image-20210809153742315</span></div></div>

<p>客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close0操作即可产生挥手操作</p>
<p>(1)客户端A发送个FIN，用来关闭客户A到服务器B的数据传送</p>
<p>(2)服务器B收到这个FIN，它发回个ACK，确认序号为收到序号加1和SYN一样，一个FIN将占用一个序号</p>
<p>(3)服务器B关闭与客户端A的连接，发送个FIN给客户端A</p>
<p>(4)客户端A发回ACK报文确认,并将确认序号设置为收到序号加1</p>
<h3 id="13-4-TCP网络编程"><a href="#13-4-TCP网络编程" class="headerlink" title="13.4 TCP网络编程"></a>13.4 TCP网络编程</h3><h4 id="13-4-1-实例1：客户端发送信息给服务端，服务端将信息显示在控制台"><a href="#13-4-1-实例1：客户端发送信息给服务端，服务端将信息显示在控制台" class="headerlink" title="13.4.1 实例1：客户端发送信息给服务端，服务端将信息显示在控制台"></a>13.4.1 实例1：客户端发送信息给服务端，服务端将信息显示在控制台</h4><pre><code class="java">//实现TCP网络编程
//实例1:客户端发送信息给服务端，服务端将信息显示在控制台
//测试程序时要先启动服务器端等待客户端呼叫
@Test
public void Client()&#123;//客户端
    Socket socket = null;
    OutputStream outputStream = null;
    try &#123;
        //1.创建IP地址对象
        InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);//服务器IP地址，由于是自己测试，所以用本机IP
        //2.创建Socket对象，指明服务器端的ip和端口号
        socket = new Socket(address,8899);//利用要传输到的IP地址和传输到的端口号创建一个套接字Socket对象
        //3.获取一个输出流，用于输出数据
        outputStream = socket.getOutputStream();//通过这个对象获取一个输出流
        //4.输出数据
        outputStream.write(&quot;你好，我是客户端&quot;.getBytes());//输出内容到服务端
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;//5.关闭资源
        if (outputStream != null) &#123;
            try &#123;
                outputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (socket != null) &#123;
            try &#123;
                socket.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
@Test
public void Server()&#123;//服务器端
    ServerSocket serverSocket = null;
    Socket socket = null;
    InputStream inputStream = null;
    ByteArrayOutputStream byteArrayOutputStream = null;
    try &#123;
        //1.创建ServerSocket对象，指明自己的端口号
        serverSocket = new ServerSocket(8899);
        //2.调用accept()方法来接收客户端传输过来的socket
        socket = serverSocket.accept();
        //3.获取一个输入流来读取数据
        inputStream = socket.getInputStream();
        //这样写可能会乱码，如果传过来的信息的字节流因为buffer数组的容量不够大，读取的时候被拆散开，那么在转换成字符串的时候就可能会出现乱码
        //比如客户端传过来一段中文，buffer数组的容量又为5，即一次性只能读取5个字节，而一个中文字符如果占3个字节，
        //那么第二个中文字符的字节就会被拆散开，在另一部分字节被读取之前，我们又需要把已读取的字节转换成字符串输出出来，这时候就可能会出现乱码
        //byte[] buffer = new byte[20];
        //int len;
        //while ((len = inputStream.read(buffer)) != -1)&#123;
        //    String str = new String(buffer,0,len);
        //    System.out.println(str);
        //&#125;
        //4.读取输入流中数据
        byteArrayOutputStream = new ByteArrayOutputStream();
        //5.对数据进行操作
        byte[] buffer = new byte[5];
        int len;
        while ((len = inputStream.read(buffer)) != -1)&#123;
            byteArrayOutputStream.write(buffer,0,len);
        &#125;
        System.out.println(byteArrayOutputStream.toString());
        System.out.println(&quot;收到来自&quot; + socket.getInetAddress().getHostAddress() + &quot;的消息&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;//6.关闭资源
        if ((socket != null)) &#123;
            try &#123;
                socket.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (serverSocket != null) &#123;
            try &#123;
                serverSocket.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (inputStream != null) &#123;
            try &#123;
                inputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
        if (byteArrayOutputStream != null) &#123;
            try &#123;
                byteArrayOutputStream.close();
            &#125; catch (IOException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="13-4-2-实例2：客户端发送文件给服务端，服务端将文件保存在本地"><a href="#13-4-2-实例2：客户端发送文件给服务端，服务端将文件保存在本地" class="headerlink" title="13.4.2 实例2：客户端发送文件给服务端，服务端将文件保存在本地"></a>13.4.2 实例2：客户端发送文件给服务端，服务端将文件保存在本地</h4><pre><code class="java">//实例2:客户端发送文件给服务端，服务端将文件保存在本地
@Test
public void Client()&#123;//客户端
    Socket socket = null;
    OutputStream outputStream = null;
    FileInputStream fileInputStream = null;
    try &#123;
        //1.创建IP地址对象
        InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);
        //2.创建Socket对象
        socket = new Socket(address,9090);
        //3.获取输出流，用于输出数据到服务器端
        outputStream = socket.getOutputStream();
        //4.创建一个文件字节输入流，读取文件到数组buffer中让输出流输出
        fileInputStream = new FileInputStream(new File(&quot;TestImage.jpg&quot;));
        byte[] buffer = new byte[1024];
        int len;
        while ((len = fileInputStream.read(buffer)) != -1)&#123;
            outputStream.write(buffer,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;//5.关闭资源
        try &#123;
            if (fileInputStream != null)
                fileInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (outputStream != null)
                outputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (socket != null)
                socket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
@Test
public void Server()&#123;//服务器端
    ServerSocket serverSocket = null;
    Socket socket = null;
    InputStream inputStream = null;
    FileOutputStream fileOutputStream = null;
    try &#123;
        //1.创建ServerSocket对象
        serverSocket = new ServerSocket(9090);
        //2.调用ServerSocket的accept()方法获取客户端的套接字对象以进行通信
        socket = serverSocket.accept();
        //3.获取一个输入流来读取客户端的数据
        inputStream = socket.getInputStream();
        //4.创建一个文件字节输出流，把客户端的文件保存到本地
        fileOutputStream = new FileOutputStream(new File(&quot;SocketImage.jpg&quot;));
        //5.用输入流读取客户端的数据，再让文件字节输出流输出数据保存到本地
        byte[] buffer = new byte[1024];
        int len;
        while ((len = inputStream.read(buffer)) != -1)&#123;
            fileOutputStream.write(buffer,0,len);
        &#125;
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        try &#123;
            if (fileOutputStream != null)
                fileOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (inputStream != null)
                inputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (socket != null)
                socket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (serverSocket != null)
                serverSocket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="13-4-3-实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接"><a href="#13-4-3-实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接" class="headerlink" title="13.4.3 实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接"></a>13.4.3 实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接</h4><pre><code class="java">//3.从客户端发送文件给服务端，服务端保存到本地,并返回“发送成功”给客户端,并关闭相应的连接
@Test
public void Client()&#123;
    Socket socket = null;
    OutputStream outputStream = null;
    FileInputStream fileInputStream = null;
    InputStream inputStream = null;
    ByteArrayOutputStream byteArrayOutputStream = null;
    try &#123;
        //1.创建IP地址对象
        InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);
        //2.创建Socket对象
        socket = new Socket(address,9090);
        //3.获取输出流，用于输出数据到服务器端
        outputStream = socket.getOutputStream();
        //4.创建一个文件字节输入流，读取文件到数组buffer中让输出流输出
        fileInputStream = new FileInputStream(new File(&quot;TestImage.jpg&quot;));
        byte[] buffer = new byte[1024];
        int len;
        while ((len = fileInputStream.read(buffer)) != -1)&#123;
            outputStream.write(buffer,0,len);
        &#125;
        //注意，此处需要利用socket对象关闭输出流来告诉服务器端传输已完成，否则服务器端就会一直等待客户端的下一次传输而不执行下方的反馈代码
        socket.shutdownOutput();
        //5.获取一个输入流，用于读取来自服务器端的数据
        inputStream = socket.getInputStream();
        //6.创建字节数组输出流，用于将输入流读取的服务器端数据输出
        byteArrayOutputStream = new ByteArrayOutputStream();
        byte[] buffer1 = new byte[20];//存储读取到的数据
        int len1;
        while ((len1 = inputStream.read(buffer1)) != -1)&#123;
            byteArrayOutputStream.write(buffer1,0,len1);//将读取到的数据写到自身类定义的数组中
        &#125;
        System.out.println(byteArrayOutputStream.toString());//将数组转换成字符串输出到控制台
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;//7.关闭资源
        try &#123;
            if (fileInputStream != null)
                fileInputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (outputStream != null)
                outputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (socket != null)
                socket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (inputStream != null)
                inputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (byteArrayOutputStream != null)
                byteArrayOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
@Test
public void Server()&#123;
    ServerSocket serverSocket = null;
    Socket socket = null;
    InputStream inputStream = null;
    FileOutputStream fileOutputStream = null;
    OutputStream outputStream = null;
    try &#123;
        //1.创建ServerSocket对象
        serverSocket = new ServerSocket(9090);
        //2.调用ServerSocket的accept()方法获取客户端的套接字对象以进行通信
        socket = serverSocket.accept();
        //3.获取一个输入流来读取客户端的数据
        inputStream = socket.getInputStream();
        //4.创建一个文件字节输出流，把客户端的文件保存到本地
        fileOutputStream = new FileOutputStream(new File(&quot;SocketImage1.jpg&quot;));
        //5.用输入流读取客户端的数据，再让文件字节输出流输出数据保存到本地
        byte[] buffer = new byte[1024];
        int len;
        while ((len = inputStream.read(buffer)) != -1)&#123;
            fileOutputStream.write(buffer,0,len);
        &#125;
        System.out.println(&quot;接收数据完成&quot;);
        //6.获取一个输出流对象，用于给客户端反馈
        outputStream = socket.getOutputStream();
        outputStream.write(&quot;服务器端已收到文件&quot;.getBytes());
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;//7.关闭资源
        try &#123;
            if (fileOutputStream != null)
                fileOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (inputStream != null)
                inputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (socket != null)
                socket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (serverSocket != null)
                serverSocket.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (outputStream != null)
                outputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<h4 id="13-4-4-实例4：服务端读取图片并发送给客户端，客户端保存图片到本地"><a href="#13-4-4-实例4：服务端读取图片并发送给客户端，客户端保存图片到本地" class="headerlink" title="13.4.4 实例4：服务端读取图片并发送给客户端，客户端保存图片到本地"></a>13.4.4 实例4：服务端读取图片并发送给客户端，客户端保存图片到本地</h4><h4 id="13-4-5-实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"><a href="#13-4-5-实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端" class="headerlink" title="13.4.5 实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端"></a>13.4.5 实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端</h4><h3 id="13-5-UDP网络编程"><a href="#13-5-UDP网络编程" class="headerlink" title="13.5 UDP网络编程"></a>13.5 UDP网络编程</h3><p><strong>类 DatagramSocket和DatagramPacket实现了基于UDP协议网络程序</strong></p>
<p>UDP数据报通过数据报<strong>套接字DatagramSocket</strong>发送和接收，系统不<strong>保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达</strong></p>
<p>DatagramPacket对象封装了UDP数据报，在<strong>数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号</strong></p>
<p>UDP协议中每个数据报都给出了完整的地址信息，因此<strong>无须建立发送方和接收方的连接</strong>。如同发快递包裹一样</p>
<pre><code class="java">//UDP网络编程
//UDP要传输的数据、传输到的主机IP及端口都打包在数据报中，所以socket只是一个根据数据报中的IP和端口进行发送数据报和接收数据报的作用
@Test
public void Send() throws IOException &#123;//发送端
    //1.创建数据报套接字DatagramSocket对象，用于传输数据
    DatagramSocket socket = new DatagramSocket();
    String str = &quot;我是UDP发送端&quot;;//要传输的数据
    byte[] data = str.getBytes();
    //2.获取要发送到的IP地址对象
    InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);
    //3.创建发送端的数据报对象，其中包含要传输的数据、要传输到的主机的IP地址及端口
    DatagramPacket packet = new DatagramPacket(data,0,data.length,address,9090);
    //4.发送打包好的数据报
    socket.send(packet);
    //5.关闭socket
    socket.close();
&#125;
@Test
public void Receiver() throws IOException &#123;//接收端
    //1.创建数据报套接字DatagramSocket对象，用于接收传入的端口参数中的数据
    DatagramSocket socket = new DatagramSocket(9090);
    byte[] buffer = new byte[100];//存储数据的数组
    //2.创建接收端的数据报对象，来接收保存传来的数据报
    DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length);
    //3.接收发送端的数据报
    socket.receive(packet);
    System.out.println(new String(packet.getData(),0,packet.getLength()));//对数据进行处理操作
    //4.关闭socket
    socket.close();
&#125;
</code></pre>
<h3 id="13-6-URL编程"><a href="#13-6-URL编程" class="headerlink" title="13.6 URL编程"></a>13.6 URL编程</h3><p><strong>URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址</strong></p>
<p>它是一种具体的URI，即<strong>URL可以用来标识一个资源，而且还指明了如何locate这个资源</strong></p>
<p>通过URL我们可以访问Internet上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源</p>
<p>URL的基本结构由5部分组成：<br><code>&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表&gt;</code></p>
<p>例如：<code>http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123&gt;</code></p>
<p><strong>#片段名：即锚点</strong>，例如看小说，直接定位到章节</p>
<p><strong>参数列表格式：参数名=参数值&amp;参数名=参数值…</strong></p>
<h4 id="13-6-1-构造器"><a href="#13-6-1-构造器" class="headerlink" title="13.6.1 构造器"></a>13.6.1 构造器</h4><p>为了表示URL，java.net中实现了类URL。我们可以通过下面的构造器来初始化一个URL对象：</p>
<ul>
<li>public URL(String spec)：<strong>通过一个表示URL地址的字符串可以构造一个URL对象</strong>。例如：<code>URL url = new URL (&quot;http://www.baidu.com&quot;);</code></li>
<li>public URL(URL context，String spec)：<strong>通过基URL和相对URL构造一个URL对象</strong>。例如：<code>URL downloadUrl = new URL(url, &quot;download.html&quot;);</code></li>
<li>public URL(String protocol, String host, String file)；例如：<code>new URL(&quot;http&quot;,&quot;www.baidu.com&quot;,&quot;download.html&quot;);</code></li>
<li>public URL(String protocol, String host, int port, String file)；例如：<code>URL gamelan = new URL(&quot;http&quot;, &quot;www.baidu.com&quot;, 80, &quot;download.html&quot;);</code></li>
</ul>
<p>URL类的构造器都声明抛出<strong>非运行时异常</strong>，必须要对这一异常进行处理，通常是<strong>用try-catch语句进行捕获</strong></p>
<h4 id="13-6-2-常用方法"><a href="#13-6-2-常用方法" class="headerlink" title="13.6.2 常用方法"></a>13.6.2 常用方法</h4><p>一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性：</p>
<ul>
<li>public String getProtocol( )：<strong>获取该URL的协议名</strong></li>
<li>public String getHost( )：<strong>获取该URL的主机名</strong></li>
<li>public String getPort( )：<strong>获取该URL的端口号</strong></li>
<li>public String getPath( )：<strong>获取该URL的文件路径</strong></li>
<li>public String getFile( )：<strong>获取该URL的文件名</strong></li>
<li>public String getQuery( )：<strong>获取该URL的查询名</strong></li>
</ul>
<pre><code class="java">//URL网络编程
//1.URL:统—资源定位符，对应着互联网的某—资源地址2.格式:
//http://Localhost:8080/TestImage.jpg?username=Tom
// 协议     主机名   端口号  资源地址        参数列表
@Test
public void TestURL()&#123;
    URL url = null;
    try &#123;
        url = new URL(&quot;http://Localhost:8080/examples/TestImage.jpg?username=Tom&quot;);
        //public String getProtocol()：获取该URL的协议名
        System.out.println(url.getProtocol());// http
        //public String getHost()：获取该URL的主机名
        System.out.println(url.getHost());// Localhost
        //public String getPort()：获取该URL的端口号
        System.out.println(url.getPort());// 8080
        //public String getPath()：获取该URL的文件路径
        System.out.println(url.getPath());// /TestImage.jpg
        //public String getFile()：获取该URL的文件名
        System.out.println(url.getFile());// /TestImage.jpg?username=Tom
        //public String getQuery()：获取该URL的查询名
        System.out.println(url.getQuery());// username=Tom
    &#125; catch (MalformedURLException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<pre><code class="java">//URL实现Tomcat服务器端资源下载
@Test
public void TestURLDownload()&#123;
    HttpURLConnection urlConnection = null;
    InputStream inputStream = null;
    FileOutputStream fileOutputStream = null;
    try &#123;
        //1.创建一个URL对象，确定要访问的地址和资源
        URL url = new URL(&quot;http://Localhost:8080/examples/TestImage.jpg&quot;);
        //2.获取Http连接
        urlConnection = (HttpURLConnection) url.openConnection();//用于获取跟服务器的连接
        //3.连接到目的地址
        urlConnection.connect();
        //4.获取一个输入流对象，用来读入资源
        inputStream = urlConnection.getInputStream();
        //5.创建一个文件字节输出流对象，用来将输入流读取的资源保存到本地
        fileOutputStream = new FileOutputStream(&quot;URLImage.jpg&quot;);
        byte[] buffer = new byte[1024];
        int len;
        while ((len = inputStream.read(buffer)) != -1)&#123;
            fileOutputStream.write(buffer,0,len);
        &#125;
        System.out.println(&quot;下载完成&quot;);
    &#125; catch (IOException e) &#123;
        e.printStackTrace();
    &#125; finally &#123;
        //6.关闭资源和连接
        try &#123;
            if (fileOutputStream != null)
                fileOutputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        try &#123;
            if (inputStream != null)
                inputStream.close();
        &#125; catch (IOException e) &#123;
            e.printStackTrace();
        &#125;
        if (urlConnection != null)
            urlConnection.disconnect();
    &#125;
&#125;
</code></pre>
<h2 id="十四、Java反射机制"><a href="#十四、Java反射机制" class="headerlink" title="十四、Java反射机制"></a>十四、Java反射机制</h2><h3 id="14-1-Java反射机制概述"><a href="#14-1-Java反射机制概述" class="headerlink" title="14.1 Java反射机制概述"></a>14.1 Java反射机制概述</h3><p>Reflection(反射）是被视为<strong>动态语言的关键</strong>，反射机制允许程序在<strong>执行期</strong>借助于Reflection API取得任何类的内部信息，并能<strong>直接操作任意对象的内部属性及方法</strong></p>
<p>加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（<strong>一个类只有一个Class对象</strong>），这个对象就包含了完整的类的结构信息。我们<strong>可以通过这个对象看到类的结构</strong>。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射</p>
<p>正常方式：引入需要的“包类”名称 —&gt; 通过new实例化 —&gt; 取得实例化对象<br>反射方式：实例化对象 —&gt; getClass()方法 —&gt; 得到完整的“包类”名称</p>
<h4 id="14-1-1-动态语言与静态语言"><a href="#14-1-1-动态语言与静态语言" class="headerlink" title="14.1.1 动态语言与静态语言"></a>14.1.1 动态语言与静态语言</h4><p>1、动态语言</p>
<p>是一类在<strong>运行时可以改变其结构的语言</strong>：例如<strong>新的函数、对象、甚至代码可以被引进</strong>，<strong>已有的函数可以被删除或是其他结构上的变化</strong>。通俗点说就是在运行时代码可以根据某些条件改变自身结构<br>主要动态语言：Object-C、C#、JavaSript、PHP、Python、Erlang</p>
<p>2、静态语言</p>
<p>与动态语言相对应的，<strong>运行时结构不可变的语言就是静态语言</strong>。如Java、C、C++<br>Java不是动态语言，但Java可以称之为“准动态语言”。即<strong>Java有一定的动态性</strong>，我们可以<strong>利用反射机制、字节码操作获得类似动态语言的特性</strong>，Java的动态性让编程的时候更加灵活</p>
<h4 id="14-1-2-Java反射机制研究及应用"><a href="#14-1-2-Java反射机制研究及应用" class="headerlink" title="14.1.2 Java反射机制研究及应用"></a>14.1.2 Java反射机制研究及应用</h4><p>Java反射机制提供的<strong>功能：</strong></p>
<ul>
<li>在<strong>运行时判断任意一个对象所属的类</strong></li>
<li>在<strong>运行时构造任意一个类的对象</strong></li>
<li>在<strong>运行时判断任意一个类所具有的成员变量和方法</strong></li>
<li>在<strong>运行时获取泛型信息</strong></li>
<li>在<strong>运行时调用任意一个对象的成员变量和方法</strong></li>
<li>在<strong>运行时处理注解</strong></li>
<li><strong>生成动态代理</strong></li>
</ul>
<h4 id="14-1-3-反射相关的API"><a href="#14-1-3-反射相关的API" class="headerlink" title="14.1.3 反射相关的API"></a>14.1.3 反射相关的API</h4><ul>
<li>java.lang.Class：代表一个类(所有的类都相当于是Class的对象)</li>
<li>java.lang.reflect.Method：代表类的方法</li>
<li>java.lang.reflect.Field：代表类的成员变量</li>
<li>java.lang.reflect.Constructor：代表类的构造器</li>
<li>……</li>
</ul>
<h4 id="14-1-4-反射前后对一个类的操作对比"><a href="#14-1-4-反射前后对一个类的操作对比" class="headerlink" title="14.1.4 反射前后对一个类的操作对比"></a>14.1.4 反射前后对一个类的操作对比</h4><pre><code class="java">//反射之前，对于Person类的操作
@Test
public void TestBeforeReflection()&#123;
    //1.创建Person对象
    Person p1 = new Person(&quot;Tom&quot;,12);
    //2.通过对象，调用其内部的属性、方法
    p1.age = 10;
    System.out.println(p1.toString());
    p1.show();
    //在Person类外部，不可以通过Person类的对象调用其内部私有结构
    //比如，name、showNation()、Person(String name)
&#125;
//使用反射之后
@Test
public void TestAfterReflection() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123;
    Class clazz = Person.class;
    //1.通过反射创建Person类的对象
    Constructor constructor = clazz.getConstructor(String.class, int.class);
    Object tom = constructor.newInstance(&quot;Tom&quot;, 12);
    Person p1 = (Person) tom;
    System.out.println(p1.toString());//Person&#123;name=&#39;Tom&#39;, age=12&#125;
    //2.通过反射，调用对象指定的属性、方法
    //调用属性
    Field age = clazz.getDeclaredField(&quot;age&quot;);
    age.set(p1,10);
    System.out.println(p1.toString());//Person&#123;name=&#39;Tom&#39;, age=10&#125;
    //调用方法
    Method show = clazz.getDeclaredMethod(&quot;show&quot;);
    show.invoke(p1);//这是Person类

    //通过反射，还可以调用Person类的私有结构的。比如:私有的构造器、方法、属性
    //私有构造器
    Constructor constructor1 = clazz.getDeclaredConstructor(String.class);
    constructor1.setAccessible(true);
    Person jerry = (Person) constructor1.newInstance(&quot;Jerry&quot;);
    System.out.println(jerry);//Person&#123;name=&#39;Jerry&#39;, age=0&#125;
    //私有属性
    Field name = clazz.getDeclaredField(&quot;name&quot;);
    name.setAccessible(true);
    name.set(jerry,&quot;Mary&quot;);
    System.out.println(jerry);//Person&#123;name=&#39;Mary&#39;, age=0&#125;
    //私有方法
    Method showNation = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class);
    showNation.setAccessible(true);
    String nation = (String) showNation.invoke(jerry,&quot;中国&quot;);//相当于String nation = jerry.showNation(&quot;中国&quot;)   我的国籍是中国
    System.out.println(nation);//中国
&#125;
</code></pre>
<h3 id="14-2-Class类的理解及获取Class实例"><a href="#14-2-Class类的理解及获取Class实例" class="headerlink" title="14.2 Class类的理解及获取Class实例"></a>14.2 Class类的理解及获取Class实例</h3><h4 id="14-2-1-Class类的理解"><a href="#14-2-1-Class类的理解" class="headerlink" title="14.2.1 Class类的理解"></a>14.2.1 Class类的理解</h4><p>关于java.Lang.class类的理解：</p>
<p>1.类的加载过程:</p>
<p>程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)<br>接着我们使用java.exe命令<strong>对某个字节码文件进行解释运行</strong>，<strong>相当于将某个字节码文件加载到内存中</strong>。此过程就称为类的加载。<strong>加载到内存中的类，我们就称为运行时类</strong>，<strong>此运行时类，就作为Class的一个实例</strong></p>
<p>比如，上方的Person类被编写成Person.class文件还不是一个运行时类，就不是Class的实例；而当我们将Person.class加载到内存(或是说JVM)中进行解释运行时，此时这个Person类才称得上是Class的实例</p>
<p>2.换句话说，<strong>Class的实例就对应着一个运行时类</strong></p>
<p>3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类</p>
<h4 id="14-2-2-获取Class类的实例"><a href="#14-2-2-获取Class类的实例" class="headerlink" title="14.2.2 获取Class类的实例"></a>14.2.2 获取Class类的实例</h4><pre><code class="java">//获取Class实例的四种方式(前三种需要掌握)
@Test
public void getClassExample() throws ClassNotFoundException &#123;
    //1.方式一：调用运行时类的属性.class
    Class&lt;Person&gt; clazz1 = Person.class;
    System.out.println(clazz1);//class Reflection.Person
    //方式二：通过运行时类的对象调用getClass()方法
    Person p = new Person();
    Class clazz2 = p.getClass();
    System.out.println(clazz2);//class Reflection.Person
    //方式三：调用Class的静态方法:forName(String classPath)  使用最多
    Class clazz3 = Class.forName(&quot;Reflection.Person&quot;);
    System.out.println(clazz3);//class Reflection.Person

    System.out.println(clazz1 == clazz2);//true
    System.out.println(clazz1 == clazz3);//true
    System.out.println(clazz2 == clazz3);//true
    //方式四：使用类的加载器:ClassLoader(了解)
    ClassLoader classLoader = ReflectionTest02.class.getClassLoader();
    Class clazz4 = classLoader.loadClass(&quot;Reflection.Person&quot;);
    System.out.println(clazz4);//class Reflection.Person
    System.out.println(clazz1 == clazz4);//true
&#125;
</code></pre>
<h4 id="14-2-3-哪些类型可以作为Class对象"><a href="#14-2-3-哪些类型可以作为Class对象" class="headerlink" title="14.2.3 哪些类型可以作为Class对象"></a>14.2.3 哪些类型可以作为Class对象</h4><p>(1) class：<strong>外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类</strong></p>
<p>(2) interface：<strong>接口</strong></p>
<p>(3 []：<strong>数组</strong></p>
<p>(4) enum：<strong>枚举</strong></p>
<p>(5) annotation：<strong>注解</strong>@interface</p>
<p>(6) primitive type：<strong>基本数据类型</strong></p>
<p>(7) <strong>void</strong></p>
<pre><code class="java">@Test
public void Test()&#123;
    Class c1 = Object.class;//对象
    Class c2 = Comparable.class;//接口
    Class c3 = String[].class;//一维数组
    Class c4 = int[][].class;//二维数组
    Class c5 = ElementType.class;//枚举类
    Class c6 = Override.class;//注解
    Class c7 = int.class;//基本数据类型
    Class c8 = void.class;//void
    Class c9 = Class.class;//Class本身

    int[] a = new int[10];
    int[] b = new int[100];
    Class c10 = a.getClass();
    Class c11 = b.getClass();
    //只要元素类型与维度一样，就是同一个Class
    System.out.println(c10 == c11);//true
&#125;
</code></pre>
<h3 id="14-3-类的加载与ClassLoader的理解"><a href="#14-3-类的加载与ClassLoader的理解" class="headerlink" title="14.3 类的加载与ClassLoader的理解"></a>14.3 类的加载与ClassLoader的理解</h3><h4 id="14-3-1-类的加载过程"><a href="#14-3-1-类的加载过程" class="headerlink" title="14.3.1 类的加载过程"></a>14.3.1 类的加载过程</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647502.png' data-fancybox='default' data-caption='image-20210810202245961'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647502.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647502.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210810202245961"></a><span class='image-caption'>image-20210810202245961</span></div></div>

<p>加载：</p>
<ul>
<li><strong>将class文件字节码内容加载到内存中</strong>，并将这些<strong>静态数据转换成方法区的运行时数据结构</strong>，然后<strong>生成一个代表这个类的java.lang.Class对象</strong>，<strong>作为方法区中类数据的访问入口</strong>（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与</li>
</ul>
<p>链接：<strong>将Java类的二进制代码合并到JVM的运行状态之中的过程</strong></p>
<ul>
<li>验证：<strong>确保加载的类信息符合JVM规范</strong>，例如：以cafe开头，没有安全方面的问题</li>
<li>准备：正式为<strong>类变量(static）分配内存并设置类变量默认初始值</strong>的阶段，这些<strong>内存都将在方法区中进行分配</strong></li>
<li>解析：虚拟机<strong>常量池内的符号引用（常量名）替换为直接引用（地址）</strong>的过程</li>
</ul>
<p>初始化：</p>
<ul>
<li><strong>执行类构造器<clinit>()方法的过程</strong>。类构造器<clinit>()方法<strong>是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的</strong>（<strong>类构造器是构造类信息的，不是构造该类对象的构造器</strong>）</li>
<li>当初始化一个类的时候，如果发现其<strong>父类还没有进行初始化</strong>，则需要<strong>先触发其父类的初始化</strong></li>
<li>虚拟机会****</li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647317.png' data-fancybox='default' data-caption='image-20210810203452201'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647317.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647317.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210810203452201"></a><span class='image-caption'>image-20210810203452201</span></div></div>

<h4 id="14-3-2-理解类加载器ClassLoader"><a href="#14-3-2-理解类加载器ClassLoader" class="headerlink" title="14.3.2 理解类加载器ClassLoader"></a>14.3.2 理解类加载器ClassLoader</h4><h5 id="1-类加载器的作用："><a href="#1-类加载器的作用：" class="headerlink" title="1.类加载器的作用："></a>1.类加载器的作用：</h5><ul>
<li><strong>类加载的作用</strong>：<strong>将class文件字节码内容加载到内存中</strong>，并将这些<strong>静态数据转换成方法区的运行时数据结构</strong>，然后<strong>在堆中生成一个代表这个类的java.lang.Class对象</strong>，作为方法区中类数据的访问入口</li>
<li><strong>类缓存：</strong>标准的JavaSE类加载器可以按要求查找类，但一旦某<strong>个类被加载到类加载器中，它将维持加载（缓存）一段时间</strong>。不过JVM垃圾回收机制可以回收这些Class对象</li>
</ul>
<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647633.png' data-fancybox='default' data-caption='image-20210810204715392'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647633.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647633.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210810204715392"></a><span class='image-caption'>image-20210810204715392</span></div></div>

<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647211.png' data-fancybox='default' data-caption='image-20210810205237266'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647211.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201647211.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210810205237266"></a><span class='image-caption'>image-20210810205237266</span></div></div>

<h5 id="2-获取三种类加载器"><a href="#2-获取三种类加载器" class="headerlink" title="2.获取三种类加载器"></a>2.获取三种类加载器</h5><pre><code class="java">@Test
public void TestClassLoader()&#123;
    //对于自定义类，使用系统类加载器进行加载
    ClassLoader classLoader = ReflectionTest03.class.getClassLoader();//获得系统类加载器
    System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2

    //调用系统类加载器的getParent()：获取扩展类加载器
    ClassLoader classLoader1 = classLoader.getParent();
    System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@1f32e575，获取到的扩展类加载器

    //调用扩展类加载器的getParent()：无法获取引导类加载器
    //引导类加载器主要负责java的核心类库，无法加载自定义类
    ClassLoader classLoader2 = classLoader1.getParent();
    System.out.println(classLoader2);//null，不能直接获取引导类加载器

    ClassLoader classLoader3 = String.class.getClassLoader();
    System.out.println(classLoader3);//null,说明String类是引导类加载的
&#125;
</code></pre>
<h5 id="3-使用ClassLoader加载配置文件"><a href="#3-使用ClassLoader加载配置文件" class="headerlink" title="3.使用ClassLoader加载配置文件"></a>3.使用ClassLoader加载配置文件</h5><pre><code class="java">@Test
public void TestLoadProperty() throws IOException &#123;
    Properties pros = new Properties();//用来读取配置文件

    //读取配置文件的方式一：此时的配置文件默认在当前项目(或Module)下
    //FileInputStream fileInputStream = new FileInputStream(&quot;jdbc.properties&quot;);
    //pros.load(fileInputStream);

    //读取配置文件的方式二：此时的配置文件默认在当前项目(或Module)的src下
    ClassLoader classLoader = ReflectionTest03.class.getClassLoader();
    InputStream inputStream = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;);
    pros.load(inputStream);

    String name = pros.getProperty(&quot;name&quot;);
    String password = pros.getProperty(&quot;password&quot;);
    System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);//方式一：name = Tom, password = abc123            方式二：name = Mary, password = 123
&#125;
</code></pre>
<h3 id="14-4-创建运行时对象"><a href="#14-4-创建运行时对象" class="headerlink" title="14.4 创建运行时对象"></a>14.4 创建运行时对象</h3><h4 id="14-4-1-通过反射创建运行时类对象"><a href="#14-4-1-通过反射创建运行时类对象" class="headerlink" title="14.4.1 通过反射创建运行时类对象"></a>14.4.1 通过反射创建运行时类对象</h4><pre><code class="java">//通过反射，创建运行时类对象
/*
newInstance():调用此方法，创建对应的运行时类的对象
要想此方法正常的创建运行时类的对象，

要求:1.运行时类必须提供空参的构造器
2.空参的构造器的访问权限得够。通常，设置为public，如果想访问private构造器，需要调用setAccessible()方法设置可调用性
在javabean中要求提供一个public的空参构造器。

原因:1.便于通过反射，创建运行时类的对象
2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器
*/
Class clazz = Person.class;
Person p1 = (Person) clazz.newInstance();
System.out.println(p1);
/*
或者
Class&lt;Person&gt; clazz = Person.class;
*/
</code></pre>
<h4 id="14-4-2-体会反射的动态性"><a href="#14-4-2-体会反射的动态性" class="headerlink" title="14.4.2 体会反射的动态性"></a>14.4.2 体会反射的动态性</h4><pre><code class="java">//体会反射的动态性
//创建一个指定类的对象。classPath指定类的全类名
public Object getInstance(String classPath) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123;
    Class clazz = Class.forName(classPath);
    return clazz.newInstance();
&#125;

@Test
public void TestDynamic()&#123;
    int num = new Random().nextInt(3);//0、1、2
    String classPath = &quot;&quot;;
    switch (num)&#123;
        case 0:
            classPath = &quot;java.util.Date&quot;;
            break;
        case 1:
            classPath = &quot;java.lang.Object&quot;;
            break;
        case 2:
            classPath = &quot;Reflection.Reflection03&quot;;
            break;
    &#125;
    try &#123;
        Object obj = getInstance(classPath);
        System.out.println(obj);
    &#125; catch (ClassNotFoundException e) &#123;
        e.printStackTrace();
    &#125; catch (InstantiationException e) &#123;
        e.printStackTrace();
    &#125; catch (IllegalAccessException e) &#123;
        e.printStackTrace();
    &#125;
&#125;
</code></pre>
<h3 id="14-5-获取运行时类的完整结构"><a href="#14-5-获取运行时类的完整结构" class="headerlink" title="14.5 获取运行时类的完整结构"></a>14.5 获取运行时类的完整结构</h3><h4 id="14-5-1-提供一个结构丰富的自定义类Person"><a href="#14-5-1-提供一个结构丰富的自定义类Person" class="headerlink" title="14.5.1 提供一个结构丰富的自定义类Person"></a>14.5.1 提供一个结构丰富的自定义类Person</h4><pre><code class="java">//自定义类
@MyAnnotation
public class Person1 extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123;

    private String name;
    int age;
    public int id;

    public Person1() &#123;
    &#125;

    @MyAnnotation(value = &quot;constructor&quot;)
    private Person1(String name) &#123;
        this.name = name;
    &#125;

    Person1(String name,int age)&#123;
        this.name = name;
        this.age = age;
    &#125;

    @MyAnnotation(value = &quot;nation&quot;)
    private String show(String nation)&#123;
        System.out.println(&quot;我的国籍是&quot; + nation);
        return nation;
    &#125;

    public String display(String interest,int age) throws NullPointerException,ClassCastException&#123;
        return interest + age;
    &#125;

    @Override
    public void Info() &#123;
        System.out.println(&quot;这是一个人&quot;);
    &#125;

    @Override
    public int compareTo(String o) &#123;
        return 0;
    &#125;
    
    private static void showDesc()&#123;
        System.out.println(&quot;我是Person1类的静态方法&quot;);
    &#125;
    
    @Override
    public String toString() &#123;
        return &quot;Person1&#123;&quot; +
                &quot;name=&#39;&quot; + name + &#39;\&#39;&#39; +
                &quot;, age=&quot; + age +
                &quot;, id=&quot; + id +
                &#39;&#125;&#39;;
    &#125;
&#125;
</code></pre>
<pre><code class="java">//自定义类的父类
public class Creature&lt;T&gt; implements Serializable &#123;
    private char gender;
    public double weight;

    private void breath()&#123;
        System.out.println(&quot;生物呼吸&quot;);
    &#125;

    public void eat()&#123;
        System.out.println(&quot;生物吃东西&quot;);
    &#125;
&#125;
//自定义类的注解
@Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)
@Retention(RetentionPolicy.SOURCE)
public @interface MyAnnotation &#123;
    String value() default &quot;hello&quot;;
&#125;
//自定义类实现的接口
public interface MyInterface &#123;
    void Info();
&#125;
</code></pre>
<h4 id="14-5-2-获取运行时类的属性结构及其内部结构"><a href="#14-5-2-获取运行时类的属性结构及其内部结构" class="headerlink" title="14.5.2 获取运行时类的属性结构及其内部结构"></a>14.5.2 获取运行时类的属性结构及其内部结构</h4><pre><code class="java">//获取运行时类的属性结构
@Test
public void TestGetField()&#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //获取属性结构
    //getFields():获取当前运行时类及其父类中声明为public访问权限的属性
    Field[] fields = clazz.getFields();
    for (Field field : fields) &#123;
        System.out.println(field);
        //public int Reflection.Person1.id
        // public double Reflection.Creature.weight
    &#125;
     System.out.println(&quot;*********************&quot;);
    //getDeclaredFields():获取当前运行时类中声明的所有属性（不包含父类中声明的属性）
    Field[] declaredFields = clazz.getDeclaredFields();
    for (Field declaredField : declaredFields) &#123;
        System.out.println(declaredField);
        //private java.lang.String Reflection.Person1.name
        // int Reflection.Person1.age
        // public int Reflection.Person1.id
    &#125;
    System.out.println(&quot;*********************&quot;);
    
    //获取属性的权限修饰符，数据类型，变量名
    for (Field declaredField : declaredFields) &#123;
        //权限修饰符
        int modifier = declaredField.getModifiers();
        System.out.print(Modifier.toString(modifier) + &quot;\t&quot;);
        //数据类型
        Class type = declaredField.getType();
        System.out.print(type + &quot;\t&quot;);
        //变量名
        String name = declaredField.getName();
        System.out.println(name);
        //private    class java.lang.String    name
        //    int    age
        //public    int    id
    &#125;
&#125;
</code></pre>
<h4 id="14-5-3-获取运行时类的方法结构及其内部结构"><a href="#14-5-3-获取运行时类的方法结构及其内部结构" class="headerlink" title="14.5.3 获取运行时类的方法结构及其内部结构"></a>14.5.3 获取运行时类的方法结构及其内部结构</h4><pre><code class="java">//获取运行时类的方法结构及其内部结构
@Test
public void TestGetMethod()&#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //getMethods():获取当前运行时类及其所有父类中声明为public权限的方法
    Method[] methods = clazz.getMethods();
    for (Method method : methods) &#123;
        System.out.println(method);
        //public int Reflection.Person1.compareTo(java.lang.String)
        //public int Reflection.Person1.compareTo(java.lang.Object)
        //public void Reflection.Person1.Info()
        //public java.lang.String Reflection.Person1.display(java.lang.String,int) throws java.lang.NullPointerException,java.lang.ClassCastException
        //public void Reflection.Creature.eat()
        //public final void java.lang.Object.wait() throws java.lang.InterruptedException
        //public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException
        //public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException
        //public boolean java.lang.Object.equals(java.lang.Object)
        //public java.lang.String java.lang.Object.toString()
        //public native int java.lang.Object.hashCode()
        //public final native java.lang.Class java.lang.Object.getClass()
        //public final native void java.lang.Object.notify()
        //public final native void java.lang.Object.notifyAll()
    &#125;
    System.out.println(&quot;************************&quot;);
    //getDeclaredMethods():获取当前运行时类中声明的所有方法(不包含父类中的方法)
    Method[] declaredMethods = clazz.getDeclaredMethods();
    for (Method declaredMethod : declaredMethods) &#123;
        System.out.println(declaredMethod);
        //public int Reflection.Person1.compareTo(java.lang.String)
        //public int Reflection.Person1.compareTo(java.lang.Object)
        //public void Reflection.Person1.Info()
        //public java.lang.String Reflection.Person1.display(java.lang.String,int) throws java.lang.NullPointerException,java.lang.ClassCastException
        //private java.lang.String Reflection.Person1.show(java.lang.String)
    &#125;

    System.out.println(&quot;*************************&quot;);
    //获取方法的内部结构
    // @Xxx(注解)
    // 权限修饰符 返回值类型 方法名 (参数值类型1 形参名1) throws XxxException &#123;&#125;
    for (Method declaredMethod : declaredMethods) &#123;
        //1.获取方法声明的注解
        Annotation[] annotations = declaredMethod.getAnnotations();
        for (Annotation annotation : annotations) &#123;
            System.out.println(annotation);//@Reflection.MyAnnotation(value=nation)
            //能被获取到的注解其元注解Retention的值需要是RUNTIME
        &#125;
        //2.获取方法的权限修饰符
        System.out.print(Modifier.toString(declaredMethod.getModifiers()) + &quot;\t&quot;);
        //3.获取方法的返回值类型
        System.out.print(declaredMethod.getReturnType().getName() + &quot;\t&quot;);
        //4.获取方法名
        System.out.print(declaredMethod.getName());
        //5.获取形参列表
        //方法一：
        System.out.print(&quot;(&quot;);
        Class[] parameterTypes = declaredMethod.getParameterTypes();//获取到形参列表的所有参数类型
        if(!(parameterTypes == null || parameterTypes.length == 0))&#123;//判断是否为空
            for (int i = 0;i &lt; parameterTypes.length;i++) &#123;//遍历形参列表
                if (i == parameterTypes.length-1)&#123;//判断是否为形参列表最后一个参数，若是就不用加&quot;,&quot;，然后跳出遍历循环
                    System.out.print(parameterTypes[i].getName() + &quot; &quot; + &quot;arg_&quot; + i);
                    break;
                &#125;
                System.out.print(parameterTypes[i].getName() + &quot; &quot; + &quot;arg_&quot; + i + &quot;,&quot;);
            &#125;
        &#125;
        System.out.print(&quot;)&quot;);
        //方法二：
        System.out.print(&quot;(&quot;);
        Parameter[] parameters = declaredMethod.getParameters();
        if (!(parameters == null || parameters.length == 0))&#123;
            for (int i = 0;i &lt; parameters.length;i++) &#123;
                if (i == parameters.length - 1)&#123;
                    System.out.print(parameters[i]);
                    break;
                &#125;
                System.out.print(parameters[i] + &quot;,&quot;);
            &#125;
        &#125;
        System.out.print(&quot;)&quot;);
        //6.获取抛出的异常
        Class[] exceptionTypes = declaredMethod.getExceptionTypes();
        if (!(exceptionTypes == null || exceptionTypes.length == 0))&#123;
            System.out.print(&quot; throws &quot;);
            for (int i = 0; i &lt; exceptionTypes.length; i++) &#123;
                if (i == exceptionTypes.length - 1)&#123;
                    System.out.print(exceptionTypes[i].getName());
                    break;
                &#125;
                System.out.print(exceptionTypes[i].getName() + &quot;,&quot;);
            &#125;
        &#125;
        System.out.println();
        //public    int    compareTo(java.lang.String arg_0)
        //public volatile    int    compareTo(java.lang.Object arg_0)
        //public    void    Info()
        //public    java.lang.String    display(java.lang.String arg_0,int arg_1) throws java.lang.NullPointerException,java.lang.ClassCastException
        //@Reflection.MyAnnotation(value=nation)
        //private    java.lang.String    show(java.lang.String arg_0)
    &#125;
&#125;
</code></pre>
<h4 id="14-5-4-获取运行时类的构造器结构"><a href="#14-5-4-获取运行时类的构造器结构" class="headerlink" title="14.5.4 获取运行时类的构造器结构"></a>14.5.4 获取运行时类的构造器结构</h4><pre><code class="java">//获取运行时类的构造器结构
@Test
public void TestGetConstructor()&#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //getConstructor():获取当前运行时类中声明为public的构造器(不包含父类构造器)
    Constructor[] constructors = clazz.getConstructors();
    for (Constructor constructor : constructors) &#123;
        System.out.println(constructor);//public Reflection.Person1()
    &#125;
    //getDeclaredConstructors():获取当前运行时类中声明的所有构造器
    Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors();
    for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123;
        System.out.println(declaredConstructor);
        //Reflection.Person1(java.lang.String,int)
        //private Reflection.Person1(java.lang.String)
        //public Reflection.Person1()
    &#125;
    //获取运行时类的构造器内部结构跟方法一样，使用获取到的构造器再调用相应的获取修饰符、构造器名字、参数类型、参数名的方法即可
&#125;
</code></pre>
<h4 id="14-5-5-获取运行时类的父类及父类泛型"><a href="#14-5-5-获取运行时类的父类及父类泛型" class="headerlink" title="14.5.5 获取运行时类的父类及父类泛型"></a>14.5.5 获取运行时类的父类及父类泛型</h4><pre><code class="java">//获取运行时类的父类及父类泛型
@Test
public void TestGetParent()&#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //getSuperClass():获取运行时类的父类
    Class superclass = clazz.getSuperclass();
    System.out.println(superclass);//class Reflection.Creature
    //getGenericSuperClass():获取运行时类的带泛型的父类
    Type genericSuperclass = clazz.getGenericSuperclass();
    System.out.println(genericSuperclass);//Reflection.Creature&lt;java.lang.String&gt;
    //getActualTypeArguments():获取运行时类的带泛型的父类的泛型
    ParameterizedType paramType = (ParameterizedType) genericSuperclass;//将泛型父类对象转换成带泛型参数的父类对象
    Type[] actualTypeArguments = paramType.getActualTypeArguments();//获取具体泛型参数类型
    for (Type actualTypeArgument : actualTypeArguments) &#123;
        System.out.println(actualTypeArgument.getTypeName());//java.lang.String
    &#125;
&#125;
</code></pre>
<h4 id="14-5-6-获取运行时类的接口、所在包、注解等"><a href="#14-5-6-获取运行时类的接口、所在包、注解等" class="headerlink" title="14.5.6 获取运行时类的接口、所在包、注解等"></a>14.5.6 获取运行时类的接口、所在包、注解等</h4><pre><code class="java">//获取运行时类的接口、所在包、注解等
@Test
public void TestGetOther()&#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //getInterfaces():获取运行时类实现的接口
    Class[] interfaces = clazz.getInterfaces();
    for (Class anInterface : interfaces) &#123;
        System.out.println(anInterface);//interface java.lang.Comparable   interface Reflection.MyInterface
    &#125;
    //获取运行时类父类实现的接口
    Class[] interfaces1 = clazz.getSuperclass().getInterfaces();
    for (Class aClass : interfaces1) &#123;
        System.out.println(aClass);//interface java.io.Serializable
    &#125;
    //获取运行时类所在的包
    Package aPackage = clazz.getPackage();
    System.out.println(aPackage);//package Reflection
    //获取运行时类的注解
    Annotation[] annotations = clazz.getAnnotations();
    for (Annotation annotation : annotations) &#123;
        System.out.println(annotation);//@Reflection.MyAnnotation(value=hello)
    &#125;
&#125;
</code></pre>
<h3 id="14-6-调用运行时类的指定结构"><a href="#14-6-调用运行时类的指定结构" class="headerlink" title="14.6 调用运行时类的指定结构"></a>14.6 调用运行时类的指定结构</h3><h4 id="14-6-1-调用运行时类的指定属性"><a href="#14-6-1-调用运行时类的指定属性" class="headerlink" title="14.6.1 调用运行时类的指定属性"></a>14.6.1 调用运行时类的指定属性</h4><pre><code class="java">//调用运行时类的指定属性 -- 需要掌握
@Test
public void TestTransferField() throws InstantiationException, IllegalAccessException, NoSuchFieldException &#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //创建运行时类的对象
    Person1 person = clazz.newInstance();
    //getField()获取指定的属性:要求运行时类中属性声明为public
    Field id = clazz.getField(&quot;id&quot;);
    //设置当前属性的值   set():参数1指明哪个对象的属性   参数2将此属性值设置为多少
    id.set(person,1001);
    //获取当前属性的值   get():参数1获取哪个对象的当前属性值
    int pId = (int) id.get(person);
    System.out.println(pId);//1001

    //getDeclaredField(String fieldName)获取运行时类中指定变量名的属性
    Field name = clazz.getDeclaredField(&quot;name&quot;);
    name.setAccessible(true);//保证当前属性是可访问的
    //获取、设置当前对象的属性值
    name.set(person,&quot;Tom&quot;);
    System.out.println(name.get(person));//Tom
&#125;
</code></pre>
<h4 id="14-6-2-调用运行时类的指定方法"><a href="#14-6-2-调用运行时类的指定方法" class="headerlink" title="14.6.2 调用运行时类的指定方法"></a>14.6.2 调用运行时类的指定方法</h4><pre><code class="java">//调用运行时类的指定方法
@Test
public void TestTransferMethod() throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123;
    Class&lt;Person1&gt; clazz = Person1.class;
    //创建运行时类的对象
    Person1 person = clazz.newInstance();
    //获取指定的某个方法(调用非静态方法)
    //getDeclaredMethod():参数1∶指明获取的方法的名称﹑参数2:指明获取的方法的形参列表
    Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class);
    show.setAccessible(true);//保证当前方法可访问
    //invoke():参数1:方法的调用者，参数2:给方法形参赋值的实参，其返回值为对应类中调用该方法的返回值
    Object chn = show.invoke(person, &quot;CHN&quot;);//类似于String chn = person.show(&quot;CHN&quot;);
    System.out.println(chn);//CHN

    //调用静态方法
    Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;);
    showDesc.setAccessible(true);
    Object invoke = showDesc.invoke(Person.class);//类似于Person.showDesc()
    System.out.println(invoke);//null，方法没有返回值则invoke返回null
&#125;
</code></pre>
<h4 id="14-6-3-调用运行时类的指定构造器"><a href="#14-6-3-调用运行时类的指定构造器" class="headerlink" title="14.6.3 调用运行时类的指定构造器"></a>14.6.3 调用运行时类的指定构造器</h4><pre><code class="java">//调用运行时类的指定构造器
@Test
public void TestTransferConstructor() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123;
    //一般情况都用newInstance()方法调用空参构造器创建对象

    Class&lt;Person1&gt; clazz = Person1.class;
    //调用指定构造器
    //getDeclaredConstructor():参数:指明要调用的构造器的参数列表
    Constructor&lt;Person1&gt; constructor = clazz.getDeclaredConstructor(String.class);
    constructor.setAccessible(true);//保证当前构造器可访问
    //调用此构造器创建运行时类对象
    Person1 person = constructor.newInstance(&quot;Tom&quot;);
    System.out.println(person);//Person1&#123;name=&#39;Tom&#39;, age=0, id=0&#125;
&#125;
</code></pre>
<h3 id="14-7-反射的应用：动态代理"><a href="#14-7-反射的应用：动态代理" class="headerlink" title="14.7 反射的应用：动态代理"></a>14.7 反射的应用：动态代理</h3><p>代理设计模式的原理：</p>
<p><strong>使用一个代理将对象包装起来</strong>,然后<strong>用该代理对象取代原始对象</strong>。任何对原始对象的调用都要通过代理。<strong>代理对象决定是否以及何时将方法调用转到原始对象上</strong></p>
<p>之前5.6.2接口中提到的代理机制的操作，属于<strong>静态代理</strong>，特征是<strong>代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展</strong>。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。<strong>最好可以通过一个代理类完成全部的代理功能</strong></p>
<h4 id="14-7-1-动态代理"><a href="#14-7-1-动态代理" class="headerlink" title="14.7.1 动态代理"></a>14.7.1 动态代理</h4><p>动态代理是<strong>指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象</strong></p>
<p>动态代理<strong>使用场合：</strong></p>
<ul>
<li><strong>调试</strong></li>
<li><strong>远程方法调用</strong></li>
</ul>
<p>动态代理相比于静态代理的<strong>优点：</strong><br><strong>抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理</strong>，这样，我们可以更加灵活和统一的处理众多的方法</p>
<h4 id="14-7-2-静态代理实例"><a href="#14-7-2-静态代理实例" class="headerlink" title="14.7.2 静态代理实例"></a>14.7.2 静态代理实例</h4><pre><code class="java">//静态代理测试
//特点：代理类和被代理类在编译期间就确定下来了
public class StaticProxyTest &#123;
    public static void main(String[] args) &#123;
        //创建被代理类对象
        ClothFactory nike = new NikeClothFactory();
        //用被代理类对象创建代理类对象
        ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike);
        //调用代理类的方法
        proxyClothFactory.produceCloth();
    &#125;
&#125;

interface ClothFactory&#123;
    void produceCloth();
&#125;

//代理类
class ProxyClothFactory implements ClothFactory&#123;
    private ClothFactory factory;

    public ProxyClothFactory(ClothFactory factory)&#123;
        this.factory = factory;
    &#125;
    @Override
    public void produceCloth() &#123;
        System.out.println(&quot;代理工厂做准备工作&quot;);
        factory.produceCloth();
        System.out.println(&quot;代理工厂做后续收尾工作&quot;);
    &#125;
&#125;
//被代理类
class NikeClothFactory implements ClothFactory&#123;
    @Override
    public void produceCloth() &#123;
        System.out.println(&quot;Nike工厂生产运动服&quot;);
    &#125;
&#125;
</code></pre>
<h4 id="14-7-3-动态代理实例"><a href="#14-7-3-动态代理实例" class="headerlink" title="14.7.3 动态代理实例"></a>14.7.3 动态代理实例</h4><pre><code class="java">//动态代理测试
//要想实现动态代理，需要解决的问题?
//问题一:如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象(动态代理的核心)
//问题二:当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a
public class DynamicProxyTest &#123;
    public static void main(String[] args) &#123;
        //创建被代理类对象
        SuperMan superMan = new SuperMan();
        //创建代理类对象
        //因为代理类和被代理类都会实现相同的接口，所以可以将代理类转换成接口对象
        Human proxyInstance = (Human) ProxyFactor.getProxyInstance(superMan);//此时的proxyInstance就是代理类的对象
        //当通过代理类对象调用方法时，会自动调用被代理类中同名的方法
        String belief = proxyInstance.getBelief();
        System.out.println(belief);
        proxyInstance.eat(&quot;四川麻辣烫&quot;);
        System.out.println(&quot;***********************&quot;);
        NikeClothFactory nikeClothFactory = new NikeClothFactory();
        ClothFactory proxyClothFactory = (ClothFactory) ProxyFactor.getProxyInstance(nikeClothFactory);
        proxyClothFactory.produceCloth();
    &#125;
&#125;

interface Human&#123;
    String getBelief();
    void eat(String food);
&#125;
//被代理类
class SuperMan implements Human&#123;
    @Override
    public String getBelief() &#123;
        return &quot;I believe I can fly!&quot;;
    &#125;

    @Override
    public void eat(String food) &#123;
        System.out.println(&quot;我喜欢吃&quot; + food);
    &#125;
&#125;
//下方两个类的个人理解:代理类创建实例的步骤和调用代理类中与被代理类中的同名方法的步骤被分成两个类单独处理，由于被代理类的不确定性，则创建出的代理类的对象也具有不确定性，所以就体现出了动态代理的动态性
//根据被代理类创建代理类的工厂
class ProxyFactor&#123;
    //调用此方法，返回一个代理类的对象
    public static Object getProxyInstance(Object obj)&#123;//obj:被代理类对象
        MyInvocationHandler handler = new MyInvocationHandler();
        handler.bind(obj);
        return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler);
        //newProxyInstance()中的参数：
        //ClassLoader loader:类加载器定义代理类
        //类&lt;?&gt;[] interfaces:代理类需要实现的接口
        //InvocationHandler h:调用被代理类的方法的具体处理类的对象
        //newProxyInstance()根据传入的被代理类的构造器、代理类需要实现哪些接口、代理类实例调用被代理类方法的具体处理类的对象来创建并返回一个代理类对象
    &#125;
&#125;
//代理类实例调用代理类中与被代理类中被调用的同名方法的具体类
class MyInvocationHandler implements InvocationHandler&#123;
    private Object obj;//需要使用被代理类的对象进行赋值
    public void bind(Object obj)&#123;
        this.obj = obj;
    &#125;
    //当我们通过代理类对象，调用方法a时，就会自动调用如下的方法：invoke()
    //将被代理类要执行的方法a的功能就声明在invoke()中
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;//相当于是调用代理类中的method方法，然后再在里面调用被代理类的同名方法
        //proxy:调用该方法的代理实例
        //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法
        //args:被调用方法的参数列表
        //obj:被代理类对象
        Object returnValue = method.invoke(obj, args);//类似obj.method(args)
        //上述方法的返回值就作为当前类中的invoke()的返回值
        return returnValue;
    &#125;
&#125;
</code></pre>
<h4 id="14-7-4-动态代理与AOP"><a href="#14-7-4-动态代理与AOP" class="headerlink" title="14.7.4 动态代理与AOP"></a>14.7.4 动态代理与AOP</h4><div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648255.png' data-fancybox='default' data-caption='image-20210812132140133'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648255.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648255.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210812132140133"></a><span class='image-caption'>image-20210812132140133</span></div></div>

<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648307.png' data-fancybox='default' data-caption='image-20210812132406550'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648307.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648307.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210812132406550"></a><span class='image-caption'>image-20210812132406550</span></div></div>

<div galleryFlag itemscope itemtype="http://schema.org/ImageGallery" class="gallery " data-group='default'><div class='fancybox'><a class='fancybox' pjax-fancybox itemscope itemtype="http://schema.org/ImageObject" itemprop="url" target="_blank" rel="noopener" href='https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648947.png' data-fancybox='default' data-caption='image-20210812132428676'><img fancybox itemprop="contentUrl" src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648947.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202109201648947.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" alt="image-20210812132428676"></a><span class='image-caption'>image-20210812132428676</span></div></div>

  </div>
  
  
    
    <div class='footer'>
       <!-- 参考资料、相关资料等 -->
      
       <!-- 相关文章 -->
      
        
  <div class="related_posts">
    <section class='header'>
      <i class="fa-solid fa-bookmark fa-fw" aria-hidden="true"></i><span>相关文章</span>
    </section>
    <section class='body'>
      <div class="vlts-rps"><a class="item" href="\categories\后端\Mybatis学习笔记.html" title="Mybatis学习笔记" rel="bookmark "><img src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Mybatis.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Mybatis.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /><span class="title">Mybatis学习笔记</span></a><a class="item" href="\categories\后端\Mybatis-plus学习笔记.html" title="Mybatis-plus学习笔记" rel="bookmark "><img src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Mybatis-plus.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Mybatis-plus.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /><span class="title">Mybatis-plus学习笔记</span></a><a class="item" href="\categories\后端\Spring5学习笔记.html" title="Spring框架笔记" rel="bookmark "><img src="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Spring.png" class="lazyload" data-srcset="https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Spring.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==" /><span class="title">Spring框架笔记</span></a></div></section></div>
      
      <!-- 版权声明组件 -->
      
      <!-- 打赏组件 -->
      
    </div>
  
  
    


  <div class='article-meta' id="bottom">
    <div class='new-meta-box'>
      
        
          
  <div class='new-meta-item category'>
    <i class="fa-solid fa-folder-open fa-fw" aria-hidden="true"></i>
    <a class="category-link" href="/categories/%E5%90%8E%E7%AB%AF/">后端</a>
    
      <span hidden itemprop="about" itemscope itemtype="http://schema.org/Thing">
        <a href="/categories/%E5%90%8E%E7%AB%AF/" itemprop="url"><span itemprop="name">后端</span></a>
      </span>
    
  </div>


        
      
        
          
  
  <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E7%AC%94%E8%AE%B0/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>笔记</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/Java/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>Java</p></a></div> <div class="new-meta-item meta-tags"><a class="tag" href="/tags/%E5%90%8E%E7%AB%AF/" rel="nofollow"><i class="fa-solid fa-hashtag fa-fw" aria-hidden="true"></i><p>后端</p></a></div>
  <span hidden itemprop="keywords">笔记 Java 后端</span>


        
      
        
          <div class="new-meta-item date" itemprop="dateModified" datetime="2022-03-27T21:38:17+08:00">
  <a class='notlink'>
    <i class="fa-solid fa-pen-to-square fa-fw" aria-hidden="true"></i>
    <p>更新于：2022年3月27日</p>
  </a>
</div>

        
      
        
          
  <div class="new-meta-item share -mob-share-list">
  <div class="-mob-share-list share-body">
    
      
        <a class="-mob-share-qq" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html&title=JavaSE学习笔记 - 夜雨声烦&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qq.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-qzone" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="https://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html&title=JavaSE学习笔记 - 夜雨声烦&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/qzone.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        <a class="-mob-share-weibo" title="" rel="external nofollow noopener noreferrer noopener"
          
          target="_blank" href="http://service.weibo.com/share/share.php?url=http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html&title=JavaSE学习笔记 - 夜雨声烦&summary="
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/weibo.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
      
        
        <div class='hoverbox'>
          <a class='share'><img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/wechat.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/wechat.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw=="></a>
          <div class='target'>
            <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAVgAAAFYCAAAAAAzB7ucAAAEZElEQVR42u3aQZLjOAwEwP7/p2cesOEQUACp9mzyZrstkykdgGr8/LGOrB8EYMFaYMGCtcBegf0J138u+OHzT3//cWMP36/uZ/v6VQ+wYMGCBQsWLFiwd2HTjVU3WP296sGfvl891/qDABYsWLBgwYIFC/YV2McCOHydFvbdG9EFnjYkYMGCBQsWLFiwYL8b9lSjUW04tm4cWLBgwYIFCxYs2P8nbDU4ngbW1d/tPghgwYIFCxYsWLBgvxM2Lai76/SAxVZQ/9okDFiwYMGCBQsWLNgS7BTmX3sde4AFCxYsWLBgwYK9Ajtd3eA4HdzoDmakgyRjD7BgwYIFCxYsWLBXYNMCOT1I2mhU9/t0jm5AXj0/WLBgwYIFCxYs2Hdg4wuFjcG0EUj3dzzIBwsWLFiwYMGCBXsFthtIpwV6WrinN3q7MSg/UGDBggULFixYsGB/BeypYDodCNmC3b6hYMGCBQsWLFiwYO/CToPd9Aal153CtAv+bjAOFixYsGDBggUL9gpst0A/1QCc+v1pAN8OzMGCBQsWLFiwYMG+AnurkE4HQ049CGv7BwsWLFiwYMGCBXsFdmtQoVuQT4Px9PfSB6L8+2DBggULFixYsGCvwqYB71Zh3Q3A02B7Gpg/XgcsWLBgwYIFCxbsVdjuAauFfXVj6YDE1qBIdV+P74MFCxYsWLBgwYK9CpsGvtMAulq4bwfX3RsQD2yABQsWLFiwYMGCPQo7DaK3gu0pTBrUrzUeYMGCBQsWLFiwYK/AbjcK3Y2mgxnVfU+D7PaNAwsWLFiwYMGCBfsrYNNGoft36SBHWuifCujBggULFixYsGDB3oHtHnjaCHSvtzWokQKv/QcBLFiwYMGCBQsW7Cpst2BOBza2AuVtmPT7H98HCxYsWLBgwYIF+ypsN3DuFtJT8O0bsAYOFixYsGDBggUL9grsdEBiG2D7Rm7v4/H6YMGCBQsWLFiwYF+FPRUMp4MZ1c+7gxbHgm6wYMGCBQsWLFiwV2CnB5tCbBf02w9C+UaBBQsWLFiwYMGCfQW2GjB3D7wFkA5opPtsP4BgwYIFCxYsWLBgr8KmENUDVQ+YBuHbjUrcGIEFCxYsWLBgwYJ9FXarYJ8GytsNwvSBGTcIYMGCBQsWLFiwYI/Cpp+fCpxPB+pdQLBgwYIFCxYsWLC/E7ZbUKcNRvf9dFBkawDlseEBCxYsWLBgwYIFewV2urYL8BRqOwCPHwSwYMGCBQsWLFiwV2C3By+qG9p63Q3Ep8F8O+gGCxYsWLBgwYIFexR22hB0A+RTAyPpvo41CGDBggULFixYsGCvwG4Fxd0DpNfbalim1wcLFixYsGDBggX7nbDTQYvpIEg60LEdgIMFCxYsWLBgwYL9btguRNo4nB70WBvYAAsWLFiwYMGCBXsUdnrANGjeOuB249EdNAELFixYsGDBggV7F7a7tiGmhX91f2lQXv4eWLBgwYIFCxYs2Cuw1u4CCxasBRYsWAvs0fUXOrAStv3OqDgAAAAASUVORK5CYII=">
          </div>
        </div>
      
    
      
        <a class="-mob-share-telegram" title="" rel="external nofollow noopener noreferrer noopener"
          
            target="_blank" href="https://t.me/share/url?url=http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html&text=JavaSE学习笔记 - 夜雨声烦"
          
          >
          
            <img src="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/telegram.png" class="lazyload" data-srcset="https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/logo/128/telegram.png" srcset="data:image/gif;base64,R0lGODlhAQABAIAAAP///////yH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==">
          
        </a>
      
    
  </div>
</div>



        
      
    </div>
    <!-- Custom Files bottomMeta begin -->
    
    <!-- Custom Files bottomMeta end -->
  </div>


  
  

  
    <div class="prev-next">
      
        <a class='prev' href='/categories/%E5%90%8E%E7%AB%AF/Spring5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html'>
          <p class='title'><i class="fa-solid fa-chevron-left" aria-hidden="true"></i>Spring框架笔记</p>
          <p class='content'>Spring5学习笔记一、概述1.Spring5框架概述1、Spring 是轻量级的开源的 JavaEE 框架
2、Spring 可以解决企业应用开发的复杂性
3、Spring 有两个核心部分：...</p>
        </a>
      
      
    </div>
  
  <!-- Custom Files postEnd begin-->
  
  <!-- Custom Files postEnd end-->
</article>


  


  <article class="post white-box shadow floatable" id="comments">
    <span hidden>
      <meta itemprop="discussionUrl" content="/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html#comments">
    </span>
    <p ct><i class='fa-solid fa-comments'></i> 评论</p>
    

    <div id="layoutHelper-comments"></div>

  </article>






</div>
<aside id='l_side' itemscope itemtype="http://schema.org/WPSideBar">
  

  
    
    
      
    
  


<div class="widget-sticky pjax">

  
  


  <section class="widget toc-wrapper desktop " id="toc-div" >
    
  <header>
    
      <i class="fa-solid fa-list fa-fw" aria-hidden="true"></i><span class='name'>本文目录</span>
    
  </header>


    <div class='content'>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81Java%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95"><span class="toc-number">1.</span> <span class="toc-text">一、Java基础语法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-1-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.</span> <span class="toc-text">1.1 数据类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-1-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.1.</span> <span class="toc-text">1.1.1 基本数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-2-%E5%BC%95%E7%94%A8%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.1.2.</span> <span class="toc-text">1.1.2 引用数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-3-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.1.3.</span> <span class="toc-text">1.1.3 类型转换</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-1-4-%E8%B5%8B%E5%80%BC%E9%97%AE%E9%A2%98"><span class="toc-number">1.1.4.</span> <span class="toc-text">1.1.4 赋值问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.</span> <span class="toc-text">1.2 变量</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-1-%E5%8F%98%E9%87%8F%E5%A3%B0%E6%98%8E"><span class="toc-number">1.2.1.</span> <span class="toc-text">1.2.1 变量声明</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-2-%E5%8F%98%E9%87%8F%E5%88%86%E7%B1%BB%E5%8F%8A%E4%BD%9C%E7%94%A8%E5%9F%9F"><span class="toc-number">1.2.2.</span> <span class="toc-text">1.2.2 变量分类及作用域</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B1%80%E9%83%A8%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.1.</span> <span class="toc-text">局部变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%AE%9E%E4%BE%8B%E5%8F%98%E9%87%8F"><span class="toc-number">1.2.2.2.</span> <span class="toc-text">实例变量</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%B1%BB%E5%8F%98%E9%87%8F%EF%BC%88%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">1.2.2.3.</span> <span class="toc-text">类变量（静态变量）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-2-3-%E5%B8%B8%E9%87%8F"><span class="toc-number">1.2.3.</span> <span class="toc-text">1.2.3 常量</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-3-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.</span> <span class="toc-text">1.3 运算符</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-1-%E8%87%AA%E5%A2%9E-%E3%80%81%E8%87%AA%E5%87%8F-%E2%80%93-%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.1.</span> <span class="toc-text">1.3.1 自增(++)、自减(–)运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-2-%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E4%BD%8D%E8%BF%90%E7%AE%97%E7%AC%A6"><span class="toc-number">1.3.2.</span> <span class="toc-text">1.3.2 逻辑运算符、位运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-3-%E4%B8%89%E5%85%83%E8%BF%90%E7%AE%97%E7%AC%A6%E3%80%81%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BF%9E%E6%8E%A5%E7%AC%A6"><span class="toc-number">1.3.3.</span> <span class="toc-text">1.3.3 三元运算符、字符串连接符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#1-3-4-%E8%BF%90%E7%AE%97%E7%AC%A6%E4%BC%98%E5%85%88%E7%BA%A7"><span class="toc-number">1.3.4.</span> <span class="toc-text">1.3.4 运算符优先级</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81Java%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">二、Java流程控制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#2-1-Scanner%E5%AF%B9%E8%B1%A1"><span class="toc-number">2.1.</span> <span class="toc-text">2.1 Scanner对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-2%E9%A1%BA%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="toc-number">2.2.</span> <span class="toc-text">2.2顺序结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-3%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.</span> <span class="toc-text">2.3选择结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-1-if%E5%8D%95%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.1.</span> <span class="toc-text">2.3.1 if单选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-2-if%E2%80%A6else%E5%8F%8C%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.2.</span> <span class="toc-text">2.3.2 if…else双选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-3-if%E2%80%A6else-if%E2%80%A6else%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.3.</span> <span class="toc-text">2.3.3 if…else if…else多选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-4-%E5%B5%8C%E5%A5%97%E7%9A%84if%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.4.</span> <span class="toc-text">2.3.4 嵌套的if选择结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-3-5-Switch%E5%A4%9A%E9%80%89%E6%8B%A9%E7%BB%93%E6%9E%84"><span class="toc-number">2.3.5.</span> <span class="toc-text">2.3.5 Switch多选择结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-4-%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">2.4 循环结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-1-while%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.1.</span> <span class="toc-text">2.4.1 while循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-2-do%E2%80%A6while%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.2.</span> <span class="toc-text">2.4.2 do…while循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-3-for%E5%BE%AA%E7%8E%AF%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.3.</span> <span class="toc-text">2.4.3 for循环结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-4-%E5%A2%9E%E5%BC%BAfor%E5%BE%AA%E7%8E%AF"><span class="toc-number">2.4.4.</span> <span class="toc-text">2.4.4 增强for循环</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#2-4-5-break%E3%80%81continue%E3%80%81goto"><span class="toc-number">2.4.5.</span> <span class="toc-text">2.4.5 break、continue、goto</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81Java%E6%96%B9%E6%B3%95"><span class="toc-number">3.</span> <span class="toc-text">三、Java方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#3-1-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.</span> <span class="toc-text">3.1 方法的定义和调用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-1-%E6%96%B9%E6%B3%95%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">3.1.1.</span> <span class="toc-text">3.1.1 方法的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-2-%E6%96%B9%E6%B3%95%E7%9A%84%E8%B0%83%E7%94%A8"><span class="toc-number">3.1.2.</span> <span class="toc-text">3.1.2 方法的调用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-3-%E5%BD%A2%E5%8F%82%E5%92%8C%E5%AE%9E%E5%8F%82"><span class="toc-number">3.1.3.</span> <span class="toc-text">3.1.3 形参和实参</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#3-1-4-%E5%80%BC%E4%BC%A0%E9%80%92%E5%92%8C%E5%BC%95%E7%94%A8%E4%BC%A0%E9%80%92-%E9%87%8D%E7%82%B9-%E9%9A%BE%E7%82%B9"><span class="toc-number">3.1.4.</span> <span class="toc-text">3.1.4 值传递和引用传递(重点\难点)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-2-%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E8%BD%BD"><span class="toc-number">3.2.</span> <span class="toc-text">3.2 方法的重载</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-3-%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%BC%A0%E9%80%92%E5%8F%82%E6%95%B0"><span class="toc-number">3.3.</span> <span class="toc-text">3.3 命令行传递参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0"><span class="toc-number">3.4.</span> <span class="toc-text">3.4 可变参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-4-%E9%80%92%E5%BD%92"><span class="toc-number">3.5.</span> <span class="toc-text">3.4 递归</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81Java%E6%95%B0%E7%BB%84"><span class="toc-number">4.</span> <span class="toc-text">四、Java数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#4-1-%E6%95%B0%E7%BB%84%E7%9A%84%E5%A3%B0%E6%98%8E%E5%88%9B%E5%BB%BA"><span class="toc-number">4.1.</span> <span class="toc-text">4.1 数组的声明创建</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-2-Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90%E5%8F%8A%E4%B8%89%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">4.2 Java内存分析及三种初始化</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-1-Java%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">4.2.1.</span> <span class="toc-text">4.2.1 Java内存分析</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-2-%E4%B8%89%E7%A7%8D%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E5%BC%8F"><span class="toc-number">4.2.2.</span> <span class="toc-text">4.2.2 三种初始化方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#4-2-3-%E4%B8%8B%E6%A0%87%E8%B6%8A%E7%95%8C%E9%97%AE%E9%A2%98"><span class="toc-number">4.2.3.</span> <span class="toc-text">4.2.3 下标越界问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-3-%E6%95%B0%E7%BB%84%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">4.3.</span> <span class="toc-text">4.3 数组的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-4-%E5%A4%9A%E7%BB%B4%E6%95%B0%E7%BB%84"><span class="toc-number">4.4.</span> <span class="toc-text">4.4 多维数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-5-Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">4.5.</span> <span class="toc-text">4.5 Arrays工具类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-6-%E6%95%B0%E7%BB%84%E6%8E%92%E5%BA%8F"><span class="toc-number">4.6.</span> <span class="toc-text">4.6 数组排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-7-%E7%A8%80%E7%96%8F%E6%95%B0%E7%BB%84"><span class="toc-number">4.7.</span> <span class="toc-text">4.7 稀疏数组</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%94%E3%80%81Java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.</span> <span class="toc-text">五、Java面向对象</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#5-1-%E4%BB%80%E4%B9%88%E6%98%AF%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.1.</span> <span class="toc-text">5.1 什么是面向对象</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-2-%E6%96%B9%E6%B3%95%E5%9B%9E%E9%A1%BE%E5%92%8C%E5%8A%A0%E6%B7%B1"><span class="toc-number">5.2.</span> <span class="toc-text">5.2 方法回顾和加深</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-3-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E5%88%86%E6%9E%90"><span class="toc-number">5.3.</span> <span class="toc-text">5.3 对象的创建分析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-1-%E7%B1%BB%E4%B8%8E%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%85%B3%E7%B3%BB"><span class="toc-number">5.3.1.</span> <span class="toc-text">5.3.1 类与对象的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-2-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.3.2.</span> <span class="toc-text">5.3.2 创建对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-3-%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%88%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%EF%BC%89"><span class="toc-number">5.3.3.</span> <span class="toc-text">5.3.3 构造器（构造方法）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-3-4-%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E5%86%85%E5%AD%98%E5%88%86%E6%9E%90"><span class="toc-number">5.3.4.</span> <span class="toc-text">5.3.4 创建对象内存分析</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-4-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E4%B8%89%E5%A4%A7%E7%89%B9%E6%80%A7"><span class="toc-number">5.4.</span> <span class="toc-text">5.4 面向对象三大特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-1-%E5%B0%81%E8%A3%85"><span class="toc-number">5.4.1.</span> <span class="toc-text">5.4.1 封装</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-2-%E7%BB%A7%E6%89%BF"><span class="toc-number">5.4.2.</span> <span class="toc-text">5.4.2 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%A6%82%E8%BF%B0%E5%8F%8A%E7%89%B9%E7%82%B9%EF%BC%9A"><span class="toc-number">5.4.2.1.</span> <span class="toc-text">1.概述及特点：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%BB%A7%E6%89%BF%E7%9A%84%E7%89%B9%E6%80%A7%EF%BC%9A"><span class="toc-number">5.4.2.2.</span> <span class="toc-text">2.继承的特性：</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F%E5%92%8C%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">5.4.2.2.1.</span> <span class="toc-text">成员变量和方法：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%9E%84%E9%80%A0%E5%99%A8%EF%BC%9A"><span class="toc-number">5.4.2.2.2.</span> <span class="toc-text">构造器：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#super%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">5.4.2.2.3.</span> <span class="toc-text">super关键字：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#this%E5%85%B3%E9%94%AE%E5%AD%97%EF%BC%9A"><span class="toc-number">5.4.2.2.4.</span> <span class="toc-text">this关键字：</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E7%BB%A7%E6%89%BF%E7%9A%84%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E9%97%AE%E9%A2%98%EF%BC%9A"><span class="toc-number">5.4.2.2.5.</span> <span class="toc-text">继承的代码执行顺序问题：</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%B9%E6%B3%95%E9%87%8D%E5%86%99"><span class="toc-number">5.4.2.3.</span> <span class="toc-text">3.方法重写</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-4-3-%E5%A4%9A%E6%80%81"><span class="toc-number">5.4.3.</span> <span class="toc-text">5.4.3 多态</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%9B%B8%E5%85%B3%E8%A7%84%E5%88%99%E5%8F%8A%E6%A6%82%E5%BF%B5"><span class="toc-number">5.4.3.1.</span> <span class="toc-text">1.相关规则及概念</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%91%E4%B8%8A%E8%BD%AC%E5%9E%8B%E5%92%8C%E5%90%91%E4%B8%8B%E8%BD%AC%E5%9E%8B%EF%BC%9A"><span class="toc-number">5.4.3.2.</span> <span class="toc-text">2.向上转型和向下转型：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-instanceof"><span class="toc-number">5.4.3.3.</span> <span class="toc-text">3.instanceof</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-5-static%E5%92%8Cfinal%E5%85%B3%E9%94%AE%E5%AD%97%E5%8F%8A%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.5.</span> <span class="toc-text">5.5 static和final关键字及代码块</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-1-static%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.5.1.</span> <span class="toc-text">5.5.1 static关键字详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-2-final%E5%85%B3%E9%94%AE%E5%AD%97%E8%AF%A6%E8%A7%A3"><span class="toc-number">5.5.2.</span> <span class="toc-text">5.5.2 final关键字详解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-5-3-%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">5.5.3.</span> <span class="toc-text">5.5.3 代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-6-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.6.</span> <span class="toc-text">5.6 抽象类和接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-1-%E6%8A%BD%E8%B1%A1%E7%B1%BB"><span class="toc-number">5.6.1.</span> <span class="toc-text">5.6.1 抽象类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8A%BD%E8%B1%A1%E7%B1%BB%E7%9A%84%E5%8C%BF%E5%90%8D%E5%AD%90%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">5.6.1.1.</span> <span class="toc-text">1.抽象类的匿名子类对象</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.1.2.</span> <span class="toc-text">2.模板方法设计模式</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-6-2-%E6%8E%A5%E5%8F%A3"><span class="toc-number">5.6.2.</span> <span class="toc-text">5.6.2 接口</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Java8%E4%B8%AD%E6%8E%A5%E5%8F%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">5.6.2.1.</span> <span class="toc-text">1.Java8中接口的新特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.2.2.</span> <span class="toc-text">2.接口应用实例：代理模式</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%8E%A5%E5%8F%A3%E5%BA%94%E7%94%A8%E5%AE%9E%E4%BE%8B%EF%BC%9A%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.6.2.3.</span> <span class="toc-text">3.接口应用实例：工厂模式</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-7-%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.7.</span> <span class="toc-text">5.7 内部类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-1-%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.7.1.</span> <span class="toc-text">5.7.1 成员内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-2-%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.7.2.</span> <span class="toc-text">5.7.2 静态内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-3-%E5%B1%80%E9%83%A8%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.7.3.</span> <span class="toc-text">5.7.3 局部内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-4-%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB"><span class="toc-number">5.7.4.</span> <span class="toc-text">5.7.4 匿名内部类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-7-5-%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">5.7.5.</span> <span class="toc-text">5.7.5 适用场景</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-8-Object%E7%B1%BB%E6%B5%85%E6%9E%90"><span class="toc-number">5.8.</span> <span class="toc-text">5.8 Object类浅析</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-1-Object%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.1.</span> <span class="toc-text">5.8.1 Object类中的方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-2-%E5%92%8Cequals-%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">5.8.2.</span> <span class="toc-text">5.8.2 &#x3D;&#x3D;和equals()方法的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-8-3-toString-%E6%96%B9%E6%B3%95"><span class="toc-number">5.8.3.</span> <span class="toc-text">5.8.3 toString()方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-9-%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-number">5.9.</span> <span class="toc-text">5.9 包装类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-1-%E8%A3%85%E7%AE%B1%E5%92%8C%E6%8B%86%E7%AE%B1"><span class="toc-number">5.9.1.</span> <span class="toc-text">5.9.1 装箱和拆箱</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-2-%E8%87%AA%E5%8A%A8%E6%8B%86%E7%AE%B1%E5%92%8C%E8%87%AA%E5%8A%A8%E8%A3%85%E7%AE%B1%EF%BC%88JDK5%E7%89%88%E6%9C%AC%E4%B9%8B%E5%90%8E%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7%EF%BC%89"><span class="toc-number">5.9.2.</span> <span class="toc-text">5.9.2 自动拆箱和自动装箱（JDK5版本之后的新特性）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-9-3-%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E5%92%8CString%E7%B1%BB%E5%9E%8B%E7%9A%84%E7%9B%B8%E4%BA%92%E8%BD%AC%E6%8D%A2"><span class="toc-number">5.9.3.</span> <span class="toc-text">5.9.3 基本数据类型和String类型的相互转换</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-10-%E5%8D%95%E4%BE%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.10.</span> <span class="toc-text">5.10 单例设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-1-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E9%A5%BF%E6%B1%89%E5%BC%8F"><span class="toc-number">5.10.1.</span> <span class="toc-text">5.10.1 单例模式饿汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-2-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">5.10.2.</span> <span class="toc-text">5.10.2 单例模式懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#5-10-3-%E9%A5%BF%E6%B1%89%E5%BC%8F%E5%92%8C%E6%87%92%E6%B1%89%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%86"><span class="toc-number">5.10.3.</span> <span class="toc-text">5.10.3 饿汉式和懒汉式的区分</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-11-MVC%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">5.11.</span> <span class="toc-text">5.11 MVC设计模式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E3%80%81Java%E5%BC%82%E5%B8%B8%E5%92%8C%E9%94%99%E8%AF%AF"><span class="toc-number">6.</span> <span class="toc-text">六、Java异常和错误</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#6-1-%E4%BB%80%E4%B9%88%E6%98%AF%E5%BC%82%E5%B8%B8"><span class="toc-number">6.1.</span> <span class="toc-text">6.1 什么是异常?</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-1-%E5%BC%82%E5%B8%B8%E5%88%86%E7%B1%BB"><span class="toc-number">6.1.1.</span> <span class="toc-text">6.1.1 异常分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-1-2-%E5%BC%82%E5%B8%B8%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">6.1.2.</span> <span class="toc-text">6.1.2 异常体系结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-3-Error"><span class="toc-number">6.1.3.</span> <span class="toc-text">6.2.3 Error</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#6-2-4-Exception"><span class="toc-number">6.1.4.</span> <span class="toc-text">6.2.4 Exception</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-2-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6"><span class="toc-number">6.2.</span> <span class="toc-text">6.2 异常处理机制</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E5%BC%82%E5%B8%B8"><span class="toc-number">6.3.</span> <span class="toc-text">6.3 自定义异常</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%83%E3%80%81Java%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.</span> <span class="toc-text">七、Java多线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#7-1-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%EF%BC%9A%E7%A8%8B%E5%BA%8F%E3%80%81%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.</span> <span class="toc-text">7.1 基本概念：程序、进程、线程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-1-CPU%E3%80%81%E5%B9%B6%E8%A1%8C%E4%B8%8E%E5%B9%B6%E5%8F%91%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">7.1.1.</span> <span class="toc-text">7.1.1 CPU、并行与并发的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%BC%98%E7%82%B9"><span class="toc-number">7.1.2.</span> <span class="toc-text">7.1.2 多线程的优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-3-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E9%9C%80%E8%A6%81%E5%A4%9A%E7%BA%BF%E7%A8%8B"><span class="toc-number">7.1.3.</span> <span class="toc-text">7.1.3 什么时候需要多线程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-1-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">7.1.4.</span> <span class="toc-text">7.1.4 线程的分类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-2-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA%E5%92%8C%E4%BD%BF%E7%94%A8"><span class="toc-number">7.2.</span> <span class="toc-text">7.2 线程的创建和使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E8%B0%83%E5%BA%A6"><span class="toc-number">7.2.1.</span> <span class="toc-text">7.2.1 线程的调度</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-2-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">7.2.2.</span> <span class="toc-text">7.2.2 多线程的创建</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E7%BB%A7%E6%89%BFThread%E7%B1%BB"><span class="toc-number">7.2.2.1.</span> <span class="toc-text">1.方法一：继承Thread类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E5%AE%9E%E7%8E%B0Runnable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.2.2.2.</span> <span class="toc-text">2.方法二：实现Runnable接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%B8%A4%E7%A7%8D%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">7.2.2.3.</span> <span class="toc-text">3.两种线程创建方式的比较</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-2-3-Thread%E7%B1%BB%E4%B8%AD%E7%9A%84%E6%9C%89%E5%85%B3%E6%96%B9%E6%B3%95%EF%BC%88%E4%BD%BF%E7%94%A8%EF%BC%89"><span class="toc-number">7.2.3.</span> <span class="toc-text">7.2.3 Thread类中的有关方法（使用）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-3-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F"><span class="toc-number">7.3.</span> <span class="toc-text">7.3 线程的生命周期</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5"><span class="toc-number">7.4.</span> <span class="toc-text">7.4 线程的同步</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-1-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.1.</span> <span class="toc-text">7.4.1 线程的安全问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-2-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95-%E5%90%8C%E6%AD%A5%E5%92%8CLock"><span class="toc-number">7.4.2.</span> <span class="toc-text">7.4.2 线程安全问题的解决办法(同步和Lock)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%96%B9%E5%BC%8F%E4%B8%80%EF%BC%9A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%9D%97"><span class="toc-number">7.4.2.1.</span> <span class="toc-text">1.方式一：同步代码块</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%96%B9%E5%BC%8F%E4%BA%8C%EF%BC%9A%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95"><span class="toc-number">7.4.2.2.</span> <span class="toc-text">2.方式二：同步方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E6%96%B9%E5%BC%8F%E4%B8%89%EF%BC%9ALock%E9%94%81-%E2%80%94JDK5-0%E6%96%B0%E5%A2%9E"><span class="toc-number">7.4.2.3.</span> <span class="toc-text">3.方式三：Lock锁 —JDK5.0新增</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-3-%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%87%92%E6%B1%89%E5%BC%8F"><span class="toc-number">7.4.3.</span> <span class="toc-text">7.4.3 线程安全的单例模式之懒汉式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-4-4-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%AD%BB%E9%94%81%E9%97%AE%E9%A2%98"><span class="toc-number">7.4.4.</span> <span class="toc-text">7.4.4 线程的死锁问题</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-5-%E7%BA%BF%E7%A8%8B%E7%9A%84%E9%80%9A%E4%BF%A1"><span class="toc-number">7.5.</span> <span class="toc-text">7.5 线程的通信</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-1-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">7.5.1.</span> <span class="toc-text">7.5.1 线程通信的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-2-%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">7.5.2.</span> <span class="toc-text">7.5.2 线程通信的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-5-3-%E5%93%AA%E4%BA%9B%E6%93%8D%E4%BD%9C%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%8C%E5%93%AA%E4%BA%9B%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%EF%BC%9F"><span class="toc-number">7.5.3.</span> <span class="toc-text">7.5.3 哪些操作会释放锁，哪些不会释放锁？</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#1-%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.5.3.0.1.</span> <span class="toc-text">1.释放锁的操作</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#2-%E4%B8%8D%E4%BC%9A%E9%87%8A%E6%94%BE%E9%94%81%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-number">7.5.3.0.2.</span> <span class="toc-text">2.不会释放锁的操作</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-6-JDK5%E6%96%B0%E5%A2%9E%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F"><span class="toc-number">7.6.</span> <span class="toc-text">7.6 JDK5新增的线程创建方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-1-%E6%96%B9%E6%B3%95%E4%B8%80%EF%BC%9A%E5%AE%9E%E7%8E%B0Callable%E6%8E%A5%E5%8F%A3"><span class="toc-number">7.6.1.</span> <span class="toc-text">7.6.1 方法一：实现Callable接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#7-6-2-%E6%96%B9%E6%B3%95%E4%BA%8C%EF%BC%9A%E7%BA%BF%E7%A8%8B%E6%B1%A0"><span class="toc-number">7.6.2.</span> <span class="toc-text">7.6.2 方法二：线程池</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AB%E3%80%81Java%E5%B8%B8%E7%94%A8%E7%B1%BB"><span class="toc-number">8.</span> <span class="toc-text">八、Java常用类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#8-1-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">8.1.</span> <span class="toc-text">8.1 字符串相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-1-String%E7%B1%BB"><span class="toc-number">8.1.1.</span> <span class="toc-text">8.1.1 String类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-String%E7%9A%84%E7%89%B9%E6%80%A7"><span class="toc-number">8.1.1.1.</span> <span class="toc-text">1.String的特性</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-String-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA"><span class="toc-number">8.1.1.2.</span> <span class="toc-text">2.String 对象的创建</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-String%E4%B8%8D%E5%90%8C%E6%8B%BC%E6%8E%A5%E6%93%8D%E4%BD%9C%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">8.1.1.3.</span> <span class="toc-text">3.String不同拼接操作的比较</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-JVM%E4%B8%AD%E6%B6%89%E5%8F%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84"><span class="toc-number">8.1.1.4.</span> <span class="toc-text">4.JVM中涉及字符串的内存结构</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-String%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">8.1.1.5.</span> <span class="toc-text">5.String常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-String%E4%B8%8E%E5%85%B6%E4%BB%96%E7%BB%93%E6%9E%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.6.</span> <span class="toc-text">6.String与其他结构之间的转换</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A0String%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E3%80%81%E5%8C%85%E8%A3%85%E7%B1%BB%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.6.1.</span> <span class="toc-text">①String与基本数据类型、包装类之间的转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A1String%E4%B8%8Echar-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.6.2.</span> <span class="toc-text">②String与char[]之间的转换</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E2%91%A2String%E4%B8%8Ebyte-%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">8.1.1.6.3.</span> <span class="toc-text">③String与byte[]之间的转换</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#7-String%E5%B8%B8%E8%A7%81%E7%9A%84%E7%AE%97%E6%B3%95%E9%A2%98%E7%9B%AE"><span class="toc-number">8.1.1.7.</span> <span class="toc-text">7.String常见的算法题目</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-1-2-StringBuffer%E5%92%8CStringBuilder"><span class="toc-number">8.1.2.</span> <span class="toc-text">8.1.2 StringBuffer和StringBuilder</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-StringBuffer%E7%B1%BB"><span class="toc-number">8.1.2.1.</span> <span class="toc-text">1.StringBuffer类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-StringBuilder%E7%B1%BB"><span class="toc-number">8.1.2.2.</span> <span class="toc-text">2.StringBuilder类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-StringBuffer%E5%92%8CStringBuilder%E4%B8%AD%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B9%E6%B3%95%EF%BC%9A"><span class="toc-number">8.1.2.3.</span> <span class="toc-text">3.StringBuffer和StringBuilder中的一些方法：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-String%E3%80%81StringBuffer%E3%80%81StringBuilder%E4%B8%89%E8%80%85%E7%9A%84%E6%95%88%E7%8E%87%E5%AF%B9%E6%AF%94"><span class="toc-number">8.1.2.4.</span> <span class="toc-text">4.String、StringBuffer、StringBuilder三者的效率对比</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-2-%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E7%9B%B8%E5%85%B3%E7%9A%84%E7%B1%BB"><span class="toc-number">8.2.</span> <span class="toc-text">8.2 日期时间相关的类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-1-java-lang-System%E7%B1%BB%EF%BC%88JDK8%E4%B9%8B%E5%89%8D%EF%BC%89"><span class="toc-number">8.2.1.</span> <span class="toc-text">8.2.1 java.lang.System类（JDK8之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-2-java-util-Date%E7%B1%BB%EF%BC%88JDK8%E4%B9%8B%E5%89%8D%EF%BC%89"><span class="toc-number">8.2.2.</span> <span class="toc-text">8.2.2 java.util.Date类（JDK8之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-3-java-text-SimpleDateFormat%E7%B1%BB%EF%BC%88JDK8%E4%B9%8B%E5%89%8D%EF%BC%89"><span class="toc-number">8.2.3.</span> <span class="toc-text">8.2.3 java.text.SimpleDateFormat类（JDK8之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-4-java-utils-Calendar-%E6%97%A5%E5%8E%86-%E7%B1%BB%EF%BC%88JDK8%E4%B9%8B%E5%89%8D%EF%BC%89"><span class="toc-number">8.2.4.</span> <span class="toc-text">8.2.4 java.utils.Calendar(日历)类（JDK8之前）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-2-5-java-time%EF%BC%88JDK8%E4%B8%AD%EF%BC%89"><span class="toc-number">8.2.5.</span> <span class="toc-text">8.2.5 java.time（JDK8中）</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-LocalDate%E3%80%81LocalTime%E3%80%81LocalDateTime%E7%B1%BB"><span class="toc-number">8.2.5.1.</span> <span class="toc-text">1.LocalDate、LocalTime、LocalDateTime类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Instant%E7%B1%BB"><span class="toc-number">8.2.5.2.</span> <span class="toc-text">2.Instant类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-java-time-format-DateTimeFormpatter%E7%B1%BB"><span class="toc-number">8.2.5.3.</span> <span class="toc-text">3.java.time.format.DateTimeFormpatter类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-%E5%85%B6%E4%BB%96API"><span class="toc-number">8.2.5.4.</span> <span class="toc-text">4.其他API</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-3-Java%E6%AF%94%E8%BE%83%E5%99%A8"><span class="toc-number">8.3.</span> <span class="toc-text">8.3 Java比较器</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-1-Comparable%E6%8E%A5%E5%8F%A3-%E8%87%AA%E7%84%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.1.</span> <span class="toc-text">8.3.1 Comparable接口(自然排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-2-Comparator%E6%8E%A5%E5%8F%A3-%E5%AE%9A%E5%88%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">8.3.2.</span> <span class="toc-text">8.3.2 Comparator接口(定制排序)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-3-3-Comparable%E6%8E%A5%E5%8F%A3%E4%B8%8EComparator%E6%8E%A5%E5%8F%A3%E7%9A%84%E7%AE%80%E5%8D%95%E5%AF%B9%E6%AF%94"><span class="toc-number">8.3.3.</span> <span class="toc-text">8.3.3 Comparable接口与Comparator接口的简单对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-4-System%E7%B1%BB"><span class="toc-number">8.4.</span> <span class="toc-text">8.4 System类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-5-Math%E7%B1%BB"><span class="toc-number">8.5.</span> <span class="toc-text">8.5 Math类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-6-BigInteger%E4%B8%8EBigDecimal"><span class="toc-number">8.6.</span> <span class="toc-text">8.6 BigInteger与BigDecimal</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-1-BigInteger%E7%B1%BB"><span class="toc-number">8.6.1.</span> <span class="toc-text">8.6.1 BigInteger类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#8-6-2-BigDecimal%E7%B1%BB"><span class="toc-number">8.6.2.</span> <span class="toc-text">8.6.2 BigDecimal类</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B9%9D%E3%80%81%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%92%8C%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.</span> <span class="toc-text">九、枚举类和注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#9-1-%E6%9E%9A%E4%B8%BE-enum"><span class="toc-number">9.1.</span> <span class="toc-text">9.1 枚举(enum)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-1-%E6%9E%9A%E4%B8%BE%E7%B1%BB%E6%88%90%E5%91%98"><span class="toc-number">9.1.1.</span> <span class="toc-text">9.1.1 枚举类成员</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-2-values-%EF%BC%8Cordinal-%E5%92%8CvalueOf-%E6%96%B9%E6%B3%95"><span class="toc-number">9.1.2.</span> <span class="toc-text">9.1.2 values()，ordinal()和valueOf()方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-3-%E4%BD%BF%E7%94%A8Enum%E5%85%B3%E9%94%AE%E5%AD%97%E5%AE%9A%E4%B9%89%E7%9A%84%E6%9E%9A%E4%B8%BE%E7%B1%BB%E5%AE%9E%E7%8E%B0%E6%8E%A5%E5%8F%A3"><span class="toc-number">9.1.3.</span> <span class="toc-text">9.1.3 使用Enum关键字定义的枚举类实现接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-4-%E5%86%85%E9%83%A8%E7%B1%BB%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE"><span class="toc-number">9.1.4.</span> <span class="toc-text">9.1.4 内部类中使用枚举</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-5-%E8%BF%AD%E4%BB%A3%E6%9E%9A%E4%B8%BE%E5%85%83%E7%B4%A0"><span class="toc-number">9.1.5.</span> <span class="toc-text">9.1.5 迭代枚举元素</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-1-6-%E5%9C%A8switch%E4%B8%AD%E4%BD%BF%E7%94%A8%E6%9E%9A%E4%B8%BE%E7%B1%BB"><span class="toc-number">9.1.6.</span> <span class="toc-text">9.1.6 在switch中使用枚举类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-2-%E6%B3%A8%E8%A7%A3-Annotation"><span class="toc-number">9.2.</span> <span class="toc-text">9.2 注解(Annotation)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-1-%E5%B8%B8%E8%A7%81%E7%9A%84Annotation%E7%A4%BA%E4%BE%8B"><span class="toc-number">9.2.1.</span> <span class="toc-text">9.2.1 常见的Annotation示例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%80%EF%BC%9A%E7%94%9F%E6%88%90%E6%96%87%E6%A1%A3%E7%9B%B8%E5%85%B3%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.1.1.</span> <span class="toc-text">示例一：生成文档相关的注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%BA%8C%EF%BC%9A%E5%9C%A8%E7%BC%96%E8%AF%91%E6%97%B6%E8%BF%9B%E8%A1%8C%E6%A0%BC%E5%BC%8F%E6%A3%80%E6%9F%A5-JDK%E5%86%85%E7%BD%AE%E7%9A%84%E4%B8%89%E4%B8%AA%E5%9F%BA%E6%9C%AC%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.1.2.</span> <span class="toc-text">示例二：在编译时进行格式检查(JDK内置的三个基本注解)</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E4%B8%89%EF%BC%9A%E8%B7%9F%E8%B8%AA%E4%BB%A3%E7%A0%81%E4%BE%9D%E8%B5%96%E6%80%A7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E6%9B%BF%E4%BB%A3%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E5%8A%9F%E8%83%BD"><span class="toc-number">9.2.1.3.</span> <span class="toc-text">示例三：跟踪代码依赖性，实现替代配置文件功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A4%BA%E4%BE%8B%E5%9B%9B%EF%BC%9AJunit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%E4%B8%AD%E7%9A%84%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.1.4.</span> <span class="toc-text">示例四：Junit单元测试中的注解</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.2.</span> <span class="toc-text">9.2.2 自定义注解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-3-JDK%E4%B8%AD%E7%9A%84%E5%85%83%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.3.</span> <span class="toc-text">9.2.3 JDK中的元注解</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Retention"><span class="toc-number">9.2.3.1.</span> <span class="toc-text">1.Retention</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Target"><span class="toc-number">9.2.3.2.</span> <span class="toc-text">2.Target</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Documented"><span class="toc-number">9.2.3.3.</span> <span class="toc-text">3.Documented</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Inherited"><span class="toc-number">9.2.3.4.</span> <span class="toc-text">4.Inherited</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#9-2-4-JDK8%E4%B8%AD%E6%B3%A8%E8%A7%A3%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7"><span class="toc-number">9.2.4.</span> <span class="toc-text">9.2.4 JDK8中注解的新特性</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%8F%AF%E9%87%8D%E5%A4%8D%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.4.1.</span> <span class="toc-text">1.可重复注解</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3"><span class="toc-number">9.2.4.2.</span> <span class="toc-text">2.类型注解</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E3%80%81Java%E9%9B%86%E5%90%88"><span class="toc-number">10.</span> <span class="toc-text">十、Java集合</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#10-1-Java%E7%BB%93%E5%90%88%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">10.1.</span> <span class="toc-text">10.1 Java结合框架概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-1-%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">10.1.1.</span> <span class="toc-text">10.1.1 集合框架的使用场景</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-1-2-Java%E9%9B%86%E5%90%88%E5%8F%AF%E5%88%86%E4%B8%BACollection%E5%92%8CMap%E4%B8%A4%E7%A7%8D%E4%BD%93%E7%B3%BB"><span class="toc-number">10.1.2.</span> <span class="toc-text">10.1.2 Java集合可分为Collection和Map两种体系</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-2-Collection%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.2.</span> <span class="toc-text">10.2 Collection接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-1-Collection%E6%8E%A5%E5%8F%A3%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">10.2.1.</span> <span class="toc-text">10.2.1 Collection接口中常用方法的使用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-2-Collection%E7%9A%84%E5%AD%90%E6%8E%A5%E5%8F%A3List"><span class="toc-number">10.2.2.</span> <span class="toc-text">10.2.2 Collection的子接口List</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-ArrayList%E7%B1%BB"><span class="toc-number">10.2.2.1.</span> <span class="toc-text">1.ArrayList类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJDK7"><span class="toc-number">10.2.2.1.1.</span> <span class="toc-text">源码分析：JDK7</span></a></li><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90%EF%BC%9AJDK8%E4%B8%ADArrayList%E7%9A%84%E5%8F%98%E5%8C%96"><span class="toc-number">10.2.2.1.2.</span> <span class="toc-text">源码分析：JDK8中ArrayList的变化</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedList%E7%B1%BB"><span class="toc-number">10.2.2.2.</span> <span class="toc-text">2.LinkedList类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.2.2.2.1.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-Vector%E7%B1%BB"><span class="toc-number">10.2.2.3.</span> <span class="toc-text">3.Vector类</span></a><ol class="toc-child"><li class="toc-item toc-level-6"><a class="toc-link" href="#%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90-1"><span class="toc-number">10.2.2.3.1.</span> <span class="toc-text">源码分析</span></a></li></ol></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-List%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.2.2.4.</span> <span class="toc-text">4.List接口中的常用方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-List%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E7%AC%94%E8%AF%95%E9%A2%98"><span class="toc-number">10.2.2.5.</span> <span class="toc-text">5.List的一道面试笔试题</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-2-3-Collection%E5%AD%90%E6%8E%A5%E5%8F%A3Set"><span class="toc-number">10.2.3.</span> <span class="toc-text">10.2.3 Collection子接口Set</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-HashSet%E7%B1%BB"><span class="toc-number">10.2.3.1.</span> <span class="toc-text">1.HashSet类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-LinkedHashSet%E7%B1%BB"><span class="toc-number">10.2.3.2.</span> <span class="toc-text">2.LinkedHashSet类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-TreeSet%E7%B1%BB"><span class="toc-number">10.2.3.3.</span> <span class="toc-text">3.TreeSet类</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-Set%E4%B8%A4%E9%81%93%E7%9B%B8%E5%85%B3%E9%9D%A2%E8%AF%95%E9%A2%98"><span class="toc-number">10.2.3.4.</span> <span class="toc-text">4.Set两道相关面试题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-3-Map%E6%8E%A5%E5%8F%A3"><span class="toc-number">10.3.</span> <span class="toc-text">10.3 Map接口</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-1-Map%E6%8E%A5%E5%8F%A3%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.3.1.</span> <span class="toc-text">10.3.1 Map接口中的常用方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-2-HashMap%E7%B1%BB"><span class="toc-number">10.3.2.</span> <span class="toc-text">10.3.2 HashMap类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.2.1.</span> <span class="toc-text">1.底层实现原理</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">10.3.2.2.</span> <span class="toc-text">2.源码分析</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-3-LinkedHashMap%E7%B1%BB"><span class="toc-number">10.3.3.</span> <span class="toc-text">10.3.3 LinkedHashMap类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">10.3.3.1.</span> <span class="toc-text">底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-4-TreeMap%E7%B1%BB"><span class="toc-number">10.3.4.</span> <span class="toc-text">10.3.4 TreeMap类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-3-5-Properties%E7%B1%BB"><span class="toc-number">10.3.5.</span> <span class="toc-text">10.3.5 Properties类</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-4-Collections%E5%B7%A5%E5%85%B7%E7%B1%BB"><span class="toc-number">10.4.</span> <span class="toc-text">10.4 Collections工具类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-1-Collections%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">10.4.1.</span> <span class="toc-text">10.4.1 Collections中的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E6%8E%92%E5%BA%8F%EF%BC%9A"><span class="toc-number">10.4.1.1.</span> <span class="toc-text">1.排序：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E6%9F%A5%E6%89%BE%E3%80%81%E6%9B%BF%E6%8D%A2%EF%BC%9A"><span class="toc-number">10.4.1.2.</span> <span class="toc-text">2.查找、替换：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E8%BD%AC%E6%8D%A2%E4%B8%BA%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E9%9B%86%E5%90%88"><span class="toc-number">10.4.1.3.</span> <span class="toc-text">3.转换为线程安全的集合</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#10-4-2-%E9%9B%86%E5%90%88%E7%BB%83%E4%B9%A0%E9%A2%98"><span class="toc-number">10.4.2.</span> <span class="toc-text">10.4.2 集合练习题</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%80%E3%80%81Java%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.</span> <span class="toc-text">十一、Java泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#11-1-%E6%B3%9B%E5%9E%8B%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.1.</span> <span class="toc-text">11.1 泛型的使用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B"><span class="toc-number">11.2.</span> <span class="toc-text">11.2 自定义泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-1-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3"><span class="toc-number">11.2.1.</span> <span class="toc-text">11.2.1 自定义泛型类和接口</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-2-2-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95"><span class="toc-number">11.2.2.</span> <span class="toc-text">11.2.2 自定义泛型方法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-3-%E6%B3%9B%E5%9E%8B%E5%9C%A8%E7%BB%A7%E6%89%BF%E6%96%B9%E9%9D%A2%E7%9A%84%E4%BD%93%E7%8E%B0"><span class="toc-number">11.3.</span> <span class="toc-text">11.3 泛型在继承方面的体现</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-4-%E9%80%9A%E9%85%8D%E7%AC%A6%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">11.4.</span> <span class="toc-text">11.4 通配符的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-1-%E4%BD%BF%E7%94%A8%E9%80%9A%E9%85%8D%E7%AC%A6%E5%90%8E%E5%AF%B9%E6%95%B0%E6%8D%AE%E7%9A%84%E5%86%99%E5%85%A5%E5%92%8C%E8%AF%BB%E5%8F%96"><span class="toc-number">11.4.1.</span> <span class="toc-text">11.4.1 使用通配符后对数据的写入和读取</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E5%86%99%E5%85%A5%E6%95%B0%E6%8D%AE"><span class="toc-number">11.4.1.1.</span> <span class="toc-text">1.写入数据</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%AF%BB%E5%8F%96%E6%95%B0%E6%8D%AE"><span class="toc-number">11.4.1.2.</span> <span class="toc-text">2.读取数据</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#11-4-2-%E6%9C%89%E9%99%90%E5%88%B6%E7%9A%84%E9%80%9A%E9%85%8D%E7%AC%A6"><span class="toc-number">11.4.2.</span> <span class="toc-text">11.4.2 有限制的通配符</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-5-%E7%BB%83%E4%B9%A0"><span class="toc-number">11.5.</span> <span class="toc-text">11.5 练习</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%BA%8C%E3%80%81Java-IO%E6%B5%81"><span class="toc-number">12.</span> <span class="toc-text">十二、Java IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#12-1-File%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.1.</span> <span class="toc-text">12.1 File类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-1-%E5%B8%B8%E7%94%A8%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">12.1.1.</span> <span class="toc-text">12.1.1 常用构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-2-%E8%B7%AF%E5%BE%84%E5%88%86%E9%9A%94%E7%AC%A6"><span class="toc-number">12.1.2.</span> <span class="toc-text">12.1.2 路径分隔符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-1-3-File%E7%B1%BB%E7%9A%84%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">12.1.3.</span> <span class="toc-text">12.1.3 File类的常用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-File%E7%B1%BB%E7%9A%84%E8%8E%B7%E5%8F%96%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.3.1.</span> <span class="toc-text">1.File类的获取功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-File%E7%B1%BB%E7%9A%84%E9%87%8D%E5%91%BD%E5%90%8D%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.3.2.</span> <span class="toc-text">2.File类的重命名功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-File%E7%B1%BB%E7%9A%84%E5%88%A4%E6%96%AD%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.3.3.</span> <span class="toc-text">3.File类的判断功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#4-File%E7%B1%BB%E7%9A%84%E5%88%9B%E5%BB%BA%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.3.4.</span> <span class="toc-text">4.File类的创建功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#5-File%E7%B1%BB%E7%9A%84%E5%88%A0%E9%99%A4%E5%8A%9F%E8%83%BD"><span class="toc-number">12.1.3.5.</span> <span class="toc-text">5.File类的删除功能</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#6-File%E7%B1%BB%E7%BB%83%E4%B9%A0"><span class="toc-number">12.1.3.6.</span> <span class="toc-text">6.File类练习</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-2-IO%E6%B5%81%E5%8E%9F%E7%90%86%E5%8F%8A%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.2.</span> <span class="toc-text">12.2 IO流原理及流的分类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-1-IO%E6%B5%81%E7%9A%84%E5%8E%9F%E7%90%86"><span class="toc-number">12.2.1.</span> <span class="toc-text">12.2.1 IO流的原理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-2-%E6%B5%81%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">12.2.2.</span> <span class="toc-text">12.2.2 流的分类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-2-3-IO%E6%B5%81%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84"><span class="toc-number">12.2.3.</span> <span class="toc-text">12.2.3 IO流的体系结构</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-3-%E8%8A%82%E7%82%B9%E6%B5%81-%E6%88%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">12.3.</span> <span class="toc-text">12.3 节点流(或文件流)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-1-FileReader%E7%B1%BB"><span class="toc-number">12.3.1.</span> <span class="toc-text">12.3.1 FileReader类</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%BD%BF%E7%94%A8FileReader%E7%B1%BBread-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%85%A5"><span class="toc-number">12.3.1.1.</span> <span class="toc-text">1.使用FileReader类read()实现数据的读入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E4%BD%BF%E7%94%A8FileReader%E7%B1%BBread-char-cbuf-%E5%AE%9E%E7%8E%B0%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%85%A5"><span class="toc-number">12.3.1.2.</span> <span class="toc-text">2.使用FileReader类read(char[] cbuf)实现数据的读入</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-2-FileWriter%E7%B1%BB"><span class="toc-number">12.3.2.</span> <span class="toc-text">12.3.2 FileWriter类</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-3-FileReader%E5%92%8CFileWriter%E5%AE%9E%E7%8E%B0%E6%96%87%E6%9C%AC%E5%86%85%E5%AE%B9%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="toc-number">12.3.3.</span> <span class="toc-text">12.3.3 FileReader和FileWriter实现文本内容的复制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-4-%E5%AD%97%E7%AC%A6%E6%B5%81%E4%B8%8D%E8%83%BD%E5%A4%84%E7%90%86%E5%9B%BE%E7%89%87%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">12.3.4.</span> <span class="toc-text">12.3.4 字符流不能处理图片的测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-5-FileInputStream%E4%B8%8D%E8%83%BD%E8%AF%BB%E5%8F%96%E6%96%87%E6%9C%AC%E7%9A%84%E6%B5%8B%E8%AF%95"><span class="toc-number">12.3.5.</span> <span class="toc-text">12.3.5 FileInputStream不能读取文本的测试</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-6-FileInputStream%E5%92%8CFileOutputStream%E8%AF%BB%E5%86%99%E9%9D%9E%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6"><span class="toc-number">12.3.6.</span> <span class="toc-text">12.3.6 FileInputStream和FileOutputStream读写非文本文件</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-3-7-FileInputStream%E5%92%8CFileOutputStream%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E6%96%B9%E6%B3%95%E6%B5%8B%E8%AF%95"><span class="toc-number">12.3.7.</span> <span class="toc-text">12.3.7 FileInputStream和FileOutputStream复制文件的方法测试</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-4-%E7%BC%93%E5%86%B2%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%80"><span class="toc-number">12.4.</span> <span class="toc-text">12.4 缓冲流(处理流之一)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-1-%E5%AD%97%E8%8A%82%E6%B5%81%E5%9E%8B"><span class="toc-number">12.4.1.</span> <span class="toc-text">12.4.1 字节流型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-2-%E5%AD%97%E7%AC%A6%E6%B5%81%E5%9E%8B"><span class="toc-number">12.4.2.</span> <span class="toc-text">12.4.2 字符流型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-4-3-%E7%BC%93%E5%86%B2%E6%B5%81%E7%BB%83%E4%B9%A0"><span class="toc-number">12.4.3.</span> <span class="toc-text">12.4.3 缓冲流练习</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-5-%E8%BD%AC%E6%8D%A2%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%BA%8C"><span class="toc-number">12.5.</span> <span class="toc-text">12.5 转换流(处理流之二)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-1-InputStreamReader"><span class="toc-number">12.5.1.</span> <span class="toc-text">12.5.1 InputStreamReader</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-2-OutputStreamWriter"><span class="toc-number">12.5.2.</span> <span class="toc-text">12.5.2 OutputStreamWriter</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-5-3-%E5%A4%9A%E7%A7%8D%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81%E9%9B%86%E7%9A%84%E8%AF%B4%E6%98%8E"><span class="toc-number">12.5.3.</span> <span class="toc-text">12.5.3 多种字符编码集的说明</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-6-%E6%A0%87%E5%87%86%E8%BE%93%E5%85%A5%E3%80%81%E8%BE%93%E5%87%BA%E6%B5%81%EF%BC%88%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%B8%89%EF%BC%89"><span class="toc-number">12.6.</span> <span class="toc-text">12.6 标准输入、输出流（处理流之三）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-7-%E6%89%93%E5%8D%B0%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E5%9B%9B"><span class="toc-number">12.7.</span> <span class="toc-text">12.7 打印流(处理流之四)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-8-%E6%95%B0%E6%8D%AE%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E4%BA%94"><span class="toc-number">12.8.</span> <span class="toc-text">12.8 数据流(处理流之五)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-9-%E5%AF%B9%E8%B1%A1%E6%B5%81-%E5%A4%84%E7%90%86%E6%B5%81%E4%B9%8B%E5%85%AD"><span class="toc-number">12.9.</span> <span class="toc-text">12.9 对象流(处理流之六)</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-1-%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">12.9.1.</span> <span class="toc-text">12.9.1 对象的序列化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-2-%E6%B5%8B%E8%AF%95ObjectOutputStream%E5%92%8CObjectInputStream"><span class="toc-number">12.9.2.</span> <span class="toc-text">12.9.2 测试ObjectOutputStream和ObjectInputStream</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-3-%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%AE%9E%E7%8E%B0%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%93%8D%E4%BD%9C"><span class="toc-number">12.9.3.</span> <span class="toc-text">12.9.3 自定义类实现序列化和反序列化操作</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-9-4-%E5%BA%8F%E5%88%97%E5%8C%96%E6%97%B6serialVersionUID%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">12.9.4.</span> <span class="toc-text">12.9.4 序列化时serialVersionUID的理解</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-10-%E9%9A%8F%E6%9C%BA%E5%AD%98%E5%8F%96%E6%96%87%E4%BB%B6%E6%B5%81"><span class="toc-number">12.10.</span> <span class="toc-text">12.10 随机存取文件流</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-10-1-RandomAccessFile%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.10.1.</span> <span class="toc-text">12.10.1 RandomAccessFile的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-RandomAccessFile%E5%AF%B9%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E8%AF%BB%E5%8F%96%E5%92%8C%E5%86%99%E5%85%A5"><span class="toc-number">12.10.1.1.</span> <span class="toc-text">1.RandomAccessFile对文件数据的读取和写入</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-RandomAccessFile%E5%AF%B9%E6%96%87%E4%BB%B6%E5%8E%9F%E6%9C%89%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A6%86%E7%9B%96%E6%95%88%E6%9E%9C"><span class="toc-number">12.10.1.2.</span> <span class="toc-text">2.RandomAccessFile对文件原有数据的覆盖效果</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-RandomAccessFile%E5%AE%9E%E7%8E%B0%E5%AF%B9%E6%96%87%E4%BB%B6%E6%95%B0%E6%8D%AE%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-number">12.10.1.3.</span> <span class="toc-text">3.RandomAccessFile实现对文件数据的插入</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-11-NIO-2%E4%B8%ADPath%E3%80%81Paths%E3%80%81Files%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">12.11.</span> <span class="toc-text">12.11 NIO.2中Path、Paths、Files类的使用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#12-11-1-NIO%E7%9A%84%E4%BB%8B%E7%BB%8D"><span class="toc-number">12.11.1.</span> <span class="toc-text">12.11.1 NIO的介绍</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#12-11-2-Path%E3%80%81Paths%E3%80%81Files%E6%A0%B8%E5%BF%83API"><span class="toc-number">12.11.2.</span> <span class="toc-text">12.11.2 Path、Paths、Files核心API</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-Path%E6%8E%A5%E5%8F%A3"><span class="toc-number">12.11.2.1.</span> <span class="toc-text">1.Path接口</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-Files%E7%B1%BB"><span class="toc-number">12.11.2.2.</span> <span class="toc-text">2.Files类</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E4%B8%89%E3%80%81Java%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.</span> <span class="toc-text">十三、Java网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#13-1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="toc-number">13.1.</span> <span class="toc-text">13.1 网络编程概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-1-%E7%BD%91%E7%BB%9C%E5%9F%BA%E7%A1%80"><span class="toc-number">13.1.1.</span> <span class="toc-text">13.1.1 网络基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-1-2-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%BD%91%E7%BB%9C%E4%B8%AD%E7%9A%84%E4%B8%BB%E6%9C%BA%E4%BA%92%E7%9B%B8%E9%80%9A%E4%BF%A1-%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%A4%E4%B8%AA%E8%A6%81%E7%B4%A0"><span class="toc-number">13.1.2.</span> <span class="toc-text">13.1.2 如何实现网络中的主机互相通信(网络编程的两个要素)</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-TCP-IP%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B%E5%90%84%E5%B1%82%E7%9A%84%E4%BD%9C%E7%94%A8"><span class="toc-number">13.1.2.1.</span> <span class="toc-text">1.TCP&#x2F;IP参考模型各层的作用</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E5%90%84%E5%B1%82%E6%B6%89%E5%8F%8A%E5%88%B0%E7%9A%84%E5%85%B7%E4%BD%93%E5%8D%8F%E8%AE%AE%EF%BC%9A"><span class="toc-number">13.1.2.2.</span> <span class="toc-text">2.各层涉及到的具体协议：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E7%A4%BA%E4%BE%8B%E5%9B%BE"><span class="toc-number">13.1.2.3.</span> <span class="toc-text">3.网络通信示例图</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-2-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A01%EF%BC%9AIP%E5%92%8C%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">13.2.</span> <span class="toc-text">13.2 通信要素1：IP和端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-1-IP%E5%9C%B0%E5%9D%80"><span class="toc-number">13.2.1.</span> <span class="toc-text">13.2.1 IP地址</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E9%80%9A%E8%BF%87%E5%9F%9F%E5%90%8D%E8%AE%BF%E9%97%AE%E5%AF%B9%E5%BA%94%E7%9A%84IP%E5%9C%B0%E5%9D%80%E7%9A%84%E7%BD%91%E5%9D%80"><span class="toc-number">13.2.1.1.</span> <span class="toc-text">1.通过域名访问对应的IP地址的网址</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-InetAddress%E7%B1%BB%E7%9A%84%E4%BD%BF%E7%94%A8"><span class="toc-number">13.2.1.2.</span> <span class="toc-text">2.InetAddress类的使用</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-2-2-%E7%AB%AF%E5%8F%A3%E5%8F%B7"><span class="toc-number">13.2.2.</span> <span class="toc-text">13.2.2 端口号</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E4%B8%A4%E5%8F%B0%E4%B8%BB%E6%9C%BA%E9%97%B4%E5%90%8C%E4%B8%80%E5%BA%94%E7%94%A8%E7%9A%84%E9%80%9A%E4%BF%A1%EF%BC%9A"><span class="toc-number">13.2.2.1.</span> <span class="toc-text">1.两台主机间同一应用的通信：</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-3-%E9%80%9A%E4%BF%A1%E8%A6%81%E7%B4%A02%EF%BC%9A%E7%BD%91%E7%BB%9C%E9%80%9A%E4%BF%A1%E5%8D%8F%E8%AE%AE"><span class="toc-number">13.3.</span> <span class="toc-text">13.3 通信要素2：网络通信协议</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-1-TCP-IP%E5%8D%8F%E8%AE%AE%E7%B0%87"><span class="toc-number">13.3.1.</span> <span class="toc-text">13.3.1 TCP&#x2F;IP协议簇</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-3-2-%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84TCP%E5%92%8CUDP%E5%8D%8F%E8%AE%AE%E4%B8%BB%E8%A6%81%E5%8C%BA%E5%88%AB"><span class="toc-number">13.3.2.</span> <span class="toc-text">13.3.2 传输层的TCP和UDP协议主要区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B"><span class="toc-number">13.3.2.1.</span> <span class="toc-text">1.TCP三次握手和四次挥手</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-4-TCP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.4.</span> <span class="toc-text">13.4 TCP网络编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-1-%E5%AE%9E%E4%BE%8B1%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E4%BF%A1%E6%81%AF%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B0%86%E4%BF%A1%E6%81%AF%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%8E%A7%E5%88%B6%E5%8F%B0"><span class="toc-number">13.4.1.</span> <span class="toc-text">13.4.1 实例1：客户端发送信息给服务端，服务端将信息显示在控制台</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-2-%E5%AE%9E%E4%BE%8B2%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B0%86%E6%96%87%E4%BB%B6%E4%BF%9D%E5%AD%98%E5%9C%A8%E6%9C%AC%E5%9C%B0"><span class="toc-number">13.4.2.</span> <span class="toc-text">13.4.2 实例2：客户端发送文件给服务端，服务端将文件保存在本地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-3-%E5%AE%9E%E4%BE%8B3%EF%BC%9A%E4%BB%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E4%BB%B6%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BF%9D%E5%AD%98%E5%88%B0%E6%9C%AC%E5%9C%B0%EF%BC%8C%E5%B9%B6%E8%BF%94%E5%9B%9E%E2%80%9C%E5%8F%91%E9%80%81%E6%88%90%E5%8A%9F%E2%80%9D%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%B9%B6%E5%85%B3%E9%97%AD%E7%9B%B8%E5%BA%94%E7%9A%84%E8%BF%9E%E6%8E%A5"><span class="toc-number">13.4.3.</span> <span class="toc-text">13.4.3 实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-4-%E5%AE%9E%E4%BE%8B4%EF%BC%9A%E6%9C%8D%E5%8A%A1%E7%AB%AF%E8%AF%BB%E5%8F%96%E5%9B%BE%E7%89%87%E5%B9%B6%E5%8F%91%E9%80%81%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%BF%9D%E5%AD%98%E5%9B%BE%E7%89%87%E5%88%B0%E6%9C%AC%E5%9C%B0"><span class="toc-number">13.4.4.</span> <span class="toc-text">13.4.4 实例4：服务端读取图片并发送给客户端，客户端保存图片到本地</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-4-5-%E5%AE%9E%E4%BE%8B5%EF%BC%9A%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%BB%99%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%8F%91%E9%80%81%E6%96%87%E6%9C%AC%EF%BC%8C%E6%9C%8D%E5%8A%A1%E7%AB%AF%E4%BC%9A%E5%B0%86%E6%96%87%E6%9C%AC%E8%BD%AC%E6%88%90%E5%A4%A7%E5%86%99%E5%9C%A8%E8%BF%94%E5%9B%9E%E7%BB%99%E5%AE%A2%E6%88%B7%E7%AB%AF"><span class="toc-number">13.4.5.</span> <span class="toc-text">13.4.5 实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-5-UDP%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B"><span class="toc-number">13.5.</span> <span class="toc-text">13.5 UDP网络编程</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-6-URL%E7%BC%96%E7%A8%8B"><span class="toc-number">13.6.</span> <span class="toc-text">13.6 URL编程</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-1-%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">13.6.1.</span> <span class="toc-text">13.6.1 构造器</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#13-6-2-%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95"><span class="toc-number">13.6.2.</span> <span class="toc-text">13.6.2 常用方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%81%E5%9B%9B%E3%80%81Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6"><span class="toc-number">14.</span> <span class="toc-text">十四、Java反射机制</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#14-1-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E6%A6%82%E8%BF%B0"><span class="toc-number">14.1.</span> <span class="toc-text">14.1 Java反射机制概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-1-%E5%8A%A8%E6%80%81%E8%AF%AD%E8%A8%80%E4%B8%8E%E9%9D%99%E6%80%81%E8%AF%AD%E8%A8%80"><span class="toc-number">14.1.1.</span> <span class="toc-text">14.1.1 动态语言与静态语言</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-2-Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E7%A0%94%E7%A9%B6%E5%8F%8A%E5%BA%94%E7%94%A8"><span class="toc-number">14.1.2.</span> <span class="toc-text">14.1.2 Java反射机制研究及应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-3-%E5%8F%8D%E5%B0%84%E7%9B%B8%E5%85%B3%E7%9A%84API"><span class="toc-number">14.1.3.</span> <span class="toc-text">14.1.3 反射相关的API</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-1-4-%E5%8F%8D%E5%B0%84%E5%89%8D%E5%90%8E%E5%AF%B9%E4%B8%80%E4%B8%AA%E7%B1%BB%E7%9A%84%E6%93%8D%E4%BD%9C%E5%AF%B9%E6%AF%94"><span class="toc-number">14.1.4.</span> <span class="toc-text">14.1.4 反射前后对一个类的操作对比</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-2-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3%E5%8F%8A%E8%8E%B7%E5%8F%96Class%E5%AE%9E%E4%BE%8B"><span class="toc-number">14.2.</span> <span class="toc-text">14.2 Class类的理解及获取Class实例</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-1-Class%E7%B1%BB%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">14.2.1.</span> <span class="toc-text">14.2.1 Class类的理解</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-2-%E8%8E%B7%E5%8F%96Class%E7%B1%BB%E7%9A%84%E5%AE%9E%E4%BE%8B"><span class="toc-number">14.2.2.</span> <span class="toc-text">14.2.2 获取Class类的实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-2-3-%E5%93%AA%E4%BA%9B%E7%B1%BB%E5%9E%8B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAClass%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.2.3.</span> <span class="toc-text">14.2.3 哪些类型可以作为Class对象</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-3-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E4%B8%8EClassLoader%E7%9A%84%E7%90%86%E8%A7%A3"><span class="toc-number">14.3.</span> <span class="toc-text">14.3 类的加载与ClassLoader的理解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-1-%E7%B1%BB%E7%9A%84%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B"><span class="toc-number">14.3.1.</span> <span class="toc-text">14.3.1 类的加载过程</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-3-2-%E7%90%86%E8%A7%A3%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8ClassLoader"><span class="toc-number">14.3.2.</span> <span class="toc-text">14.3.2 理解类加载器ClassLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A"><span class="toc-number">14.3.2.1.</span> <span class="toc-text">1.类加载器的作用：</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#2-%E8%8E%B7%E5%8F%96%E4%B8%89%E7%A7%8D%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">14.3.2.2.</span> <span class="toc-text">2.获取三种类加载器</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#3-%E4%BD%BF%E7%94%A8ClassLoader%E5%8A%A0%E8%BD%BD%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6"><span class="toc-number">14.3.2.3.</span> <span class="toc-text">3.使用ClassLoader加载配置文件</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-4-%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.</span> <span class="toc-text">14.4 创建运行时对象</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-1-%E9%80%9A%E8%BF%87%E5%8F%8D%E5%B0%84%E5%88%9B%E5%BB%BA%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E5%AF%B9%E8%B1%A1"><span class="toc-number">14.4.1.</span> <span class="toc-text">14.4.1 通过反射创建运行时类对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-4-2-%E4%BD%93%E4%BC%9A%E5%8F%8D%E5%B0%84%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7"><span class="toc-number">14.4.2.</span> <span class="toc-text">14.4.2 体会反射的动态性</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%AE%8C%E6%95%B4%E7%BB%93%E6%9E%84"><span class="toc-number">14.5.</span> <span class="toc-text">14.5 获取运行时类的完整结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-1-%E6%8F%90%E4%BE%9B%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%B8%B0%E5%AF%8C%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BBPerson"><span class="toc-number">14.5.1.</span> <span class="toc-text">14.5.1 提供一个结构丰富的自定义类Person</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-2-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E5%B1%9E%E6%80%A7%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.5.2.</span> <span class="toc-text">14.5.2 获取运行时类的属性结构及其内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-3-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%96%B9%E6%B3%95%E7%BB%93%E6%9E%84%E5%8F%8A%E5%85%B6%E5%86%85%E9%83%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.5.3.</span> <span class="toc-text">14.5.3 获取运行时类的方法结构及其内部结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-4-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%9E%84%E9%80%A0%E5%99%A8%E7%BB%93%E6%9E%84"><span class="toc-number">14.5.4.</span> <span class="toc-text">14.5.4 获取运行时类的构造器结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-5-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E7%88%B6%E7%B1%BB%E5%8F%8A%E7%88%B6%E7%B1%BB%E6%B3%9B%E5%9E%8B"><span class="toc-number">14.5.5.</span> <span class="toc-text">14.5.5 获取运行时类的父类及父类泛型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-5-6-%E8%8E%B7%E5%8F%96%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8E%A5%E5%8F%A3%E3%80%81%E6%89%80%E5%9C%A8%E5%8C%85%E3%80%81%E6%B3%A8%E8%A7%A3%E7%AD%89"><span class="toc-number">14.5.6.</span> <span class="toc-text">14.5.6 获取运行时类的接口、所在包、注解等</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-6-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E7%BB%93%E6%9E%84"><span class="toc-number">14.6.</span> <span class="toc-text">14.6 调用运行时类的指定结构</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-1-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E5%B1%9E%E6%80%A7"><span class="toc-number">14.6.1.</span> <span class="toc-text">14.6.1 调用运行时类的指定属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-2-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-number">14.6.2.</span> <span class="toc-text">14.6.2 调用运行时类的指定方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-6-3-%E8%B0%83%E7%94%A8%E8%BF%90%E8%A1%8C%E6%97%B6%E7%B1%BB%E7%9A%84%E6%8C%87%E5%AE%9A%E6%9E%84%E9%80%A0%E5%99%A8"><span class="toc-number">14.6.3.</span> <span class="toc-text">14.6.3 调用运行时类的指定构造器</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-7-%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%9A%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">14.7.</span> <span class="toc-text">14.7 反射的应用：动态代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-1-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86"><span class="toc-number">14.7.1.</span> <span class="toc-text">14.7.1 动态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-2-%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="toc-number">14.7.2.</span> <span class="toc-text">14.7.2 静态代理实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-3-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E5%AE%9E%E4%BE%8B"><span class="toc-number">14.7.3.</span> <span class="toc-text">14.7.3 动态代理实例</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#14-7-4-%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E4%B8%8EAOP"><span class="toc-number">14.7.4.</span> <span class="toc-text">14.7.4 动态代理与AOP</span></a></li></ol></li></ol></li></ol>
    </div>
  </section>

  

</div>


<!-- 没有 pjax 占位会报错 万恶的 pjax -->

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <div class="pjax">
    <!-- pjax占位 -->
  </div>

  <!-- Custom Files side begin -->
  
  <!-- Custom Files side end -->
</aside>



          <!--此文件用来存放一些不方便取值的变量-->
<!--思路大概是将值藏到重加载的区域内-->

<pjax>
<script>
  window.pdata={}
  pdata.ispage=true;
  pdata.commentPath="";
  pdata.commentPlaceholder="";
  pdata.commentConfig={};
  //  see: /layout/_partial/scripts/_ctrl/coverCtrl.ejs
  
    // header
    var l_header=document.getElementById("l_header");
    
    l_header.classList.remove("show");
    
    
      // cover
      var cover_wrapper=document.querySelector('#l_cover .cover-wrapper');
      var scroll_down=document.getElementById('scroll-down');
      cover_wrapper.id="half";
      cover_wrapper.style.display="";
      scroll_down.style.display="none";
    
  
</script>
</pjax>
        </div>
        
  
  <footer class="footer clearfix"  itemscope itemtype="http://schema.org/WPFooter">
    <br><br>
    
      
        <div class="aplayer-container">
          

  
    <meting-js
      theme='#1BCDFC'
      autoplay='false'
      volume='0.7'
      loop='all'
      order='random'
      fixed='false'
      list-max-height='200px'
      server='tencent'
      type='playlist'
      id='8413384953'
      list-folded='true'>
    </meting-js>
  


        </div>
      
    
      
        <br>
        <div class="social-wrapper" itemprop="about" itemscope itemtype="http://schema.org/Thing">
          
            
              <a href="/atom.xml"
                class="social fas fa-rss flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
            
              <a href="https://github.com/rainvex"
                class="social fab fa-github flat-btn"
                target="_blank"
                rel="external nofollow noopener noreferrer" itemprop="url">
                
              </a>
            
          
        </div>
      
    
      
        
          <div><p><span id="lc-sv">本站总访问量为 <span id='number'><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span> 次</span> <span id="lc-uv">访客数为 <span id='number'><i class="fa-solid fa-loader fa-spin fa-fw" aria-hidden="true"></i></span> 人</span></p>
</div>
        
      
    
      
        <div class='copyright'>
        <p><a href="/">Copyright © since 2022 夜雨声烦</a></p>

        </div>
      
    
    <!-- Custom Files footer begin-->
    
    <!-- Custom Files footer end-->
  </footer>


        <a id="s-top" class="fa-solid fa-arrow-up fa-fw" href="/" onclick="return false;" title="top"></a>
      </div>
    </div>
    <div>
      <script>
  /******************** volantis.dom ********************************/
  // 页面选择器 将dom对象缓存起来 see: /source/js/app.js etc.
  volantis.dom.bodyAnchor = volantis.dom.$(document.getElementById("safearea")); // 页面主体
  volantis.dom.topBtn = volantis.dom.$(document.getElementById('s-top')); // 向上
  volantis.dom.wrapper = volantis.dom.$(document.getElementById('wrapper')); // 整个导航栏
  volantis.dom.coverAnchor = volantis.dom.$(document.querySelector('#l_cover .cover-wrapper')); // 1个
  volantis.dom.switcher = volantis.dom.$(document.querySelector('#l_header .switcher .s-search')); // 搜索按钮   移动端 1个
  volantis.dom.header = volantis.dom.$(document.getElementById('l_header')); // 移动端导航栏
  volantis.dom.search = volantis.dom.$(document.querySelector('#l_header .m_search')); // 搜索框 桌面端 移动端 1个
  volantis.dom.mPhoneList = volantis.dom.$(document.querySelectorAll('#l_header .m-phone .list-v')); //  手机端 子菜单 多个
</script>

<script>
  
  volantis.css("https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/static/fontawesome/css/all.min.css");
  
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/font-awesome-animation/font-awesome-animation.min.css");
  
  
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/node-waves/dist/waves.min.css");
  
</script>

<!-- required -->


<!-- internal -->

<script src="/js/app.af2d54c8.js"></script>





  













<div id="rightmenu-wrapper">
  <ul class="list-v rightmenu" id="rightmenu-content">
    
  <li class='navigation menuNavigation-Content'>


    <a class="nav icon-only fix-cursor-default" onclick="history.back()"><i class="fa-solid fa-arrow-left fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="history.forward()"><i class="fa-solid fa-arrow-right fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="window.location.reload()"><i class="fa-solid fa-redo fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" onclick="VolantisApp.scrolltoElement(volantis.dom.bodyAnchor)"><i class="fa-solid fa-arrow-up fa-fw"></i></a>



    <a class="nav icon-only fix-cursor-default" href="/"><i class="fa-solid fa-home fa-fw"></i></a>


  </li>


    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyPaste" data-event="copyPaste" data-group="inputBox">
      <i class="fa-solid fa-paste fa-fw"></i>
      粘贴文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyAll" data-event="copyAll" data-group="inputBox">
      <i class="fa-solid fa-object-ungroup fa-fw"></i>
      全选文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyCut" data-event="copyCut" data-group="inputBox">
      <i class="fa-solid fa-cut fa-fw"></i>
      剪切文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyText" data-event="copyText" data-group="seletctText">
      <i class="fa-solid fa-copy fa-fw"></i>
      复制文本
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="searchWord" data-event="OpenSearch(__text__)" data-group="seletctText">
      <i class="fa-solid fa-search fa-fw"></i>
      站内搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="bingSearch" data-event="window.open(`https://cn.bing.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-solid fa-search fa-fw"></i>
      必应搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleSearch" data-event="window.open(`https://www.google.com/search?q=${__text__}`)" data-group="seletctText">
      <i class="fa-solid fa-search fa-fw"></i>
      谷歌搜索
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="openTab" data-event="window.open(__link__)" data-group="elementCheck">
      <i class="fa-solid fa-external-link-square-alt fa-fw"></i>
      新标签页打开
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyLink" data-event="copyLink" data-group="elementCheck">
      <i class="fa-solid fa-link fa-fw"></i>
      复制链接地址
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="copyImg" data-event="copyImg" data-group="elementImage">
      <i class="fa-solid fa-image fa-fw"></i>
      复制图片
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="googleImg" data-event="window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)" data-group="elementImage">
      <i class="fa-solid fa-images fa-fw"></i>
      谷歌识图
    </span>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="github" target="_blank" rel="noopener" href="https://github.com/rainvex" data-group="link">
      <i class="fa-solid fa-code-branch SUNFLOWER fa-fw"></i>
      本站源码
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="friends" href="friends/" data-group="link">
      <i class="fa-solid fa-flower-daffodil AMETHYST fa-fw"></i>
      我的朋友们
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="archive" href="archives/" data-group="link">
      <i class="fa-solid fa-globe-asia CONCRETE fa-fw"></i>
      文章归档
    </a>
  </li>



  <li class="menuLoad-Content">
    <a class="vlts-menu fix-cursor-default" id="about" href="about/" data-group="link">
      <i class="fa-solid fa-gingerbread-man WISTERIA fa-fw"></i>
      关于我
    </a>
  </li>



    <hr class="menuLoad-Content" >



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="darkMode" data-event="volantis.dark.toggle()" data-group="darkMode">
      <i class="fa-solid fa-eclipse-alt WISTERIA fa-fw"></i>
      暗黑模式
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="printMode" data-event="printMode" data-group="articlePage">
      <i class="fa-solid fa-print fa-fw"></i>
      打印页面
    </span>
  </li>



  <li class="menuLoad-Content">
    <span class="vlts-menu fix-cursor-default event" id="readMode" data-event="readMode" data-group="articlePage">
      <i class="fa-solid fa-book-open fa-fw"></i>
      阅读模式
    </span>
  </li>


<div id="menuMusic">
  <li class='music name menuOption-Content'>
    <p class='nav music-title fix-cursor-default'></p>
  </li>
  <li class='music ctrl'>
    <a class='nav icon-only backward fix-cursor-default' href="/" onclick="return false;" title="backward">
      <i class='fa-solid fa-step-backward fa-fw'></i>
    </a>
    <a class='nav icon-only toggle fix-cursor-default' href="/" onclick="return false;" title="toggle">
      <i class='fa-solid fa-play fa-fw'></i>
    </a>
    <a class='nav icon-only forward fix-cursor-default' href="/" onclick="return false;" title="forward">
      <i class='fa-solid fa-step-forward fa-fw'></i>
    </a>
  </li>
  <li class='music volume'>
    <div class='nav volume'>
      <div class="aplayer-volume-bar-wrap">
        <div class="aplayer-volume-bar fix-cursor-pointer">
          <div class="aplayer-volume"></div>
          <i class='left fa-solid fa-volume-off fa-fw'></i>
          <i class='right fa-solid fa-volume-up fa-fw'></i>
        </div>
      </div>
    </div>
  </li>
</div>

  </ul>
</div>
<script src="/js/plugins/rightMenus.1aa99ff1.js"></script>
<script>
  const RightMenusFunction = {};
  














  //RightMenusFunction['copyPaste'] = (fun) => {fun()}





  //RightMenusFunction['copyAll'] = (fun) => {fun()}





  //RightMenusFunction['copyCut'] = (fun) => {fun()}





  //RightMenusFunction['copyText'] = (fun) => {fun()}





  RightMenusFunction['searchWord'] = (__text__) => {OpenSearch(__text__)}





  RightMenusFunction['bingSearch'] = (__text__) => {window.open(`https://cn.bing.com/search?q=${__text__}`)}





  RightMenusFunction['googleSearch'] = (__text__) => {window.open(`https://www.google.com/search?q=${__text__}`)}





  RightMenusFunction['openTab'] = (__link__) => {window.open(__link__)}





  //RightMenusFunction['copyLink'] = (fun) => {fun()}





  //RightMenusFunction['copyImg'] = (fun) => {fun()}





  RightMenusFunction['googleImg'] = (__link__) => {window.open(`https://www.google.com.hk/searchbyimage?image_url=${__link__}`)}















  RightMenusFunction['darkMode'] = () => {volantis.dark.toggle()}





  //RightMenusFunction['printMode'] = (fun) => {fun()}





  //RightMenusFunction['readMode'] = (fun) => {fun()}





</script>



<!-- rightmenu要在darkmode之前（ToggleButton） darkmode要在comments之前（volantis.dark.push）-->

  <script>
const rootElement = document.documentElement;
const darkModeStorageKey = "color-scheme";
const rootElementDarkModeAttributeName = "color-scheme";
const setLS = (k, v) => {
    localStorage.setItem(k, v);
};
const removeLS = (k) => {
    localStorage.removeItem(k);
};
const getLS = (k) => {
    return localStorage.getItem(k);
};
const getModeFromCSSMediaQuery = () => {
  return window.matchMedia("(prefers-color-scheme: dark)").matches
    ? "dark"
    : "light";
};
const resetRootDarkModeAttributeAndLS = () => {
  rootElement.removeAttribute(rootElementDarkModeAttributeName);
  removeLS(darkModeStorageKey);
};
const validColorModeKeys = {
  dark: true,
  light: true,
};
const applyCustomDarkModeSettings = (mode) => {
  const currentSetting = mode || getLS(darkModeStorageKey);
  getCustomDarkMode();
  if (currentSetting === getModeFromCSSMediaQuery()) {
    resetRootDarkModeAttributeAndLS();
  } else if (validColorModeKeys[currentSetting]) {
    rootElement.setAttribute(rootElementDarkModeAttributeName, currentSetting);
  } else {
    resetRootDarkModeAttributeAndLS();
  }
};
const invertDarkModeObj = {
  dark: "light",
  light: "dark",
};
/**
 * get target mode
 */
 const getCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  if(currentSetting=="dark"){
    volantis.dark.mode="light";
  }else{
    volantis.dark.mode="dark";
  }
  // console.log(volantis.dark.mode)
};
const toggleCustomDarkMode = () => {
  let currentSetting = getLS(darkModeStorageKey);
  if (validColorModeKeys[currentSetting]) {
    currentSetting = invertDarkModeObj[currentSetting];
  } else if (currentSetting === null) {
    currentSetting = invertDarkModeObj[getModeFromCSSMediaQuery()];
  } else {
    return;
  }
  setLS(darkModeStorageKey, currentSetting);
  return currentSetting;
};
/**
 * 暗黑模式触发器
 */
volantis.dark.toggle=()=>{
  const mode = toggleCustomDarkMode();
  applyCustomDarkModeSettings(mode);
  // 使用 volantis.dark.push 方法传入volantis.dark.toggle回调函数 参见layout/_partial/scripts/global.ejs
  volantis.dark.method.toggle.start();
}
/**
 * bind event for toggle button
 */

function bindToggleButton() {
  var btn= document.querySelectorAll("#wrapper .toggle-mode-btn,#rightmenu-wrapper .toggle-mode-btn")
  btn.forEach(function (e) {
    volantis.dom.$(e).on('click',volantis.dark.toggle);
  })
}
applyCustomDarkModeSettings();
document.addEventListener("DOMContentLoaded", ()=>{
  volantis.requestAnimationFrame(bindToggleButton)
});
volantis.pjax.push(bindToggleButton);

const darkModelListeners={
  dark:(mediaQueryList )=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "dark";
    }
    volantis.dark.method.toggle.start();
  },
  light:(mediaQueryList)=>{
    if(mediaQueryList.matches){
      volantis.dark.mode = "light";
    }
    volantis.dark.method.toggle.start();
  }
}
window.matchMedia('(prefers-color-scheme: dark)').addListener(darkModelListeners.dark)
window.matchMedia('(prefers-color-scheme: light)').addListener(darkModelListeners.light)
</script>




<script>
  function loadIssuesJS() {
    
      const sites_api = document.getElementById('sites-api');
      if (sites_api != undefined && typeof SitesJS === 'undefined') {
        volantis.js("/js/plugins/tags/sites.76bf19b8.js")
      }
    
    
      const friends_api = document.getElementById('friends-api');
      if (friends_api != undefined && typeof FriendsJS === 'undefined') {
        volantis.js("/js/plugins/tags/friends.f372da57.js")
      }
    
    
      const contributors_api = document.getElementById('contributors-api');
      if (contributors_api != undefined && typeof ContributorsJS === 'undefined') {
        volantis.js("/js/plugins/tags/contributors.aec80453.js")
      }
    
  };
  loadIssuesJS()
  volantis.pjax.push(()=>{
    loadIssuesJS();
  })

</script>




  <script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/vanilla-lazyload/dist/lazyload.min.js"></script>
<script>
  // https://www.npmjs.com/package/vanilla-lazyload
  // Set the options globally
  // to make LazyLoad self-initialize
  window.lazyLoadOptions = {
    elements_selector: ".lazyload",
    threshold: 0
  };
  // Listen to the initialization event
  // and get the instance of LazyLoad
  window.addEventListener(
    "LazyLoad::Initialized",
    function (event) {
      window.lazyLoadInstance = event.detail.instance;
    },
    false
  );
  document.addEventListener('DOMContentLoaded', function () {
    lazyLoadInstance.update();
  });
  document.addEventListener('pjax:complete', function () {
    lazyLoadInstance.update();
  });
</script>




  

<script>
  window.FPConfig = {
	delay: 0,
	ignoreKeywords: ["#"],
	maxRPS: 6,
	hoverDelay: 0
  };
</script>
<script defer src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/flying-pages/flying-pages.min.js"></script>





   <script type="text/javascript">
  function pjax_scrollrebeal() {
    ScrollReveal().reveal("#l_main .reveal", {
      distance: "32px",
      duration: "800",
      interval: "20",
      scale: "1",
      easing: "ease-out",
    });
  }
  function init_scrollrebeal() {
    if (typeof ScrollReveal == "undefined") {
      volantis.requestAnimationFrame(init_scrollrebeal);
    } else {
      pjax_scrollrebeal();
    }
  }
  volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/scrollreveal/dist/scrollreveal.min.js");
  document.addEventListener("DOMContentLoaded", init_scrollrebeal);
  volantis.pjax.push(
    pjax_scrollrebeal,
    "pjax_scrollrebeal",
    (setRequestAnimationFrame = false)
  );
</script>




  <script>
  volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.css");
  (async () => {
    // APlayer 需要在  MetingJS 之前加载
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/aplayer/dist/APlayer.min.js")
    await volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/meting/dist/Meting.min.js")
  
    // 右键 music 需要在 APlayer  MetingJS 之后加载
    await volantis.js('/js/plugins/aplayer.dbe5eea9.js')
  
  })();

  function SetAPlayerPlugin(){
    let Metings = document.querySelectorAll('meting-js');
    if (Metings.length === 0) {return;};
    if (Metings[0].aplayer && Metings[0].aplayer.on) {
      // improve the accessibility https://web.dev/button-name/
      document.querySelectorAll(".aplayer-icon-menu").forEach(e=>{
        e.setAttribute("aria-label","Aplayer Menu")
      })
      // message see: /layout/_plugins/message/script.ejs
      
        try {
          setTimeout(() => {
            Metings.forEach((item, index) => {
              const aplayerItem = item.aplayer; if(!aplayerItem) return;
              const rightAplayerCheck = 'true' === 'true'
                && item.meta.id === '8413384953';
              if(rightAplayerCheck) RightMenuAplayer.checkAPlayer();
              if(aplayerItem.events.events.play.every(item => {return item.name !== 'messagePlay'})) {
                aplayerItem.on('play', function messagePlay() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    VolantisApp.message('音乐通知', title + ' - ' + artist, {
                      icon: 'fa-solid fa-play',
                      transitionIn: 'flipInX',
                      transitionOut: 'flipOutX'
                    });
                  }, 100)
                });
              }
              if(aplayerItem.events.events.pause.every(item => {return item.name !== 'messagePause'})) {
                aplayerItem.on('pause', function messagePause() {
                  let index = aplayerItem.list.index;
                  let title = aplayerItem.list.audios[index].title;
                  let artist = aplayerItem.list.audios[index].artist;
                  setTimeout(() => {
                    // 歌曲播放结束也会触发 pause 事件，为了避免错误提示，等待一会儿
                    if(aplayerItem.paused) {
                      VolantisApp.message('音乐通知', title + ' - ' + artist, {
                        icon: 'fa-solid fa-pause',
                        transitionIn: 'flipInX',
                        transitionOut: 'flipOutX'
                      });
                    }
                  }, 100)
                });
              }
            });
          }, 500)
        } catch (error) { console.error(error); }
      
    }else{
      volantis.requestAnimationFrame(SetAPlayerPlugin)
    }
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    SetAPlayerPlugin();
  });
  volantis.pjax.push(SetAPlayerPlugin);
</script>




      <script>
  volantis.layoutHelper("comments",`<div id="waline"><i class="fa-solid fa-cog fa-spin fa-fw fa-2x"></i></div>`)
  
  function pjax_waline() {
    if(!document.querySelector("#waline"))return;
    let locale = {};
    let path = pdata.commentPath;
    let pagePlaceholder = pdata.commentPlaceholder || "期待你的评论😆";
    if (path.length == 0) {
      let defaultPath = '';
      path = defaultPath || decodeURI(window.location.pathname);
    }
    if(pagePlaceholder.length != 0) {
      locale.placeholder = pagePlaceholder;
    }

    try {
      Waline.init(Object.assign(Object.assign({"js":"https://unpkg.com/@waline/client@v2/dist/waline.js","css":"https://unpkg.com/@waline/client@v2/dist/waline.css","path":null,"placeholder":"期待你的评论😆","serverURL":"https://waline-comment-coral.vercel.app/","imageUploader":false,"pageview":true,"comment":true,"emoji":["//unpkg.com/@waline/emojis@1.0.1/tw-emoji"],"dark":"auto","requiredMeta":["nick","mail"],"copyright":false}, {
        el: '#waline',
        path: path,
        // https://github.com/volantis-x/hexo-theme-volantis/issues/713
        
        locale,
      }),pdata.commentConfig));
    } catch (error) {
      alert(`Waline ${error}`)
    }
    fancybox_waline()
  }

  function fancybox_waline() {
    if(typeof VolantisFancyBox === "undefined") {
      const checkFancyBox = setInterval(() => {
        if(typeof VolantisFancyBox === "undefined") return;
        clearInterval(checkFancyBox);
        VolantisFancyBox.bind('#waline .wl-content img:not(.wl-emoji)');
      })
    } else {
      VolantisFancyBox.bind('#waline .wl-content img:not(.wl-emoji)');
    }
  }

  volantis.css('https://unpkg.com/@waline/client@v2/dist/waline.css')
  volantis.js('https://unpkg.com/@waline/client@v2/dist/waline.js').then(pjax_waline)
  volantis.pjax.push(pjax_waline);
</script>
    





<!-- optional -->

  <script>
  const SearchServiceDataPathRoot = ("/" || "/").endsWith("/") ?
    "/" || "/" :
    "//" || "/";
  const SearchServiceDataPath = SearchServiceDataPathRoot + "content.json";

  function loadSearchScript() {
    // see: layout/_partial/scripts/_ctrl/cdnCtrl.ejs
    return volantis.js("/js/search/hexo.0e52f222.js");
  }

  function loadSearchService() {
    loadSearchScript();
    document.querySelectorAll(".input.u-search-input").forEach((e) => {
      e.removeEventListener("focus", loadSearchService, false);
    });

    document.querySelectorAll(".u-search-form").forEach((e) => {
      e.addEventListener("submit", (event) => {
        event.preventDefault();
      }, false);
    });
  }

  // 打开并搜索 字符串 s
  function OpenSearch(s) {
    if (typeof SearchService === 'undefined')
      loadSearchScript().then(() => {
        SearchService.setQueryText(s);
        SearchService.search();
      });
    else {
      SearchService.setQueryText(s);
      SearchService.search();
    }
  }

  // 访问含有 ?s=xxx  的链接时打开搜索 // 与搜索引擎 structured data 相关: /scripts/helpers/structured-data/lib/config.js
  if (window.location.search && /^\?s=/g.test(window.location.search)) {
    let queryText = decodeURI(window.location.search)
      .replace(/\ /g, "-")
      .replace(/^\?s=/g, "");
    OpenSearch(queryText);
  }

  // 搜索输入框获取焦点时加载搜索
  document.querySelectorAll(".input.u-search-input").forEach((e) => {
    e.addEventListener("focus", loadSearchService, false);
  });
</script>



  
<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/node-waves/dist/waves.min.js"></script>

<script type="text/javascript">
document.addEventListener("DOMContentLoaded", function () {
  Waves.attach('.flat-btn', ['waves-button']);
  Waves.attach('.float-btn', ['waves-button', 'waves-float']);
  Waves.attach('.float-btn-light', ['waves-button', 'waves-float', 'waves-light']);
  Waves.attach('.flat-box', ['waves-block']);
  Waves.attach('.float-box', ['waves-block', 'waves-float']);
  Waves.attach('.waves-image');
  Waves.init();
});
</script>



  
<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/comment_typing/comment_typing.js"></script>




  <script>

  volantis.css("https://unpkg.com/@highlightjs/cdn-assets@11.5.1/styles/atom-one-dark.min.css");


  volantis.js("https://unpkg.com/@highlightjs/cdn-assets@11.5.1/highlight.min.js").then(()=>{
    volantis.requestAnimationFrame(hljs.highlightAll)
  })
  volantis.pjax.push(()=>{
    document.querySelectorAll('pre code').forEach((block) => {
      hljs.highlightElement(block);
    });
  },"highlightjs")


  function pjax_highlightjs_copyCode(){
    if (!(document.querySelector(".highlight .code pre") ||
      document.querySelector(".article pre code"))) {
      return;
    }
    VolantisApp.utilCopyCode(".highlight .code pre, .article pre code")
  }
  volantis.requestAnimationFrame(pjax_highlightjs_copyCode)
  volantis.pjax.push(pjax_highlightjs_copyCode)

</script>




  <script defer>

  const LCCounter = {
    app_id: 'feD0Tuc86XvFVWdNoOX3PxFD-MdYXbMMI',
    app_key: '5d0fVvMLecbMACPBq7cqcEpz',
    custom_api_server: '',

    // 查询存储的记录
    getRecord(Counter, url, title) {
      return new Promise(function (resolve, reject) {
        Counter('get', '/classes/Counter?where=' + encodeURIComponent(JSON.stringify({url})))
          .then(resp => resp.json())
          .then(({results, code, error}) => {
            if (code === 401) {
              throw error;
            }
            if (results && results.length > 0) {
              var record = results[0];
              resolve(record);
            } else {
              Counter('post', '/classes/Counter', {url, title: title, times: 0})
                .then(resp => resp.json())
                .then((record, error) => {
                  if (error) {
                    throw error;
                  }
                  resolve(record);
                }).catch(error => {
                console.error('Failed to create', error);
                reject(error);
              });
            }
          }).catch((error) => {
          console.error('LeanCloud Counter Error:', error);
          reject(error);
        });
      })
    },

    // 发起自增请求
    increment(Counter, incrArr) {
      return new Promise(function (resolve, reject) {
        Counter('post', '/batch', {
          "requests": incrArr
        }).then((res) => {
          res = res.json();
          if (res.error) {
            throw res.error;
          }
          resolve(res);
        }).catch((error) => {
          console.error('Failed to save visitor count', error);
          reject(error);
        });
      });
    },

    // 构建自增请求体
    buildIncrement(objectId) {
      return {
        "method": "PUT",
        "path": `/1.1/classes/Counter/${ objectId }`,
        "body": {
          "times": {
            '__op': 'Increment',
            'amount': 1
          }
        }
      }
    },

    // 校验是否为有效的 UV
    validUV() {
      var key = 'LeanCloudUVTimestamp';
      var flag = localStorage.getItem(key);
      if (flag) {
        // 距离标记小于 24 小时则不计为 UV
        if (new Date().getTime() - parseInt(flag) <= 86400000) {
          return false;
        }
      }
      localStorage.setItem(key, new Date().getTime().toString());
      return true;
    },

    addCount(Counter) {
      var enableIncr = '' === 'true' && window.location.hostname !== 'localhost';
      enableIncr = true;
      var getterArr = [];
      var incrArr = [];
      // 请求 PV 并自增
      var pvCtn = document.querySelector('#lc-sv');
      if (pvCtn || enableIncr) {
        var pvGetter = this.getRecord(Counter, 'http://rainvex.com' + '/#lc-sv', 'Visits').then((record) => {
          incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-sv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + 1;
              if (pvCtn) {
                pvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(pvGetter);
      }

      // 请求 UV 并自增
      var uvCtn = document.querySelector('#lc-uv');
      if (uvCtn || enableIncr) {
        var uvGetter = this.getRecord(Counter, 'http://rainvex.com' + '/#lc-uv', 'Visitors').then((record) => {
          var vuv = this.validUV();
          vuv && incrArr.push(this.buildIncrement(record.objectId))
          var eles = document.querySelectorAll('#lc-uv #number');
          if (eles.length > 0) {
            eles.forEach((el,index,array)=>{
              el.innerText = record.times + (vuv ? 1 : 0);
              if (uvCtn) {
                uvCtn.style.display = 'inline';
              }
            })
          }
        });
        getterArr.push(uvGetter);
      }

      // 请求文章的浏览数，如果是当前页面就自增
      var allPV = document.querySelectorAll('#lc-pv');
      if (allPV.length > 0 || enableIncr) {
        for (i = 0; i < allPV.length; i++) {
          let pv = allPV[i];
          let title = pv.getAttribute('data-title');
          var url = 'http://rainvex.com' + pv.getAttribute('data-path');
          if (url) {
            var viewGetter = this.getRecord(Counter, url, title).then((record) => {
              // 是当前页面就自增
              let curPath = window.location.pathname;
              if (curPath.includes('index.html')) {
                curPath = curPath.substring(0, curPath.lastIndexOf('index.html'));
              }
              if (pv.getAttribute('data-path') == curPath) {
                incrArr.push(this.buildIncrement(record.objectId));
              }
              if (pv) {
                var ele = pv.querySelector('#lc-pv #number');
                if (ele) {
                  if (pv.getAttribute('data-path') == curPath) {
                    ele.innerText = (record.times || 0) + 1;
                  } else {
                    ele.innerText = record.times || 0;
                  }
                  pv.style.display = 'inline';
                }
              }
            });
            getterArr.push(viewGetter);
          }
        }
      }

      // 如果启动计数自增，批量发起自增请求
      if (enableIncr) {
        Promise.all(getterArr).then(() => {
          incrArr.length > 0 && this.increment(Counter, incrArr);
        })
      }

    },


    fetchData(api_server) {
      var Counter = (method, url, data) => {
        return fetch(`${ api_server }/1.1${ url }`, {
          method,
          headers: {
            'X-LC-Id': this.app_id,
            'X-LC-Key': this.app_key,
            'Content-Type': 'application/json',
          },
          body: JSON.stringify(data)
        });
      };
      this.addCount(Counter);
    },

    refreshCounter() {
      var api_server = this.app_id.slice(-9) !== '-MdYXbMMI' ? this.custom_api_server : `https://${ this.app_id.slice(0, 8).toLowerCase() }.api.lncldglobal.com`;
      if (api_server) {
        this.fetchData(api_server);
      } else {
        fetch('https://app-router.leancloud.cn/2/route?appId=' + this.app_id)
          .then(resp => resp.json())
          .then(({api_server}) => {
            this.fetchData('https://' + api_server);
          });
      }
    }

  };

  LCCounter.refreshCounter();

  document.addEventListener('pjax:complete', function () {
    LCCounter.refreshCounter();
  });
</script>




  


<!-- baidu Analytics -->
<script>
var _hmt = _hmt || [];
(function() {
  setTimeout(function() {
    volantis.js("https://hm.baidu.com/hm.js?09155030c63c73fbb962f7c640bfacc3")
  }, 1000);
})();
// 关于百度统计对 SPA 页面的处理：
// 方案一：百度统计>管理>单页应用设置中，打开开启按钮即可对SPA进行统计。 https://tongji.baidu.com/web/help/article?id=324
// 方案二：取消注释下列代码。 https://tongji.baidu.com/web/help/article?id=235
volantis.pjax.push(()=>{_hmt.push(['_trackPageview', document.location.pathname]);},'baidu_analytics')
</script>












  <script>
  let imgs = ["https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/bg9.jpg"];
  let index = 0;
  let IntervalParallax = null;

  function parallax(){
    let ParallaxWindow = document.querySelector("#parallax-window");
    
      ParallaxWindow = document.querySelector("html");
    
    Parallax.window = ParallaxWindow;
    Parallax.options.fade = 1500;
    Parallax.cache = 1;
    next_parallax();
    Parallax.init();
    if (imgs.length>1) {
      IntervalParallax = setInterval(function () {
        next_parallax();
      }, '0');
    }
  }

  function next_parallax() {
    if (typeof Parallax == "undefined") {
      return
    }
    
    if (imgs.length>=1) {
      Parallax.options.src = imgs[index % imgs.length];
      Parallax.start();
      index++;
      if (Parallax.cache) {
        fetch(imgs[index % imgs.length] +"?t=" + new Date().getTime());
        if (index == imgs.length) {
          Parallax.cache = 0;
        }
      }
    }
  }
  var runningOnBrowser = typeof window !== "undefined";
  var isBot = runningOnBrowser && !("onscroll" in window) || typeof navigator !== "undefined" && /(gle|ing|ro|msn)bot|crawl|spider|yand|duckgo/i.test(navigator.userAgent);
  if (!isBot) {
    volantis.js('/js/plugins/parallax.8bf0ab10.js').then(()=>{
      parallax()
    })
    volantis.pjax.send(()=>{
      clearInterval(IntervalParallax)
    },"clearIntervalParallax");
    volantis.pjax.push(parallax);
  }
</script>




  <script>
  function load_swiper() {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    volantis.css("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.css");
    volantis.js("https://unpkg.com/volantis-static@0.0.1654736714924/libs/swiper/swiper-bundle.min.js").then(() => {
      pjax_swiper();
    });
  }

  load_swiper();

  function pjax_swiper() {
    volantis.swiper = new Swiper('.swiper-container', {
      slidesPerView: 'auto',
      spaceBetween: 8,
      centeredSlides: true,
      loop: true,
      pagination: {
        el: '.swiper-pagination',
        clickable: true,
      },
      navigation: {
        nextEl: '.swiper-button-next',
        prevEl: '.swiper-button-prev',
      },
    });
  }

  volantis.pjax.push(() => {
    if (!document.querySelectorAll(".swiper-container")[0]) return;
    if (typeof volantis.swiper === "undefined") {
      load_swiper();
    } else {
      pjax_swiper();
    }
  });
</script>


<!-- pjax 标签必须存在于所有页面 否则 pjax error -->
<pjax>

</pjax>

<script>
  function listennSidebarTOC() {
    const navItems = document.querySelectorAll(".toc li");
    if (!navItems.length) return;
    let targets = []
    const sections = [...navItems].map((element) => {
      const link = element.querySelector(".toc-link");
      const target = document.getElementById(
        decodeURI(link.getAttribute("href")).replace("#", "")
      );
      targets.push(target)
      // 解除 a 标签 href 的 锚点定位, a 标签 href 的 锚点定位 会随机启用?? 产生错位???
      link.setAttribute("onclick","return false;")
      link.setAttribute("toc-action","toc-"+decodeURI(link.getAttribute("href")).replace("#", ""))
      link.setAttribute("href","/")
      // 配置 点击 触发新的锚点定位
      link.addEventListener("click", (event) => {
        event.preventDefault();
        // 这里的 addTop 是通过错位使得 toc 自动展开.
        volantis.scroll.to(target,{addTop: 5, observer:true})
        // Anchor id
        history.pushState(null, document.title, "#" + target.id);
      });
      return target;
    });

    function activateNavByIndex(target) {
      if (target.classList.contains("active-current")) return;

      document.querySelectorAll(".toc .active").forEach((element) => {
        element.classList.remove("active", "active-current");
      });
      target.classList.add("active", "active-current");
      let parent = target.parentNode;
      while (!parent.matches(".toc")) {
        if (parent.matches("li")) parent.classList.add("active");
        parent = parent.parentNode;
      }
    }

    // 方案一：
    volantis.activateNavIndex=0
    activateNavByIndex(navItems[volantis.activateNavIndex])
    volantis.scroll.push(()=>{
      if (targets[0].getBoundingClientRect().top >= 0) {
        volantis.activateNavIndex = 0
      }else if (targets[targets.length-1].getBoundingClientRect().top < 0) {
        volantis.activateNavIndex = targets.length-1
      } else {
        for (let index = 0; index < targets.length; index++) {
          const target0 = targets[index];
          const target1 = targets[(index+1)%targets.length];
          if (target0.getBoundingClientRect().top < 0&&target1.getBoundingClientRect().top >= 0) {
            volantis.activateNavIndex=index
            break;
          }
        }
      }
      activateNavByIndex(navItems[volantis.activateNavIndex])
    })

    // 方案二：
    // IntersectionObserver 不是完美精确到像素级别 也不是低延时性的
    // function findIndex(entries) {
    //   let index = 0;
    //   let entry = entries[index];
    //   if (entry.boundingClientRect.top > 0) {
    //     index = sections.indexOf(entry.target);
    //     return index === 0 ? 0 : index - 1;
    //   }
    //   for (; index < entries.length; index++) {
    //     if (entries[index].boundingClientRect.top <= 0) {
    //       entry = entries[index];
    //     } else {
    //       return sections.indexOf(entry.target);
    //     }
    //   }
    //   return sections.indexOf(entry.target);
    // }
    // function createIntersectionObserver(marginTop) {
    //   marginTop = Math.floor(marginTop + 10000);
    //   let intersectionObserver = new IntersectionObserver(
    //     (entries, observe) => {
    //       let scrollHeight = document.documentElement.scrollHeight;
    //       if (scrollHeight > marginTop) {
    //         observe.disconnect();
    //         createIntersectionObserver(scrollHeight);
    //         return;
    //       }
    //       let index = findIndex(entries);
    //       activateNavByIndex(navItems[index]);
    //     }, {
    //       rootMargin: marginTop + "px 0px -100% 0px",
    //       threshold: 0,
    //     }
    //   );
    //   sections.forEach((element) => {
    //     element && intersectionObserver.observe(element);
    //   });
    // }
    // createIntersectionObserver(document.documentElement.scrollHeight);
  }

  document.addEventListener("DOMContentLoaded", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
  document.addEventListener("pjax:success", ()=>{
    volantis.requestAnimationFrame(listennSidebarTOC)
  });
</script>



<script>
  document.onreadystatechange = function () {
    if (document.readyState == 'complete') {
      // 页面加载完毕 样式加载失败，或是当前网速慢，或是开启了省流模式
      const { saveData, effectiveType } = navigator.connection || navigator.mozConnection || navigator.webkitConnection || {}
      if (getComputedStyle(document.querySelector("#safearea"), null)["display"] == "none" || saveData || /2g/.test(effectiveType)) {
        document.querySelectorAll(".reveal").forEach(function (e) {
          e.style["opacity"] = "1";
        });
        document.querySelector("#safearea").style["display"] = "block";
      }
    }
  }
</script>


  <script type="application/ld+json">[{"@context":"http://schema.org","@type":"Organization","name":"夜雨声烦","url":"http://rainvex.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},{"@context":"http://schema.org","@type":"Person","name":"夜雨声烦","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://rainvex.com/","sameAs":["https://github.com/volantis-x"],"description":"夜雨声烦的个人博客"},{"@context":"http://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"item":{"@id":"http://rainvex.com/","name":"夜雨声烦"}},{"@type":"ListItem","position":2,"item":{"@id":"http://rainvex.com/categories/后端/","name":"后端"}},{"@type":"ListItem","position":3,"item":{"@id":"http://rainvex.com/categories/后端/JavaSE学习笔记.html","name":"JavaSE学习笔记"}}]},{"@context":"http://schema.org","@type":"WebSite","name":"夜雨声烦","url":"http://rainvex.com/","keywords":"rainvex,blog,夜雨声烦","description":"夜雨声烦的个人博客","author":{"@type":"Person","name":"夜雨声烦","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://rainvex.com/","description":"夜雨声烦的个人博客"},"publisher":{"@type":"Organization","name":"夜雨声烦","url":"http://rainvex.com/","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"potentialAction":{"@type":"SearchAction","name":"Site Search","target":{"@type":"EntryPoint","urlTemplate":"http://rainvex.com?s={search_term_string}"},"query-input":"required name=search_term_string"}},{"@context":"http://schema.org","@type":"BlogPosting","headline":"JavaSE学习笔记","description":"夜雨声烦的个人博客","inLanguage":["zh-CN","en","default"],"mainEntityOfPage":{"@type":"WebPage","@id":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html"},"author":{"@type":"Person","name":"夜雨声烦","image":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png"},"url":"http://rainvex.com/"},"publisher":{"@type":"Organization","name":"夜雨声烦","logo":{"@type":"ImageObject","url":"https://unpkg.com/volantis-static@0.0.1654736714924/media/org.volantis/blog/favicon/android-chrome-192x192.png","width":192,"height":192}},"url":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","wordCount":0,"datePublished":"2022-03-27T13:38:17.000Z","dateModified":"2022-03-27T13:38:17.000Z","articleSection":"后端","keywords":"笔记,Java,后端","image":{"@type":"ImageObject","url":"https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/blog/image/Java.png","width":1024,"height":768}}]</script>



      
        <!--
  pjax重载区域接口：
  1.  <pjax></pjax> 标签 pjax 标签必须存在于所有页面 否则 pjax error
  2.  script[data-pjax]
  3.  .pjax-reload script
  4.  .pjax
-->



<script src="https://unpkg.com/volantis-static@0.0.1654736714924/libs/pjax/pjax.min.js"></script>


<script>
    var pjax;
    document.addEventListener('DOMContentLoaded', function () {
      pjax = new Pjax({
        elements: 'a[href]:not([href^="#"]):not([href="javascript:void(0)"]):not([pjax-fancybox]):not([onclick="return false;"]):not([onclick="return!1"]):not([target="_blank"]):not([target="view_window"]):not([href$=".xml"])',
        selectors: [
          "head title",
          "head meta[name=keywords]",
          "head meta[name=description]",
          
          "#l_main",
          "#pjax-header-nav-list",
          ".pjax",
          "pjax", // <pjax></pjax> 标签
          "script[data-pjax], .pjax-reload script" // script标签添加data-pjax 或 script标签外层添加.pjax-reload 的script代码段重载
        ],
        cacheBust: false,   // url 地址追加时间戳，用以避免浏览器缓存
        timeout: 5000,
        
      });
    });

    document.addEventListener('pjax:send', function (e) {
      //window.stop(); // 相当于点击了浏览器的停止按钮

      try {
        var currentUrl = window.location.pathname;
        var targetUrl = e.triggerElement.href;
        var banUrl = [""];
        if (banUrl[0] != "") {
          banUrl.forEach(item => {
            if(currentUrl.indexOf(item) != -1 || targetUrl.indexOf(item) != -1) {
              window.location.href = targetUrl;
            }
          });
        }
      } catch (error) {}

      // 使用 volantis.pjax.send 方法传入pjax:send回调函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.send.start();
    });

    document.addEventListener('pjax:complete', function () {
      // 使用 volantis.pjax.push 方法传入重载函数 参见layout/_partial/scripts/global.ejs
      volantis.pjax.method.complete.start();
    });

    document.addEventListener('pjax:error', function (e) {
      if(volantis.debug) {
        console.error(e);
        console.log('pjax error: \n' + JSON.stringify(e));
      }else{
        // 使用 volantis.pjax.error 方法传入pjax:error回调函数 参见layout/_partial/scripts/global.ejs
        volantis.pjax.method.error.start();
        window.location.href = e.triggerElement.href;
      }
    });
</script>

      
    </div>
    <!-- import body_end begin-->
    <!-- import body_end end-->
    <!-- Custom Files bodyEnd begin-->
    
    <!-- Custom Files bodyEnd end-->
  </body>
</html>

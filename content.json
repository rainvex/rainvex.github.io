{"meta":{"title":"夜雨声烦","subtitle":"Rainvex","description":"夜雨声烦的个人博客","author":"夜雨声烦","url":"http://rainvex.com","root":"/"},"pages":[{"title":"夜雨声烦番剧列表","date":"2022-08-23T15:56:26.530Z","updated":"2022-08-23T15:56:26.530Z","comments":true,"path":"anime/index.html","permalink":"http://rainvex.com/anime/index.html","excerpt":"","text":"暂时未做，以后有时间慢慢做吧，主要暂时还不知道咋做🙄"},{"title":"","date":"2022-08-21T11:37:14.716Z","updated":"2022-08-21T11:37:14.716Z","comments":true,"path":"404.html","permalink":"http://rainvex.com/404.html","excerpt":"","text":"404 很抱歉，您访问的页面不存在 可能是输入地址有误或该地址已被删除"},{"title":"","date":"2022-08-23T15:55:22.222Z","updated":"2022-08-23T15:55:22.222Z","comments":true,"path":"about/index.html","permalink":"http://rainvex.com/about/index.html","excerpt":"","text":"✨关于博主在校学生,主后端辅前端 ✨关于博客网站使用Hexo搭建，主题提供是Volantis，个人网站的建立是希望拥有一个能随时展示自己，同时记录各种技术文章，总结学习工作内容和分享个人心情、经历的地方，主要包含前后端相关技术文章和自己在学习过程的笔记，记录问题及解决方法，方便在今后的学习中回顾复习更加清晰，或许同时还能有幸帮助到一些在某项技术点上有疑难困惑的人（我的水平还差得远呢🙄）。总之，有写的不清楚的地方望见谅，有错误的地方希望小伙伴们指正 ✨其他 网站大部分文章符合开源协议，可在非盈利用途下自由转载、复制，但对文章本身内容请勿在转载过程中断章取义，改写文章原本的表达含义，转载请注明引用来源，尊重原作者的创作成果；对于标记为”禁止转载”的文章，不得随意转载。请悉知 关于您的用户隐私数据声明：本网站无登录注册功能，且该网站属于无后端开发，所有界面均是静态html，网站本身不会以任何理由收集存储您的用户数据。评论的数据存储能力由第三方平台leancloud提供，具体相关的隐私策略和数据使用规范可以点击链接了解；如果您不了解或不希望这些平台使用您的信息，可以选择不使用这些功能或禁止浏览器授权本网站获取位置信息等行为 评论功能的使用情况说明：评论功能依托于waline提供的相关服务，可以匿名发表评论，但也请规范发言，切勿发布广告或恶意内容等信息，希望互相尊重。"},{"title":"留言板","date":"2022-08-22T13:50:39.945Z","updated":"2022-08-22T13:50:39.945Z","comments":true,"path":"info/index.html","permalink":"http://rainvex.com/info/index.html","excerpt":"","text":"欢迎你的留言"},{"title":"分类","date":"2022-08-22T13:57:31.770Z","updated":"2022-08-22T13:57:31.770Z","comments":true,"path":"categories/index.html","permalink":"http://rainvex.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2022-08-21T11:37:48.919Z","updated":"2022-08-21T11:37:48.919Z","comments":true,"path":"mylist/index.html","permalink":"http://rainvex.com/mylist/index.html","excerpt":"","text":""},{"title":"标签云","date":"2022-08-22T13:57:54.605Z","updated":"2022-08-22T13:57:54.605Z","comments":true,"path":"tags/index.html","permalink":"http://rainvex.com/tags/index.html","excerpt":"","text":""},{"title":"我的朋友们","date":"2022-08-23T15:56:56.564Z","updated":"2022-08-23T15:56:56.564Z","comments":true,"path":"friends/index.html","permalink":"http://rainvex.com/friends/index.html","excerpt":"","text":"内容待完善"}],"posts":[{"title":"置顶","slug":"置顶","date":"2022-08-22T15:28:01.000Z","updated":"2022-09-11T07:20:23.000Z","comments":true,"path":"categories/置顶/置顶.html","link":"","permalink":"http://rainvex.com/categories/%E7%BD%AE%E9%A1%B6/%E7%BD%AE%E9%A1%B6.html","excerpt":"","text":"最近心血来潮新换了一个主题，对着官方文档和一些大佬做的成品进行模仿、改动，但是还有很多这个主题集成的功能没配置，也有很多想加上的页面还没有做。而且因为这个主题所需要请求的资源比较多，访问起来比较慢，考虑到最近时间的原因只能先做这么多，勉勉强强能用吧，以后再慢慢完善，优化访问速度等。由于评论系统是部署在国外的托管网站上，现在国内好像不能正常使用了，后面再搞😫","categories":[{"name":"置顶","slug":"置顶","permalink":"http://rainvex.com/categories/%E7%BD%AE%E9%A1%B6/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://rainvex.com/tags/%E7%BD%AE%E9%A1%B6/"}],"author":"夜雨声烦"},{"title":"Mybatis-plus学习笔记","slug":"Mybatis-plus学习笔记","date":"2022-07-05T07:00:35.000Z","updated":"2022-07-05T07:00:35.000Z","comments":true,"path":"categories/后端/Mybatis-plus学习笔记.html","link":"","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/Mybatis-plus%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"Mybatis-plus学习笔记一、入门案例1.1 初始化项目1.创建新项目image-20220703160345161 image-20220703160636682 2.导入需要的依赖&lt;!--mybatis-plus--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--lombok--&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;!--mysql驱动--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--druid数据源--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; 3.编写配置文件首先把项目中的resources目录下的application.properties文件重命名为application.yaml（可选，看自己对配置文件格式的喜好） 然后在application.yaml文件中进行如下配置 spring: # 配置数据源 datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: root mybatis-plus: # mybatis-plus日志配置 configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl # mybatis-plus映射文件位置配置，即当我们需要写较复杂的sql语句时需要在resouces目录下的xxMapper.xml中进行，这个配置就是指定其位置 mapper-locations: classpath*:/mapper/**/*.xml 简要介绍： 1、type：指定数据源的类型，这里我们使用的是阿里巴巴的druid数据源 2、驱动类driver-class-name： spring boot 2.0（内置jdbc5驱动），驱动类使用-&gt;driver-class-name: com.mysql.jdbc.Driver spring boot 2.1及以上（内置jdbc8驱动），驱动类使用-&gt;driver-class-name: com.mysql.cj.jdbc.Driver 否则运行测试用例的时候会有 WARN 信息 3、连接地址url MySQL5.7版本的url：jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;useSSL=false MySQL8.0版本的url：jdbc:mysql://localhost:3306/mybatisplus?serverTimezone=GMT%2B8&amp;characterEncoding=utf-8&amp;useSSL=false 否则运行测试用例报告如下错误： java.sql.SQLException: The server time zone value ‘ÖÐ¹ú±ê×¼Ê±¼ä’ is unrecognized or represents more 1.2 创建数据库1.创建数据库和表CREATE DATABASE `mybatis_plus` use `mybatis_plus`; CREATE TABLE `user` ( `id` bigint(20) NOT NULL COMMENT &#39;主键ID&#39;, `name` varchar(30) DEFAULT NULL COMMENT &#39;姓名&#39;, `age` int(11) DEFAULT NULL COMMENT &#39;年龄&#39;, `email` varchar(50) DEFAULT NULL COMMENT &#39;邮箱&#39;, PRIMARY KEY (`id`) ) ENGINE=InnoDB DEFAULT CHARSET=utf8; 2.导入测试数据INSERT INTO user (id, name, age, email) VALUES (1, &#39;Jone&#39;, 18, &#39;test1@baomidou.com&#39;), (2, &#39;Jack&#39;, 20, &#39;test2@baomidou.com&#39;), (3, &#39;Tom&#39;, 28, &#39;test3@baomidou.com&#39;), (4, &#39;Sandy&#39;, 21, &#39;test4@baomidou.com&#39;), (5, &#39;Billie&#39;, 24, &#39;test5@baomidou.com&#39;); 1.3 构建项目结构1.新建包、实体类和mapper接口（1）在项目中新建包entity和mapper，分别用于存放实体类和mapper接口类 （2）在entity包中新建一个类为``User`，如下 //以下三个注解皆是lombok插件中的，这样我们就可以不用自己生成getter、setter、toString等方法 @Data @AllArgsConstructor @NoArgsConstructor public class User &#123; private Long id; private String name; private Integer age; private String email; &#125; 通过点击左下角的Structure即可查看该User类的结构 image-20220703163818969 （3）在mapper包下新建一个接口类为``UserMapper，使其继承BaseMapper` //BaseMapper是MyBatis-Plus提供的模板mapper，其中包含了基本的CRUD方法，泛型为操作的实体类型 //当继承了BaseMapper，我们就可以使用该mapper接口对象实现对单表的基本CRUD操作 public interface UserMapper extends BaseMapper&lt;User&gt; &#123; &#125; 2.配置启动类在SpringBoot工程的启动类即xxxApplication程序上方添加注解@MaperScan(&quot;mapper包的路径&quot;)，目的是指定mapper所在位置，让Spring容器在自动注入时能够扫描到mapper接口类，下方这个com.xk.mybatisplus.mapper就是刚刚我们创建的mapper包 image-20220703164124904 搭建好的结构如图所示： image-20220703170536716 1.4 测试在Test目录中可以新建一个测试类，编写好测试方式进行测试 @SpringBootTest class MybatisPlusApplicationTests &#123; //这儿它会爆红，因为找不到注入的对象，因为类是动态创建的，但是程序可以正确的执行。为了避免报错，可以在mapper接口上添加 @Repository 注解 @Autowired private UserMapper userMapper; @Test void testSelectList() &#123; //selectList()方式是根据MP内置的条件构造器QueryWrapper查询一个list集合，null表示没有条件，即查询所有 //然后遍历集合逐个打印 userMapper.selectList(null).forEach(System.out::println); &#125; &#125; 测试结果： User(id=1, name=Jone, age=18, email=test1@baomidou.com) User(id=2, name=Jack, age=20, email=test2@baomidou.com) User(id=3, name=Tom, age=28, email=test3@baomidou.com) User(id=4, name=Sandy, age=21, email=test4@baomidou.com) User(id=5, name=Billie, age=24, email=test5@baomidou.com) 由于我们在配置文件中配置了mybatis-plus的日志打印功能，所以在控制台可以看见执行该测试程序动态生成的sql语句： ==&gt; Preparing: SELECT id,name,age,email FROM user ==&gt; Parameters: &lt;== Columns: id, name, age, email &lt;== Row: 1, Jone, 18, test1@baomidou.com &lt;== Row: 2, Jack, 20, test2@baomidou.com &lt;== Row: 3, Tom, 28, test3@baomidou.com &lt;== Row: 4, Sandy, 21, test4@baomidou.com &lt;== Row: 5, Billie, 24, test5@baomidou.com &lt;== Total: 5 二、基本CRUD2.1 BaseMapper方法使用介绍public interface BaseMapper&lt;T&gt; extends Mapper&lt;T&gt; &#123; /** * 插入一条记录 * @param entity 实体对象 */ int insert(T entity); /** * 根据 ID 删除 * @param id 主键ID */ int deleteById(Serializable id); /** * 根据实体(ID)删除 * @param entity 实体对象 * @since 3.4.4 */ int deleteById(T entity); /** * 根据 columnMap 条件，删除记录 * @param columnMap 表字段 map 对象 */ int deleteByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); /** * 根据 entity 条件，删除记录 * @param queryWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成 where语句） */ int delete(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 删除（根据ID 批量删除） * @param idList 主键ID列表(不能为 null 以及 empty) */ int deleteBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); /** * 根据 ID 修改 * @param entity 实体对象 */ int updateById(@Param(Constants.ENTITY) T entity); /** * 根据 whereEntity 条件，更新记录 * @param entity 实体对象 (set 条件值,可以为 null) * @param updateWrapper 实体对象封装操作类（可以为 null,里面的 entity 用于生成where 语句） */ int update(@Param(Constants.ENTITY) T entity, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; updateWrapper); /** * 根据 ID 查询 * @param id 主键ID */ T selectById(Serializable id); /** * 查询（根据ID 批量查询） * @param idList 主键ID列表(不能为 null 以及 empty) */ List&lt;T&gt; selectBatchIds(@Param(Constants.COLLECTION) Collection&lt;? extends Serializable&gt; idList); /** * 查询（根据 columnMap 条件） * @param columnMap 表字段 map 对象 */ List&lt;T&gt; selectByMap(@Param(Constants.COLUMN_MAP) Map&lt;String, Object&gt; columnMap); /** * 根据 entity 条件，查询一条记录 * 查询一条记录，例如 qw.last(&quot;limit 1&quot;) 限制取一条记录, 注意：多条数据会报异常 * @param queryWrapper 实体对象封装操作类（可以为 null） */ default T selectOne(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper) &#123; List&lt;T&gt; ts = this.selectList(queryWrapper); if (CollectionUtils.isNotEmpty(ts)) &#123; if (ts.size() != 1) &#123; throw ExceptionUtils.mpe(&quot;One record is expected, but the query result is multiple records&quot;); &#125;else&#123; return ts.get(0); &#125; &#125;else&#123; return null; &#125; &#125; /** * 根据 Wrapper 条件，查询记录数是否存在 * @param queryWrapper 实体对象封装操作类（可以为 null） */ default boolean exists(Wrapper&lt;T&gt; queryWrapper) &#123; Long count = this.selectCount(queryWrapper); return null != count &amp;&amp; count &gt; 0L; &#125; /** * 根据 Wrapper 条件，查询总记录数 * @param queryWrapper 实体对象封装操作类（可以为 null） */ Long selectCount(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 entity 条件，查询全部记录 * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;T&gt; selectList(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录 * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;Map&lt;String, Object&gt;&gt; selectMaps(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录 * 注意： 只返回第一个字段的值 * @param queryWrapper 实体对象封装操作类（可以为 null） */ List&lt;Object&gt; selectObjs(@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 entity 条件，查询全部记录（并翻页） * @param page 分页查询条件（可以为 RowBounds.DEFAULT） * @param queryWrapper 实体对象封装操作类（可以为 null） */ &lt;P extends IPage&lt;T&gt;&gt; P selectPage(P page, @Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); /** * 根据 Wrapper 条件，查询全部记录（并翻页） * @param page 分页查询条件 * @param queryWrapper 实体对象封装操作类 */ &lt;P extends IPage&lt;Map&lt;String, Object&gt;&gt;&gt; P selectMapsPage(P page,@Param(Constants.WRAPPER) Wrapper&lt;T&gt; queryWrapper); &#125; 通过以上方式，我们可以更快的对单表数据进行操作，并且无需自己写一句sql 2.2 插入在刚刚入门案例搭建好的项目结构基础上，我们在测试类中编写测试代码对CRUD进行测试 @Test void testInsert()&#123; User user = new User(null, &quot;张三&quot;, 23, &quot;zhangsan@qq.com&quot;); //insert方法等价于INSERT INTO user ( id, name, age, email ) VALUES ( ?, ?, ?, ? ) //插入成功后Mybatis-Plus会返回受影响行数，并将该对象插入后的对应数据的id赋值到对象上 int result = userMapper.insert(user); //result = 1 System.out.println(&quot;受影响行数：&quot; + result); //id=1543529939734368257，这是MyBatis-Plus在实现数据插入时，默认基于雪花算法策略生成的id，所以我们在数据库中的id字段类型设置为了bigint，当然，我们也可以不使用这种方式生成id，而是在对象的id属性上加上@TableId注解将id的生成方式设置为自增，这个就后面再说明 System.out.println(&quot;id自动获取：&quot; + user.getId()); &#125; 执行完后在数据库user表中进行查看，可发现新增的记录 2.3 删除2.3.1 通过id删除@Test void testDelete()&#123; //通过id删除用户信息 //DELETE FROM user WHERE id=? int result = userMapper.deleteById(1543529939734368257L); System.out.println(&quot;受影响行数：&quot; + result); //1 &#125; 执行后，id为1543529939734368257的数据被删除 2.3.2 通过id批量删除@Test void testDelete()&#123; //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(&quot;受影响行数：&quot; + result); //1 &#125; 执行后，id为1、2、3的数据被删除 2.3.3 通过map条件集合删除@Test void testDelete()&#123; //根据map集合中所设置的条件删除记录 //DELETE FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;name&quot;, &quot;Sandy&quot;); map.put(&quot;age&quot;, 21); int result = userMapper.deleteByMap(map); System.out.println(&quot;受影响行数：&quot; + result); //1 &#125; 执行后，name为Sandy且age为21的数据被删除 从2.1可知，BaseMapper还提供了通过条件构造器的方式进行删除、修改、查询的方法，这些方法的测试就留到条件构造器讲解部分再进行 为了后续测试，我们重新添加一些数据到数据表中 2.4 修改@Test void testUpdate()&#123; User user = new User(4L, &quot;admin&quot;, 22, null); //UPDATE user SET name=?, age=? WHERE id=? int result = userMapper.updateById(user); System.out.println(&quot;受影响行数：&quot; + result); //1 &#125; 方法执行后，id为4的数据的name、age字段值会被修改为admin和22，而没有被设置的email则不变 2.5 查询2.5.1 通过id查询@Test void testSelect()&#123; //根据id查询用户信息 //SELECT id,name,age,email FROM user WHERE id=? User user = userMapper.selectById(4L); System.out.println(user);//User(id=4, name=admin, age=22, email=test4@baomidou.com) &#125; 2.5.2 通过id批量查询@Test void testSelect()&#123; //根据多个id查询多个用户信息 //SELECT id,name,age,email FROM user WHERE id IN ( ? , ? ) List&lt;Long&gt; idList = Arrays.asList(4L, 5L); List&lt;User&gt; list = userMapper.selectBatchIds(idList); list.forEach(System.out::println); //User(id=4, name=admin, age=22, email=test4@baomidou.com) //User(id=5, name=Billie, age=24, email=test5@baomidou.com) &#125; 2.5.3 通过map条件集合查询@Test void testSelect()&#123; //通过map条件查询用户信息 //SELECT id,name,age,email FROM user WHERE name = ? AND age = ? Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;age&quot;, 22); map.put(&quot;name&quot;, &quot;admin&quot;); List&lt;User&gt; list = userMapper.selectByMap(map); list.forEach(System.out::println);//User(id=4, name=admin, age=22, email=test4@baomidou.com) &#125; 2.5.4 查询所有数据@Test void testSelect()&#123; //查询所有用户信息 //SELECT id,name,age,email FROM user List&lt;User&gt; list = userMapper.selectList(null);//查询条件构造器为null，说明没有条件，则查询所有数据 list.forEach(System.out::println); //User(id=1, name=Jone, age=18, email=test1@baomidou.com) //User(id=2, name=Jack, age=20, email=test2@baomidou.com) //User(id=3, name=Tom, age=28, email=test3@baomidou.com) //User(id=4, name=admin, age=22, email=test4@baomidou.com) //User(id=5, name=Billie, age=24, email=test5@baomidou.com) &#125; 2.6 自定义SQL首先，在UserMaper接口中自定义一个方法 @Repository public interface UserMapper extends BaseMapper&lt;User&gt; &#123; Map&lt;String,Object&gt; selectMapById(Long id); &#125; 然后，在resources目录下创建一个mapper目录，再在里面创建一个UserMapper.xml文件（注意：应该提前在yaml配置文件中配置好mapper-locations，否则会找不到该映射文件，这里在前面也已经提到过且配置好的） 然后，在UserMapper中添加如下代码： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.xk.mybatisplus.mapper.UserMapper&quot;&gt; &lt;!--Map&lt;String,Object&gt; selectMapById(Long id);--&gt; &lt;select id=&quot;selectMapById&quot; resultType=&quot;map&quot;&gt; select id,name,age,email from user where id = #&#123;id&#125; &lt;/select&gt; &lt;/mapper&gt; 最后，测试 @Test void testCustom()&#123; Map&lt;String, Object&gt; map = userMapper.selectMapById(2L); System.out.println(map);//&#123;name=Jack, id=2, age=20, email=test2@baomidou.com&#125; &#125; 这儿其实就是Mybatis的内容，但是我们不用再像Mybtis中那样每次使用XXMapper前都需要先通过SqlSession获取mapper对象 2.7 通用ServiceMybatis-plus将通用的service CRUD方法封装成了一个IService接口 说明： 通用 Service CRUD 被封装IService接口，进一步封装 CRUD 采用save saveOrUpdate get remove update list page count chain前缀命名的方式与 Mapper 层进行区分，避免混淆 在方法条件中，泛型 T 为任意实体对象，对象 Wrapper 为条件构造器 建议：如果存在自定义通用 Service 方法的可能，请创建自己的 IBaseService 继承 Mybatis-Plus 提供的基类 通用Service接口和类中的方法可自行通过源码查询 这里通过查看Mybatis-plus的``IService接口和ServiceImpl`类源码关系可以知晓对于我们自定义的Service层接口和类应该怎样使用框架提供的通用方法 //IService接口 public interface IService&lt;T&gt;&#123;...&#125; //ServiceImpl类 public class ServiceImpl&lt;M extends BaseMapper&lt;T&gt;, T&gt; implements IService&lt;T&gt; &#123;...&#125; 2.7.1 如何使用通用Service1.创建Service接口//让自定义service继承IService，即可拥有IService中已定义的CRUD通用方法 public interface UserService extends IService&lt;User&gt; &#123; &#125; 2.创建ServiceImpl//让自定义的service接口实现类实现自定义的service接口，并且继承已定义的ServiceImpl通用实现类，那么此时自定义的service接口实现类既能去实现且拥有自定义service接口中的方法，又能拥有ServiceImpl中已经实现的service层通用方法 @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; &#125; 当UserService中我们没有定义任何新的方法时，UserServiceImpl这样写并不会报错，因为尽管在UserServiceImpl里面并没有去实现接口UserService继承的IService中任何的方法，但是它继承的ServiceImpl实现了IService的方法，等价于它自身也就实现了IService中的方法 通过上方ServiceImpl的源码可知，我们自定义的service实现类要想继承ServiceImpl，不仅需要提供该service要操作的实体类对象，还要提供实体类对象对应的mapper接口对象 3.测试查询记录数@Test void testCountService()&#123; long count = userService.count(); System.out.println(&quot;总记录数：&quot; + count);//总记录数：5 &#125; 4.测试批量插入@Test void testSaveBatch()&#123; // SQL长度有限制，海量数据插入单条SQL无法实行 // 因此MP将批量插入放在了通用Service中实现，而不是通用Mapper // 而在通用Service中是将所有数据通过循环遍历插入实现 ArrayList&lt;User&gt; users = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 5; i++) &#123; User user = new User(); user.setName(&quot;ybc&quot; + i); user.setAge(20 + i); users.add(user); &#125; //SQL:INSERT INTO t_user ( username, age ) VALUES ( ?, ? ) userService.saveBatch(users); &#125; 三、常用注解3.1 @TableName在之前的测试中，我们并没有指定需要操作的数据库表，但Mybatis-plus仍然能准确地自动操作对应表，这是因为在自定义Mapper接口继承BaseMapper时设置了BaseMapper的泛型对象为User，Mybatis-plus就会根据这个实体对象类型在数据库中找到对应的user表（此过程中默认实体对象类型的类名和表名一致，不区分大小写），由此可知，Mybatis-plus在操作表时，是由BaseMapper的泛型决定的 当我们将user表修改为t_user而User对象类型名不变时，再去对数据表进行操作就会出现找不到对应表的错误 image-20220704142801176 此时，我们有两种方法可以解决： 3.1.1 使用@TableName当我们的实体类对象类名和表名不一致时，可以使用@TableName指定，例如： @TableName(&quot;t_user&quot;)//里面的字符串就是数据库中对应表的表名 public class User &#123; private Long id; private String name; private Integer age; private String email; &#125; 3.1.2 全局配置我们还可以在application.yaml文件中对表名的前缀进行全局配置 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath*:/mapper/**/*.xml global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ 3.2 @TableId3.2.1 场景一在Mybatis-plus中默认将id作为数据表的主键，如果我们将数据表中id修改为uid，User对象的属性也修改为对应的uid，此时当我们的数据操作中涉及到对象uid，Mybatis-plus会报以下错误，说明MyBatis-plus没有将uid作为主键赋值 image-20220704143952381 解决的方法就是在实体类是对象User的属性uid上加上``@TableId`，表明将uid作为主键 @TableName(&quot;t_user&quot;) public class User &#123; @TableId private Long uid; private String name; private Integer age; private String email; &#125; 3.2.2 场景二如果在实体类对象中我们的主键属性名为id，而在数据库表中主键字段名为uid，此时当我们的数据操作中涉及到对象主键id，Mybatis-plus会报以下错误，说明我们实体类对象的主键id没有和数据库表中的主键uid对应 image-20220704144912934 解决方法是通过@TableId的value属性，为实体类对象的主键id指定其在数据库表中的映射名 @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;) //@TableId(&quot;uid&quot;) private Long id; private String name; private Integer age; private String email; &#125; 3.2.3 场景三通过前面的讲解我们可以知道，Mybatis-plus对于主键id的生成方式默认为基于雪花算法的策略生成，但是我们通常很多情况是基于数据库的自增策略生成，所以，要完成这个需求，我们需要将@TableId的type属性设置为IdType.AUTO @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;,type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; &#125; 同样，我们也可以像前面配置数据库表名前缀的方式一样，通过配置文件进行全局配置 mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath*:/mapper/**/*.xml global-config: db-config: # 配置MyBatis-Plus操作表的默认前缀 table-prefix: t_ # 设置id生成策略为自增 id-type: auto Mybatis-plus对于id的生成策略方式有： 值 描述 ASSIGN_ID（默认） 分配 ID(主键类型为 Number(Long 和 Integer)或 String)(since 3.3.0),使用接口IdentifierGenerator的方法nextId(默认实现类为DefaultIdentifierGenerator雪花算法) ASSIGN_UUID 分配 UUID,主键类型为 String(since 3.3.0),使用接口IdentifierGenerator的方法nextUUID(默认 default 方法) INPUT insert 前自行 set 主键值 NONE 无状态，该类型为未设置主键类型（注解里等于跟随全局，全局里约等于 INPUT） AUTO 数据库 ID 自增 3.2.4 雪花算法1.背景需要选择合适的方案去应对数据规模的增长，以应对逐渐增长的访问压力和数据量 数据库的扩展方式主要包括：业务分库、主从复制，数据库分表 2.数据库分表将不同业务数据分散存储到不同的数据库服务器，能够支撑百万甚至千万用户规模的业务，但如果业务继续发展，同一业务的单表数据也会达到单台数据库服务器的处理瓶颈。例如，淘宝的几亿用户数据，如果全部存放在一台数据库服务器的一张表中，肯定是无法满足性能要求的，此时就需要对单表数据进行拆分 单表数据拆分有两种方式：垂直分表和水平分表。示意图如下： image-20220704151108950 (1)垂直分表垂直分表适合将表中某些不常用且占了大量空间的列拆分出去 例如，前面示意图中的 nickname 和 description 字段，假设我们是一个婚恋网站，用户在筛选其他用户的时候，主要是用 age 和 sex 两个字段进行查询，而 nickname 和 description 两个字段主要用于展示，一般不会在业务查询中用到。description 本身又比较长，因此我们可以将这两个字段独立到另外一张表中，这样在查询 age 和 sex 时，就能带来一定的性能提升 (2)水平分表水平分表适合表行数特别大的表，有的公司要求单表行数超过 5000 万就必须进行分表，这个数字可以作为参考，但并不是绝对标准，关键还是要看表的访问性能。对于一些比较复杂的表，可能超过 1000万就要分表了；而对于一些简单的表，即使存储数据超过 1 亿行，也可以不分表 但不管怎样，当看到表的数据量达到千万级别时，作为架构师就要警觉起来，因为这很可能是架构的性能瓶颈或者隐患 水平分表相比垂直分表，会引入更多的复杂性，例如要求全局唯一的数据id该如何处理，比如： 主键自增 ①以最常见的用户 ID 为例，可以按照 1000000 的范围大小进行分段，1 ~ 999999 放到表 1中，1000000 ~ 1999999 放到表2中，以此类推②复杂点：分段大小的选取。分段太小会导致切分后子表数量过多，增加维护复杂度；分段太大可能会导致单表依然存在性能问题，一般建议分段大小在 100 万至 2000 万之间，具体需要根据业务选取合适的分段大小③优点：可以随着数据的增加平滑地扩充新的表。例如，现在的用户是 100 万，如果增加到 1000 万，只需要增加新的表就可以了，原有的数据不需要动④缺点：分布不均匀。假如按照 1000 万来进行分表，有可能某个分段实际存储的数据量只有 1 条，而另外一个分段实际存储的数据量有 1000 万条 取模 ①同样以用户 ID 为例，假如我们一开始就规划了 10 个数据库表，可以简单地用 user_id % 10 的值来表示数据所属的数据库表编号，ID 为 985 的用户放到编号为 5 的子表中，ID 为 10086 的用户放到编号为 6 的子表中②复杂点：初始表数量的确定。表数量太多维护比较麻烦，表数量太少又可能导致单表性能存在问题③优点：表分布比较均匀④缺点：扩充新的表很麻烦，所有数据都要重分布 雪花算法 雪花算法是由Twitter公布的分布式主键生成算法，它能够保证不同表的主键的不重复性，以及相同表的主键的有序性①核心思想：长度共64bit（一个long型）。首先是一个符号位，1bit标识，由于long基本类型在Java中是带符号的，最高位是符号位，正数是0，负数是1，所以id一般是正数，最高位是0。41bit时间截(毫秒级)，存储的是时间截的差值（当前时间截 - 开始时间截)，结果约等于69.73年。10bit作为机器的ID（5个bit是数据中心，5个bit的机器ID，可以部署在1024个节点）。12bit作为毫秒内的流水号（意味着每个节点在每毫秒可以产生 4096 个 ID） image-20220704151850833 ②优点：整体上按照时间自增排序，并且整个分布式系统内不会产生ID碰撞，并且效率较高 3.3 @TableField这个注解的使用和作用与@TableId相似，只不过这个是针对于普通属性和字段之间关系的注解 当我们的实体类对象的属性名与数据库表中的字段名不一致时，可以通过这个注解实现同步 比如，我们在数据库表user中的字段名为username，而在实体类对象User的属性名为name，此时使用@TableField注解的value属性： @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;,type = IdType.AUTO) private Long id; @TableField(value = &quot;username&quot;) //如果数据库表中的字段名为下划线的格式也可以使用这种方法 private String name; private Integer age; private String email; &#125; 当我们在一个实体类对象中，其属性值可能还包含了其它类型的对象，但是它又不属于当前对象的一个数据库字段，此时我们可以使用@TableField的exist属性类排除这个对象属性，比如： @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;,type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; @TableField(exist = false) private List&lt;Course&gt; courseList; &#125; 3.4 @TableLogic物理删除：真实删除，将对应数据从数据库中删除，之后查询不到此条被删除的数据逻辑删除：假删除，将对应数据中代表是否被删除字段的状态修改为“被删除状态”，之后在数据库中仍旧能看到此条数据记录使用场景：可以进行数据恢复 首先，在表中加上一个标志逻辑删除的字段，数据类型设为int，默认值为0，表示默认为未删除 然后，在对应的实体类对象中加上该属性，并在属性上方加上@TableLogic注解，作为逻辑删除的标识属性 @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;,type = IdType.AUTO) private Long id; private String name; private Integer age; private String email; @TableLogic private Integer isDelete; &#125; 此时，我们去测试删除几条数据 @Test void testDelete()&#123; //通过多个id批量删除 //DELETE FROM user WHERE id IN ( ? , ? , ? ) List&lt;Long&gt; idList = Arrays.asList(1L, 2L, 3L); int result = userMapper.deleteBatchIds(idList); System.out.println(&quot;受影响行数：&quot; + result); &#125; //==&gt; Preparing: UPDATE t_user SET is_delete=1 WHERE uid IN ( ? , ? , ? ) AND is_delete=0 //==&gt; Parameters: 1(Long), 2(Long), 3(Long) //&lt;== Updates: 3 //Closing non transactional SqlSession [org.apache.ibatis.session.defaults.DefaultSqlSession@13234ac9] //受影响行数：3 //通过控制台日志打印可以发现，删除实质上变成了修改，而此时再去数据库中查看可发现id为1、2、3的数据并没有被删除，而是id_delete字段的值被设为了1 此时，我们再查询所有数据 @Test void testSelect()&#123; //查询所有用户信息 //SELECT id,name,age,email FROM user List&lt;User&gt; list = userMapper.selectList(null); list.forEach(System.out::println); //User(id=4, name=admin, age=22, email=test4@baomidou.com, isDelete=0) //User(id=5, name=Billie, age=24, email=test5@baomidou.com, isDelete=0) //User(id=1543595258846908417, name=ybc0, age=20, email=null, isDelete=0) //User(id=1543595259274727425, name=ybc1, age=21, email=null, isDelete=0) //User(id=1543595259274727426, name=ybc2, age=22, email=null, isDelete=0) //User(id=1543595259274727427, name=ybc3, age=23, email=null, isDelete=0) //User(id=1543595259274727428, name=ybc4, age=24, email=null, isDelete=0) //User(id=1543848119749087234, name=张三, age=23, email=zhangsan@qq.com, isDelete=0) &#125; //==&gt; Preparing: SELECT uid AS id,name,age,email,is_delete FROM t_user WHERE is_delete=0 //==&gt; Parameters: //&lt;== Columns: id, name, age, email, is_delete //&lt;== Row: 4, admin, 22, test4@baomidou.com, 0 //&lt;== Row: 5, Billie, 24, test5@baomidou.com, 0 //&lt;== Row: 1543595258846908417, ybc0, 20, null, 0 //&lt;== Row: 1543595259274727425, ybc1, 21, null, 0 //&lt;== Row: 1543595259274727426, ybc2, 22, null, 0 //&lt;== Row: 1543595259274727427, ybc3, 23, null, 0 //&lt;== Row: 1543595259274727428, ybc4, 24, null, 0 //&lt;== Row: 1543848119749087234, 张三, 23, zhangsan@qq.com, 0 //&lt;== Total: 8 可以发现，查询出来的数据中字段is_delete都为0，刚刚被逻辑删除的几条数据则没有查询出来，但实际上他们并没有被删除，只是is_delete字段值为1 Mybatis-plus还提供了很多注解，这里只是常用的部分，其余详细内容需要到官方文档去查看 四、条件构造器4.1 Wrapper介绍Wrapper ： 条件构造抽象类，最顶端父类 AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件 QueryWrapper ： 查询条件封装 UpdateWrapper ： Update 条件封装 AbstractLambdaWrapper ： 使用Lambda 语法 LambdaQueryWrapper ：用于Lambda语法使用的查询Wrapper LambdaUpdateWrapper ： Lambda 更新封装Wrapper Wrapper结构图： image-20220704160530615 4.2 QueryWrapper通过QueryWrapper条件构造器我们可以对数据进行增删改查、排序、分组等操作 4.2.1 组装查询条件@Autowired private UserMapper userMapper; @Test void testQueryWrapper1()&#123; //查询用户名包含a，年龄在20到30之间，并且邮箱不为null的用户信息 //SELECT id,name,age,email,is_deleted FROM t_user WHERE is_deleted=0 AND (name LIKE ? AND age BETWEEN ? AND ? AND email IS NOT NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.like(&quot;name&quot;, &quot;a&quot;) .between(&quot;age&quot;, 20, 30) .isNotNull(&quot;email&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println); //User(id=4, name=admin, age=22, email=test4@baomidou.com, isDelete=0) &#125; 4.2.2 组装排序条件@Test void testQueryWrapper2()&#123; //按年龄降序查询用户，如果年龄相同则按id升序排列 //SELECT id,name,age,email,is_deleted FROM t_user WHERE is_deleted=0 ORDER BY age DESC,id ASC QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper .orderByDesc(&quot;age&quot;) .orderByAsc(&quot;id&quot;); List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); //User(id=5, name=Billie, age=24, email=test5@baomidou.com, isDelete=0) //User(id=1543595259274727428, name=ybc4, age=24, email=null, isDelete=0) //User(id=1543595259274727427, name=ybc3, age=23, email=null, isDelete=0) //User(id=1543848119749087234, name=张三, age=23, email=zhangsan@qq.com, isDelete=0) //User(id=4, name=admin, age=22, email=test4@baomidou.com, isDelete=0) //User(id=1543595259274727426, name=ybc2, age=22, email=null, isDelete=0) //User(id=1543595259274727425, name=ybc1, age=21, email=null, isDelete=0) //User(id=1543595258846908417, name=ybc0, age=20, email=null, isDelete=0) &#125; 4.2.3 组装删除条件@Test void testQueryWrapper3()&#123; //删除email为空的用户 //DELETE FROM t_user WHERE is_deleted=0 AND (email IS NULL) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.isNull(&quot;email&quot;); //条件构造器也可以构建删除语句的条件 int result = userMapper.delete(queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result); &#125; 4.2.4 组装修改条件@Test void testQueryWrapper4()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将（年龄大于20并且用户名中包含有a）或邮箱为null的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE is_deleted=0 AND (name LIKE ? AND age &gt; ? OR email IS NULL) queryWrapper .like(&quot;name&quot;, &quot;a&quot;) .gt(&quot;age&quot;, 20) .or() .isNull(&quot;email&quot;); User user = new User(); user.setAge(18); user.setEmail(&quot;user@qq.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result); &#125; 4.2.5 条件优先级@Test void testQueryWrapper4()&#123; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //将用户名中包含有a并且（年龄大于20或邮箱为null）的用户信息修改 //UPDATE t_user SET age=?, email=? WHERE is_deleted=0 AND (name LIKE ? AND (age &gt; ? OR email IS NULL)) //lambda表达式内的条件优先执行 queryWrapper .like(&quot;name&quot;, &quot;a&quot;) .and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;));//这儿使用lambda表达式让sql先执行(age &gt; ? OR email IS NULL)再执行name LIKE ? User user = new User(); user.setAge(18); user.setEmail(&quot;user@qq.com&quot;); int result = userMapper.update(user, queryWrapper); System.out.println(&quot;受影响的行数：&quot; + result); &#125; 4.2.6 组装select子句@Test void testQueryWrapper5()&#123; //查询用户信息的name和age字段 //SELECT name,age FROM t_user WHERE is_delete=0 QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.select(&quot;name&quot;, &quot;age&quot;); //selectMaps()返回Map集合列表，通常配合select()使用，避免User对象中没有被查询到的列值为null List&lt;Map&lt;String, Object&gt;&gt; maps = userMapper.selectMaps(queryWrapper); maps.forEach(System.out::println); //&#123;name=admin, age=18&#125; //&#123;name=Billie, age=24&#125; //&#123;name=张三, age=23&#125; &#125; 4.2.7 实现子查询@Test void testQueryWrapper6()&#123; //查询id小于等于3的用户信息 // SELECT uid,name,age,email,is_deleted FROM t_user WHERE is_delete=0 AND (uid IN (select uid from t_user where uid &lt;= 3)) QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); queryWrapper.inSql(&quot;uid&quot;, &quot;select uid from t_user where uid &lt;= 3&quot;); List&lt;User&gt; list = userMapper.selectList(queryWrapper); list.forEach(System.out::println); //User(id=1, name=Jone, age=18, email=test1@baomidou.com, isDelete=0) //User(id=2, name=Jack, age=20, email=test2@baomidou.com, isDelete=0) //User(id=3, name=Tom, age=28, email=test3@baomidou.com, isDelete=0) &#125; 4.3 UpdateWrapper@Test void testUpdateWrapper()&#123; //将（年龄大于20或邮箱为null）并且用户名中包含有a的用户信息将年龄修改为18，邮箱修改为user@qq.com UpdateWrapper&lt;User&gt; updateWrapper = new UpdateWrapper&lt;&gt;(); //lambda表达式内的条件优先执行 //UPDATE t_user SET age=?,email=? WHERE is_delete = 0 AND (username LIKE ? AND (age &gt; ? OR email IS NULL)) //组装set子句以及修改条件 updateWrapper .set(&quot;age&quot;, 18) .set(&quot;email&quot;, &quot;user@qq.com&quot;) .like(&quot;name&quot;, &quot;a&quot;) .and(i -&gt; i.gt(&quot;age&quot;, 20).or().isNull(&quot;email&quot;)); //如果不需要使用实体类对象进行填充，update方法第一个参数可以设置为null int result = userMapper.update(null, updateWrapper); System.out.println(result); &#125; 4.4 Condition在实际开发中，我们的查询条件或修改字段都需要先判断是否满足一定的条件后才会拼接到SQL中，比如判空，若不为空时才将条件添加到sql中，而这些条件应该如何处理？ 4.4.1 方法一：逐个判断@Test void testCondition()&#123; //定义查询条件，有可能为null String name = null; Integer ageBegin = 10; Integer ageEnd = 24; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成 if(StringUtils.isNotBlank(name))&#123; queryWrapper.like(&quot;name&quot;,&quot;a&quot;); &#125; if(ageBegin != null)&#123; queryWrapper.ge(&quot;age&quot;, ageBegin); &#125; if(ageEnd != null)&#123; queryWrapper.le(&quot;age&quot;, ageEnd); &#125; //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?) //因为name属性值为空，不满足条件，所以没有被拼接到sql中 List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 4.4.2 方法二：使用带condition参数的重载方法即使用条件构造器的方法时，需要满足一定条件才能拼接到sql中的查询条件或修改字段都使用方法参数中带有condition的重载方法，比如，like方法使用public Children like(boolean condition, R column, Object val) @Test void testCondition()&#123; //定义查询条件，有可能为null String name = null; Integer ageBegin = 10; Integer ageEnd = 24; QueryWrapper&lt;User&gt; queryWrapper = new QueryWrapper&lt;&gt;(); //StringUtils.isNotBlank()判断某字符串是否不为空且长度不为0且不由空白符(whitespace)构成 queryWrapper .like(StringUtils.isNotBlank(name),&quot;name&quot;,&quot;a&quot;) .ge(ageBegin != null,&quot;age&quot;,ageBegin) .le(ageEnd != null,&quot;age&quot;,ageEnd); //SELECT id,username AS name,age,email,is_deleted FROM t_user WHERE (age &gt;= ? AND age &lt;= ?) //因为name属性值为空，不满足条件，所以没有被拼接到sql中 List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 4.5 LambdaQueryWrapper@Test void testLambdaQueryWrapper()&#123; //定义查询条件，有可能为null String name = &quot;a&quot;; Integer ageBegin = 10; Integer ageEnd = 24; LambdaQueryWrapper&lt;User&gt; queryWrapper = new LambdaQueryWrapper&lt;&gt;(); //避免使用字符串表示数据库表字段，防止因写错造成运行时错误 queryWrapper .like(StringUtils.isNotBlank(name), User::getName, name) .ge(ageBegin != null, User::getAge, ageBegin) .le(ageEnd != null, User::getAge, ageEnd); //SELECT uid AS id,name,age,email,is_delete FROM t_user WHERE is_delete=0 AND (name LIKE ? AND age &gt;= ? AND age &lt;= ?) List&lt;User&gt; users = userMapper.selectList(queryWrapper); users.forEach(System.out::println); &#125; 4.6 LambdaUpdateWrapper@Test void testLambdaUpdateWrapper()&#123; //组装set子句 LambdaUpdateWrapper&lt;User&gt; updateWrapper = new LambdaUpdateWrapper&lt;&gt;(); //避免使用字符串表示数据库表字段，防止因写错造成运行时错误 updateWrapper .set(User::getAge, 18) .set(User::getEmail, &quot;user@qq.com&quot;) .like(User::getName, &quot;a&quot;) .and(i -&gt; i.lt(User::getAge, 24).or().isNull(User::getEmail)); //lambda表达式内的逻辑优先运算 //UPDATE t_user SET age=?,email=? WHERE is_delete=0 AND (name LIKE ? AND (age &lt; ? OR email IS NULL)) int update = userMapper.update(null, updateWrapper); System.out.println(update); &#125; 五、插件5.1 分页插件5.1.1 分页插件的配置和使用1.分页插件的配置首先，新建一个包为config 然后新建一个Mybatis-plus的配置类MybatisPlusConfig @Configuration @MapperScan(&quot;com.xk.mybatisplus.mapper&quot;) //将之前在SpringBoot启动类上配置的扫描配置注解移动到这个配置类 public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); return interceptor; &#125; &#125; 2.分页插件的使用@Test void testPage()&#123; //第一参数为当前页码，第二个参数为每页的数据量 Page&lt;User&gt; page = new Page&lt;&gt;(2,3); //传入page对象和一个没有条件的条件构造器 userMapper.selectPage(page, null); System.out.println(page); //User(id=4, name=admin, age=18, email=user@qq.com, isDelete=0) //User(id=5, name=Billie, age=24, email=test5@baomidou.com, isDelete=0) //User(id=1543595258846908417, name=ybc0, age=20, email=null, isDelete=0) //过程中执行的sql语句 //SELECT COUNT(*) AS total FROM t_user WHERE is_delete = 0 //SELECT uid AS id,name,age,email,is_delete FROM t_user WHERE is_delete=0 LIMIT ?,? &#125; image-20220704200539783 3.分页数据获取@Test void testPage()&#123; //第一参数为当前页码，第二个参数为每页的数据量 Page&lt;User&gt; page = new Page&lt;&gt;(2,3); //传入page对象和一个没有条件的条件构造器 userMapper.selectPage(page, null); //获取分页数据 List&lt;User&gt; list = page.getRecords(); list.forEach(System.out::println); //User(id=4, name=admin, age=18, email=user@qq.com, isDelete=0) //User(id=5, name=Billie, age=24, email=test5@baomidou.com, isDelete=0) //User(id=1543595258846908417, name=ybc0, age=20, email=null, isDelete=0) System.out.println(&quot;当前页：&quot;+page.getCurrent());//当前页：2 System.out.println(&quot;每页显示的条数：&quot;+page.getSize());//每页显示的条数：3 System.out.println(&quot;总记录数：&quot;+page.getTotal());//总记录数：11 System.out.println(&quot;总页数：&quot;+page.getPages());//总页数：4 System.out.println(&quot;是否有上一页：&quot;+page.hasPrevious());//是否有上一页：true System.out.println(&quot;是否有下一页：&quot;+page.hasNext());//是否有下一页：true &#125; 5.2 xml自定义分页通过上述例子可以知道，当我们需要对数据进行分页查询时，我们可以在selectPage方法中传入Mybatis-plus自带的分页插件对象和条件构造器，让查询条件拼接到sql语句中，然后再将符合条件的数据进行分页，但是如果我们需要查询的数据需要使用较复杂一些的sql或是多表联查，那么条件构造器将不能满足我们的使用要求，此时我们就可以自定义sql语句，然后将自定义sql语句查询出来的数据进行分页 这里举一个简单的例子，只是为了说明可以这样使用： 首先，在UserMapper中自定义一个方法 //当我们需要将自定义sql查询出来的数据进行分页时，查询的方法参数中必须将Page对象放在第一位，尽管我们在sql中并不使用它 Page&lt;User&gt; selectPaged(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;) Integer age); 然后，在UserMapper.xml文件中编写方法对应的sql语句 &lt;!--Page&lt;User&gt; selectPaged(@Param(&quot;page&quot;) Page&lt;User&gt; page, @Param(&quot;age&quot;) Integer age);--&gt; &lt;select id=&quot;selectPaged&quot; resultType=&quot;com.xk.mybatisplus.entity.User&quot;&gt; select uid,name,age,email,is_delete from t_user where is_delete = 0 and age &gt; #&#123;age&#125; &lt;/select&gt; 测试： @Test void testCustomPage()&#123; Page&lt;User&gt; page = new Page&lt;&gt;(2, 3); //将page分页对象和查询条件作为参数传入，当然，像这种简单的查询我们可以使用条件构造器代替这种自定义sql的方式 userMapper.selectPaged(page,20); List&lt;User&gt; records = page.getRecords(); records.forEach(System.out::println); //User(id=null, name=ybc2, age=22, email=null, isDelete=0) //User(id=null, name=ybc3, age=23, email=null, isDelete=0) //User(id=null, name=ybc4, age=24, email=null, isDelete=0) //==&gt; Preparing: SELECT COUNT(*) AS total FROM t_user WHERE is_delete = 0 AND age &gt; ? //==&gt; Parameters: 20(Integer) //&lt;== Columns: total //&lt;== Row: 7 //&lt;== Total: 1 //==&gt; Preparing: select uid,name,age,email,is_delete from t_user where is_delete = 0 and age &gt; ? LIMIT ?,? //==&gt; Parameters: 20(Integer), 3(Long), 3(Long) //&lt;== Columns: uid, name, age, email, is_delete //&lt;== Row: 1543595259274727426, ybc2, 22, null, 0 //&lt;== Row: 1543595259274727427, ybc3, 23, null, 0 //&lt;== Row: 1543595259274727428, ybc4, 24, null, 0 //&lt;== Total: 3 &#125; 5.3 乐观锁和悲观锁5.3.1 介绍场景：一件商品，成本价是80元，售价是100元。老板先是通知小李，说你去把商品价格增加50元。小李正在玩游戏，耽搁了一个小时。正好一个小时后，老板觉得商品价格增加到150元，价格太高，可能会影响销量。又通知小王，你把商品价格降低30元。此时，小李和小王同时操作商品后台系统。小李操作的时候，系统先取出商品价格100元；小王也在操作，取出的商品价格也是100元。小李将价格加了50元，并将100+50=150元存入了数据库；小王将商品减了30元，并将100-30=70元存入了数据库。是的，如果没有锁，小李的操作就完全被小王的覆盖了。现在商品价格是70元，比成本价低10元。几分钟后，这个商品很快出售了1千多件商品，老板亏1万多 上面的故事，如果是乐观锁，小王保存价格前，会检查下价格是否被人修改过了。如果被修改过了，则重新取出的被修改后的价格，150元，这样他会将120元存入数据库 如果是悲观锁，小李取出数据后，小王只能等小李操作完之后，才能对价格进行操作，也会保证最终的价格是120元 5.3.2 模拟冲突首先，新建一个数据表，并插入一条数据 CREATE TABLE t_product ( id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;, NAME VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;商品名称&#39;, price INT(11) DEFAULT 0 COMMENT &#39;价格&#39;, VERSION INT(11) DEFAULT 0 COMMENT &#39;乐观锁版本号&#39;, PRIMARY KEY (id) ); INSERT INTO t_product (id, NAME, price) VALUES (1, &#39;外星人笔记本&#39;, 100); 然后，创建对应实体类 @Data @AllArgsConstructor @NoArgsConstructor @TableName(&quot;t_product&quot;) public class Product &#123; @TableId(value = &quot;id&quot;) private Long id; @TableField(value = &quot;NAME&quot;) private String name; @TableField(value = &quot;price&quot;) private Integer price; @TableField(value = &quot;VERSION&quot;) private Integer version; &#125; 然后，新建mapper @Repository public interface ProductMapper extends BaseMapper&lt;Product&gt; &#123; &#125; 测试： @Autowired private ProductMapper productMapper; @Test void tesOptimisticLock()&#123; //1、小李 Product p1 = productMapper.selectById(1L); System.out.println(&quot;小李取出的价格：&quot; + p1.getPrice());//小李取出的价格：100 //2、小王 Product p2 = productMapper.selectById(1L); System.out.println(&quot;小王取出的价格：&quot; + p2.getPrice());//小王取出的价格：100 //3、小李将价格加了50元，存入了数据库 p1.setPrice(p1.getPrice() + 50); productMapper.updateById(p1); System.out.println(&quot;小李修改后结果：&quot; + productMapper.selectById(1L).getPrice());//小李修改后结果：150 //4、小王将商品减了30元，存入了数据库 p2.setPrice(p2.getPrice() - 30); productMapper.updateById(p2); System.out.println(&quot;小王修改后结果：&quot; + productMapper.selectById(1L).getPrice());//小王修改后结果：70 //最后的结果 Product p3 = productMapper.selectById(1L); //价格覆盖，最后的结果：70 System.out.println(&quot;最后的结果：&quot; + p3.getPrice());//最后的结果：70 &#125; //从以上测试可以发现，由于修改之前，小李和小王都获取最初的价格，而小王修改后将小李修改的价格覆盖了，导致最终的价格是小王在最初价格的基础上修改的，这就造成了冲突 5.3.3 乐观锁实现逻辑在数据库表中添加version字段，作为数据的版本 取出记录时，连同version一起获取 SELECT id,`name`,price,`version` FROM product WHERE id=1 更新时将已修改的数据中version字段加1，并且在where条件中加上version=之前获取时的版本号 UPDATE product SET price=price+50, `version`=`version` + 1 WHERE id=1 AND `version`=1 # 小李的sql UPDATE product SET price=price-30, `version`=`version` + 1 WHERE id=1 AND `version`=1 # 小王的sql # 当小王的sql执行时会发现已经找不到id=1且version=1的数据了，因为已经被小李修改为了version=2，这时小王的修改就不会成功，他必须重新获取一次数据再进行修改 5.3.4 Mybatis-plus实现乐观锁1.@Version给实体类中作为数据版本号的属性添加上@Version注解 @Data @AllArgsConstructor @NoArgsConstructor @TableName(&quot;t_product&quot;) public class Product &#123; @TableId(value = &quot;id&quot;) private Long id; @TableField(value = &quot;NAME&quot;) private String name; @TableField(value = &quot;price&quot;) private Integer price; @TableField(value = &quot;VERSION&quot;) @Version private Integer version; &#125; 2.配置乐观锁@Configuration @MapperScan(&quot;com.xk.mybatisplus.mapper&quot;) public class MybatisPlusConfig &#123; @Bean public MybatisPlusInterceptor mybatisPlusInterceptor()&#123; MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); //添加分页插件 interceptor.addInnerInterceptor(new PaginationInnerInterceptor(DbType.MYSQL)); //添加乐观锁插件 interceptor.addInnerInterceptor(new OptimisticLockerInnerInterceptor()); return interceptor; &#125; &#125; 3.测试此时再将上方的测试方法运行一次 @Autowired private ProductMapper productMapper; @Test void tesOptimisticLock()&#123; //1、小李 Product p1 = productMapper.selectById(1L); System.out.println(&quot;小李取出的价格：&quot; + p1.getPrice());//小李取出的价格：100 //2、小王 Product p2 = productMapper.selectById(1L); System.out.println(&quot;小王取出的价格：&quot; + p2.getPrice());//小王取出的价格：100 //3、小李将价格加了50元，存入了数据库 p1.setPrice(p1.getPrice() + 50); productMapper.updateById(p1); System.out.println(&quot;小李修改后结果：&quot; + productMapper.selectById(1L).getPrice());//小李修改后结果：150 //4、小王将商品减了30元，存入了数据库 p2.setPrice(p2.getPrice() - 30); productMapper.updateById(p2); System.out.println(&quot;小王修改后结果：&quot; + productMapper.selectById(1L).getPrice());//小王修改后结果：150 //最后的结果 Product p3 = productMapper.selectById(1L); //小王修改失败，最后的结果：150 System.out.println(&quot;最后的结果：&quot; + p3.getPrice());//最后的结果：150 //若小王还想修改，需要重新获取一次这条数据 Product p4 = productMapper.selectById(1L); System.out.println(&quot;小王重新获取数据后的价格：&quot; + p4.getPrice());//150 p4.setPrice(p4.getPrice() - 30); productMapper.updateById(p4); System.out.println(&quot;小王重新修改后结果：&quot; + productMapper.selectById(1L).getPrice());//120 &#125; 5.4 MybatisX插件MyBatis-Plus为我们提供了强大的mapper和service模板，能够大大的提高开发效率。但是在真正开发过程中，MyBatis-Plus并不能为我们解决所有问题，例如一些复杂的SQL，多表联查，我们就需要自己去编写代码和SQL语句，我们该如何快速的解决这个问题呢，这个时候可以使用MyBatisX插件。MyBatisX一款基于 IDEA 的快速开发插件，为效率而生。 5.4.1 安装MybatisX在IDEA中，点击File-&gt;settings 然后： image-20220705133049646 安装完成后，若没有勾选则需要勾选表示启用，然后点击apply和ok 5.4.2 XML跳转当我们在项目的java包下有实体类的mapper接口，resources包下有实体类的对应mapper接口的映射文件时，我们可以通过点击旁边的图标进行来回跳转 image-20220705135845344 5.4.3 代码生成为了方便测试，可以新建一个项目进行 然后把之前项目中的部分依赖复制到新项目中 &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.29&lt;/version&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; 然后，将application.yaml配置文件中的内容复制一份到新项目 spring: datasource: type: com.alibaba.druid.pool.DruidDataSource driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: root mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath*:/mapper/**/*.xml 然后，在idea中配置数据源（必须） image-20220705141308172 image-20220705141506313 配置成功后，就可以看到数据库和数据库中的表了 image-20220705141549137 然后，右键选择我们要生成代码的数据表，点击MybatisX-Generator image-20220705141644268 在弹出的窗口中进行配置，可以根据自己需要进行配置，然后点击next image-20220705142706912 在下一个页面进行详细配置，然后点finish image-20220705143227503 然后即可看见MybatisX自动生成的对应controller、service、mapper及实体类 5.4.4 快速生成CRUD当我们在mapper接口中对一个增删改查的方法进行编写时，只需要将方法名命名成见名知意的效果（在这个过程中MybatisX还会提示我们），然后按快捷键Alt + Enter，点击[MybatisX] Generate Mybatis Sql选项，MybatisX将会为我们自动生成方法以及对应的映射sql语句 image-20220705144826767 当方法旁边出现mybatis的图标时，就说明它已经为我们生成好了sql语句 image-20220705145144512 我们点击图标即可跳转到对应映射方法处 image-20220705145235897 例子： public interface UserMapper extends BaseMapper&lt;User&gt; &#123; List&lt;User&gt; selectAgeAndNameByAgeBetween(@Param(&quot;beginAge&quot;) Integer beginAge, @Param(&quot;endAge&quot;) Integer endAge); List&lt;User&gt; selectAllOrderByAgeDesc(); int insertSelective(User user); int updateAgeAndNameByUid(@Param(&quot;age&quot;) Integer age, @Param(&quot;name&quot;) String name, @Param(&quot;uid&quot;) Long uid); int deleteByUidAndName(@Param(&quot;uid&quot;) Long uid, @Param(&quot;name&quot;) String name); &#125; &lt;select id=&quot;selectAgeAndNameByAgeBetween&quot; resultMap=&quot;BaseResultMap&quot;&gt; select age, name from t_user where age between #&#123;beginAge,jdbcType=INTEGER&#125; and #&#123;endAge,jdbcType=INTEGER&#125; &lt;/select&gt; &lt;select id=&quot;selectAllOrderByAgeDesc&quot; resultMap=&quot;BaseResultMap&quot;&gt; select &lt;include refid=&quot;Base_Column_List&quot;/&gt; from t_user order by age desc &lt;/select&gt; &lt;insert id=&quot;insertSelective&quot;&gt; insert into t_user &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;uid != null&quot;&gt;uid,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;name,&lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt;age,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;email,&lt;/if&gt; &lt;if test=&quot;isDelete != null&quot;&gt;is_delete,&lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt;gender,&lt;/if&gt; &lt;/trim&gt; values &lt;trim prefix=&quot;(&quot; suffix=&quot;)&quot; suffixOverrides=&quot;,&quot;&gt; &lt;if test=&quot;uid != null&quot;&gt;#&#123;uid,jdbcType=BIGINT&#125;,&lt;/if&gt; &lt;if test=&quot;name != null&quot;&gt;#&#123;name,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;age != null&quot;&gt;#&#123;age,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;if test=&quot;email != null&quot;&gt;#&#123;email,jdbcType=VARCHAR&#125;,&lt;/if&gt; &lt;if test=&quot;isDelete != null&quot;&gt;#&#123;isDelete,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;if test=&quot;gender != null&quot;&gt;#&#123;gender,jdbcType=INTEGER&#125;,&lt;/if&gt; &lt;/trim&gt; &lt;/insert&gt; &lt;update id=&quot;updateAgeAndNameByUid&quot;&gt; update t_user set age = #&#123;age,jdbcType=NUMERIC&#125;, name = #&#123;name,jdbcType=VARCHAR&#125; where uid = #&#123;uid,jdbcType=NUMERIC&#125; &lt;/update&gt; &lt;delete id=&quot;deleteByUidAndName&quot;&gt; delete from t_user where uid = #&#123;uid,jdbcType=NUMERIC&#125; AND name = #&#123;name,jdbcType=VARCHAR&#125; &lt;/delete&gt; 六、通用枚举在实际开发中，数据的有些字段值是固定的，例如性别（男或女），此时我们可以使用MyBatis-Plus的通用枚举来实现 首先，在t_user表中加上gender字段，代表性别 alter table t_user add gender int null; 然后，在实体类中添加对应属性 @Data @AllArgsConstructor @NoArgsConstructor @TableName(&quot;t_user&quot;) public class User &#123; @TableId(value = &quot;uid&quot;) private Long id; private String name; private Integer age; private String email; //添加对应属性，类型为一会我们需要自定义的枚举类型 private GenderEnum gender; @TableLogic private Integer isDelete; &#125; 然后，新建一个自定义枚举，并在我们需要插入到数据库中的属性上添加@EnumValue //这是一种通用枚举使用的第一种方法：使用@EnumValue注解 @Getter public enum GenderEnum &#123; MALE(1,&quot;男&quot;), FEMALE(2,&quot;女&quot;); //这儿我们在gender属性上方添加@EnumValue注解，代表插入数据库时是将该枚举类型的gender属性值插入到数据库中 //如果我们要将genderName插入的话，就在genderName上方添加该注解 @EnumValue private Integer gender; private String genderName; GenderEnum(Integer gender,String genderName)&#123; this.gender = gender; this.genderName = genderName; &#125; &#125; //第二种方法：将自定义枚举实现IEnun接口 @Getter public enum GenderEnum implements IEnum&lt;Integer&gt; &#123;//IEnum接口的泛型填写该枚举中我们需要存入数据库中的属性的类型，然后实现getValue方法，在getValue方法中返回我们需要存入数据库中的属性值 MALE(1,&quot;男&quot;), FEMALE(2,&quot;女&quot;); private Integer gender; private String genderName; GenderEnum(Integer gender,String genderName)&#123; this.gender = gender; this.genderName = genderName; &#125; @Override public Integer getValue() &#123; return this.gender; &#125; &#125; 然后，在application.yaml配置文件中配置扫描通用枚举（ 注意：从Mybatis-plus3.5.2开始，无需进行配置） mybatis-plus: configuration: log-impl: org.apache.ibatis.logging.stdout.StdOutImpl mapper-locations: classpath:mapper/*.xml # 配置扫描通用枚举的包 type-enums-package: com.xk.mybatisplus.entity 测试： @Test void testEnum()&#123; User user = new User(); user.setName(&quot;Enum&quot;); user.setAge(20); user.setGender(GenderEnum.MALE); //INSERT INTO t_user ( uid, name, age, gender ) VALUES ( ?, ?, ?, ? ) //Parameters: 1543959249498730498(Long), Enum(String), 20(Integer), 1(Integer) userMapper.insert(user);//1 &#125; 七、代码生成器7.1 引入依赖&lt;!--代码生成器依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;mybatis-plus-generator&lt;/artifactId&gt; &lt;version&gt;3.5.2&lt;/version&gt; &lt;/dependency&gt; &lt;!--模板引擎依赖，这个需要看自己使用什么模板，再决定导入什么依赖，默认 Velocity 可选模板引擎 Beetl 或 Freemarker--&gt; &lt;dependency&gt; &lt;groupId&gt;org.freemarker&lt;/groupId&gt; &lt;artifactId&gt;freemarker&lt;/artifactId&gt; &lt;version&gt;2.3.31&lt;/version&gt; &lt;/dependency&gt; 7.2 复制代码新建一个类，去到官网的代码生成器部分将代码复制粘贴到类中 public class CodeGenerator &#123; public static void main(String[] args) &#123; //将自己的数据库url、用户名、密码填写到这儿 FastAutoGenerator.create(&quot;jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC&quot;, &quot;root&quot;, &quot;root&quot;) .globalConfig(builder -&gt; &#123; builder.author(&quot;rainvex&quot;) // 设置作者 //.enableSwagger() // 开启 swagger 模式 .fileOverride() // 是否覆盖已生成文件 .outputDir(&quot;E:\\\\JavaProject\\\\Study\\\\MybatisPlus\\\\src\\\\main\\\\java&quot;); // 指定输出目录 &#125;) .packageConfig(builder -&gt; &#123; builder.parent(&quot;com.xk.mybatisplus&quot;) // 设置父包名 .moduleName(&quot;generators&quot;) // 设置父包模块名，即我们要将生成的代码放到com.xk.mybatisplus下的哪个包下，这儿就说明我的是生成到com.xk.mybatisplus.generators包下 .pathInfo(Collections.singletonMap(OutputFile.xml, &quot;E:\\\\JavaProject\\\\Study\\\\MybatisPlus\\\\src\\\\main\\\\resources\\\\mapper&quot;)); // 设置mapper.xml文件生成路径 &#125;) .strategyConfig(builder -&gt; &#123; builder.addInclude(&quot;t_user&quot;,&quot;t_product&quot;) // 设置需要生成的表名 .addTablePrefix(&quot;t_&quot;, &quot;c_&quot;); // 设置过滤表前缀 &#125;) .templateEngine(new FreemarkerTemplateEngine()) // 使用Freemarker引擎模板，默认的是Velocity引擎模板 .execute(); &#125; &#125; 从代码生成器的配置可以看出，我们将数据表t_user、t_product对应的controller、service、mapper、实体类都生成到了E:\\JavaProject\\Study\\MybatisPlus\\src\\main\\java\\com.xk.mybatisplus\\generators包下，如果不想将生成的代码放到新的一个包下，而是直接覆盖之前的代码，那么则不设置moduleName即可，而对应的mapper.xml文件生成到了E:\\JavaProject\\Study\\MybatisPlus\\src\\main\\resources\\mapper下 生成后的结果如图： image-20220705114655460 八、多数据源适用于多种场景：纯粹多库、 读写分离、 一主多从、 混合模式等 场景说明：创建两个库，分别为：mybatis_plus（以前的库不动）与mybatis_plus_1（新建），将mybatis_plus库的product表移动到mybatis_plus_1库，这样每个库一张表，通过一个测试用例分别获取用户数据与商品数据，如果获取到说明多库模拟成功 8.1 新建数据库和表新建一个数据库mybatisplus1，并新建一个表t_product，和之前的mybatisplus数据库中的一样 # 创建数据库 CREATE DATABASE `mybatisplus1` use `mybatisplus1`; # 创建数据表 CREATE TABLE t_product ( id BIGINT(20) NOT NULL COMMENT &#39;主键ID&#39;, name VARCHAR(30) NULL DEFAULT NULL COMMENT &#39;商品名称&#39;, price INT(11) DEFAULT 0 COMMENT &#39;价格&#39;, version INT(11) DEFAULT 0 COMMENT &#39;乐观锁版本号&#39;, PRIMARY KEY (id) ); # 插入数据 INSERT INTO t_product (id, NAME, price) VALUES (1, &#39;外星人笔记本&#39;, 100); 8.2 删除原有表删除数据库mybatisplus中原有的t_product表 use mybatisplus; DROP TABLE IF EXISTS t_product; 新建和删除表后，确保实体类的对应的表名和属性名正确 8.3 导入依赖&lt;dependency&gt; &lt;groupId&gt;com.baomidou&lt;/groupId&gt; &lt;artifactId&gt;dynamic-datasource-spring-boot-starter&lt;/artifactId&gt; &lt;version&gt;3.5.1&lt;/version&gt; &lt;/dependency&gt; 8.4 配置数据源将之前的数据源配置删除，添加多数据源配置 spring: datasource: dynamic: # 设置默认的数据源或者数据源组,默认值即为master primary: master # 严格匹配数据源,默认false.当设置为true时若未匹配到指定数据源则抛异常,而false则会使用默认数据源 strict: false datasource: master: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: root slave1: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/mybatisplus1?characterEncoding=utf-8&amp;useSSL=false&amp;serverTimezone=UTC username: root password: root 8.5 添加@DS注解在UserServiceImpl和ProductServiceImpl类上方添加@DS注解，指明该service要使用的数据源 @DS(&quot;master&quot;) @Service public class UserServiceImpl extends ServiceImpl&lt;UserMapper, User&gt; implements UserService &#123; &#125; @DS(&quot;slave1&quot;) @Service public class ProductServiceImpl extends ServiceImpl&lt;ProductMapper, Product&gt; implements ProductService &#123; &#125; 8.6 测试@Autowired private UserService userService; @Autowired private ProductService productService; @Test void testDatasource()&#123; System.out.println(userService.getById(1L)); //User(id=1, name=Jone, age=18, email=test1@baomidou.com, gender=null, isDelete=0) System.out.println(productService.getById(1L)); //Product(id=1, name=外星人笔记本, price=100, version=0) &#125; //当能分别查询出数据，说明多数据源配置成功 如果我们实现读写分离，将写操作方法加上主库数据源，读操作方法加上从库数据源，自动切换，就能实现读写分离","categories":[{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://rainvex.com/tags/Mybatis/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"}]},{"title":"云计算与大数据实验","slug":"云计算与大数据实验","date":"2022-05-28T09:27:34.000Z","updated":"2022-05-28T09:27:34.000Z","comments":true,"path":"categories/教程/云计算与大数据实验.html","link":"","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/%E4%BA%91%E8%AE%A1%E7%AE%97%E4%B8%8E%E5%A4%A7%E6%95%B0%E6%8D%AE%E5%AE%9E%E9%AA%8C.html","excerpt":"","text":"云计算与大数据实验该教程是本学期大数据与云计算课程的课程实验，希望能帮助到不知道如何下手的同学，同样也是对自己学习过程的记录，方便以后的学习 声明：该教程只是为了帮助大家完成本学期的实验，请不要直接将教程中的内容直接复制作为实验报告，务必按照自己的实际情况进行操作和编写，如若出现因复制教程内容导致实验报告雷同被查的情况，一概不负责 一、准备工作开始之前，需要先完成Ubuntu系统下的Hadoop分布式集群安装，如果还未完成，可以先参考之前的这篇文章；如果一开始就使用的是单机版Hadoop，可以直接做实验，不用管前面这些配置，也不用跑去虚拟机上搭建一个分布式Hadoop集群 如果一开始就自己搭建了分布式Hadoop集群，那么在Windows上也要完成Hadoop环境的配置，因为在后续实验中我们需要在Windows上使用IDEA编写测试类来对Ubuntu中Hadoop的HDFS文件系统进行操作，所以Windows也要配置好Hadoop环境，不然会报HADOOP_HOME找不到之类的错误（Hadoop需要依赖JDK，就默认大家都已经安装了JDK） 1.1 Windows中安装Hadoop如果是直接使用老师发的配置好的hadoop压缩包则只需要查看如何配置好环境变量即可，另外，建议Windows中安装的Hadoop和Ubuntu中安装的Hadoop版本一样，以免引起不必要的麻烦或是可能因版本不同引起造成的冲突问题 1.1.1 下载Hadoop这个在之前的Ubuntu下搭建Hadoop分布式集群教程中已经提到过，就不再赘述了 注：我使用的是Hadoop3.2.3 1.1.2 解压Hadoop新建一个文件夹，用来存放Hadoop 然后将下载好的压缩包（后缀名就是tar.gz，不用怀疑）移动到这个文件夹下，**以管理员身份解压**到当前文件夹 1.1.3 设置环境变量依次点击计算机-&gt;属性-&gt;高级系统设置-&gt;环境变量 然后进行以下环境变量配置 添加HADOOP_HOME image-202205271849078 添加到Path变量 image-20220527185048944 image-20220527190838965 然后一路确定即可 此时，我们打开Windows的命令行窗口，输入hadoop测试一下，发现报错 image-20220527185557657 根据提示找到这个hadoop-env.cmd文件，使用本文编辑器打开进行如下修改 image-20220527191541240 然后，再次使用hadoop和hadoop -version命令测试，发现未报错 image-20220527191847744 输入hadoop -version打印的是jdk的版本，输入hadoop version打印的是hadoop的版本 1.1.4 下载winutils这是Hadoop在Windows上运行必须要使用的东西 github下载地址和网盘分享地址（提取码: keg8，网盘只提供了3.2.0版本，其他版本请从github上下载） 找到自己hadoop对应的版本，将整个hadoop-xxx\\bin文件夹下载下来，然后将这几个文件全部复制到hadoop\\bin、hadoop\\sbin、C:\\Windows\\System32这三个文件夹下 image-20220527193216469 1.1.5 修改Hadoop配置文件这一部分跟之前在Ubuntu中搭建Hadoop集群几乎一样，只需要修改一部分地方 由于我们并不是在Windows上使用Hadoop，所以其实在Windows上配置Hadoop环境只需修改需要的即可，比如我们的实验是操作HDFS，那么配置core-site.xml、hdfs-site.xml、mapred-site.xml即可，好像还是几乎都要配置😂（算了，都配置吧🙄），但是有些配置项确实可以不需要 ① 配置核心组件core-site.xml使用文本编辑器打开并编辑core-site.xml文件，在&lt;configuration&gt;标签中添加： &lt;configuration&gt; &lt;!--指定HDFS的（NameNode）的缺省路径地址,localhost：是计算机名，也可以是ip地址--&gt; &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://localhost:9000&lt;/value&gt; &lt;/property&gt; &lt;!-- 指定hadoop运行时产生文件的存储目录(以个人为准) --&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/D:/CodeEnvironment/Hadoop/tmp&lt;/value&gt; &lt;!--可以自己新建好，也可以等会儿格式化时让其自己创建--&gt; &lt;/property&gt; &lt;/configuration&gt; ② 配置文件系统hdfs-site.xml使用文本编辑器打开并编辑hdfs-site.xml文件，在&lt;configuration&gt;标签中添加： &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/D:/CodeEnvironment/Hadoop/tmp/dfs/name&lt;/value&gt; &lt;!--可以自己新建好，也可以等会儿格式化时让其自己创建--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/D:/CodeEnvironment/Hadoop/tmp/dfs/data&lt;/value&gt; &lt;!--可以自己新建好，也可以等会儿格式化时让其自己创建--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;localhost:50070&lt;/value&gt; &lt;/property&gt; ③ 配置文件系统yarn-site.xml使用文本编辑器打开并编辑yarn-site.xml文件，在&lt;configuration&gt;标签中添加： &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;localhost&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;localhost:18040&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;localhost:18030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;localhost:18025&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;localhost:18141&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;localhost:18088&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!--这个是之前在Ubuntu中配置Hadoop集群测试的时候出错添加的，如果不加测试会出现找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster的错误，但是在Windows下还需不需要配置我也不清楚，以防万一我就配置上了，value标签的内容还是一样的获取方法，通过hadoop classpath命令获取，然后将其复制到此处，后面的mapred-site.xml文件中也添加了这个配置，但是name不一样，如果嫌修改路径符号麻烦也可以不添加--&gt; &lt;name&gt;yarn.application.classpath&lt;/name&gt; &lt;value&gt;/D:/CodeEnvironment/Hadoop/etc/hadoop;D:/CodeEnvironment/Hadoop/share/hadoop/common;D:/CodeEnvironment/Hadoop/share/hadoop/common/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/common/*;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs/*;D:/CodeEnvironment/Hadoop/share/hadoop/yarn;D:/CodeEnvironment/Hadoop/share/hadoop/yarn/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/yarn/*;D:/CodeEnvironment/Hadoop/share/hadoop/mapreduce/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/mapreduce/* &lt;/value&gt; &lt;/property&gt; ④ 配置计算框架mapred-site.xml使用文本编辑器打开并编辑mapred-site.xml文件，在&lt;configuration&gt;标签中添加： &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapred.job.tracker&lt;/name&gt; &lt;value&gt;hdfs://localhost:9001&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;localhost:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;localhost:19888&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/D:/CodeEnvironment/Hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/D:/CodeEnvironment/Hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/D:/CodeEnvironment/Hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;/D:/CodeEnvironment/Hadoop/etc/hadoop;D:/CodeEnvironment/Hadoop/share/hadoop/common;D:/CodeEnvironment/Hadoop/share/hadoop/common/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/common/*;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/hdfs/*;D:/CodeEnvironment/Hadoop/share/hadoop/yarn;D:/CodeEnvironment/Hadoop/share/hadoop/yarn/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/yarn/*;D:/CodeEnvironment/Hadoop/share/hadoop/mapreduce/lib/*;D:/CodeEnvironment/Hadoop/share/hadoop/mapreduce/* &lt;/value&gt; &lt;/property&gt; 1.1.6 格式化HDFS在命令行窗口输入hdfs namenode -format，如果中间出现提示，输入Y即可 格式化完成后，可以在hadoop的文件夹中看到它已经自动帮我们新建好了之前配置的文件夹（这儿只有name文件夹，没有data文件夹，等会儿启动hadoop后就会出现data） image-20220527203001012 1.1.7 启动Hadoop在命令行窗口输入start-all.cmd 此时会弹出四个窗口，但是其中有两个窗口报错（如果没有报错就不用管） image-20220527204332749 出现这个原因是由于我之前安装过node.js，系统里有重名命令yarn，所以在运行hadoop的yarn的时候需要指定其yarn路径，解决办法是打开sbin目录下的start-yarn.cmd文件，修改方式如下： image-20220527205006313 此时使用stop-all.cmd停止所有服务后，再start-all.cmd开启所有服务，成功开启 image-20220527205205838 使用jps命令查看启动进程 image-20220527205326955 在Windows上的浏览器中访问localhost:50070和localhost:18088 image-20220527205452620 image-20220527205515592 到此，Windows上配置Hadoop环境就完成了，这其实也算是一个hadoop单机版的安装步骤了 1.2 Ping请确保Windows和Ubuntu能够互相ping通 然后，正式开始实验内容 二、实验一：HDFS的文件操作命令及API编程2.1 HDFS的基本文件操作命令该小节在Ubuntu中进行操作，如果只安装了单机版当我没说🙄，直接在Windows上操作，把操作的目录名和路径改为windows上的习惯即可 这一小节是书上实验要求的 ① 使用start-all.sh启动 hadoop，通过jps命令查看启动进程，下面所有操作都建立在Ubuntu中的Hadoop启动成功的条件下；通过web方式查看namenode和jobtracker，在浏览器输入master:50070和master:18088即可访问，这儿不再赘述 image-20220527211236064 ② 进入自己Ubuntu中安装hadoop的目录下，进入tmp目录，右键单击选择在终端打开，或者在任意位置的终端中使用cd 要进入的目录命令进入到tmp目录，再使用ls命令查看 hadoop下tmp目录中的文件，包括dfs目录和 mapped目录（不知道为什么没有mapped目录，可能配置文件没配置的原因） image-20220527211631172 ③ 在终端使用hadoop fs -ls /列出HDFS上根目录下的文件和目录，如果从未使用过，那么HDFS中暂无任何目录和文件，就不会输出任何东西 image-20220528133324311 ④ 使用命令hadoop fs -mkdir -p /user/xk在HDFS的user目录下创建一个名字盘拼音的目录，并使用hadoop fs -ls -R /查看，加上-R指令就是表示递归查看，会把每一层的每一个文件都显示出来，前面创建目录的-p也基本是同一个意思，表示递归创建 image-20220528133456084 image-20220528133550169 ⑤ 在Ubuntu的/usr目录下创建一个test目录，进入test目录，执行echo &quot;hello world&quot; ＞ testl．txt命令创建 test1.txt文件，并输入hello world内容，然后使用cat命令查看内容（创建位置和目录名字随自己而定） image-20220528134008138 ⑥ 将刚才在本地创建的 test1.txt文件上传（put）到HDFS下名字的目录下，并查看HDFS的/user/xk目录下是否有test1.txt文件。命令为hadoop fs -put 要上传的文件 要上传到的位置 image-20220528134253086 也可以通过以下方式查看hdfs上的目录和文件 打开浏览器，访问master:50070 image-20220528134526022 点击进入要查看的目录 image-20220528134600321 ⑦ 查看HDFS下刚才上传的文件的内容。命令hadoop fs -cat 要查看的文件 image-20220528134334624 ⑧ 彻底删除Ubuntu上刚刚创建的/usr/test目录中的test1.txt文件，删除后可以使用ls确认是否是否成功删除 image-20220528134830955 ⑨ 将HDFS上的 test1.txt文件下载到Ubuntu中并查看。下载的命令是hadoop fs -get 要下载的文件 要下载的目录位置，下载到Ubuntu中后使用ls再查看该目录，发现又有了一个test1.txt文件，使用cat查看文件内容 image-20220528135002426 ⑩ 在HDFS上删除test1.txt文件，命令是hadoop fs -rm -r 要删除的文件，-r或-R表示递归处理，将指定目录下的所有文件与子目录一并处理。删除后再通过ls查看是否还存在 image-20220528135131667 2.2 HDFS API编程实验2.2.1 ResultFilter编写程序实现如下功能：在输入文件目录下的所有文件中，检索某一特定字符串所出现的行，将这些行的内容输出到本地文件系统的输出文件夹中，也是书上的那个实验 ① 首先使用idea新建一个maven项目，这个就不用赘述了 ② 在pom.xml文件导入所需要的依赖，为了后面不再重复此操作，这里就把所有要用到的jar包依赖全部导入了（注意：依赖的版本尽量和自己的hadoop版本一致，以免造成版本冲突问题，我用的都是3.2.3，所以我这里就全部使用的3.2.3的版本） &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-hdfs&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-common&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-client&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;io.netty&lt;/groupId&gt; &lt;artifactId&gt;netty&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-common&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hadoop&lt;/groupId&gt; &lt;artifactId&gt;hadoop-mapreduce-client-core&lt;/artifactId&gt; &lt;version&gt;3.2.3&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;compile&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase&lt;/artifactId&gt; &lt;version&gt;2.4.11&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-client&lt;/artifactId&gt; &lt;version&gt;2.4.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.hbase&lt;/groupId&gt; &lt;artifactId&gt;hbase-common&lt;/artifactId&gt; &lt;version&gt;2.4.11&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; ③ 导入依赖后，新建一个包，再在包下新建一个类ResultFilter（需不需要建包自己随意，只是方便管理），然后复制代码…（真就为了效率直接复制，这也是我自己辛辛苦苦自己打的😭） 同志们，下面的每个程序导包都仔细点，基本都是org.apache.hadoop下的，但还是需要仔细点，可能在不同包下还有相同的类名 public class ResultFilter &#123; public static void main(String[] args) throws IOException &#123; Configuration configuration = new Configuration(); //hdfs和local分别对应HDFS实例和本地文件系统实例 FileSystem hdfs = FileSystem.get(configuration); LocalFileSystem local = FileSystem.getLocal(configuration); Path inputDir,localFile; FileStatus[] inputFiles; FSDataInputStream in; FSDataOutputStream out = null; Scanner scan; String str; byte[] buf; int singleFileLines; int numLines,numFiles,i; if (args.length!= 4)&#123; //输入参数数量不足，提示参数格式后终止程序执行 System.err.println(&quot;usage resultFilter &lt;dfs path&gt; &lt;local path&gt; &lt;match str&gt; &lt;single file lines&gt;&quot;); return; &#125; inputDir = new Path(args[0]); singleFileLines = Integer.parseInt(args[3]); try &#123; inputFiles = hdfs.listStatus(inputDir); //获取目录信息 numLines = 0; numFiles = 1; //输出文件从1开始编号 localFile = new Path(args[1]); if (local.exists(localFile)) &#123; //若目标路径存在，则删除之 local.delete(localFile,true); &#125; for (i = 0;i &lt; inputFiles.length;i++)&#123; if (inputFiles[i].isDir())&#123;//忽略子目录 continue; &#125; System.out.println(inputFiles[i].getPath().getName()); in = hdfs.open(inputFiles[i].getPath()); scan = new Scanner(in); while (scan.hasNext())&#123; str = scan.nextLine(); if (!str.contains(args[2]))&#123; continue; //如果该行没有match字符串，则忽略之 &#125; numLines++; if (numLines == 1)&#123; //如果是1，说明需要新建文件了 localFile = new Path(args[1] + File.separator + numFiles); out = local.create(localFile); //创建文件 numFiles++; &#125; buf = (str + &quot;\\n&quot;).getBytes(); out.write(buf,0,buf.length);//将字符串写入输出流 if (numLines == singleFileLines)&#123; //如果已满足相应行数，关闭文件 out.close(); numLines = 0; //行数变为0，重新统计 &#125; &#125; scan.close(); in.close(); &#125; if (out != null)&#123; out.close(); &#125; &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; &#125; &#125; ④ 将项目打成jar包 image-20220528141838720 ⑤ 在target文件夹下把jar包复制到Ubuntu中，复制过去后可以重命名一下，等会输命令就不用输那么长了，我重命令为BigData.jar image-20220528142012378 ⑥ 在任意位置新建两个文件，并在里面随便输入一些内容，创建文件的命令：touch 文件名 image-20220528142227183 ⑦ 将创建好的文件上传到HDFS上，上传后可以通过上面2.1节提到的方法查看是否上传成功 image-20220528142331644 ⑧ 在终端中运行命令hadoop jar jar包名字 要执行的类名 要检索的文件所在的目录 输出目录 要检索的字符串 每个输出文件所包含的最大行数，我的命令就是hadoop jar BigData.jar experimentone.ResultFilter /user/xk output world 3，表示我要运行的jar包名为BigData.jar，要运行的类名为experimentone包下的ResultFilter类，要检索的文件所在目录是HDFS上的/user/xk，检索输出的文件保存在名为output的目录，要检索的字符串为world，输出文件的最大行数为3（注意自己jar包存放位置，我是因为jar包和终端所在位置都在Desktop才这样写，如果jar包存放位置和终端所处位置不一样，则需要在jar包名字前加上路径，比如/usr/xk/BigData.jar） image-20220528143122096 运行成功后Ubuntu桌面（不一定是桌面，如果你没指定具体路径，它默认是在你终端现处位置的目录下创建output）多出了一个output目录，里面包含三个文件（文件个数与查询出来的内容总行数、规定的每个文件最大行数有关），分别名为1、2、3，里面的内容就是我检索的目录中所有文件里包含了world的那一行的内容，且每个文件的最大行数为3（我所有操作都是在桌面位置的终端进行，所以output会在桌面，如果想指定具体创建位置和目录名，可以在命令中写详细点） image-20220528143353939 2.2.2 CreateDirectory这个是老师给出拓展实验之一，实验目的就是在HDFS上面创建一个目录 省去上面提到的导入依赖的步骤，直接在包下新建一个名为CreateDirectory的类 然后，代码如下： public class CreateDirectory &#123; private static final String hostString = &quot;hdfs://master:9000&quot;; public static void main(String[] args) throws IOException &#123; Configuration conf = new Configuration(); conf.set(&quot;fs.default.name&quot;, hostString); FileSystem hdfs = FileSystem.get(conf); if(hdfs.exists(new Path(&quot;hdfs:/myTestDirectory&quot;)))&#123; System.out.println(&quot;目录已经存在！,先删除&quot;); hdfs.delete(new Path(&quot;hdfs:/myTestDirectory&quot;),true); &#125;else &#123; boolean isok =hdfs.mkdirs(new Path(&quot;hdfs:/myTestDirectory&quot;)); if(isok) System.out.println(&quot;目录创建成功！&quot;); else System.out.println(&quot;目录创建失败！&quot;); &#125; hdfs.close(); &#125; &#125; 然后，依旧是点击侧边栏的Maven，这次首先点击clean将刚刚编译的内容清除，再点击package将项目打包，再复制到Ubuntu中 这样似乎很麻烦，因为每次我们新建一个类去完成另一个实验都要进行这样的操作，所以我建议把所有代码敲完了再把整个项目打成jar包复制到Ubuntu中，比如像这样： image-20220528144604203 继续上面的步骤，将jar包复制到Ubuntu中后，我们使用命令hadoop jar BigData.jar experimentone.CreateDirectory 执行该程序，然后我们可以通过hadoop fs -ls /查看是否真正创建成功，也可以通过上面提到的通过web方式进行查看 image-20220528144937444 2.2.3 HdfsClient这个也是老师给出的拓展实验之二，实验目的是通过Windows下的IDEA模拟HDFS客户端来操作Ubuntu中的HDFS 在准备工作中我们在Windows下安装Hadoop就是为了这个实验 同样，新建一个名为HdfsClient的类，代码如下： public class HdfsClient &#123; FileSystem fs = null; //连接hdfs集群 @Before public void init() &#123; Configuration conf = new Configuration(); System.out.println(&quot;执行Before！&quot;); try &#123; fs = FileSystem.get(new URI(&quot;hdfs://master:9000/&quot;), conf, &quot;xk&quot;);//xk改成自己虚拟机的用户名，如果单独为hadoop创建一个用户，则修改为hadoop的用户名 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (URISyntaxException e) &#123; e.printStackTrace(); &#125; &#125; //下载数据 hdfs-&gt;本地 @Test public void hdfsGet() &#123; try &#123; fs.copyToLocalFile(new Path(&quot;/zookeeper.out&quot;), new Path(&quot;e:/zookeeper.out&quot;)); fs.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //上传数据 本地上传到hdfs集群 @Test public void localToHdfs() &#123; try &#123; fs.copyFromLocalFile(new Path(&quot;e:/new2.txt&quot;), new Path(&quot;/new2.txt&quot;)); fs.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //hdfs中创建文件夹 @Test public void hdfsMkdir() &#123; try &#123; fs.mkdirs(new Path(&quot;/hdfs-clientTest&quot;)); fs.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //在hdfs中移动修改文件 @Test public void hdfsRename() &#123; try &#123; fs.rename(new Path(&quot;/zookeeper.out&quot;), new Path(&quot;/zookeeperXK.out&quot;)); fs.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //删除文件夹 @Test public void deleteDir() &#123; try &#123; fs.delete(new Path(&quot;/hdfs-clientTest&quot;), true); fs.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; /* * 查询hdfs下指定目录下的信息 */ @Test public void hdfsLs() throws Exception &#123; //只查询文件的信息不返回文件夹的信息 RemoteIterator&lt;LocatedFileStatus&gt; iter = fs.listFiles(new Path(&quot;/&quot;), true); //如果有数据 while (iter.hasNext()) &#123; //取 LocatedFileStatus status = iter.next(); System.out.println(&quot;文件路径为：&quot; + status.getPath()); System.out.println(&quot;块大小为：&quot; + status.getBlockSize()); System.out.println(&quot;文件长度为：&quot; + status.getLen()); System.out.println(&quot;副本数量为：&quot; + status.getReplication()); System.out.println(&quot;块信息为：&quot; + Arrays.toString(status.getBlockLocations())); //分割线 System.out.println(&quot;==================================&quot;); &#125; fs.close(); &#125; /* * 查询hdfs下指定目录下的文件和文件夹信息 */ @Test public void hdfsLs2() throws Exception &#123; //展示状态信息 FileStatus[] listStatus = fs.listStatus(new Path(&quot;/&quot;)); for (FileStatus ls : listStatus) &#123; System.out.println(&quot;文件路径为：&quot; + ls.getPath()); System.out.println(&quot;块大小为：&quot; + ls.getBlockSize()); System.out.println(&quot;文件长度为：&quot; + ls.getLen()); System.out.println(&quot;副本数量为：&quot; + ls.getReplication()); System.out.println(&quot;==================================&quot;); &#125; fs.close(); &#125; &#125; 这个实验不需要将项目打成jar包在Ubuntu下运行，而是直接在Windows下操作 但是，在这之前，我们需要在Ubuntu中创建文件，并将其上传到hdfs上。touch创建文件，vi 编辑文件，hadoop fs -put XXX XXX上传文件，hadoop fs -ls /查看文件，我这儿是将当前目录下的zookeeper.out文件上传到了HDFS的根目录中 image-20220528151905054 另外，我们在Windows上也需要随意新建一个文件，一会儿会通过HdfsClient将其上传到HDFS上，文件名和存放路径不同也要修改HdfsClient中相应的代码片段 现在开始执行单元测试程序 ① 下载数据 hdfs -&gt; Windows本地，执行hdfsGet()方法 执行完成后，可在自己Windows上对应位置查看到下载下来的文件，比如，我的就是在e:/zookeeper.out image-20220528153028597 运行过程中出现以下提示不用担心，这是因为hadoop的相关依赖又依赖了log4j这个日志jar包，项目如果有这个依赖但是没有其配置文件就会报错，我们不需要查看日志就不用管，如果有强迫症非要消掉报错，可以在网上搜一下log4j的配置文件，将其添加到项目的resource文件夹下即可 image-20220528153858942 ② 上传数据 Windows本地 -&gt; hdfs，执行localToHdfs()方法 执行成功后，可以在web端的hdfs进行查看，我在本地创建new2.txt文件被上传到了hdfs上 image-20220528153656938 ③ hdfs中创建文件夹，执行hdfsMkdir()方法 执行成功，以同样的方式查看 image-20220528153936498 ④ 在hdfs中移动修改文件，执行hdfsRename()方法 执行成功后，可以发现zookeeper.out文件被重命名 image-20220528154158891 ⑤ 删除文件夹，执行deleteDir()方法 执行成功后，hdfs-clientTest目录就会被删掉 ⑥ 查询hdfs下指定目录下的信息，执行hdfsLs()方法 执行完成后，idea的终端会输出打印HDFS中指定目录下（我们程序中是要查询出根目录下的）所有文件的相关信息 image-20220528154508742 ⑦ 查询hdfs下指定目录下文件和文件夹的信息，执行hdfsLs2()方法 执行完成后，会打印出hdfs中指定目录下的文件和文件夹相关信息 image-20220528155054407 三、实验二：IDEA下的MapReduce编程3.1 WordCount这是书上的实验 在开始这个实验之前需要上传一个新的文件到HDFS上，并且里面要包含一些内容，这个实验的目的就是为了统计这个文件中各个单词的个数 准备工作操作参考： image-20220528160147121 省去新建项目和导入依赖的步骤，直接新建一个名为WordCount的类 实验代码如下： public class WordCount &#123; public static void main(String[] args) throws Exception&#123; Configuration conf = new Configuration(); //以下这些配置都见名知意，不用解释吧 conf.set(&quot;fs.default.name&quot;,&quot;hdfs://192.168.228.128:9000&quot;);//ip改为自己虚拟机的 conf.set(&quot;mapred.job.tracker&quot;,&quot;192.168.228.128:9001&quot;); conf.set(&quot;hadoop.job.user&quot;,&quot;xk&quot;);//xk改为自己的 String[] ars = new String[]&#123;&quot;input&quot;,&quot;output&quot;&#125;; String[] otherArgs = new GenericOptionsParser(conf, ars).getRemainingArgs(); if (otherArgs.length != 2)&#123; System.err.println(&quot;Usage:wordcount &quot;); System.exit(2); &#125; Job job = new Job(conf, &quot;word count&quot;); job.setJarByClass(WordCount.class); job.setMapperClass(TokenizerMapper.class); job.setCombinerClass(IntSumReducer.class); job.setReducerClass(IntSumReducer.class); job.setOutputKeyClass(Text.class); job.setOutputValueClass(IntWritable.class); //添加hdfs上我们要统计的文件 FileInputFormat.addInputPath(job,new Path(&quot;hdfs://192.168.228.128:9000/user/xk/test.txt&quot;)); //设置统计结果输出目录（依然是存放在hdfs上的） FileOutputFormat.setOutputPath(job,new Path(&quot;hdfs://192.168.228.128:9000/user/xk/output&quot;)); System.exit(job.waitForCompletion(true) ? 0 : 1); &#125; public static class TokenizerMapper extends Mapper&lt;Object, Text, Text, IntWritable&gt;&#123; private final static IntWritable one = new IntWritable(1); private Text word = new Text(); public void map(Object key,Text value, Context context) throws IOException, InterruptedException &#123; StringTokenizer itr = new StringTokenizer(value.toString()); while (itr.hasMoreTokens())&#123; word.set(itr.nextToken()); context.write(word,one); &#125; &#125; &#125; public static class IntSumReducer extends Reducer&lt;Text, IntWritable, Text, IntWritable&gt;&#123; private IntWritable result = new IntWritable(); public void reduce(Text key,Iterable&lt;IntWritable&gt; values,Context context) throws IOException, InterruptedException &#123; int sum = 0; for (IntWritable val : values) &#123; sum += val.get(); &#125; result.set(sum); context.write(key,result); &#125; &#125; &#125; 同样，将项目打成jar包（如果不是一次性将所有程序写好后打的jar包请记得先clean再package），复制到Ubuntu中，然后使用命令hadoop jar 要运行的jar包 要运行的类名运行该程序 image-20220528161615949 等过一会儿运行完成后，终端大概是这样的 image-20220528161658397 通过web端查看，可以看到多出一个output目录 image-20220528161848081 output的生成位置取决于在程序中的此处的设置： image-20220529183816805 进入到output目录中，可以看到两个文件 image-20220528162015041 我们将这个目录下载下来查看 image-20220528162401811 3.2 InvertedIndex这是实验二老师给出的扩展实验 开始实验之前，请先将课上老师发的三个文件复制到Ubuntu中 image-20220528163756886 然后，在Ubuntu中的HDFS上创建几个目录，InvertedIndex和InvertedIndex/input 然后，将那三个文件上传到input目录中 image-20220528164046576 然后在项目中新建几个类，分别为InvertedIndexCombiner、InvertedIndexMapper、InvertedIndexReducer、InvertedIndexRunner public class InvertedIndexCombiner extends Reducer&lt;Text, Text, Text, Text&gt; &#123; private static Text info = new Text(); // 输入： &lt;MapReduce:file3 &#123;1,1,...&#125;&gt; // 输出：&lt;MapReduce file3:2&gt; @Override protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; int sum = 0;// 统计词频 for (Text value : values) &#123; sum += Integer.parseInt(value.toString()); &#125; // 查找分隔位置 int splitIndex = key.toString().indexOf(&quot;:&quot;); // 重新设置 value 值由 URL 和词频组成 info.set(key.toString().substring(splitIndex + 1) +&quot;:&quot;+sum); // 重新设置 key 值为单词 key.set(key.toString().substring(0,splitIndex)); context.write(key,info); &#125; &#125; public class InvertedIndexMapper extends Mapper&lt;LongWritable, Text, Text, Text&gt; &#123; // 存储单词和文件明组合 private static Text keyInfo = new Text(); // 存储词频,初始化为 private static final Text valueInfo = new Text(&quot;1&quot;); @Override protected void map(LongWritable key, Text value, Mapper&lt;LongWritable, Text, Text, Text&gt;.Context context) throws IOException, InterruptedException &#123; String line = value.toString(); // 得到字段数组 String[] fields = StringUtils.split(line, &#39; &#39;);//别用双引号 // 得到这行数据所在的文件切片 FileSplit fileSplit = (FileSplit) context.getInputSplit(); // 根据文件切片得到文件名 String fileName = fileSplit.getPath().getName(); for (String field : fields) &#123; // key值由单词和URL组成，如“MapReduce:file1” keyInfo.set(field + &quot;:&quot; + fileName); context.write(keyInfo, valueInfo); &#125; &#125; &#125; public class InvertedIndexReducer extends Reducer&lt;Text, Text, Text, Text&gt; &#123; private static Text result = new Text(); // 输入：&lt;MapReduce file3:2&gt; // 输出：&lt;MapReduce file1:1;file2:1;file3:2;&gt; @Override protected void reduce(Text key, Iterable&lt;Text&gt; values, Context context) throws IOException, InterruptedException &#123; // 生成文档列表 String fileList = new String(); for (Text value : values) &#123; fileList += value.toString() + &quot;;&quot;; &#125; result.set(fileList); context.write(key, result); &#125; &#125; public class InvertedIndexRunner &#123; public static void main(String[] args) throws IOException, ClassNotFoundException, InterruptedException &#123; Configuration conf = new Configuration(); //配置RM地址 conf.set(&quot;fs.default.name&quot;, &quot;hdfs://192.168.228.128:9000&quot;); conf.set(&quot;mapred.job.tracker&quot;, &quot;192.168.228.128:9001&quot;); conf.set(&quot;hadoop.job.user&quot;,&quot;xk&quot;); //构建Job实例 Job job = Job.getInstance(conf); //为Job设置类名 job.setJarByClass(InvertedIndexRunner.class); //为Job设置Mapper类 job.setMapperClass(InvertedIndexMapper.class); //为Job设置Combiner类 job.setCombinerClass(InvertedIndexCombiner.class); //为Job设置Reducer类 job.setReducerClass(InvertedIndexReducer.class); //为Job的输出数据设置Key类 job.setOutputKeyClass(Text.class); //为Job输出设置value类 job.setOutputValueClass(Text.class); //为Job设置输入路径 FileInputFormat.setInputPaths(job, new Path(&quot;hdfs://192.168.228.128:9000/InvertedIndex/input&quot;)); // 指定处理完成之后的结果所保存的位置 FileOutputFormat.setOutputPath(job, new Path(&quot;hdfs://192.168.228.128:9000/InvertedIndex/output&quot;)); // 向 YARN 集群提交这个 Job boolean res = job.waitForCompletion(true); System.exit(res ? 0 : 1); &#125; &#125; 同样，将项目打成jar包，复制到Ubuntu中，然后使用命令hadoop jar 要运行的jar包 要运行的类名运行该程序 程序运行完后，在hdfs的/InvertedIndex目录下多出了一个output目录 我们同样也可以下载下来查看 image-20220528164553511 到此，本学期所有的课程实验就都完成了，其实这些实验都很简单，毕竟代码都是现成的，我们只需要能运行出来就行，就是配置环境麻烦 最后，希望大家都能准确无误地运行出来，有问题和疑惑可以QQ私聊我或在下面评论","categories":[{"name":"教程","slug":"教程","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://rainvex.com/tags/Ubuntu/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://rainvex.com/tags/Hadoop/"}],"author":"夜雨声烦"},{"title":"Mybatis学习笔记","slug":"Mybatis学习笔记","date":"2022-05-10T14:54:33.000Z","updated":"2022-05-10T14:54:33.000Z","comments":true,"path":"categories/后端/Mybatis学习笔记.html","link":"","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/Mybatis%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"Mybatis学习笔记边做笔记边学习是真的慢啊，10个小时的视频都看了5天🤔，虽然这能让自己理解的效果稍微好一些，对以后学习回顾也是一个好处，但是现在时间已经不允许我再慢慢搞了😭，越学越觉得自己会的东西少且low，面经看一个不会一个，lc也没刷，学历也差，再看看今年的形式真是焦虑至极啊😖希望快点好起来 一、Mybatis简介下载地址 将mybatis下载下来后，文件夹中有官方文档和jar包，现在我们都是使用Maven直接导入依赖，所以现在没必要去下载，除非不使用Maven就可以下载下来将其jar包导入到项目进行使用 1.1 MyBatis历史MyBatis最初是Apache的一个开源项目iBatis, 2010年6月这个项目由Apache Software Foundation迁移到了Google Code。随着开发团队转投Google Code旗下， iBatis3.x正式更名为MyBatis。代码于2013年11月迁移到Github。Mybatis一词来源于“internet”和“abatis”的组合，是一个基于Java的持久层框架。 iBatis提供的持久层框架包括SQL Maps和Data Access Objects（DAO） 1.2 MyBatis特性 MyBatis 是支持定制化 SQL、存储过程以及高级映射的优秀的持久层框架 MyBatis 避免了几乎所有的 JDBC 代码和手动设置参数以及获取结果集 MyBatis可以使用简单的XML或注解用于配置和原始映射，将接口和Java的POJO（Plain Old Java Objects，普通的Java对象）映射成数据库中的记录 MyBatis 是一个 半自动的ORM（Object Relation Mapping）框架 1.3 和其它持久化层技术对比 JDBC SQL 夹杂在Java代码中耦合度高，导致硬编码内伤 维护不易且实际开发需求中 SQL 有变化，频繁修改的情况多见 代码冗长，开发效率低 Hibernate 和 JPA 操作简便，开发效率高 程序中的长难复杂 SQL 需要绕过框架 内部自动生产的 SQL，不容易做特殊优化 基于全映射的全自动框架，大量字段的 POJO 进行部分映射时比较困难 反射操作太多，导致数据库性能下降 Mybatis 轻量级，性能出色 SQL 和 Java 编码分开，功能边界清晰。Java代码专注业务、SQL语句专注数据 开发效率稍逊于HIbernate，但是完全能够接受 二、搭建Mybatis2.1 开发环境IDEA：2021.2 Mybatis：3.5.9 Maven：3.8.1 MySQL：5.7 2.2 创建maven工程打开IDEA，新建项目 image-20220505213035962 image-20220505213221200 完成Maven项目的创建 2.3 准备工作2.3.1 导入Maven依赖&lt;!--更改打包方式为jar，其实可以不用改，默认就为jar--&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;!--导入依赖--&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 2.3.2 创建数据库和数据表首先我们需要创建好一个数据库和数据表来作为本次学习Mybatis使用的数据存储介质 image-20220505214050950 创建好数据库后，为了操作操作方便，我们还可以将数据库作为数据源添加到IDEA中，过程如下：（而且如果不添加数据源的话，等下方配置mapper接口的映射方法时会报错说什么找不到数据源之类的，虽然可能没什么影响，但是有强迫症的话就很恼火） image-20220505221518133 image-20220505221729097 2.3.3 创建对应实体类public class User &#123; //实体类的属性名要尽量和数据库中表的字段名一致 private Integer id; private String username; private String password; private Integer age; private String gender; private String email; //省略get、set、toString方法 &#125; 2.3.4 创建配置文件和mapper接口 在java文件夹中创建好mapper包，然后在其中创建一个名为UserMapper的mapper接口，其作用就是代替之前javaweb开发中操作数据库的dao层 MyBatis中的mapper接口相当于以前的dao。但是区别在于，mapper仅仅是接口，我们不需要提供实现类 在resource文件夹下创建一个mybatis-config.xml的配置文件 习惯上命名为mybatis-config.xml，这个文件名仅仅只是建议，并非强制要求。将来整合Spring之后，这个配置文件可以省略。核心配置文件主要用于配置连接数据库的环境以及MyBatis的全局配置信息 核心配置文件存放的位置是src/main/resources目录下 在resource文件夹下创建一个专门存放mapper接口的映射文件的包mappers，在这个包中创建好UserMapper接口的映射文件UserMapper.xml文件 相关概念：ORM（Object Relationship Mapping）对象关系映射 对象：Java的实体类对象 关系：关系型数据库 映射：二者之间的对应关系 Java概念 数据库概念 类 表 属性 字段/列 对象 记录/行 1、映射文件的命名规则：表所对应的实体类的类名+Mapper.xml例如：表t_user，映射的实体类为User，所对应的映射文件为UserMapper.xml因此一个映射文件对应一个实体类，对应一张表的操作MyBatis映射文件用于编写SQL，访问以及操作表中的数据MyBatis映射文件存放的位置是src/main/resources/mappers目录下 2、MyBatis中可以面向接口操作数据，要保证两个一致：a&gt;mapper接口的全类名和映射文件的命名空间（namespace）保持一致b&gt;mapper接口中方法的方法名和映射文件中编写SQL的标签的id属性保持一致 创建好后的结构如图所示： image-20220505215333614 2.4 配置Mybatis2.4.1 配置mybatis配置文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--其中这四个是需要改成自己数据库的配置--&gt; &lt;!--如果在pom文件中导入的mysql驱动依赖是8.x版本的，driver应该这样配置--&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--将创建的映射文件引入--&gt; &lt;mapper resource=&quot;mappers/UserMapper.xml&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 2.4.2 编写Mapper接口内容//由于只是测试，所以mapper映射文件中会写死条件，这里的方法就不设置传参了 public interface UserMapper &#123; //插入新用户 int insertUser(); //更新用户 int updateUser(); //删除用户 int deleteUser(); //通过id查询用户 User queryUserById(); //查询所有用户 List&lt;User&gt; queryAllUser(); &#125; 2.4.3 配置Mapper接口的映射文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt; &lt;mapper namespace=&quot;com.mybatis.mapper.UserMapper&quot;&gt; &lt;!--是UserMapper中的int insertUser()方法的映射--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#39;admin&#39;,&#39;123456&#39;,23,&#39;女&#39;,&#39;12345@qq.com&#39;) &lt;/insert&gt; &lt;!--int updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username = &#39;zhangsan&#39; where id = 2 &lt;/update&gt; &lt;!--int deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 2 &lt;/delete&gt; &lt;!--User queryUserById();--&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;com.mybatis.entity.User&quot;&gt; select * from t_user where id = 1 &lt;/select&gt; &lt;!--List&lt;User&gt; queryAllUser()--&gt; &lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.mybatis.entity.User&quot;&gt; select * from t_user &lt;/select&gt; &lt;/mapper&gt; 查询功能的标签必须设置resultType或resultMap属性 resultType：设置默认的映射关系（即实体类对象属性和数据库表字段映射一致的情况）resultMap：设置自定义的映射关系（后面会讲到如何使用） 2.5 加入日志功能可加可不加 &lt;!--导入依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; 添加log4j的配置文件，命名为log4j.xml，存放在src/main/resources目录下 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE log4j:configuration SYSTEM &quot;log4j.dtd&quot;&gt; &lt;log4j:configuration xmlns:log4j=&quot;http://jakarta.apache.org/log4j/&quot;&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;org.apache.log4j.ConsoleAppender&quot;&gt; &lt;param name=&quot;Encoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;layout class=&quot;org.apache.log4j.PatternLayout&quot;&gt; &lt;param name=&quot;ConversionPattern&quot; value=&quot;%-5p %d&#123;MM-dd HH:mm:ss,SSS&#125;%m (%F:%L) \\n&quot; /&gt; &lt;/layout&gt; &lt;/appender&gt; &lt;logger name=&quot;java.sql&quot;&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;/logger&gt; &lt;logger name=&quot;org.apache.ibatis&quot;&gt; &lt;level value=&quot;info&quot; /&gt; &lt;/logger&gt; &lt;root&gt; &lt;level value=&quot;debug&quot; /&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;/log4j:configuration&gt; 日志的级别FATAL(致命)&gt;ERROR(错误)&gt;WARN(警告)&gt;INFO(信息)&gt;DEBUG(调试)从左到右打印的内容越来越详细，且打印信息会大于等于设置的日志级别 2.6 测试功能2.6.1 测试添加功能@Test public void insertUser() throws IOException &#123; //读取MyBatis的核心配置文件 InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); //创建SqlSessionFactoryBuilder对象 SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); //通过核心配置文件所对应的字节输入流创建工厂类SqlSessionFactory，生产SqlSession对象 SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); //SqlSession sqlSession = sqlSessionFactory.openSession(); 创建SqlSession对象，此时通过SqlSession对象所操作的sql都必须手动提交或回滚事务 SqlSession sqlSession = sqlSessionFactory.openSession(true); //创建SqlSession对象，此时通过SqlSession对象所操作的sql都会自动提交 //通过代理模式创建UserMapper接口的代理实现类对象 UserMapper userMapper = sqlSession.getMapper(UserMapper.class); //调用UserMapper接口中的方法，就可以根据UserMapper的全类名匹配元素文件，通过调用的方法名匹配映射文件中的SQL标签，并执行标签中的SQL语句 int result = userMapper.insertUser(); //sqlSession.commit(); 如果是使用sqlSessionFactory.openSession()创建的sqlSession对象就需要使用这行代码手动提交或回滚事务 System.out.println(&quot;result：&quot; + result);//返回受影响行数 &#125; SqlSession：代表Java程序和数据库之间的会话（HttpSession是Java程序和浏览器之间的会话） SqlSessionFactory：是“生产”SqlSession的“工厂” 工厂模式：如果创建某一个对象，使用的过程基本固定，那么我们就可以把创建这个对象的相关代码封装到一个“工厂类”中，以后都使用这个工厂类来“生产”我们需要的对象 此时，数据库中就多出一条数据： image-20220505223723254 注：如果我们不手动提交或设置自动提交事务，测试输出的结果仍虽然会是1，但是数据库中不会有数据，并且它会占用id 2.6.2 测试修改和删除功能@Test public void updateUser() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int i = userMapper.updateUser(); System.out.println(&quot;result:&quot; + i);//result:1 &#125; @Test public void deleteUser() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); int i = userMapper.deleteUser(); System.out.println(&quot;result:&quot; + i);//result:1 &#125; 更新用户结果：id为2的用户的用户名已经被更新为”zhangsan” image-20220505232726960 删除用户结果：id为2的用户已经被删除 image-20220505223723254 2.6.3 测试查询功能@Test public void queryUserById() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = userMapper.queryUserById(); System.out.println(user);//User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125; &#125; @Test public void queryAllUser() throws IOException &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); SqlSession sqlSession = sqlSessionFactory.openSession(true); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); List&lt;User&gt; userList = userMapper.queryAllUser(); System.out.println(userList); //[User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=3, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;] &#125; 2.6.4 封装工具类由于每次操作我们都需要使用相同的步骤来创建sqlSession，这样就晓得操作过程非常繁琐，所以我们可以将这些操作使用一个工具类来进行封装 public class SqlSessionUtils &#123; public static SqlSession getSqlSession()&#123; SqlSession sqlSession = null; try &#123; InputStream is = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactoryBuilder sqlSessionFactoryBuilder = new SqlSessionFactoryBuilder(); SqlSessionFactory sqlSessionFactory = sqlSessionFactoryBuilder.build(is); sqlSession = sqlSessionFactory.openSession(true); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return sqlSession; &#125; &#125; 三、Mybatis基础功能3.1 核心配置文件详解核心配置文件中的标签必须按照固定的顺序： properties -&gt; settings -&gt; typeAliases -&gt; typeHandlers -&gt; objectFactory -&gt; objectWrapperFactory -&gt; reflectorF actory -&gt; plugins - &gt; environments -&gt; databaseIdProvider -&gt; mappers 这里只配置properties、typeAliases、environments和mappers，其余的等使用到的时候再添加 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//MyBatis.org//DTD Config 3.0//EN&quot; &quot;http://MyBatis.org/dtd/MyBatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--引入properties文件，此时就可以在配置数据库时使用$&#123;属性名&#125;的方式访问属性值--&gt; &lt;!--jdbc.properties存放在resources文件夹中--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;typeAliases&gt; &lt;!-- typeAlias：设置某个具体的类型的别名 属性： type：需要设置别名的类型的全类名 alias：设置此类型的别名，若不设置此属性，该类型拥有默认的别名，即类名且不区分大小写。若设置此属性，此时该类型的别名只能使用alias所设置的值 alisa属性也可以在实体类中使用@Alisa注解代替 --&gt; &lt;!--&lt;typeAlias type=&quot;com.mybatis.entity.User&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--&lt;typeAlias type=&quot;com.mybatis.entity.User&quot; alias=&quot;abc&quot;&gt;&lt;/typeAlias&gt;--&gt; &lt;!--以包为单位，设置改包下所有的类型都拥有默认的别名，即类名且不区分大小写--&gt; &lt;package name=&quot;com.mybatis.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;!-- environments：设置多个连接数据库的环境 属性： default：设置默认使用的环境的id --&gt; &lt;environments default=&quot;mysql_test&quot;&gt; &lt;!-- environment：设置具体的连接数据库的环境信息属性： id：设置环境的唯一标识，可通过environments标签中的default设置某一个环境的id，表示默认使用的环境 --&gt; &lt;environment id=&quot;mysql_test&quot;&gt; &lt;!-- transactionManager：设置事务管理方式 属性： type：设置事务管理方式，type=&quot;JDBC|MANAGED&quot; type=&quot;JDBC&quot;：设置当前环境的事务管理都必须手动处理 type=&quot;MANAGED&quot;：设置事务被管理，例如spring中的AOP，使用声明式事务 --&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;!-- dataSource：设置数据源 属性： type：设置数据源的类型，type=&quot;POOLED|UNPOOLED|JNDI&quot; type=&quot;POOLED&quot;：使用数据库连接池，即会将创建的连接进行缓存，下次使用可以从缓存中直接获取，不需要重新创建 type=&quot;UNPOOLED&quot;：不使用数据库连接池，即每次使用连接都需要重新创建 type=&quot;JNDI&quot;：调用上下文中的数据源 --&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;!--设置驱动类的全类名--&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;!--设置连接数据库的连接地址--&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;!--设置连接数据库的用户名--&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;!--设置连接数据库的密码--&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;!--引入单个mapper映射文件--&gt; &lt;!--&lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;--&gt; &lt;!-- 以包为单位，将包下所有的映射文件引入核心配置文件 注意：此方式必须保证mapper接口和mapper映射文件必须在相同的包下 比如，mapper接口所在包为com.mybatis.mapper，那么mapper映射文件也必须在resources下的com.mybatis.mapper包中 --&gt; &lt;package name=&quot;com.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; Tips小技巧：创建Mybatis核心配置文件和mapper映射文件模板①创建Mybatis核心配置文件模板（文件名可选，如果不设置，新建模板文件时就会提示输入文件名） image-20220506200053384 测试：选择一个文件夹，右键新建，选择新建一个mybatis-config文件，在新文件中就可以发现Mybatis那些必要的配置代码就自动生成了，减少了每次使用mybatis都需要去复制编写的麻烦 image-20220506200533404 ②创建mapper映射文件的方式同上，这里就不再多说了 3.2 Mybatis的增删改查1、增加 &lt;!--是UserMapper中的int insertUser()方法的映射--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values(null,&#39;admin&#39;,&#39;123456&#39;,23,&#39;女&#39;,&#39;12345@qq.com&#39;) &lt;/insert&gt; 2、修改 &lt;!--int updateUser();--&gt; &lt;update id=&quot;updateUser&quot;&gt; update t_user set username = &#39;zhangsan&#39; where id = 2 &lt;/update&gt; 3、删除 &lt;!--int deleteUser();--&gt; &lt;delete id=&quot;deleteUser&quot;&gt; delete from t_user where id = 2 &lt;/delete&gt; 4、查询单个实体类对象 &lt;!--User queryUserById();--&gt; &lt;select id=&quot;queryUserById&quot; resultType=&quot;com.mybatis.entity.User&quot;&gt; select * from t_user where id = 1 &lt;/select&gt; 5、查询集合 &lt;!--List&lt;User&gt; queryAllUser()--&gt; &lt;select id=&quot;queryAllUser&quot; resultType=&quot;com.mybatis.entity.User&quot;&gt; select * from t_user &lt;/select&gt; 注意：1、查询的标签select必须设置属性resultType或resultMap，用于设置实体类和数据库表的映射关系 resultType：自动映射，用于属性名和表中字段名一致的情况 resultMap：自定义映射，用于一对多或多对一或字段名和属性名不一致的情况 2、当查询的数据为多条时，不能使用实体类作为返回值，只能使用集合，否则会抛出异常TooManyResultsException；但是若查询的数据只有一条，可以使用实体类或集合作为返回值 3、其实如果简单一点的sql语句可以不使用mapper映射文件来编写，可以使用注解@Select、@Update、@Delete、@Insert来代替，将这些注解标识在方法上面，然后在注解中编写sql语句，例如 @Select(&quot;select * from t_user where username = #&#123;username&#125;&quot;) User getUserByUsername(String username); 3.3 Mybatis获取参数值MyBatis获取参数值的两种方式：$&#123;&#125;和#&#123;&#125; $&#123;&#125;的本质就是字符串拼接，#&#123;&#125;的本质就是占位符赋值 $&#123;&#125;使用字符串拼接的方式拼接sql，若为字符串类型或日期类型的字段进行赋值时，需要手动加单引号；但是#&#123;&#125;使用占位符赋值的方式拼接sql，此时为字符串类型或日期类型的字段进行赋值时，可以自动添加单引号 3.3.1 单个字面量类型的参数若mapper接口中的方法参数为单个的字面量类型 此时可以使用$&#123;&#125;和#&#123;&#125;以任意的名称获取参数的值，注意$&#123;&#125;需要手动加单引号 &lt;!--User getUserByUsername(String username);--&gt; &lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = &#39;$&#123;username&#125;&#39; &lt;/select&gt; &lt;!--User getUserByUsername(String username);--&gt; &lt;select id=&quot;getUserByUsername&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; &lt;/select&gt; 3.3.2 多个字面量类型的参数若mapper接口中的方法参数为多个时，此时MyBatis会自动将这些参数放在一个map集合中 以arg0，arg1…为键，以参数为值 以param1，param2…为键，以参数为值 注：多个字面量类型的参数不能像单个字面量类型参数一样直接通过参数名作为键，如果不使用上面这两种键来取值，就得使用@Param注解标识参数，否则会获取不了参数值 然后只需要通过$&#123;&#125;和#&#123;&#125;访问map集合的键就可以获取相对应的值，注意$&#123;&#125;需要手动加单引号 &lt;!--User checkLogin(String username,String password)--&gt; &lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;arg0&#125; and password = #&#123;arg1&#125; &lt;/select&gt; &lt;!--User checkLogin(String username,String password)--&gt; &lt;select id=&quot;checkLogin&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;param1&#125; and password = #&#123;param2&#125; &lt;/select&gt; 3.3.3 map集合类型的参数若mapper接口中的方法需要的参数为多个时，此时可以手动创建map集合，将这些数据放在map中，只需要通过$&#123;&#125;和#&#123;&#125;访问map集合的键就可以获取相对应的值，注意$&#123;&#125;需要手动加单引号 @Test public void checkLoginByMap() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); UserMapper mapper = sqlSession.getMapper(UserMapper.class); Map&lt;String, Object&gt; map = new HashMap&lt;&gt;(); map.put(&quot;username&quot;,&quot;admin&quot;); map.put(&quot;password&quot;,&quot;123456&quot;); User user = mapper.checkLoginByMap(map); System.out.println(user); &#125; &lt;!--User checkLoginByMap(Map map)--&gt; &lt;select id=&quot;checkLoginByMap&quot; resultType=&quot;User&quot;&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; 3.3.4 实体类类型的参数若mapper接口中的方法参数为实体类对象时，此时可以使用$&#123;&#125;和#&#123;&#125;，通过访问实体类对象中的属性名获取属性值，注意$&#123;&#125;需要手动加单引号 @Test public void insertUser() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); UserMapper userMapper = sqlSession.getMapper(UserMapper.class); User user = new User(); user.setId(null); user.setUsername(&quot;lisi&quot;); user.setPassword(&quot;123456&quot;); user.setAge(20); user.setGender(&quot;男&quot;); user.setEmail(&quot;123456@qq.com&quot;); int i = userMapper.insertUser(user); System.out.println(i); &#125; &lt;!--int insertUser(User user)--&gt; &lt;insert id=&quot;insertUser&quot;&gt; insert into t_user values (#&#123;id&#125;, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; 3.3.5 使用@Param标识的参数可以通过@Param注解标识mapper接口中的方法参数，此时，会将这些参数放在map集合中 以@Param注解的value属性值为键，以参数为值 以param1，param2…为键，以参数为值 然后只需要通过$&#123;&#125;和#&#123;&#125;访问map集合的键就可以获取相对应的值，注意$&#123;&#125;需要手动加单引号 &lt;!--User checkLoginByParam(@Param(&quot;username&quot;) String username, @Param(&quot;password&quot;) String password)--&gt; &lt;select id=&quot;checkLoginByParam&quot; resultType=&quot;User&quot;&gt; &lt;!--这里#&#123;&#125;中的值就是我们设置@Param注解的value的值--&gt; select * from t_user where username = #&#123;username&#125; and password = #&#123;password&#125; &lt;/select&gt; 3.4 Mybatis的各种查询方式3.4.1 查询单个实体类对象/** * 根据用户id查询用户信息 */ User getUserById(@Param(&quot;id&quot;) Integer id); &lt;!--User getUserById(@Param(&quot;id&quot;) Integer id)--&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;User&quot;&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;--&gt; 3.4.2 查询一个list集合/** * 查询所有用户信息 */ List&lt;User&gt; getAllUser(); &lt;!--List&lt;User&gt; getAllUser()--&gt; &lt;select id=&quot;getAllUser&quot; resultType=&quot;User&quot;&gt; select * from t_user &lt;/select&gt; &lt;!-- [User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=3, username=&#39;zhangsan&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=4, username=&#39;lisi&#39;, password=&#39;123456&#39;, age=20, gender=&#39;男&#39;, email=&#39;123456@qq.com&#39;&#125;] --&gt; 3.4.3 查询单个数据/** * 查询用户的总记录数 * 在MyBatis中，对于Java中常用的类型都设置了类型别名 * 例如：java.lang.Integer--&gt;int|integer * 例如：int--&gt;_int|_integer * 例如：Map--&gt;map,List--&gt;list */ Integer getUserCount(); &lt;!--Integer getUserCount()--&gt; &lt;select id=&quot;getUserCount&quot; resultType=&quot;Integer&quot;&gt; select count(id) from t_user &lt;/select&gt; &lt;!--3--&gt; &lt;!--count(1)和count(*)查询出来的结果是一样的，而使用count(字段名)查询的话，若某一条数据的当前字段名值为null，那么这条数据不会被算到count中--&gt; 3.4.4 查询一条数据为map集合/** * 根据用户id查询用户信息为map集合 */ Map&lt;String,Object&gt; getUserToMap(@Param(&quot;id&quot;) Integer id); &lt;!--Map&lt;String,Object&gt; getUserToMap(@Param(&quot;id&quot;) Integer id)--&gt; &lt;select id=&quot;getUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user where id = #&#123;id&#125; &lt;/select&gt; &lt;!--&#123;password=123456, gender=女, id=1, age=23, email=12345@qq.com, username=admin&#125;--&gt; 3.4.5 查询多条数据为map集合① 方式一 /** * 查询所有用户信息为map集合 * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，此时可以将这些map放在一个list集合中获取 */ List&lt;Map&lt;String,Object&gt;&gt; getAllUserToListMap(); &lt;!--List&lt;Map&lt;String,Object&gt;&gt; getAllUserToListMap()--&gt; &lt;select id=&quot;getAllUserToListMap&quot; resultType=&quot;map&quot;&gt; select * from t_user &lt;/select&gt; &lt;!-- [&#123;password=123456, gender=女, id=1, age=23, email=12345@qq.com, username=admin&#125;, &#123;password=123456, gender=女, id=3, age=23, email=12345@qq.com, username=zhangsan&#125;, &#123;password=123456, gender=男, id=4, age=20, email=123456@qq.com, username=lisi&#125;] --&gt; ② 方式二 /** * 查询所有用户信息为map集合 * 将表中的数据以map集合的方式查询，一条数据对应一个map；若有多条数据，就会产生多个map集合，并且最终要以一个map的方式返回数据，此时需要通过@MapKey注解设置为map集合的键，值是每条数据所对应的map集合 */ @MapKey(&quot;id&quot;) Map&lt;String,Object&gt; getAllUserToMap(); &lt;!--Map&lt;String,Object&gt; getAllUserToMap()--&gt; &lt;select id=&quot;getAllUserToMap&quot; resultType=&quot;map&quot;&gt; select * from t_user &lt;/select&gt; &lt;!-- &#123; 1=&#123;password=123456, gender=女, id=1, age=23, email=12345@qq.com, username=admin&#125;， 3=&#123;password=123456, gender=女, id=3, age=23, email=12345@qq.com, username=zhangsan&#125;, 4=&#123;password=123456, gender=男, id=4, age=20, email=123456@qq.com, username=lisi&#125;&#125; --&gt; 3.4.6 Mybatis中的映射别名Java常用类型在Mybatis中的映射别名 image-20220506225408569 image-20220506225428281 3.5 特殊SQL3.5.1 模糊查询//根据username模糊查询用户 List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username); 模糊查询中字符串的拼接有三种方式： &lt;!--List&lt;User&gt; getUserByLike(@Param(&quot;username&quot;) String username)--&gt; &lt;!--第一种：使用双引号加#&#123;&#125;的方式--&gt; &lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; &lt;!--这种方式IDE会报错，但是仍能查询--&gt; select * from t_user where username like &quot;%&quot;#&#123;username&#125;&quot;%&quot; &lt;/select&gt; &lt;!--第二种：使用单引号加$&#123;&#125;的方式--&gt; &lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; select * from t_user where username like &#39;%$&#123;username&#125;%&#39; &lt;/select&gt; &lt;!--第三种：使用concat函数--&gt; &lt;select id=&quot;getUserByLike&quot; resultType=&quot;User&quot;&gt; select * from t_user where username like concat(&#39;%&#39;,#&#123;username&#125;,&#39;%&#39;); &lt;/select&gt; @Test public void getUserByLike() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper sqlMapper = sqlSession.getMapper(SQLMapper.class); List&lt;User&gt; userList = sqlMapper.getUserByLike(&quot;a&quot;); System.out.println(userList); //[User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=3, username=&#39;zhangsan&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;] &#125; 3.5.2 批量删除//批量删除用户 //注意：这儿ids用几个id值拼接而成的字符串，如&quot;1,2,3&quot; Integer deleteMore(@Param(&quot;ids&quot;) String ids); &lt;!--Integer deleteMore(@Param(&quot;ids&quot;) String ids)--&gt; &lt;!--在mybatis中批量删除只能使用$&#123;&#125;，因为#&#123;&#125;在生成sql语句时后自动拼接单引号，这对于mysql的in语法是错误的，in中只能是数值，而不能是字符串--&gt; &lt;delete id=&quot;deleteMore&quot;&gt; delete from t_user where id in ($&#123;ids&#125;); &lt;/delete&gt; @Test public void deleteMore() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper sqlMapper = sqlSession.getMapper(SQLMapper.class); Integer deleteMore = sqlMapper.deleteMore(&quot;1,2,3&quot;); System.out.println(deleteMore); &#125; 3.5.3 动态设置表名//查询不同表中的用户 List&lt;User&gt; selectUserByTableName(@Param(&quot;tableName&quot;) String tableName); &lt;!--List&lt;User&gt; selectUserByTableName(@Param(&quot;tableName&quot;) String tableName)--&gt; &lt;!--同样，由于表名不是字符串，不需要单引号来进行拼接，所以动态设置表名也只能使用$&#123;&#125;的方式--&gt; &lt;select id=&quot;selectUserByTableName&quot; resultType=&quot;User&quot;&gt; select * from $&#123;tableName&#125; &lt;/select&gt; @Test public void selectUserByTableName() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper sqlMapper = sqlSession.getMapper(SQLMapper.class); List&lt;User&gt; userList = sqlMapper.selectUserByTableName(&quot;t_user&quot;); System.out.println(userList); //[User&#123;id=1, username=&#39;admin&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=3, username=&#39;zhangsan&#39;, password=&#39;123456&#39;, age=23, gender=&#39;女&#39;, email=&#39;12345@qq.com&#39;&#125;, User&#123;id=4, username=&#39;lisi&#39;, password=&#39;123456&#39;, age=20, gender=&#39;男&#39;, email=&#39;123456@qq.com&#39;&#125;] &#125; 3.5.4 添加功能中获取自增的主键应用场景：当我们新添加一个用户后，需要获取到这个用户的id，来进行其他操作，此时我们就可以通过这个功能来实现 //添加一个新用户 Integer insertUser(User user); &lt;!--Integer insertUser(User user)--&gt; &lt;!--useGeneratedKeys属性表示当前这个sql使用到了自动递增的主键；keyProperty表示将自增主键配置到传入的实体类对象参数的哪个属性--&gt; &lt;insert id=&quot;insertUser&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt; insert into t_user values (null, #&#123;username&#125;, #&#123;password&#125;, #&#123;age&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; @Test public void insertUser() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SQLMapper sqlMapper = sqlSession.getMapper(SQLMapper.class); User user = new User(); user.setId(null); user.setUsername(&quot;wangwu&quot;); user.setPassword(&quot;123456&quot;); user.setAge(32); user.setGender(&quot;男&quot;); user.setEmail(&quot;123456@qq.com&quot;); Integer insertUser = sqlMapper.insertUser(user); System.out.println(insertUser);//1 System.out.println(user);//User&#123;id=7, username=&#39;wangwu&#39;, password=&#39;123456&#39;, age=32, gender=&#39;男&#39;, email=&#39;123456@qq.com&#39;&#125;，可以发现新添加的用户的id被赋值了 &#125; 3.6 自定义映射ResultMap3.6.1 解决字段名和属性名的映射关系首先，我们新建两张数据表 员工表： image-20220507174414656 部门表： image-20220507174429777 然后，随便添加几条数据 然后，新建对应实体类 public class Employee &#123; private Integer eid; private String employeeName; private Integer employeeAge; private String employeeGender; private String employeeEmail; private Integer did; //省略构造方法、set、get、toString方法 &#125; public class Department &#123; private Integer did; private String departmentName; //省略构造方法、set、get、toString方法 &#125; 然后，编写mapper接口和映射文件进行测试 //获取所有员工信息 List&lt;Employee&gt; getAllEmployee(); &lt;!--List&lt;Employee&gt; getAllEmployee()--&gt; &lt;select id=&quot;getAllEmployee&quot; resultType=&quot;Employee&quot;&gt; select * from t_employee &lt;/select&gt; @Test public void getAllEmployee() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; allEmployee = employeeMapper.getAllEmployee(); allEmployee.forEach(employee -&gt; System.out.println(employee)); //Employee&#123;eid=1, employeeName=&#39;null&#39;, employeeAge=&#39;null&#39;, employeeGender=&#39;null&#39;, employeeEmail=&#39;null&#39;, did=1&#125; //Employee&#123;eid=2, employeeName=&#39;null&#39;, employeeAge=&#39;null&#39;, employeeGender=&#39;null&#39;, employeeEmail=&#39;null&#39;, did=1&#125; //Employee&#123;eid=3, employeeName=&#39;null&#39;, employeeAge=&#39;null&#39;, employeeGender=&#39;null&#39;, employeeEmail=&#39;null&#39;, did=2&#125; //Employee&#123;eid=4, employeeName=&#39;null&#39;, employeeAge=&#39;null&#39;, employeeGender=&#39;null&#39;, employeeEmail=&#39;null&#39;, did=2&#125; &#125; 可以发现，由于我们的实体类的部分属性名和数据库字段名不匹配，输出的实体类对象对应的属性就没有被赋值 ①解决方法一在查询时，给数据库字段取别名来让字段名和属性名映射一致 &lt;!--List&lt;Employee&gt; getAllEmployee()--&gt; &lt;select id=&quot;getAllEmployee&quot; resultType=&quot;Employee&quot;&gt; select eid,employee_name employeeName,employee_age employeeAge,employee_gender employeeGender,employee_email employeeEmail,did from t_employee &lt;/select&gt; @Test public void getAllEmployee() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; allEmployee = employeeMapper.getAllEmployee(); allEmployee.forEach(employee -&gt; System.out.println(employee)); //Employee&#123;eid=1, employeeName=&#39;zhangsan&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, did=1&#125; //Employee&#123;eid=2, employeeName=&#39;lisi&#39;, employeeAge=&#39;24&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, did=1&#125; //Employee&#123;eid=3, employeeName=&#39;wangwu&#39;, employeeAge=&#39;25&#39;, employeeGender=&#39;女&#39;, employeeEmail=&#39;12345@qq.com&#39;, did=2&#125; //Employee&#123;eid=4, employeeName=&#39;刘六&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, did=2&#125; &#125; 通过测试发现，实体类对象对应的属性都被赋值了 但是这种方法当字段名太多的情况下就显得非常麻烦，所以不建议使用 ②解决方法二在mybatis全局配置文件中配置一个**mapUnderscoreToCamelCase**即可 &lt;!--注意setting配置的位置在properties和typeAliases之间--&gt; &lt;settings&gt; &lt;!--此时，employee_name就会被解析成employeeName--&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; ③解决方法三通过自定义resultMap来解决 采用resultMap自定义映射进行配置时，无论字段名和属性名是否一致，建议将所有字段名和属性名的映射都进行配置，当然，如果我们确实用不到的属性也可以不配置 &lt;!--通过如下自定义resultMap的设置就可以解决字段名和属性名映射问题了--&gt; &lt;resultMap id=&quot;employeeResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;result property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;/resultMap&gt; &lt;!--List&lt;Employee&gt; getAllEmployee()--&gt; &lt;select id=&quot;getAllEmployee&quot; resultMap=&quot;employeeResultMap&quot;&gt; select * from t_employee &lt;/select&gt; resultMap：设置自定义映射，其属性： id：表示自定义映射的唯一标识 type：查询的数据要映射的实体类的类型 子标签： id：设置主键的映射关系 result：设置普通字段的映射关系 association：设置多对一的映射关系 collection：设置一对多的映射关系 属性： property：设置映射关系中实体类中的属性名 column：设置映射关系中表中的字段名 javaType：association中的属性，用于为配置对象类型的属性指定具体对象类型 3.6.2 多对一映射处理实际情况中，我们查询出的员工信息中会包含其部门的一些相关信息而非只有部门id；同样，当我们查询一个部门的信息时，我们应该可以看到一个部门中有哪些员工；此时就涉及到了实体类之间的关联关系，那么数据库表也会存在相同的关联关系，而多个不同员工可以属于同一个部门就是多对一关系 首先，我们需要改变实体类的属性设置 public class Employee &#123; private Integer eid; private String employeeName; private Integer employeeAge; private String employeeGender; private String employeeEmail; private Department department; &#125; public class Department &#123; private Integer did; private String departmentName; private List&lt;Employee&gt; employeeList; &#125; //均省略构造方法、set、get、toString方法 ①级联属性赋值方式处理将查询出来的信息的表字段名通过对象.属性名的方式进行配置映射 //获取所有员工及其对应部门信息 List&lt;Employee&gt; getEmployeeAndDepartment(); &lt;!--Employee getEmployeeAndDepartment()--&gt; &lt;resultMap id=&quot;EmployeeAndDepartmentResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;!--将查询出来的信息的表字段名通过&quot;对象.属性名&quot;的方式进行配置映射--&gt; &lt;result property=&quot;department.did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;department.departmentName&quot; column=&quot;department_name&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeAndDepartment&quot; resultMap=&quot;EmployeeAndDepartmentResultMap&quot;&gt; select * from t_employee left join t_department on t_employee.did = t_department.did &lt;/select&gt; @Test public void getEmployeeAndDepartment() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; employeeAndDepartment = employeeMapper.getEmployeeAndDepartment(); employeeAndDepartment.forEach(employee -&gt; System.out.println(employee)); //Employee&#123;eid=1, employeeName=&#39;zhangsan&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=Department&#123;did=1, departmentName=&#39;开发部&#39;, employeeList=null&#125;&#125; //Employee&#123;eid=2, employeeName=&#39;lisi&#39;, employeeAge=&#39;24&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=Department&#123;did=1, departmentName=&#39;开发部&#39;, employeeList=null&#125;&#125; //Employee&#123;eid=3, employeeName=&#39;wangwu&#39;, employeeAge=&#39;25&#39;, employeeGender=&#39;女&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=Department&#123;did=2, departmentName=&#39;运营部&#39;, employeeList=null&#125;&#125; //Employee&#123;eid=4, employeeName=&#39;刘六&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=Department&#123;did=2, departmentName=&#39;运营部&#39;, employeeList=null&#125;&#125; &#125; ②使用association处理通过association标签先为对象类型的属性进行映射配置，然后再将这个对象类型属性赋值给我们需要查询的对象 //获取所有员工及其对应部门信息 List&lt;Employee&gt; getEmployeeAndDepartment(); &lt;!--Employee getEmployeeAndDepartment()--&gt; &lt;resultMap id=&quot;EmployeeAndDepartmentResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;!--通过&quot;association&quot;标签先为对象类型的属性进行映射配置，然后再将这个对象类型属性赋值给我们需要查询的对象--&gt; &lt;!-- association:处理多对一的映射关系 property:需要处理多对一映射关系的属性名 javaType:该属性的类型 --&gt; &lt;association property=&quot;department&quot; javaType=&quot;Department&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;departmentName&quot; column=&quot;department_name&quot;/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeAndDepartment&quot; resultMap=&quot;EmployeeAndDepartmentResultMap&quot;&gt; select * from t_employee left join t_department on t_employee.did = t_department.did &lt;/select&gt; 经过测试发现，查询结果一样 ③分步查询处理先将一个我们需要查询的信息查询出来，然后再通过查询出来得到的信息去查询另一个信息 在本例中，我们先把员工的信息查询出来（其中包含了其所在部门的id即did），然后再通过查询出来的部门id去查询对应部门，再将查询出的部门赋值给员工信息中的部门对象属性 //EmployeeMapper接口 //查询员工及其部门信息 List&lt;Employee&gt; getEmployeeAndDepartment(); //DepartmentMapper接口 //根据部门d查询对应部门 Department getDepartmentById(@Param(&quot;did&quot;) Integer did); &lt;!--EmployeeMapper中--&gt; &lt;!--Employee getEmployeeAndDepartment()--&gt; &lt;resultMap id=&quot;EmployeeAndDepartmentResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;!-- select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId），即我们要使用哪个mapper映射文件中的哪个方法进行查询 column：将sql以及查询结果中的某个字段设置为分步查询的条件，这儿就代表我们将员工信息查询结果的did作为下一步查询部门的条件 --&gt; &lt;association property=&quot;department&quot; select=&quot;com.mybatis.mapper.DepartmentMapper.getDepartmentById&quot; column=&quot;did&quot;&gt;&lt;/association&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeAndDepartment&quot; resultMap=&quot;EmployeeAndDepartmentResultMap&quot;&gt; select * from t_employee &lt;/select&gt; &lt;!--DepartmentMapper中--&gt; &lt;!--Department getDepartmentById(@Param(&quot;did&quot;) Integer did)--&gt; &lt;resultMap id=&quot;departmentResultMap&quot; type=&quot;Department&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;departmentName&quot; column=&quot;department_name&quot;/&gt; &lt;!--这儿我们暂时不需要Department对象中的员工集合employeeList，所以不用配置映射--&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentById&quot; resultMap=&quot;departmentResultMap&quot;&gt; select * from t_department where did = #&#123;did&#125; &lt;/select&gt; 经过测试发现，查询结果一样 这种方式虽然看起来比较麻烦，但是在其他的mapper中编写查询语句是可以复用的，比如我们这儿新增的根据部门ID查询对应部门信息的方法不仅可以和查询员工信息的功能合起来使用还可以作为单独一个功能使用 ④延迟加载功能在mybatis核心配置文件中设置全局配置信息： &lt;settings&gt; &lt;!--配置延迟加载功能--&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; lazyLoadingEnabled：延迟加载的全局开关。当开启时，所有关联对象（即我们在分布查询中的第二步、第三步等）都会延迟加载 aggressiveLazyLoading：当开启时，任何方法的调用都会加载该对象的所有属性或是说都会执行分布查询所有步骤（当mybatis版本&lt;=3.4.1时该项默认为true） 配置好延迟加载时就可以实现按需加载，获取的数据是什么，就只会执行相应的sql 比如我们只需要获取员工信息，那么就只会执行查询员工信息的sql，而不会继续执行查询部门信息的sql；同样，如果我们需要部门信息，那么它才会把员工信息查询出来后再根据部门id去查询对应部门信息 如果有些需求不需要延迟加载，可通过association和collection中的fetchType属性设置当前的分步查询是否使用延迟加载，fetchType=&quot;lazy(延迟加载)|eager(立即加载)&quot; 测试： @Test public void getEmployeeAndDepartment() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); List&lt;Employee&gt; employeeAndDepartment = employeeMapper.getEmployeeAndDepartment(); //此时我们只需要获取员工的名字 employeeAndDepartment.forEach(employee -&gt; System.out.println(employee.getEmployeeName())); &#125; image-20220508195606762 可以发现，开启延迟加载时，当我们只需获取员工名字，那么它只会执行分布查询中的第一步，即查询出员工信息 经过测试，当我们在mybatis-config.xml全局配置文件中开启延迟加载时和在全局配置文件中关闭延迟加载但在mapper映射文件的某个方法中加上fetchType=lazy时都会出现以上情况（第二种情况视频老师是说的是必须要在全局配置文件开启延迟加载后设置fetchType才有用，但是是错的，我亲自测试仍然可以，至少在我使用的mybatis3.5.9版本是这样的） 而当关闭延迟加载后，它又会将分布查询所有步骤进行执行 image-20220508192500784 经过测试，当我们在mybatis-config.xml全局配置文件中关闭延迟加载时和在全局配置文件中开启延迟加载但在mapper映射文件的某个方法中加上fetchType=eager时也都会出现以上情况 总结： 我们可以在全局配置文件开启延迟加载的情况下利用fetchType=eager使某一个方法不延迟加载，也可以在全局配置文件关闭延迟加载的情况下利用fetchType=lazy使某一个方法延迟加载 lazyLoadingEnabled是针对所有方法的延迟加载功能，fetchType是针对某一个方法的延迟加载功能 3.6.3 一对多映射处理一个部门中有多个员工就是一对多关系 ①使用collection处理//通过部门id查询对应部门及其包含的员工 Department getDepartmentById(@Param(&quot;did&quot;) Integer did); &lt;!--Department getDepartmentById(@Param(&quot;did&quot;) Integer did)--&gt; &lt;resultMap id=&quot;departmentResultMap&quot; type=&quot;Department&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;departmentName&quot; column=&quot;department_name&quot;/&gt; &lt;!-- ofType：设置collection标签所处理的集合属性中存储数据的类型 --&gt; &lt;collection property=&quot;employeeList&quot; ofType=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentById&quot; resultMap=&quot;departmentResultMap&quot;&gt; select * from t_department left join t_employee on t_department.did = t_employee.did where t_department.did = #&#123;did&#125; &lt;/select&gt; @Test public void getDepartmentById() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DepartmentMapper departmentMapper = sqlSession.getMapper(DepartmentMapper.class); Department department = departmentMapper.getDepartmentById(1); System.out.println(department); //Department&#123;did=1, departmentName=&#39;开发部&#39;, employeeList=[Employee&#123;eid=1, employeeName=&#39;zhangsan&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=null&#125;, Employee&#123;eid=2, employeeName=&#39;lisi&#39;, employeeAge=&#39;24&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=null&#125;]&#125; &#125; ②分步查询//DepartmentMapper接口中 //通过部门id查询对应部门及其包含的员工 Department getDepartmentById(@Param(&quot;did&quot;) Integer did); //EmployeeMapper接口中 //根据部门id查询员工信息 List&lt;Employee&gt; getDepartmentAndEmployeeByDid(@Param(&quot;did&quot;) Integer did); &lt;!--Department getDepartmentById(@Param(&quot;did&quot;) Integer did)--&gt; &lt;resultMap id=&quot;departmentResultMap&quot; type=&quot;Department&quot;&gt; &lt;id property=&quot;did&quot; column=&quot;did&quot;/&gt; &lt;result property=&quot;departmentName&quot; column=&quot;department_name&quot;/&gt; &lt;!-- select：设置分步查询，查询某个属性的值的sql的标识（namespace.sqlId），即通过哪个方法查询 column：将sql以及查询结果中的某个字段设置为分步查询的条件，即查询条件 与多对一映射处理的分布查询一样的效果 --&gt; &lt;collection property=&quot;employeeList&quot; select=&quot;com.mybatis.mapper.EmployeeMapper.getDepartmentAndEmployeeByDid&quot; column=&quot;did&quot;&gt;&lt;/collection&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentById&quot; resultMap=&quot;departmentResultMap&quot;&gt; select * from t_department where did = #&#123;did&#125; &lt;/select&gt; &lt;!--List&lt;Employee&gt; getDepartmentAndEmployeeByDid(@Param(&quot;did&quot;) Integer did)--&gt; &lt;resultMap id=&quot;departmentAndEmployeeByDidResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getDepartmentAndEmployeeByDid&quot; resultMap=&quot;departmentAndEmployeeByDidResultMap&quot;&gt; select * from t_employee where did = #&#123;did&#125; &lt;/select&gt; 经过测试发现，查询结果一样 同样，这儿也可以配置延迟加载的功能，具体参考多对一映射处理中的延迟加载功能部分 3.7 动态SQLMybatis框架的动态SQL技术是一种根据特定条件动态拼装SQL语句的功能，它存在的意义是为了解决拼接SQL语句字符串时的痛点问题 3.7.1 if if标签可通过test属性的表达式进行判断，若表达式的结果为true，则标签中的内容会被拼接到sql语句中；反之标签中的内容不会被拼接 //根据条件批量查询员工 List&lt;Employee&gt; getEmployeeListByIF(Employee employee); &lt;!--List&lt;Employee&gt; getEmployeeListByIF(Employee employee)--&gt; &lt;resultMap id=&quot;employeeListResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeListByIF&quot; resultMap=&quot;employeeListResultMap&quot;&gt; select * from t_employee where 1=1 &lt;if test=&quot;employeeName != null and employeeName != &#39;&#39;&quot;&gt; and employee_name = #&#123;employeeName&#125; &lt;/if&gt; &lt;if test=&quot;employeeAge != null and employeeAge != &#39;&#39;&quot;&gt; and employee_age = #&#123;employeeAge&#125; &lt;/if&gt; &lt;if test=&quot;employeeGender != null and employeeGender != &#39;&#39;&quot;&gt; and employee_gender = #&#123;employeeGender&#125; &lt;/if&gt; &lt;if test=&quot;employeeEmail != null and employeeEmail != &#39;&#39;&quot;&gt; and employee_email = #&#123;employeeEmail&#125; &lt;/if&gt; &lt;/select&gt; @Test public void getEmployeeListByIF() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); Employee employee = new Employee(); employee.setEmployeeAge(23); employee.setEmployeeGender(&quot;男&quot;); employee.setEmployeeEmail(&quot;12345@qq.com&quot;); List&lt;Employee&gt; employeeList = mapper.getEmployeeListByIF(employee); System.out.println(employeeList); //[Employee&#123;eid=1, employeeName=&#39;zhangsan&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=null&#125;, Employee&#123;eid=4, employeeName=&#39;刘六&#39;, employeeAge=&#39;23&#39;, employeeGender=&#39;男&#39;, employeeEmail=&#39;12345@qq.com&#39;, department=null&#125;] &#125; image-20220508215205570 通过sql语句可以发现，值为null的属性名未被拼接到sql语句中 3.7.2 where where和if一般结合使用： 若where标签中的if条件都不满足，则where标签没有任何功能，即不会添加where关键字 若where标签中的if条件满足，则where标签会自动添加where关键字，并将条件最前方多余的and去掉 注意：where标签不能将sql语句中条件后面多余的and去掉 仍然使用上方的例子根据条件批量查询员工，但是&lt;select&gt;标签中where我们使用&lt;where&gt;标签代替 //根据条件批量查询员工 List&lt;Employee&gt; getEmployeeListByWhere(Employee employee); &lt;!--List&lt;Employee&gt; getEmployeeListByWhere(Employee employee)--&gt; &lt;resultMap id=&quot;employeeListResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeListByWhere&quot; resultMap=&quot;employeeListResultMap&quot;&gt; select * from t_employee &lt;where&gt; &lt;if test=&quot;employeeName != null and employeeName != &#39;&#39;&quot;&gt; and employee_name = #&#123;employeeName&#125; &lt;/if&gt; &lt;if test=&quot;employeeAge != null and employeeAge != &#39;&#39;&quot;&gt; and employee_age = #&#123;employeeAge&#125; &lt;/if&gt; &lt;if test=&quot;employeeGender != null and employeeGender != &#39;&#39;&quot;&gt; and employee_gender = #&#123;employeeGender&#125; &lt;/if&gt; &lt;if test=&quot;employeeEmail != null and employeeEmail != &#39;&#39;&quot;&gt; and employee_email = #&#123;employeeEmail&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt; image-20220508215817851 通过测试发现，mybatis为sql语句动态添加了where子句，并且还为我们将条件中多余的and去掉了；当然，如果我们&lt;where&gt;标签中的条件都不成立，那么sql语句中也不会有where子句 3.7.3 trim trim用于去掉或添加标签中的内容 常用属性： prefix：在trim标签中的内容的前面添加某些内容 prefixOverrides：在trim标签中的内容的前面去掉某些内容 suffix：在trim标签中的内容的后面添加某些内容 suffixOverrides：在trim标签中的内容的后面去掉某些内容 仍用上方的例子根据条件批量查询员工 &lt;!--List&lt;Employee&gt; getEmployeeListByTrim(Employee employee)--&gt; &lt;resultMap id=&quot;employeeListResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeListByTrim&quot; resultMap=&quot;employeeListResultMap&quot;&gt; select * from t_employee &lt;trim prefix=&quot;where&quot; suffixOverrides=&quot;and|or&quot;&gt; &lt;if test=&quot;employeeName != null and employeeName != &#39;&#39;&quot;&gt; employee_name = #&#123;employeeName&#125; and &lt;/if&gt; &lt;if test=&quot;employeeAge != null and employeeAge != &#39;&#39;&quot;&gt; employee_age = #&#123;employeeAge&#125; or &lt;/if&gt; &lt;if test=&quot;employeeGender != null and employeeGender != &#39;&#39;&quot;&gt; employee_gender = #&#123;employeeGender&#125; and &lt;/if&gt; &lt;if test=&quot;employeeEmail != null and employeeEmail != &#39;&#39;&quot;&gt; employee_email = #&#123;employeeEmail&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; image-20220508221117483 image-20220508221148677 通过测试发现，当if中有满足的条件，则&lt;trim&gt;标签会自动拼接上前缀where，并且会自动去除设置的后缀重写的and或or；而当if中没有满足的条件时，&lt;trim&gt;则不会添加前缀where 3.7.4 choose、when、otherwise choose、when、otherwise相当于if…else if..else when至少要有一个，otherwise最多只能有一个 当其中一个条件满足时其他条件就不再进行判断了，所以这类动态SQL拼接后最多只会有一个条件 这儿仍然使用上方的例子根据条件批量查询员工 &lt;!--List&lt;Employee&gt; getEmployeeListByChoose(Employee employee)--&gt; &lt;resultMap id=&quot;employeeListResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeListByChoose&quot; resultMap=&quot;employeeListResultMap&quot;&gt; select * from t_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;employeeName != null and employeeName != &#39;&#39;&quot;&gt; employee_name = #&#123;employeeName&#125; &lt;/when&gt; &lt;when test=&quot;employeeAge != null and employeeAge != &#39;&#39;&quot;&gt; employee_age = #&#123;employeeAge&#125; &lt;/when&gt; &lt;when test=&quot;employeeGender != null and employeeGender != &#39;&#39;&quot;&gt; employee_gender = #&#123;employeeGender&#125; &lt;/when&gt; &lt;when test=&quot;employeeEmail != null and employeeEmail != &#39;&#39;&quot;&gt; employee_email = #&#123;employeeEmail&#125; &lt;/when&gt; &lt;otherwise&gt; did = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; image-20220508222708090 image-20220508222815433 3.7.5 foreach foreach标签的属性： collection：设置要循环的数组或集合 item：表示集合或数组中的每一个数据 separator：设置循环体之间的分隔符 open：设置foreach标签中的内容的开始符 close：设置foreach标签中的内容的结束符 //批量添加新员工 Integer insertEmployeeList(@Param(&quot;employeeList&quot;) List&lt;Employee&gt; employeeList); //批量删除员工 Integer deleteEmployeeByIds(@Param(&quot;eids&quot;) int[] eids); &lt;!--Integer insertEmployeeList(@Param(&quot;employeeList&quot;) List&lt;Employee&gt; employeeList)--&gt; &lt;insert id=&quot;insertEmployeeList&quot;&gt; insert into t_employee values &lt;foreach collection=&quot;employeeList&quot; item=&quot;employee&quot; separator=&quot;,&quot;&gt; (null,#&#123;employee.employeeName&#125;,#&#123;employee.employeeAge&#125;,#&#123;employee.employeeGender&#125;,#&#123;employee.employeeEmail&#125;,null) &lt;/foreach&gt; &lt;/insert&gt; &lt;!--Integer deleteEmployeeByIds(@Param(&quot;eids&quot;) int[] eids)--&gt; &lt;!--第一种方式，使用in--&gt; &lt;delete id=&quot;deleteEmployeeByIds&quot;&gt; delete from t_employee where eid in &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;,&quot; open=&quot;(&quot; close=&quot;)&quot;&gt; #&#123;eid&#125; &lt;/foreach&gt; &lt;/delete&gt; &lt;!--第二种方式，使用or--&gt; &lt;delete id=&quot;deleteEmployeeByIds&quot;&gt; delete from t_employee where &lt;foreach collection=&quot;eids&quot; item=&quot;eid&quot; separator=&quot;or&quot;&gt; eid = #&#123;eid&#125; &lt;/foreach&gt; &lt;/delete&gt; @Test public void insertEmployeeList() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); List&lt;Employee&gt; employeeList = new ArrayList&lt;&gt;(); employeeList.add(new Employee(null,&quot;李四&quot;,30,&quot;女&quot;,&quot;1234@qq.com&quot;,null)); employeeList.add(new Employee(null,&quot;王五&quot;,27,&quot;男&quot;,&quot;1234@qq.com&quot;,null)); Integer list = mapper.insertEmployeeList(employeeList); System.out.println(list); &#125; @Test public void deleteEmployeeByIds() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); DynamicSQLMapper mapper = sqlSession.getMapper(DynamicSQLMapper.class); int[] eids = new int[]&#123;5,6,7,8&#125;;//即删除eid为5、6、7、8的员工 Integer delete = mapper.deleteEmployeeByIds(eids); System.out.println(delete); &#125; 批量添加新员工结果： image-20220508230802136 批量删除新员工结果： image-20220508231156340 image-20220508231816412 由于这里我测试是添加了两条数据后eid为分别5和6，然后再测试的第一种删除方式，此时就把5和6删除了；然后我又添加了两条数据到表中，eid分别为7和8，再测试了第二种删除的方法，此时又把7和8删除了。所以这两种方式我这儿删除的结果影响行数都是2，正常情况下应该是5、6、7、8都会被删除，同时删除影响行数返回4 3.7.6 sql sql片段，可以记录一段公共sql片段，在使用的地方通过include标签进行引入 通过&lt;sql&gt;标签记录一段公共sql片段，然后在需要的地方使用&lt;include&gt;进行引入 &lt;!--定义sql片段--&gt; &lt;sql id=&quot;employeeColumns&quot;&gt; eid,employee_name,employee_age,employee_gender,employee_email &lt;/sql&gt; &lt;!--List&lt;Employee&gt; getEmployeeListByChoose(Employee employee)--&gt; &lt;resultMap id=&quot;employeeListResultMap&quot; type=&quot;Employee&quot;&gt; &lt;id property=&quot;eid&quot; column=&quot;eid&quot;/&gt; &lt;result property=&quot;employeeName&quot; column=&quot;employee_name&quot;/&gt; &lt;result property=&quot;employeeAge&quot; column=&quot;employee_age&quot;/&gt; &lt;result property=&quot;employeeGender&quot; column=&quot;employee_gender&quot;/&gt; &lt;result property=&quot;employeeEmail&quot; column=&quot;employee_email&quot;/&gt; &lt;/resultMap&gt; &lt;select id=&quot;getEmployeeListByChoose&quot; resultMap=&quot;employeeListResultMap&quot;&gt; &lt;!--引入sql片段，refid的值为被引入的sql片段的id--&gt; select &lt;include refid=&quot;employeeColumns&quot;/&gt; from t_employee &lt;where&gt; &lt;choose&gt; &lt;when test=&quot;employeeName != null and employeeName != &#39;&#39;&quot;&gt; employee_name = #&#123;employeeName&#125; &lt;/when&gt; &lt;when test=&quot;employeeAge != null and employeeAge != &#39;&#39;&quot;&gt; employee_age = #&#123;employeeAge&#125; &lt;/when&gt; &lt;when test=&quot;employeeGender != null and employeeGender != &#39;&#39;&quot;&gt; employee_gender = #&#123;employeeGender&#125; &lt;/when&gt; &lt;when test=&quot;employeeEmail != null and employeeEmail != &#39;&#39;&quot;&gt; employee_email = #&#123;employeeEmail&#125; &lt;/when&gt; &lt;otherwise&gt; did = 1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; image-20220508224937827 四、Mybatis缓存4.1 Mybatis一级缓存4.1.1 一级缓存说明一级缓存是SqlSession级别的，通过同一个SqlSession查询的数据会被缓存，下次查询相同的数据，就会从缓存中直接获取，不会从数据库重新访问 案例测试： &lt;!--Employee getEmployeeByID(@Param(&quot;eid&quot;) Integer eid)--&gt; &lt;select id=&quot;getEmployeeByID&quot; resultType=&quot;Employee&quot;&gt; select * from t_employee where eid = #&#123;eid&#125; &lt;/select&gt; @Test public void getEmployeeByID() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); Employee employee = mapper.getEmployeeByID(1); System.out.println(employee); Employee employee2 = mapper.getEmployeeByID(1); System.out.println(employee2); //此时我们的employee和employee2都是查询eid为1的员工信息 &#125; image-20220509203238586 通过测试结果发现，当我们两次都查询eid为1的员工时，sql语句只执行了一遍（因为我没配置对象属性和字段的映射，所以查询结果中那些属性都为null） 可能有小伙伴会说，这两个对象都是通过同一个mapper调用方法获取的，不能说明Mybatis一级缓存是SqlSession级别的，那么我们再创建一个新的mapper进行测试 @Test public void getEmployeeByID() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); CacheMapper mapper2 = sqlSession.getMapper(CacheMapper.class); Employee employee = mapper.getEmployeeByID(1); System.out.println(employee); Employee employee2 = mapper2.getEmployeeByID(1); System.out.println(employee2); &#125; image-20220509203933634 经过测试，sql语句仍然是只执行了一遍，说明同一个SqlSession创建的不同mapper查询的数据同样是从缓存中进行获取的 那么我们创建一个新的SqlSession，再通过这个对象创建一个mapper进行测试 @Test public void getEmployeeByID() &#123; SqlSession sqlSession = SqlSessionUtils.getSqlSession(); SqlSession sqlSession2 = SqlSessionUtils.getSqlSession(); CacheMapper mapper = sqlSession.getMapper(CacheMapper.class); CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class); Employee employee = mapper.getEmployeeByID(1); System.out.println(employee); Employee employee2 = mapper2.getEmployeeByID(1); System.out.println(employee2); &#125; image-20220509204132786 经过测试发现，这次sql语句就执行了两次，原因是我们调用这两次查询方法的mapper是来自不同SqlSession对象创建的，所以就不存在缓存一说了 总结：Mybatis一级缓存是SqlSession级别的 4.1.2 一级缓存失效的四种情况 不同的SqlSession对应不同的一级缓存（即我们上面做的案例） 同一个SqlSession但是查询条件不同 同一个SqlSession两次查询期间执行了任何一次增删改操作 同一个SqlSession两次查询期间手动清空了缓存（执行sqlsession.clearCache()方法） 4.2 Mybatis二级缓存4.2.1 二级缓存说明二级缓存是SqlSessionFactory级别，通过同一个SqlSessionFactory创建的SqlSession查询的结果会被缓存；此后若再次执行相同的查询语句，结果就会从缓存中获取 由于SqlSession是由SqlSessionFactory创建出来的，所以二级缓存的范围也就比一级缓存大，即同一个SqlSessionFactory创建出来的不同SqlSession中的查询都可以共用二级缓存中的数据；而一级缓存中的数据只能是同一个SqlSession中的查询才能共用 二级缓存开启的条件： 在核心配置文件中，设置全局配置属性cacheEnabled=&quot;true&quot;，默认为true，不需要设置 在映射文件中设置标签&lt;cache/&gt; 二级缓存必须在SqlSession关闭或提交之后有效 查询的数据所转换的实体类类型必须实现序列化的接口 案例测试： &lt;!--首先按照开启条件在映射文件中添加&lt;cache/&gt;标签--&gt; &lt;cache/&gt; //查询数据对应的实体类实现序列化的接口 public class Employee implements Serializable &#123;&#125; @Test public void testTwoCache()&#123; try &#123; InputStream resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); SqlSession sqlSession1 = sqlSessionFactory.openSession(true); SqlSession sqlSession2 = sqlSessionFactory.openSession(true); CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class); CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class); Employee employee1 = mapper1.getEmployeeByID(1); Employee employee2 = mapper2.getEmployeeByID(1); System.out.println(employee1); System.out.println(employee2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; image-20220509211114823 以上测试中，我们没有将SqlSession关闭，通过测试结果发现，sql语句执行了两次，表明两次查询都是从数据库查询出来的 这时，可能有人会说，我们不是设置了自动提交吗，满足开启二级缓存的条件为什么还是没有使用二级缓存？我看弹幕有人说是因为SqlSession的自动提交是在整个程序运行完之后，所以就没有完全满足开启二级缓存的条件，那么第一次查询到结果后并没有将结果放到二级缓存中，第二次查询就也会从数据库中去查询 于是，我将SqlSession自动提交关闭了，进行了手动提交（不关闭自动提交，手动关闭SqlSession也可以） @Test public void testTwoCache()&#123; try &#123; InputStream resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); SqlSession sqlSession1 = sqlSessionFactory.openSession(); SqlSession sqlSession2 = sqlSessionFactory.openSession(); CacheMapper mapper1 = sqlSession1.getMapper(CacheMapper.class); CacheMapper mapper2 = sqlSession2.getMapper(CacheMapper.class); Employee employee1 = mapper1.getEmployeeByID(1); sqlSession1.commit(); Employee employee2 = mapper2.getEmployeeByID(1); sqlSession2.commit(); System.out.println(employee1); System.out.println(employee2); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; image-20220509211943215 通过测试结果发现，sql语句只执行了一次，说明从数据库查询只进行了一次，二级缓存开启成功 而且，通过图中倒数第三行可以发现，第二查询的缓存命中率为0.5，也说明了第二次查询是直接从缓存中获取的数据 4.2.2 二级缓存失效的情况两次查询之间执行了任意的增删改，会使一级和二级缓存同时失效 4.2.3 二级缓存相关配置在mapper配置文件中添加的cache标签可以设置一些属性： eviction属性：缓存回收策略（默认的是 LRU） LRU（Least Recently Used） – 最近最少使用的：移除最长时间不被使用的对象。 FIFO（First in First out） – 先进先出：按对象进入缓存的顺序来移除它们 SOFT – 软引用：移除基于垃圾回收器状态和软引用规则的对象。 WEAK – 弱引用：更积极地移除基于垃圾收集器状态和弱引用规则的对象 flushInterval属性：刷新间隔，单位毫秒。默认情况是不设置，也就是没有刷新间隔，缓存仅仅调用语句（增删改语句）时刷新 size属性：引用数目，正整数。代表缓存最多可以存储多少个对象，太大容易导致内存溢出 readOnly属性：只读，true/false（这儿对于从缓存中查询到的对象是否能被修改其实是建议，只是出于对数据安全性和一致性的考虑） true：只读缓存；会给所有调用者直接返回缓存数据对象本身，因此这些对象不能被修改（这种情况查询出来的对象不能修改，如果修改了那么缓存中的对象也会被修改）。这提供了很重要的性能优势 false：读写缓存；会返回缓存对象的拷贝（通过序列化）（这种情况查询出来的对象可修改，而此时修改的是拷贝出来的对象，缓存中的对象不会变）。这会慢一些，但是安全，因此默认是false 4.3 Mybatis缓存查询顺序 先查询二级缓存，因为二级缓存中可能会有其他程序已经查出来的数据，可以拿来直接使用。 如果二级缓存没有命中，再查询一级缓存 如果一级缓存也没有命中，则查询数据库 SqlSession关闭之后，一级缓存中的数据会写入二级缓存 4.4 整合第三方缓存EHCache了解即可，最终实现的功能都是一样的 4.4.1 添加依赖&lt;!-- Mybatis EHCache整合包 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.caches&lt;/groupId&gt; &lt;artifactId&gt;mybatis-ehcache&lt;/artifactId&gt; &lt;version&gt;1.2.2&lt;/version&gt; &lt;/dependency&gt; &lt;!-- slf4j日志门面的一个具体实现 --&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; 导入依赖后的各个依赖jar包 image-20220509220850298 4.4.2 各jar包功能 jar包名称 作用 mybatis-ehcache Mybatis和EHCache的整合包 ehcache EHCache核心包 slf4j-api SLF4J日志门面包-接口 logback-classic 支持SLF4J门面接口的一个具体实现 4.4.3 创建EHCache的配置文件ehcache.xml配置文件名必须为ehcache.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; &lt;ehcache xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;../config/ehcache.xsd&quot;&gt; &lt;!-- ehcache缓存的数据在磁盘中的保存路径 --&gt; &lt;diskStore path=&quot;D:\\ehcache&quot;/&gt; &lt;defaultCache maxElementsInMemory=&quot;1000&quot; maxElementsOnDisk=&quot;10000000&quot; eternal=&quot;false&quot; overflowToDisk=&quot;true&quot; timeToIdleSeconds=&quot;120&quot; timeToLiveSeconds=&quot;120&quot; diskExpiryThreadIntervalSeconds=&quot;120&quot; memoryStoreEvictionPolicy=&quot;LRU&quot;&gt; &lt;/defaultCache&gt; &lt;/ehcache&gt; 4.4.4 设置二级缓存的类型在mapper映射文件中设置&lt;cache&gt;的type属性，表示二级缓存的类型，默认为mybatis本身的二级缓存 &lt;cache type=&quot;org.mybatis.caches.ehcache.EhcacheCache&quot;/&gt; 4.4.5 加入logback日志存在SLF4J时，作为简易日志的log4j将失效，此时我们需要借助SLF4J的具体实现logback来打印日志 创建logback的配置文件logback.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;configuration debug=&quot;true&quot;&gt; &lt;!-- 指定日志输出的位置 --&gt; &lt;appender name=&quot;STDOUT&quot; class=&quot;ch.qos.logback.core.ConsoleAppender&quot;&gt; &lt;encoder&gt; &lt;!-- 日志输出的格式 --&gt; &lt;!-- 按照顺序分别是：时间、日志级别、线程名称、打印日志的类、日志主体内容、换行 --&gt; &lt;pattern&gt;[%d&#123;HH:mm:ss.SSS&#125;] [%-5level] [%thread] [%logger] [%msg]%n&lt;/pattern&gt; &lt;/encoder&gt; &lt;/appender&gt; &lt;!-- 设置全局日志级别。日志级别按顺序分别是：DEBUG、INFO、WARN、ERROR --&gt; &lt;!-- 指定任何一个日志级别都只打印当前级别和后面级别的日志。 --&gt; &lt;root level=&quot;DEBUG&quot;&gt; &lt;!-- 指定打印日志的appender，这里通过&quot;STDOUT&quot;引用了前面配置的appender --&gt; &lt;appender-ref ref=&quot;STDOUT&quot; /&gt; &lt;/root&gt; &lt;!-- 根据特殊需求指定局部日志级别 --&gt; &lt;logger name=&quot;com.atguigu.crowd.mapper&quot; level=&quot;DEBUG&quot;/&gt; &lt;/configuration&gt; 4.4.6 EHCache配置文件说明 属性名 是否必须 作用 maxElementsInMemory 是 在内存中缓存的element的最大数目 maxElementsOnDisk 是 在磁盘上缓存的element的最大数目，若是0表示无穷大 eternal 是 设定缓存的elements是否永远不过期。 如果为true，则缓存的数据始终有效， 如果为false那么还要根据timeToIdleSeconds、timeToLiveSeconds判断 overflowToDisk 是 设定当内存缓存溢出的时候是否将过期的element缓存到磁盘上 timeToIdleSeconds 否 当缓存在EhCache中的数据前后两次访问的时间超过timeToIdleSeconds的属性取值时， 这些数据便会删除，默认值是0,也就是可闲置时间无穷大 timeToLiveSeconds 否 缓存element的有效生命期，默认是0.,也就是element存活时间无穷大 diskSpoolBufferSizeMB 否 DiskStore(磁盘缓存)的缓存区大小。默认是30MB。每个Cache都应该有自己的一个缓冲区 diskPersistent 否 在VM重启的时候是否启用磁盘保存EhCache中的数据，默认是false。 diskExpiryThreadIntervalSeconds 否 磁盘缓存的清理线程运行间隔，默认是120秒。每个120s， 相应的线程会进行一次EhCache中数据的清理工作 memoryStoreEvictionPolicy 否 当内存缓存达到最大，有新的element加入的时候， 移除缓存中element的策略。 默认是LRU（最近最少使用），可选的有LFU（最不常使用）和FIFO（先进先出） 五、Mybatis逆向工程正向工程：先创建Java实体类，由框架负责根据实体类生成数据库表。Hibernate是支持正向工程的 逆向工程：先创建数据库表，由框架负责根据数据库表，反向生成如下资源： Java实体类 Mapper接口 Mapper映射文件 5.1 创建逆向工程的步骤 重新创建了一个新模块 5.1.1 添加依赖和插件&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.9&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.17&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;!--这个mysql依赖也得加上，不然等会儿QBC查询会报错。虽然在build中引入了插件所需要的mysql驱动，但是那个只是用于逆向生成时连接数据库使用的，这个是后面我们测试需要用的--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;!-- 控制Maven在构建过程中相关配置 --&gt; &lt;build&gt; &lt;!-- 构建过程中用到的插件 --&gt; &lt;plugins&gt; &lt;!-- 具体插件，逆向工程的操作是以构建过程中插件形式出现的 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-maven-plugin&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;!-- 插件的依赖 --&gt; &lt;dependencies&gt; &lt;!-- 逆向工程的核心依赖 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.4.1&lt;/version&gt; &lt;/dependency&gt; &lt;!-- 数据库连接池 --&gt; &lt;dependency&gt; &lt;groupId&gt;com.mchange&lt;/groupId&gt; &lt;artifactId&gt;c3p0&lt;/artifactId&gt; &lt;version&gt;0.9.5.5&lt;/version&gt; &lt;/dependency&gt; &lt;!-- MySQL驱动 --&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.28&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt; 5.1.2 创建mybatis-config.xml配置文件创建mybatis全局配置文件mybatis-config.xml和数据库配置文件jdbc.properties 配置内容根据自己需求进行增删改 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt; &lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt; &lt;configuration&gt; &lt;!--引入properties文件--&gt; &lt;properties resource=&quot;jdbc.properties&quot;/&gt; &lt;settings&gt; &lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt; &lt;setting name=&quot;lazyLoadingEnabled&quot; value=&quot;true&quot;/&gt; &lt;/settings&gt; &lt;!--设置类型别名--&gt; &lt;typeAliases&gt; &lt;package name=&quot;com.mybatis.entity&quot;/&gt; &lt;/typeAliases&gt; &lt;!--设置连接数据库的环境--&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driver&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;!--引入映射文件--&gt; &lt;mappers&gt; &lt;package name=&quot;com.mybatis.mapper&quot;/&gt; &lt;/mappers&gt; &lt;/configuration&gt; 5.1.3 创建逆向工程的配置文件 文件名必须是generatorConfig.xml &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!DOCTYPE generatorConfiguration PUBLIC &quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;&gt; &lt;generatorConfiguration&gt; &lt;!-- targetRuntime: 执行生成的逆向工程的版本 MyBatis3Simple: 生成基本的CRUD（简洁版） MyBatis3: 生成带条件的CRUD（完善版） 指定生成的版本不同生成出来的文件内容也不同 --&gt; &lt;context id=&quot;DB2Tables&quot; targetRuntime=&quot;MyBatis3Simple&quot;&gt; &lt;!-- 数据库的连接信息 --&gt; &lt;jdbcConnection driverClass=&quot;com.mysql.cj.jdbc.Driver&quot; connectionURL=&quot;jdbc:mysql://localhost:3306/mybatis&quot; userId=&quot;root&quot; password=&quot;root&quot;/&gt; &lt;!-- javaBean的生成策略--&gt; &lt;!-- targetPackage：生成包 targetProject：生成位置 enableSubPackages：开启生成子包功能 trimStrings：开启去除字段名中的空格 --&gt; &lt;javaModelGenerator targetPackage=&quot;com.mybatis.entity&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;property name=&quot;trimStrings&quot; value=&quot;true&quot; /&gt; &lt;/javaModelGenerator&gt; &lt;!-- SQL映射文件的生成策略 --&gt; &lt;sqlMapGenerator targetPackage=&quot;com.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\resources&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/sqlMapGenerator&gt; &lt;!-- Mapper接口的生成策略 --&gt; &lt;!--type:该属性用于选择一个预定义的客户端代码（可以理解为Mapper接口）生成器，用户可以自定义实现 MyBatis3: ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件 MIXEDMAPPER:XML和注解的混合形式，(上面这种情况中的)SqlProvider注解方法会被XML替代 XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。 MyBatis3Simple: ANNOTATEDMAPPER:基于注解的Mapper接口，不会有对应的XML映射文件 XMLMAPPER:所有的方法都在XML中，接口调用依赖XML文件。 --&gt; &lt;javaClientGenerator type=&quot;XMLMAPPER&quot; targetPackage=&quot;com.mybatis.mapper&quot; targetProject=&quot;.\\src\\main\\java&quot;&gt; &lt;property name=&quot;enableSubPackages&quot; value=&quot;true&quot; /&gt; &lt;/javaClientGenerator&gt; &lt;!-- 逆向分析的表 --&gt; &lt;!-- tableName设置为*号，可以对应所有表，此时不写domainObjectName --&gt; &lt;!-- domainObjectName属性指定生成出来的实体类的类名 --&gt; &lt;table tableName=&quot;t_employee&quot; domainObjectName=&quot;Employee&quot;/&gt; &lt;table tableName=&quot;t_department&quot; domainObjectName=&quot;Department&quot;/&gt; &lt;/context&gt; &lt;/generatorConfiguration&gt; 5.1.4 执行MBG插件的generate目标执行mybatis-generator插件之前，除了配置文件以外没有其他文件 image-20220509231034731 双击执行插件 image-20220509231125787 执行mybatis-generator插件之后，java实体类、mapper接口、mapper映射文件都被生成出来了。这里就不展示文件中的内容了 生成的简洁版： image-20220509231220994 生成的完善版：在entity包中多了两个Example类，这个是用于条件查询的类，里面包含了条件查询的各种方法，并且mapper接口文件和mapper映射文件中的内容也更丰富完善 image-20220509233307763 5.2 QBC查询QBC（Query By Condition）：根据条件查询 //这里只测试部分功能，其他就可以自己继续研究 @Test public void testQBC()&#123; try &#123; InputStream resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); //查询所有数据 List&lt;Employee&gt; employees = employeeMapper.selectByExample(null); employees.forEach(employee -&gt; System.out.println(employee)); //根据条件查询 EmployeeExample employeeExample = new EmployeeExample(); //下面这些方法就是Example类中的方法，这些方法都是逆向工程根据配置自动生成的 //andEmployeeNameEqualTo:员工名等于? //andEmployeeAgeGreaterThanOrEqualTo:员工年龄大于等于? //or():或者 //andDidIsNotNull:员工所属部门id不为null employeeExample.createCriteria().andEmployeeNameEqualTo(&quot;zhangsan&quot;).andEmployeeAgeGreaterThanOrEqualTo(20); employeeExample.or().andDidIsNotNull(); List&lt;Employee&gt; employees1 = employeeMapper.selectByExample(employeeExample); employees1.forEach(employee1 -&gt; System.out.println(employee1)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; image-20220509235119925 通过测试发现，sql语句中会自动帮我们拼接好条件并格式化进行查询 感受：这个功能虽然非常快捷方便，但是我认为初学者还是应该自己搭建这些环境，等到以后足够熟悉了，只需要注重业务时再用比较好 六、Mybatis分页插件6.1 分页插件的使用步骤6.1.1 添加依赖&lt;dependency&gt; &lt;groupId&gt;com.github.pagehelper&lt;/groupId&gt; &lt;artifactId&gt;pagehelper&lt;/artifactId&gt; &lt;version&gt;5.3.0&lt;/version&gt; &lt;/dependency&gt; 6.1.2 配置分页插件在MyBatis的核心配置文件中配置插件 &lt;!--注意位置--&gt; &lt;plugins&gt; &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;/&gt; &lt;/plugins&gt; 6.2 分页插件的使用 MySQL中指定查询位置及条数的语法：limit index, pagesize，也通常用于分页 index：当前页的起始索引 pagesize：每页显示的条数 pageNum：当前页的页码 index=( pageNum-1 )*pagesize 分页插件Pagehelper的使用： 在查询功能之前使用PageHelper.startPage(int pageNum, int pageSize)开启分页功能 pageNum：当前页的页码 pageSize：每页显示的条数 在查询获取list集合之后，可以使用PageInfo&lt;T&gt; pageInfo = new PageInfo&lt;&gt;(List&lt;T&gt; list, int navigatePages)获取分页相关数据 list：分页之后的数据 navigatePages：导航分页的页码数（比如，我们当前在第5页，而指定的navigatePages为5，那么此时可以显示出来的页码就是3、4、5、6、7这5个页码，其余页码都用...代替） 类似这种功能：image-20220510090040104 测试： @Test public void testPageHelper()&#123; try &#123; InputStream resource = Resources.getResourceAsStream(&quot;mybatis-config.xml&quot;); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(resource); SqlSession sqlSession = sqlSessionFactory.openSession(true); EmployeeMapper employeeMapper = sqlSession.getMapper(EmployeeMapper.class); PageHelper.startPage(1, 3);//开启分页 //查询所有数据 List&lt;Employee&gt; employees = employeeMapper.selectByExample(null); employees.forEach(employee -&gt; System.out.println(employee)); PageInfo&lt;Employee&gt; pageInfo = new PageInfo&lt;&gt;(employees,4);//通过PageInfo对象获取页面相关信息，4为我们指定的导航页显示的页码个数 System.out.println(pageInfo); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; image-20220510091429312 此时，PageInfo对象为： PageInfo{pageNum=1, pageSize=3, size=3, startRow=1, endRow=3, total=13, pages=5, list=Page{count=true, pageNum=1, pageSize=3, startRow=0, endRow=3, total=13, pages=5, reasonable=false, pageSizeZero=false} 中间这部分是我们查询到的数据 prePage=0, nextPage=2, isFirstPage=true, isLastPage=false, hasPreviousPage=false, hasNextPage=true, navigatePages=4, navigateFirstPage=1, navigateLastPage=4, navigatepageNums=[1, 2, 3, 4]} image-20220510092111757此时的PageInfo对象为： PageInfo{pageNum=3, pageSize=3, size=3, startRow=7, endRow=9, total=13, pages=5, list=Page{count=true, pageNum=3, pageSize=3, startRow=6, endRow=9, total=13, pages=5, reasonable=false, pageSizeZero=false} 中间部分仍是我们查询到的数据 prePage=2, nextPage=4, isFirstPage=false, isLastPage=false, hasPreviousPage=true, hasNextPage=true, navigatePages=4, navigateFirstPage=1, navigateLastPage=4, navigatepageNums=[1, 2, 3, 4]} PageInfo对象中，常用的数据： pageNum：当前页的页码 pageSize：每页显示的条数 size：当前页显示的真实条数 total：总记录数（即我们数据库中的数据条数） pages：总页数（由我们的总记录数计算得到） prePage：上一页的页码（由当前页的页码计算得到） nextPage：下一页的页码（由当前页的页码计算得到） isFirstPage/isLastPage：是否为第一页/最后一页 hasPreviousPage/hasNextPage：是否存在上一页/下一页 navigatePages：导航分页的页码数 navigateFirstPage：导航分页要显示出来的第一页的页码 navigateLastPage：导航分页要显示出来的最后一页的页码 navigatepageNums：导航分页的页码，[1,2,3,4]，即我们会先显示出来的页码","categories":[{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://rainvex.com/tags/Mybatis/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"}]},{"title":"SpringMVC笔记","slug":"SpringMVC学习笔记","date":"2022-05-04T13:02:33.000Z","updated":"2022-05-04T13:02:33.000Z","comments":true,"path":"categories/后端/SpringMVC学习笔记.html","link":"","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/SpringMVC%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"前段时间以课程设计项目为借口偷了两三个星期的懒没有继续看视频学习😂，最近终于把SpringMVC看完了。这篇笔记的话我是直接用的视频配套的笔记，因为我觉得写的挺清楚的，就是有很多地方不太详细，再加上视频老师虽然讲的挺清楚，但是他不爱做笔记🤔，所以我就在这个基础上进行增加修改了，我也大多是对一些具体步骤进行添加修改，然后就是针对源码讲解部分和自己的理解进行了一个笔记的补充 一、SpringMVC简介1、什么是MVCMVC是一种软件架构的思想，将软件按照模型、视图、控制器来划分 M：Model，模型层，指工程中的JavaBean，作用是处理数据 JavaBean分为两类： 一类称为实体类Bean：专门存储业务数据的，如 Student、User 等 一类称为业务处理 Bean：指 Service 或 Dao 对象，专门用于处理业务逻辑和数据访问。 V：View，视图层，指工程中的html或jsp等页面，作用是与用户进行交互，展示数据 C：Controller，控制层，指工程中的servlet，作用是接收请求和响应浏览器 MVC的工作流程：用户通过视图层发送请求到服务器，在服务器中请求被Controller接收，Controller调用相应的Model层处理请求，处理完毕将结果返回到Controller，Controller再根据请求处理的结果找到相应的View视图，渲染数据后最终响应给浏览器 2、什么是SpringMVCSpringMVC是Spring的一个后续产品，是Spring的一个子项目 SpringMVC 是 Spring 为表述层开发提供的一整套完备的解决方案。在表述层框架历经 Strust、WebWork、Strust2 等诸多产品的历代更迭之后，目前业界普遍选择了 SpringMVC 作为 Java EE 项目表述层开发的首选方案。 注：三层架构分为表述层（或表示层）、业务逻辑层、数据访问层，表述层表示前台页面和后台servlet 3、SpringMVC的特点 Spring 家族原生产品，与 IOC 容器等基础设施无缝对接 基于原生的Servlet，通过了功能强大的前端控制器DispatcherServlet，对请求和响应进行统一处理 表述层各细分领域需要解决的问题全方位覆盖，提供全面解决方案 代码清新简洁，大幅度提升开发效率 内部组件化程度高，可插拔式组件即插即用，想要什么功能配置相应组件即可 性能卓著，尤其适合现代大型、超大型互联网项目要求 二、HelloWorld1、开发环境IDE：idea 2021.2 构建工具：maven3.8.1 服务器：tomcat9 Spring版本：最新版 2、创建maven工程新建maven工程后，在父工程中新建一个模块（或者直接新建一个maven工程也行，新建模块只是为了区分不同内容） image-20220417204458446 a&gt;打包方式：war在新建的SpringMVC-day1模块下的pom文件中添加&lt;packaging&gt;war&lt;/packaging&gt; b&gt;引入依赖在pom文件中引入下方依赖 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;ch.qos.logback&lt;/groupId&gt; &lt;artifactId&gt;logback-classic&lt;/artifactId&gt; &lt;version&gt;1.2.11&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.1&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.thymeleaf&lt;/groupId&gt; &lt;artifactId&gt;thymeleaf-spring5&lt;/artifactId&gt; &lt;version&gt;3.0.15.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 注：由于 Maven 的传递性，我们不必将所有需要的包全部配置依赖，而是配置最顶端的依赖，其他靠传递性导入。 c&gt;添加web模块在src-&gt;main中新建一个目录webapp 然后，在项目结构中，模块-&gt;需要添加web.xml的项目模块-&gt;找到Web-&gt;点击部署描述符旁的+号-&gt;点击web.xml image-20220417205043236 在点击web.xml后弹出框中更改web.xml的路径，然后确定，点击应用即可 image-20220417205313678 创建好后如图所示 image-20220417210222391 3、配置web.xml注册SpringMVC的前端控制器DispatcherServlet a&gt;默认配置方式此配置作用下，SpringMVC的配置文件默认位于WEB-INF下，默认名称为&lt;servlet-name&gt;-servlet.xml，例如，以下配置所对应SpringMVC的配置文件位于WEB-INF下，文件名为springMVC-servlet.xml &lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; b&gt;扩展配置方式可通过init-param标签设置SpringMVC配置文件的位置和名称，通过load-on-startup标签设置SpringMVC前端控制器DispatcherServlet的初始化时间 &lt;!-- 配置SpringMVC的前端控制器，对浏览器发送的请求统一进行处理 --&gt; &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!-- 通过初始化参数指定SpringMVC配置文件的位置和名称 --&gt; &lt;init-param&gt; &lt;!-- contextConfigLocation为固定值 --&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;!-- 使用classpath:表示从类路径查找配置文件，例如maven工程中的src/main/resources --&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!-- 作为框架的核心组件，在启动过程中有大量的初始化操作要做 而这些操作放在第一次请求时才执行会严重影响访问速度 因此需要通过此标签将启动控制DispatcherServlet的初始化时间提前到服务器启动时 --&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;!-- 设置springMVC的核心控制器所能处理的请求的请求路径 /所匹配的请求可以是/login或.html或.js或.css方式的请求路径 但是/不能匹配.jsp请求路径的请求 --&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 注： &lt;url-pattern&gt;标签中使用/和/*的区别： /所匹配的请求可以是/login或.html或.js或.css方式的请求路径，但是/不能匹配.jsp请求路径的请求 因此就可以避免在访问jsp页面时，该请求被DispatcherServlet处理，从而找不到相应的页面 /*则能够匹配所有请求，例如在使用过滤器时，若需要对所有请求进行过滤，就需要使用/*的写法 4、创建请求控制器由于前端控制器对浏览器发送的请求进行了统一的处理，但是具体的请求有不同的处理过程，因此需要创建处理具体请求的类，即请求控制器 请求控制器中每一个处理请求的方法成为控制器方法 因为SpringMVC的控制器由一个POJO（普通的Java类）担任，因此需要通过@Controller注解将其标识为一个控制层组件，交给Spring的IoC容器管理，此时SpringMVC才能够识别控制器的存在 @Controller public class HelloController &#123; &#125; 5、创建springMVC的配置文件&lt;!-- 自动扫描包 --&gt; &lt;context:component-scan base-package=&quot;com.springMVC&quot;/&gt; &lt;!-- 配置Thymeleaf视图解析器 --&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.thymeleaf.spring5.view.ThymeleafViewResolver&quot;&gt; &lt;property name=&quot;order&quot; value=&quot;1&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;templateEngine&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.SpringTemplateEngine&quot;&gt; &lt;property name=&quot;templateResolver&quot;&gt; &lt;bean class=&quot;org.thymeleaf.spring5.templateresolver.SpringResourceTemplateResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.html&quot;/&gt; &lt;property name=&quot;templateMode&quot; value=&quot;HTML5&quot;/&gt; &lt;property name=&quot;characterEncoding&quot; value=&quot;UTF-8&quot; /&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/property&gt; &lt;/bean&gt; &lt;!--后面两个配置可以等后面用到再添加--&gt; &lt;!-- 处理静态资源，例如html、js、css、jpg 若只设置该标签，则只能访问静态资源，其他请求则无法访问 此时必须设置&lt;mvc:annotation-driven/&gt;解决问题 --&gt; &lt;mvc:default-servlet-handler/&gt; &lt;!-- 开启mvc注解驱动 --&gt; &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!-- 处理响应中文内容乱码 --&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot; /&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 6、运行配置在IDEA右上方点击添加配置 image-20220420171741927 点击’+’号，选择Tomcat服务器的本地image-20220420171903803 修改配置名称，在部署页添加工件 image-20220420172102138 选择:war exploded的工件（因为新建SpringMVC-day1后修改成了demo1，所以这里跟上方新建模块的截图中名称不一样，可以忽略） image-20220420172544274 为了方便，可以把应用程序上下文修改一下 image-20220420172853770 然后，点击应用确定即可 7、测试HelloWorlda&gt;实现对首页的访问在请求控制器中创建处理请求的方法 // @RequestMapping注解：处理请求和控制器方法之间的映射关系 // @RequestMapping注解的value属性可以通过请求地址匹配请求，/表示的当前工程的上下文路径 // localhost:8080/springMVC/ @RequestMapping(&quot;/&quot;) public String index() &#123; //设置视图名称 return &quot;index&quot;; &#125; b&gt;通过超链接跳转到指定页面在主页index.html中设置超链接 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;首页&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/hello&#125;&quot;&gt;HelloWorld&lt;/a&gt;&lt;br/&gt; &lt;/body&gt; &lt;/html&gt; 在请求控制器中创建处理请求的方法 @RequestMapping(&quot;/hello&quot;) public String HelloWorld() &#123; return &quot;target&quot;; &#125; 8、总结浏览器发送请求，若请求地址符合前端控制器的url-pattern，该请求就会被前端控制器DispatcherServlet处理。前端控制器会读取SpringMVC的核心配置文件，通过扫描组件找到控制器，将请求地址和控制器中@RequestMapping注解的value属性值进行匹配，若匹配成功，该注解所标识的控制器方法就是处理请求的方法。处理请求的方法需要返回一个字符串类型的视图名称，该视图名称会被视图解析器解析，加上前缀和后缀组成视图的路径，通过Thymeleaf对视图进行渲染，最终转发到视图所对应页面 三、@RequestMapping注解1、@RequestMapping注解的功能从注解名称上我们可以看到，@RequestMapping注解的作用就是将请求和处理请求的控制器方法关联起来，建立映射关系。 SpringMVC 接收到指定的请求，就会来找到在映射关系中对应的控制器方法来处理这个请求。 2、@RequestMapping注解的位置@RequestMapping标识一个类：设置映射请求的请求路径的初始信息 @RequestMapping标识一个方法：设置映射请求请求路径的具体信息 @Controller @RequestMapping(&quot;/test&quot;) public class RequestMappingController &#123; //此时请求映射所映射的请求的请求路径为：/test/testRequestMapping @RequestMapping(&quot;/testRequestMapping&quot;) public String testRequestMapping()&#123; return &quot;success&quot;; &#125; &#125; 3、@RequestMapping注解的value属性@RequestMapping注解的value属性通过请求的请求地址匹配请求映射 @RequestMapping注解的value属性是一个字符串类型的数组，表示该请求映射能够匹配多个请求地址所对应的请求 @RequestMapping注解的value属性必须设置，至少通过请求地址匹配请求映射 &lt;a th:href=&quot;@&#123;/testRequestMapping&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/testRequestMapping&lt;/a&gt;&lt;br&gt; &lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; @RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ) public String testRequestMapping()&#123; return &quot;success&quot;; &#125; 4、@RequestMapping注解的method属性@RequestMapping注解的method属性通过请求的请求方式（get或post）匹配请求映射 @RequestMapping注解的method属性是一个RequestMethod类型的数组，表示该请求映射能够匹配多种请求方式的请求 若当前请求的请求地址满足请求映射的value属性，但是请求方式不满足method属性，则浏览器报错405：Request method ‘POST’ not supported &lt;a th:href=&quot;@&#123;/test&#125;&quot;&gt;测试@RequestMapping的value属性--&gt;/test&lt;/a&gt;&lt;br&gt; &lt;form th:action=&quot;@&#123;/test&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125;, method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ) public String testRequestMapping()&#123; return &quot;success&quot;; &#125; 注： 1、对于处理指定请求方式的控制器方法，SpringMVC中提供了@RequestMapping的派生注解 处理get请求的映射–&gt;@GetMapping 处理post请求的映射–&gt;@PostMapping 处理put请求的映射–&gt;@PutMapping 处理delete请求的映射–&gt;@DeleteMapping 2、常用的请求方式有get，post，put，delete 但是目前浏览器只支持get和post，若在form表单提交时，为method设置了其他请求方式的字符串（put或delete），则按照默认的请求方式get处理 若要发送put和delete请求，则需要通过spring提供的过滤器HiddenHttpMethodFilter，在RESTful部分会讲到 5、@RequestMapping注解的params属性（了解）@RequestMapping注解的params属性通过请求的请求参数匹配请求映射 @RequestMapping注解的params属性是一个字符串类型的数组，可以通过四种表达式设置请求参数和请求映射的匹配关系 “param”：要求请求映射所匹配的请求必须携带param请求参数 “!param”：要求请求映射所匹配的请求必须不能携带param请求参数 “param=value”：要求请求映射所匹配的请求必须携带param请求参数且param=value “param!=value”：要求请求映射所匹配的请求必须携带param请求参数但是param!=value &lt;a th:href=&quot;@&#123;/test(username=&#39;admin&#39;,password=123456)&quot;&gt;测试@RequestMapping的params属性--&gt;/test&lt;/a&gt;&lt;br&gt; @RequestMapping( value = &#123;&quot;/testRequestMapping&quot;, &quot;/test&quot;&#125; ,method = &#123;RequestMethod.GET, RequestMethod.POST&#125; ,params = &#123;&quot;username&quot;,&quot;password!=123456&quot;&#125; ) public String testRequestMapping()&#123; return &quot;success&quot;; &#125; 注： 若当前请求满足@RequestMapping注解的value和method属性，但是不满足params属性，此时页面回报错400：Parameter conditions “username, password!=123456” not met for actual request parameters: username={admin}, password={123456} 6、@RequestMapping注解的headers属性（了解）@RequestMapping注解的headers属性通过请求的请求头信息匹配请求映射 @RequestMapping注解的headers属性是一个字符串类型的数组，可以通过四种表达式设置请求头信息和请求映射的匹配关系 “header”：要求请求映射所匹配的请求必须携带header请求头信息 “!header”：要求请求映射所匹配的请求必须不能携带header请求头信息 “header=value”：要求请求映射所匹配的请求必须携带header请求头信息且header=value “header!=value”：要求请求映射所匹配的请求必须携带header请求头信息且header!=value 若当前请求满足@RequestMapping注解的value和method属性，但是不满足headers属性，此时页面显示404错误，即资源未找到 7、SpringMVC支持ant风格的路径？：表示任意的单个字符 *：表示任意的0个或多个字符 **：表示任意的一层或多层目录 注意：在使用**时，只能使用/**/xxx的方式 8、SpringMVC支持路径中的占位符（重点）原始请求发送方式：/deleteUser?id=1 rest请求发送方式：/deleteUser/1 SpringMVC路径中的占位符常用于RESTful风格中，当请求路径中将某些数据通过路径的方式传输到服务器中，就可以在相应的@RequestMapping注解的value属性中通过占位符{xxx}表示传输的数据，再通过@PathVariable注解，将占位符所表示的数据赋值给控制器方法的形参 &lt;a th:href=&quot;@&#123;/testRest/1/admin&#125;&quot;&gt;测试路径中的占位符--&gt;/testRest&lt;/a&gt;&lt;br&gt; @RequestMapping(&quot;/testRest/&#123;id&#125;/&#123;username&#125;&quot;) public String testRest(@PathVariable(&quot;id&quot;) String id, @PathVariable(&quot;username&quot;) String username)&#123; System.out.println(&quot;id:&quot;+id+&quot;,username:&quot;+username); return &quot;success&quot;; &#125; //最终输出的内容为--&gt;id:1,username:admin 四、SpringMVC获取请求参数1、通过ServletAPI获取将HttpServletRequest作为控制器方法的形参，此时HttpServletRequest类型的参数表示封装了当前请求的请求报文的对象 @RequestMapping(&quot;/testParam&quot;) public String testParam(HttpServletRequest request)&#123; String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;; &#125; //getParameter获取单个参数值 //getParameterValues获取多个参数值（数组形式） 2、通过控制器方法的形参获取请求参数在控制器方法的形参位置，设置和请求参数同名的形参，当浏览器发送请求，匹配到请求映射时，在DispatcherServlet中就会将请求参数赋值给相应的形参 &lt;a th:href=&quot;@&#123;/testParam(username=&#39;admin&#39;,password=123456)&#125;&quot;&gt;测试获取请求参数--&gt;/testParam&lt;/a&gt;&lt;br&gt; @RequestMapping(&quot;/testParam&quot;) public String testParam(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;success&quot;; &#125; 注： 若请求所传输的请求参数中有多个同名的请求参数，此时可以在控制器方法的形参中设置字符串数组或者字符串类型的形参接收此请求参数 若使用字符串数组类型的形参，此参数的数组中包含了每一个数据 若使用字符串类型的形参，此参数的值为每个数据中间使用逗号拼接的结果 3、@RequestParam@RequestParam是将请求参数和控制器方法的形参创建映射关系 @RequestParam注解一共有三个属性： value：指定为形参赋值的请求参数的参数名 required：设置是否必须传输此请求参数，默认值为true 若设置为true时，则当前请求必须传输value所指定的请求参数，若没有传输该请求参数，且没有设置defaultValue属性，则页面报错400：Required String parameter ‘xxx’ is not present；若设置为false，则当前请求不是必须传输value所指定的请求参数，若没有传输，则注解所标识的形参的值为null defaultValue：不管required属性值为true或false，当value所指定的请求参数没有传输或传输的值为””时，则使用默认值为形参赋值 @RequestMapping(&quot;/testRequestParam&quot;) public String testRequestParam(@RequestParam(&quot;username&quot;) String username,@RequestParam(&quot;password&quot;) String password)&#123; System.out.println(&quot;username:&quot;+username); System.out.println(&quot;password:&quot;+password); return &quot;success&quot;; &#125; 4、@RequestHeader@RequestHeader是将请求头信息和控制器方法的形参创建映射关系 @RequestHeader注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 获取请求中的请求头信息必须使用 5、@CookieValue@CookieValue是将cookie数据和控制器方法的形参创建映射关系 @CookieValue注解一共有三个属性：value、required、defaultValue，用法同@RequestParam 6、通过POJO获取请求参数可以在控制器方法的形参位置设置一个实体类类型的形参，此时若浏览器传输的请求参数的参数名和实体类中的属性名一致，那么请求参数就会为此属性赋值 &lt;form th:action=&quot;@&#123;/testpojo&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; 性别：&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;男&quot;&gt;男&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;女&quot;&gt;女&lt;br&gt; 年龄：&lt;input type=&quot;text&quot; name=&quot;age&quot;&gt;&lt;br&gt; 邮箱：&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping(&quot;/testpojo&quot;) public String testPOJO(User user)&#123; System.out.println(user); return &quot;success&quot;; &#125; //最终结果--&gt;User&#123;id=null, username=&#39;张三&#39;, password=&#39;123&#39;, age=23, sex=&#39;男&#39;, email=&#39;123@qq.com&#39;&#125; 7、解决获取请求参数的乱码问题解决获取请求参数的乱码问题，可以使用SpringMVC提供的编码过滤器CharacterEncodingFilter，但是必须在web.xml中进行注册 &lt;!--配置springMVC的编码过滤器--&gt; &lt;filter&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;forceResponseEncoding&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;CharacterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; image-20220420161434054 通过CharacterEncodingFilter源码可以大致清楚为什么在配置文件中需要这样配置，初始化参数中encoding是设置我们需要的编码格式，源码中设置请求编码格式时的条件中，isForceRequestEncoding返回的是默认的false，由于之前我们并没有设置过请求的编码格式，那么request.getCharacterEncoding返回的是null，此时就满足了设置请求编码的条件，则请求的编码格式被设为UTF-8；在配置文件中，forceResponseEncoding被设置为true，那么源码中设置响应编码格式的条件则成立，此时响应的编码格式也会被设置为UTF-8 注： SpringMVC中处理编码的过滤器一定要配置到其他过滤器之前，否则无效 五、域对象共享数据主要了解request（一次请求的范围）、session（一次会话的范围，浏览器的开启和关闭）、servletcontext（也叫application，整个应用的范围，服务器开启到关闭）三个域对象 1、使用ServletAPI向request域对象共享数据@RequestMapping(&quot;/testServletAPI&quot;) public String testServletAPI(HttpServletRequest request)&#123; request.setAttribute(&quot;testScope&quot;, &quot;hello,servletAPI&quot;); return &quot;success&quot;; &#125; 2、使用ModelAndView向request域对象共享数据@RequestMapping(&quot;/testModelAndView&quot;) public ModelAndView testModelAndView()&#123; /** * ModelAndView有Model和View的功能 * Model主要用于向请求域共享数据 * View主要用于设置视图，实现页面跳转 */ ModelAndView mav = new ModelAndView(); //向请求域共享数据 mav.addObject(&quot;testScope&quot;, &quot;hello,ModelAndView&quot;); //设置视图，实现页面跳转 mav.setViewName(&quot;success&quot;); return mav; &#125; 3、使用Model向request域对象共享数据@RequestMapping(&quot;/testModel&quot;) public String testModel(Model model)&#123; model.addAttribute(&quot;testScope&quot;, &quot;hello,Model&quot;); return &quot;success&quot;; &#125; 4、使用map向request域对象共享数据@RequestMapping(&quot;/testMap&quot;) public String testMap(Map&lt;String, Object&gt; map)&#123; map.put(&quot;testScope&quot;, &quot;hello,Map&quot;); return &quot;success&quot;; &#125; 5、使用ModelMap向request域对象共享数据@RequestMapping(&quot;/testModelMap&quot;) public String testModelMap(ModelMap modelMap)&#123; modelMap.addAttribute(&quot;testScope&quot;, &quot;hello,ModelMap&quot;); return &quot;success&quot;; &#125; 6、Model、ModelMap、Map的关系通过在java程序中输出Model、ModelMap、Map类型的参数可以发现输出的内容和数据类型都是一样，其实本质上都是 BindingAwareModelMap 类型的，而这三种类型都是BindingAwareModelMap的父类或其父类实现的接口，并且这三种数据类型都有同一个被重写的toString方法 public class BindingAwareModelMap extends ExtendedModelMap &#123;&#125; public class ExtendedModelMap extends ModelMap implements Model &#123;&#125; public class ModelMap extends LinkedHashMap&lt;String, Object&gt; &#123;&#125; public interface Model&#123;&#125; public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;&#125; image-20220427135823738t 通过上图和代码可以发现其中的继承和实现关系，而其中这三种类型的参数所拥有的toStirng方法都继承自HashMap类 7、向session域共享数据@RequestMapping(&quot;/testSession&quot;) public String testSession(HttpSession session)&#123; session.setAttribute(&quot;testSessionScope&quot;, &quot;hello,session&quot;); return &quot;success&quot;; &#125; 8、向application域共享数据@RequestMapping(&quot;/testApplication&quot;) public String testApplication(HttpSession session)&#123; ServletContext application = session.getServletContext(); application.setAttribute(&quot;testApplicationScope&quot;, &quot;hello,application&quot;); return &quot;success&quot;; &#125; 六、SpringMVC的视图SpringMVC中的视图是View接口，视图的作用渲染数据，将模型Model中的数据展示给用户 SpringMVC视图的种类很多，默认有转发视图和重定向视图 当工程引入jstl的依赖，转发视图会自动转换为JstlView 若使用的视图技术为Thymeleaf，在SpringMVC的配置文件中配置了Thymeleaf的视图解析器，由此视图解析器解析之后所得到的是ThymeleafView 1、ThymeleafView当控制器方法中所设置的视图名称没有任何前缀时，此时的视图名称会被SpringMVC配置文件中所配置的视图解析器解析，视图名称拼接视图前缀和视图后缀所得到的最终路径，会通过转发的方式实现跳转 @RequestMapping(&quot;/testHello&quot;) public String testHello()&#123; return &quot;hello&quot;; &#125; image-202204271408705 2、转发视图SpringMVC中默认的转发视图是InternalResourceView SpringMVC中创建转发视图的情况： 当控制器方法中所设置的视图名称以”forward:”为前缀时，创建InternalResourceView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”forward:”去掉，剩余部分作为最终路径通过转发的方式实现跳转 例如”forward:/“，”forward:/employee” @RequestMapping(&quot;/testForward&quot;) public String testForward()&#123; return &quot;forward:/testHello&quot;; &#125; image-202204271408705 3、重定向视图SpringMVC中默认的重定向视图是RedirectView 当控制器方法中所设置的视图名称以”redirect:”为前缀时，创建RedirectView视图，此时的视图名称不会被SpringMVC配置文件中所配置的视图解析器解析，而是会将前缀”redirect:”去掉，剩余部分作为最终路径通过重定向的方式实现跳转 例如”redirect:/“，”redirect:/employee” @RequestMapping(&quot;/testRedirect&quot;) public String testRedirect()&#123; return &quot;redirect:/testHello&quot;; &#125; image-202205041619137 注： 重定向视图在解析时，会先将redirect:前缀去掉，然后会判断剩余部分是否以/开头，若是则会自动拼接上下文路径 4、回顾转发和重定向区别： URL地址问题 请求转发不会改变地址栏的URL地址 请求重定向会改变地址栏的URL地址 数据共享问题 请求转发的数据处理是在同一次请求中，可以使用request对象实现数据共享。 请求重定向是向服务器发送了两次请求，不能使用request对象实现数据共享，想要让两次请求数据共享必须使用session对象。 效率问题 请求转发的效率高于重定向(服务器内部的页面跳转 &gt; 再次向服务器发送请求调用servlet完成页面跳转) 本质区别 请求转发是属于请求对象的方法（调用HttpServletRequest对象的方法） 请求重定向是属于响应对象的方法（调用HttpServletResponse对象的方法） 使用时机： 请求转发会在每次刷新时会重新向服务器发送请求，每刷新一次，就重新发送一次请求。对于表单提交来讲，若提交表单后再重新加载页面，使用转发可能会导致信息的重复提交，因此，表单提交需要使用请求重定向 请求转发只能访问当前服务器中的某些页面，因此若要访问其他服务器上的页面，需要使用请求重定向 参考博客：https://blog.csdn.net/weixin_43490440/article/details/100920817 5、视图控制器view-controller当控制器方法中，仅仅用来实现页面跳转，即只需要设置视图名称时，可以将处理器方法使用view-controller标签进行表示 &lt;!-- path：设置处理的请求地址 view-name：设置请求地址所对应的视图名称 --&gt; &lt;mvc:view-controller path=&quot;/testView&quot; view-name=&quot;success&quot;&gt;&lt;/mvc:view-controller&gt; 注： 当SpringMVC中设置任何一个view-controller时，其他控制器中的请求映射将全部失效，此时需要在SpringMVC的核心配置文件中设置开启mvc注解驱动的标签：**&lt;mvc:annotation-driven /&gt;** 6、配置jsp文件的视图解析&lt;!--在springMVC.xml配置文件中配置--&gt; &lt;bean id=&quot;viewResolver&quot; class=&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;&gt; &lt;!-- 视图前缀 --&gt; &lt;property name=&quot;prefix&quot; value=&quot;/WEB-INF/templates/&quot;/&gt; &lt;!-- 视图后缀 --&gt; &lt;property name=&quot;suffix&quot; value=&quot;.jsp&quot;/&gt; &lt;/bean&gt; &lt;!--其余配置都和前面一样--&gt; 七、RESTful1、RESTful简介REST：Representational State Transfer，表现层资源状态转移。 a&gt;资源资源是一种看待服务器的方式，即，将服务器看作是由很多离散的资源组成。每个资源是服务器上一个可命名的抽象概念。因为资源是一个抽象的概念，所以它不仅仅能代表服务器文件系统中的一个文件、数据库中的一张表等等具体的东西，可以将资源设计的要多抽象有多抽象，只要想象力允许而且客户端应用开发者能够理解。与面向对象设计类似，资源是以名词为核心来组织的，首先关注的是名词。一个资源可以由一个或多个URI来标识。URI既是资源的名称，也是资源在Web上的地址。对某个资源感兴趣的客户端应用，可以通过资源的URI与其进行交互。 b&gt;资源的表述资源的表述是一段对于资源在某个特定时刻的状态的描述。可以在客户端-服务器端之间转移（交换）。资源的表述可以有多种格式，例如HTML/XML/JSON/纯文本/图片/视频/音频等等。资源的表述格式可以通过协商机制来确定。请求-响应方向的表述通常使用不同的格式。 c&gt;状态转移状态转移说的是：在客户端和服务器端之间转移（transfer）代表资源状态的表述。通过转移和操作资源的表述，来间接实现操作资源的目的。 2、RESTful的实现具体说，就是 HTTP 协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。 它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来删除资源。 REST 风格提倡 URL 地址使用统一的风格设计，从前到后各个单词使用斜杠分开，不使用问号键值对方式携带请求参数，而是将要发送给服务器的数据作为 URL 地址的一部分，以保证整体风格的一致性。 操作 传统方式 REST风格 查询操作 getUserById?id=1 user/1–&gt;get请求方式 保存操作 saveUser user–&gt;post请求方式 删除操作 deleteUser?id=1 user/1–&gt;delete请求方式 更新操作 updateUser user–&gt;put请求方式 3、HiddenHttpMethodFilter由于浏览器只支持发送get和post方式的请求，那么该如何发送put和delete请求呢？ SpringMVC 提供了 HiddenHttpMethodFilter 帮助我们将 POST 请求转换为 DELETE 或 PUT 请求 HiddenHttpMethodFilter的源码部分： image-20220502155150101 image-20220502155210796 通过源码可以发现HiddenHttpMethodFilter 处理put和delete请求的条件： a&gt;当前请求的请求方式必须为post b&gt;当前请求必须传输参数名为_method的参数 满足以上条件，HiddenHttpMethodFilter 过滤器就会将当前请求的请求方式post转换为请求参数_method的值，因此请求参数_method的值才是最终的请求方式 在web.xml中注册HiddenHttpMethodFilter &lt;filter&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.HiddenHttpMethodFilter&lt;/filter-class&gt; &lt;/filter&gt; &lt;filter-mapping&gt; &lt;filter-name&gt;HiddenHttpMethodFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt; &lt;/filter-mapping&gt; &lt;!--比如，在不使用ajax的情况下，我们现在需要提交一个put请求，只需要将表单方法设置为post，然后再添加一个隐藏域，提交名为_method，值为put，经过过滤器处理后，这个请求就会变成put请求--&gt; &lt;form action=&quot;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;提交&quot;&gt; &lt;/form&gt; delete请求方式的处理见8.5节 注： 目前为止，SpringMVC中提供了两个过滤器：CharacterEncodingFilter和HiddenHttpMethodFilter 在web.xml中注册时，必须先注册CharacterEncodingFilter，再注册HiddenHttpMethodFilter 原因： 在 CharacterEncodingFilter 中通过 request.setCharacterEncoding(encoding) 方法设置字符集的 request.setCharacterEncoding(encoding) 方法要求前面不能有任何获取请求参数的操作 而 HiddenHttpMethodFilter 恰恰有一个获取请求方式的操作： String paramValue = request.getParameter(this.methodParam); 八、RESTful案例1、准备工作和传统 CRUD 一样，实现对员工信息的增删改查。 搭建环境 准备实体类 package com.atguigu.mvc.bean; public class Employee &#123; private Integer id; private String lastName; private String email; //1 male, 0 female private Integer gender; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getLastName() &#123; return lastName; &#125; public void setLastName(String lastName) &#123; this.lastName = lastName; &#125; public String getEmail() &#123; return email; &#125; public void setEmail(String email) &#123; this.email = email; &#125; public Integer getGender() &#123; return gender; &#125; public void setGender(Integer gender) &#123; this.gender = gender; &#125; public Employee(Integer id, String lastName, String email, Integer gender) &#123; super(); this.id = id; this.lastName = lastName; this.email = email; this.gender = gender; &#125; public Employee() &#123; &#125; &#125; 准备dao模拟数据 package com.atguigu.mvc.dao; import java.util.Collection; import java.util.HashMap; import java.util.Map; import com.atguigu.mvc.bean.Employee; import org.springframework.stereotype.Repository; @Repository public class EmployeeDao &#123; private static Map&lt;Integer, Employee&gt; employees = null; static&#123; employees = new HashMap&lt;Integer, Employee&gt;(); employees.put(1001, new Employee(1001, &quot;E-AA&quot;, &quot;aa@163.com&quot;, 1)); employees.put(1002, new Employee(1002, &quot;E-BB&quot;, &quot;bb@163.com&quot;, 1)); employees.put(1003, new Employee(1003, &quot;E-CC&quot;, &quot;cc@163.com&quot;, 0)); employees.put(1004, new Employee(1004, &quot;E-DD&quot;, &quot;dd@163.com&quot;, 0)); employees.put(1005, new Employee(1005, &quot;E-EE&quot;, &quot;ee@163.com&quot;, 1)); &#125; private static Integer initId = 1006; public void save(Employee employee)&#123; if(employee.getId() == null)&#123; employee.setId(initId++); &#125; employees.put(employee.getId(), employee); &#125; public Collection&lt;Employee&gt; getAll()&#123; return employees.values(); &#125; public Employee get(Integer id)&#123; return employees.get(id); &#125; public void delete(Integer id)&#123; employees.remove(id); &#125; &#125; 2、功能清单 功能 URL 地址 请求方式 访问首页√ / GET 查询全部数据√ /employee GET 删除√ /employee/2 DELETE 跳转到添加数据页面√ /toAdd GET 执行保存√ /employee POST 跳转到更新数据页面√ /employee/2 GET 执行更新√ /employee PUT 3、具体功能：访问首页a&gt;配置view-controller&lt;mvc:view-controller path=&quot;/&quot; view-name=&quot;index&quot;/&gt; b&gt;创建页面&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot; &gt; &lt;title&gt;Title&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;首页&lt;/h1&gt; &lt;a th:href=&quot;@&#123;/employee&#125;&quot;&gt;访问员工信息&lt;/a&gt; &lt;/body&gt; &lt;/html&gt; 4、具体功能：查询所有员工数据a&gt;控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET) public String getEmployeeList(Model model)&#123; Collection&lt;Employee&gt; employeeList = employeeDao.getAll(); model.addAttribute(&quot;employeeList&quot;, employeeList); return &quot;employee_list&quot;; &#125; b&gt;创建employee_list.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Employee Info&lt;/title&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;table border=&quot;1&quot; cellpadding=&quot;0&quot; cellspacing=&quot;0&quot; style=&quot;text-align: center;&quot; id=&quot;dataTable&quot;&gt; &lt;tr&gt; &lt;th colspan=&quot;5&quot;&gt;Employee Info&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;id&lt;/th&gt; &lt;th&gt;lastName&lt;/th&gt; &lt;th&gt;email&lt;/th&gt; &lt;th&gt;gender&lt;/th&gt; &lt;th&gt;options(&lt;a th:href=&quot;@&#123;/toAdd&#125;&quot;&gt;add&lt;/a&gt;)&lt;/th&gt; &lt;/tr&gt; &lt;tr th:each=&quot;employee : $&#123;employeeList&#125;&quot;&gt; &lt;td th:text=&quot;$&#123;employee.id&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;$&#123;employee.gender&#125;&quot;&gt;&lt;/td&gt; &lt;td&gt; &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#39;/employee/&#39;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; &lt;a th:href=&quot;@&#123;&#39;/employee/&#39;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/body&gt; &lt;/html&gt; 5、具体功能：删除a&gt;创建处理delete请求方式的表单&lt;!-- 作用：通过超链接控制表单的提交，将post请求转换为delete请求 --&gt; &lt;form id=&quot;delete_form&quot; method=&quot;post&quot;&gt; &lt;!-- HiddenHttpMethodFilter要求：必须传输_method请求参数，并且值为最终的请求方式 --&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;delete&quot;/&gt; &lt;/form&gt; b&gt;删除超链接绑定点击事件引入vue.js &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; 删除超链接 &lt;a class=&quot;deleteA&quot; @click=&quot;deleteEmployee&quot; th:href=&quot;@&#123;&#39;/employee/&#39;+$&#123;employee.id&#125;&#125;&quot;&gt;delete&lt;/a&gt; 通过vue处理点击事件 &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#dataTable&quot;, methods:&#123; //event表示当前事件 deleteEmployee:function (event) &#123; //通过id获取表单标签 var delete_form = document.getElementById(&quot;delete_form&quot;); //将触发事件的超链接的href属性为表单的action属性赋值 delete_form.action = event.target.href; //提交表单 delete_form.submit(); //阻止超链接的默认跳转行为 event.preventDefault(); &#125; &#125; &#125;); &lt;/script&gt; c&gt;控制器方法@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.DELETE) public String deleteEmployee(@PathVariable(&quot;id&quot;) Integer id)&#123; employeeDao.delete(id); return &quot;redirect:/employee&quot;; &#125; 测试时发现vue.js静态资源找不到，导致发送删除请求时仍是发送的get请求，报出method get not suppport的错误，解决方法分两步： ①此时，我们需要将项目重新打包后再运行而不是直接重新部署就完事了，因为我们后来添加的vue.js资源并没有被打包到项目中 ②然后，重新打包再运行测试时，在控制台仍然报出找不到vue.js的错误，这是因为处理前端请求的DispatcherServlet不能处理静态资源，所以我们需要在springMVC.xml文件中添加&lt;mvc:default-servlet-handler/&gt;标签来让springMVC中的DefaultServletHttpRequestHandler处理对静态资源的请求 6、具体功能：跳转到添加数据页面a&gt;配置view-controller&lt;mvc:view-controller path=&quot;/toAdd&quot; view-name=&quot;employee_add&quot;&gt;&lt;/mvc:view-controller&gt; b&gt;创建employee_add.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Add Employee&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot;&gt;&lt;br&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;add&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 7、具体功能：执行保存a&gt;控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.POST) public String addEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;; &#125; 8、具体功能：跳转到更新数据页面a&gt;修改超链接&lt;a th:href=&quot;@&#123;&#39;/employee/&#39;+$&#123;employee.id&#125;&#125;&quot;&gt;update&lt;/a&gt; b&gt;控制器方法@RequestMapping(value = &quot;/employee/&#123;id&#125;&quot;, method = RequestMethod.GET) public String getEmployeeById(@PathVariable(&quot;id&quot;) Integer id, Model model)&#123; Employee employee = employeeDao.get(id); model.addAttribute(&quot;employee&quot;, employee); //此处应该是使用的转发进行跳转，因为进入到更改信息页面我们还会用到这次请求的数据，但是因为默认就是转发跳转，所以这儿就没有加前缀forwrad return &quot;employee_update&quot;; &#125; c&gt;创建employee_update.html&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Update Employee&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;form th:action=&quot;@&#123;/employee&#125;&quot; method=&quot;post&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;_method&quot; value=&quot;put&quot;&gt; &lt;input type=&quot;hidden&quot; name=&quot;id&quot; th:value=&quot;$&#123;employee.id&#125;&quot;&gt; lastName:&lt;input type=&quot;text&quot; name=&quot;lastName&quot; th:value=&quot;$&#123;employee.lastName&#125;&quot;&gt;&lt;br&gt; email:&lt;input type=&quot;text&quot; name=&quot;email&quot; th:value=&quot;$&#123;employee.email&#125;&quot;&gt;&lt;br&gt; &lt;!-- th:field=&quot;$&#123;employee.gender&#125;&quot;可用于单选框或复选框的回显 若单选框的value和employee.gender的值一致，则添加checked=&quot;checked&quot;属性 --&gt; gender:&lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;1&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;male &lt;input type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;0&quot; th:field=&quot;$&#123;employee.gender&#125;&quot;&gt;female&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;update&quot;&gt;&lt;br&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; 9、具体功能：执行更新a&gt;控制器方法@RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.PUT) public String updateEmployee(Employee employee)&#123; employeeDao.save(employee); return &quot;redirect:/employee&quot;; &#125; 10、静态资源处理的过程经过第5点测试删除功能时报错，这里稍微详细说一下springmvc处理静态资源的过程 在Tomcat中有一个web.xml文件，其中有一个设置默认Servlet和映射路径的的设置： &lt;servlet&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;servlet-class&gt;org.apache.catalina.servlets.DefaultServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;debug&lt;/param-name&gt; &lt;param-value&gt;0&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;listings&lt;/param-name&gt; &lt;param-value&gt;false&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;default&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;!--这个设置就表示将所有请求都交给DefaultServlet进行处理--&gt; 但是在项目工程中，我们还有一个web.xml文件进行了重新设置，即下方配置，将所有请求都交给DispatcherServlet进行处理，此时Tomcat会根据“就近原则”使用项目工程中的web.xml文件配置，但是DispatcherServlet又不能处理静态资源的请求 &lt;servlet&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springMVC.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;springMVC&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 所以，我们就在springmvc配置文件中添加了&lt;mvc:default-servlet-handler/&gt;标签，让DispatcherServlet处理不了的请求交给DefaultServlet处理 但是&lt;mvc:default-servlet-handler/&gt;标签又必须和&lt;mvc:annotation-driven/&gt;标签配合使用，如果不用&lt;mvc:annotation-driven/&gt;标签，那么所有的请求又都会被DefaultServlet处理，这样就只能处理静态资源的请求，其它由注解驱动的请求就都不会被处理了。如果加上&lt;mvc:annotation-driven/&gt;标签，那么请求就都会先被DispatcherServlet处理，如果处理不了再交给DefaultServlet处理 八、HttpMessageConverterHttpMessageConverter，报文信息转换器，将请求报文转换为Java对象，或将Java对象转换为响应报文 HttpMessageConverter提供了两个注解和两个类型：@RequestBody，@ResponseBody，RequestEntity， ResponseEntity 1、@RequestBody@RequestBody可以获取请求体，需要在控制器方法设置一个形参，使用@RequestBody进行标识，当前请求的请求体就会为当前注解所标识的形参赋值 &lt;form th:action=&quot;@&#123;/testRequestBody&#125;&quot; method=&quot;post&quot;&gt; 用户名：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; @RequestMapping(&quot;/testRequestBody&quot;) public String testRequestBody(@RequestBody String requestBody)&#123; System.out.println(&quot;requestBody:&quot;+requestBody); return &quot;success&quot;; &#125; 输出结果： requestBody:username=admin&amp;password=123456 2、RequestEntityRequestEntity封装请求报文的一种类型，需要在控制器方法的形参中设置该类型的形参，当前请求的请求报文就会赋值给该形参，可以通过getHeaders()获取请求头信息，通过getBody()获取请求体信息 @RequestMapping(&quot;/testRequestEntity&quot;) public String testRequestEntity(RequestEntity&lt;String&gt; requestEntity)&#123; //当前RequestEntity表示整个请求报文信息 System.out.println(&quot;requestHeader:&quot;+requestEntity.getHeaders()); System.out.println(&quot;requestBody:&quot;+requestEntity.getBody()); return &quot;success&quot;; &#125; 输出结果：requestHeader:[host:”localhost:8080”, connection:”keep-alive”, content-length:”27”, cache-control:”max-age=0”, sec-ch-ua:”” Not A;Brand”;v=”99”, “Chromium”;v=”90”, “Google Chrome”;v=”90””, sec-ch-ua-mobile:”?0”, upgrade-insecure-requests:”1”, origin:”http://localhost:8080&quot;, user-agent:”Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/90.0.4430.93 Safari/537.36”]requestBody:username=admin&amp;password=123 3、@ResponseBody通过ServletAPI响应数据给浏览器 @RequestMapping(&quot;/testResponseBody&quot;) public String testResponseBody(HttpServletResponse response) throws IOException &#123; response.getWriter().print(&quot;hello world&quot;);//将hello world响应给浏览器 &#125; @ResponseBody用于标识一个控制器方法，可以将该方法的返回值直接作为响应报文的响应体响应到浏览器 @RequestMapping(&quot;/testResponseBody&quot;) @ResponseBody public String testResponseBody()&#123; return &quot;success&quot;; &#125; 结果：浏览器页面显示success，这个就是将success作为响应报文的响应体响应到浏览器然后在浏览器页面显示出来，而不是返回的success.html这个页面 4、SpringMVC处理json@ResponseBody处理json的步骤： a&gt;导入jackson的依赖 &lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.12.1&lt;/version&gt; &lt;/dependency&gt; b&gt;在SpringMVC的核心配置文件中开启mvc的注解驱动，此时在HandlerAdaptor中会自动装配一个消息转换器：MappingJackson2HttpMessageConverter，可以将响应到浏览器的Java对象转换为Json格式的字符串 &lt;mvc:annotation-driven /&gt; c&gt;在处理器方法上使用**@ResponseBody注解进行标识** d&gt;将Java对象直接作为控制器方法的返回值返回，就会自动转换为Json格式的字符串 @RequestMapping(&quot;/testResponseUser&quot;) @ResponseBody public User testResponseUser()&#123; return new User(1001,&quot;admin&quot;,&quot;123456&quot;,23,&quot;男&quot;); &#125; 浏览器的页面中展示的结果： {“id”:1001,”username”:”admin”,”password”:”123456”,”age”:23,”sex”:”男”} 处理响应中文乱码 &lt;mvc:annotation-driven&gt; &lt;mvc:message-converters&gt; &lt;!--处理响应中文乱码--&gt; &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt; &lt;property name=&quot;defaultCharset&quot; value=&quot;UTF-8&quot;/&gt; &lt;property name=&quot;supportedMediaTypes&quot;&gt; &lt;list&gt; &lt;value&gt;text/html&lt;/value&gt; &lt;value&gt;application/json&lt;/value&gt; &lt;/list&gt; &lt;/property&gt; &lt;/bean&gt; &lt;/mvc:message-converters&gt; &lt;/mvc:annotation-driven&gt; 5、SpringMVC处理ajaxa&gt;请求超链接： &lt;div id=&quot;app&quot;&gt; &lt;a th:href=&quot;@&#123;/testAjax&#125;&quot; @click=&quot;testAjax&quot;&gt;testAjax&lt;/a&gt;&lt;br&gt; &lt;/div&gt; b&gt;通过vue和axios处理点击事件： &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/vue.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot; th:src=&quot;@&#123;/static/js/axios.min.js&#125;&quot;&gt;&lt;/script&gt; &lt;script type=&quot;text/javascript&quot;&gt; var vue = new Vue(&#123; el:&quot;#app&quot;, methods:&#123; testAjax:function (event) &#123; axios(&#123; method:&quot;post&quot;, url:event.target.href, params:&#123; username:&quot;admin&quot;, password:&quot;123456&quot; &#125; &#125;).then(function (response) &#123; alert(response.data); &#125;); event.preventDefault(); &#125; &#125; &#125;); &lt;/script&gt; c&gt;控制器方法： @RequestMapping(&quot;/testAjax&quot;) @ResponseBody public String testAjax(String username, String password)&#123; System.out.println(&quot;username:&quot;+username+&quot;,password:&quot;+password); return &quot;hello,ajax&quot;; &#125; 6、@RestController注解@RestController注解是springMVC提供的一个复合注解，标识在控制器的类上，就相当于为类添加了@Controller注解，并且为其中的每个方法添加了@ResponseBody注解 7、ResponseEntityResponseEntity用于控制器方法的返回值类型，该控制器方法的返回值就是响应到浏览器的响应报文 九、文件上传和下载1、文件下载使用ResponseEntity实现下载文件的功能 @RequestMapping(&quot;/fileDown&quot;) public ResponseEntity&lt;byte[]&gt; testResponseEntity(HttpSession session) throws IOException, IOException &#123; //获取ServletContext对象 ServletContext servletContext = session.getServletContext(); //获取服务器中文件的真实路径 String realPath = servletContext.getRealPath(&quot;/static/file/about.md&quot;); System.out.println(realPath); //创建输入流 InputStream is = new FileInputStream(realPath); //创建字节数组 byte[] bytes = new byte[is.available()]; //is.available()是获取到需要下载的文件的输入流字节大小 //将流读到字节数组中 is.read(bytes); //创建HttpHeaders对象设置响应头信息 MultiValueMap&lt;String, String&gt; headers = new HttpHeaders(); //设置要下载方式以及下载文件的名字 headers.add(&quot;Content-Disposition&quot;, &quot;attachment;filename=about.md&quot;); //这儿除了filename的值需要改变，其他都是固定格式 //设置响应状态码 HttpStatus statusCode = HttpStatus.OK; //创建ResponseEntity对象 ResponseEntity&lt;byte[]&gt; responseEntity = new ResponseEntity&lt;&gt;(bytes, headers, statusCode); //关闭输入流 is.close(); return responseEntity; &#125; 2、文件上传文件上传要求form表单的请求方式必须为post，并且添加属性enctype=”multipart/form-data” &lt;form th:action=&quot;@&#123;/fileUpload&#125;&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; 头像：&lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;上传&quot;&gt; &lt;/form&gt; SpringMVC中将上传的文件封装到MultipartFile对象中，通过此对象可以获取文件相关信息 上传步骤： a&gt;添加依赖： &lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt; &lt;/dependency&gt; b&gt;在SpringMVC的配置文件中添加配置： &lt;!--必须通过文件解析器的解析才能将文件转换为MultipartFile对象，而且要加上id，因为spring是通过id来辨认注入bean的--&gt; &lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;/&gt; c&gt;控制器方法： @RequestMapping(&quot;/fileUpload&quot;) public String testUpoad(MultipartFile file,HttpSession session) throws IOException &#123; //这儿的MultipartFile类型的形参名必须要和表单中上传文件的input标签的name属性值一样，否则就算加上了文件解析器也会报空指针异常 //获取上传的文件的文件名 String fileName = file.getOriginalFilename(); //处理文件重名问题 String hzName = fileName.substring(fileName.lastIndexOf(&quot;.&quot;)); fileName = UUID.randomUUID().toString() + hzName; //获取服务器中file目录的路径 ServletContext servletContext = session.getServletContext(); String filePath = servletContext.getRealPath(&quot;/static/file&quot;); File path = new File(filePath); if(!path.exists())&#123; path.mkdir(); &#125; String finalPath = path + File.separator + fileName; //实现上传功能 file.transferTo(new File(finalPath)); return &quot;success&quot;; &#125; 十、拦截器拦截器、过滤器、监听器的执行顺序：监听器 -&gt; 过滤器 -&gt; 拦截器 -&gt; servlet执行 -&gt; 拦截器 -&gt; 过滤器 -&gt; 监听器 拦截器作用于controller前后 1、拦截器的配置SpringMVC中的拦截器用于拦截控制器方法的执行 SpringMVC中的拦截器需要实现HandlerInterceptor接口 SpringMVC的拦截器必须在SpringMVC的配置文件中进行配置： &lt;!--首先要先创建一个拦截器类，实现HandlerInterceptor接口--&gt; &lt;!--然后在springMVC配置文件中进行配置--&gt; &lt;mvc:interceptors&gt; &lt;bean class=&quot;com.springMVC.interceptor.FirstInterceptor&quot;/&gt; &lt;/mvc:interceptors&gt; &lt;mvc:interceptors&gt; &lt;!--这种配置方式需要先在拦截器类上添加@Component注解，并且确保能被扫描到--&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptors&gt; &lt;!-- 以上两种配置方式都是对DispatcherServlet所处理的所有的请求进行拦截 --&gt; &lt;mvc:interceptor&gt; &lt;mvc:mapping path=&quot;/**&quot;/&gt; &lt;mvc:exclude-mapping path=&quot;/testRequestEntity&quot;/&gt; &lt;ref bean=&quot;firstInterceptor&quot;&gt;&lt;/ref&gt; &lt;/mvc:interceptor&gt; &lt;!-- 以上配置方式可以通过ref或bean标签设置拦截器，通过mvc:mapping设置需要拦截的请求，通过mvc:exclude-mapping设置需要排除的请求，即不需要拦截的请求 --&gt; 2、拦截器的三个抽象方法SpringMVC中的拦截器有三个抽象方法： preHandle：控制器方法执行之前执行preHandle()，其boolean类型的返回值表示是否拦截或放行，返回true为放行，即调用控制器方法；返回false表示拦截，即不调用控制器方法 postHandle：控制器方法执行之后执行postHandle() afterComplation：处理完视图和模型数据，渲染视图完毕之后执行afterComplation() DispatcherServlet类中doDispatch方法的源码： image-20220503162430030 image-20220503162649914 3、多个拦截器的执行顺序a&gt;若每个拦截器的preHandle()都返回true 此时多个拦截器的执行顺序和拦截器在SpringMVC的配置文件的配置顺序有关： preHandle()会按照配置的顺序执行，而postHandle()和afterComplation()会按照配置的反序执行 源码分析：（我所使用的jdk版本跟老师的不一样，所以源码也有些不一样） ①首先是拦截器的preHandle方法 image-20220503174247758 进入到applyPreHandle方法中 image-20220503174811560 从上方程序可以看出，当每个拦截器的preHandle方法返回的都是true，那么applyPreHandle方法返回的也是true，就会继续执行控制器方法 image-20220503175340203 在applyPostHandle方法中，可以看出拦截器的postHandle方法就是按拦截器的配置顺序的倒序进行执行的 image-20220503175522838 到了最后处理好数据和渲染视图之后，就开始调用执行拦截器的afterCompletion方法，同样，这儿也是直接按倒序进行调用执行的 image-20220503175910374 所以，最后执行的顺序即： 拦截器配置顺序： &lt;mvc:interceptors&gt; &lt;bean class=&quot;com.springMVC.interceptor.FirstInterceptor&quot;/&gt; &lt;bean class=&quot;com.springMVC.interceptor.SecondInterceptor&quot;/&gt; &lt;/mvc:interceptors&gt; FirstInterceptor ---&gt; preHandle SecondInterceptor ---&gt; preHandle SecondInterceptor ---&gt; postHandle FirstInterceptor ---&gt; postHandle SecondInterceptor ---&gt; afterCompletion FirstInterceptor ---&gt; afterCompletion b&gt;若某个拦截器的preHandle()返回了false 这里我使用了三个拦截器进行测试 如果第一个拦截器的preHandle()就返回false，那么只会执行完第一个拦截器的preHandle方法： FirstInterceptor ---&gt; preHandle 如果是第二个拦截器的preHandle()返回false，那么第一个拦截器的postHandle方法不会执行，但会执行afterCompletion方法；而第二个拦截器就只会执行preHandle方法 FirstInterceptor ---&gt; preHandle SecondInterceptor ---&gt; preHandle FirstInterceptor ---&gt; afterCompletion 如果是第三个拦截器的preHandle()返回false，那么第一个和第二个拦截器的postHandle方法不会执行，但会执行afterCompletion方法；而第三个拦截器就只会执行preHandle方法 FirstInterceptor ---&gt; preHandle SecondInterceptor ---&gt; preHandle ThirdInterceptor ---&gt; preHandle SecondInterceptor ---&gt; afterCompletion FirstInterceptor ---&gt; afterCompletion 总结：preHandle()返回false和它之前的拦截器的preHandle()方法都会执行，返回false之前的拦截器的afterComplation()也会执行而且是按逆序执行，但是postHandle()都不执行，而在返回false的拦截器之后的拦截器所有方法都不执行 十一、异常处理器1、基于配置的异常处理SpringMVC提供了一个处理控制器方法执行过程中所出现的异常的接口：HandlerExceptionResolver HandlerExceptionResolver接口的实现类有：DefaultHandlerExceptionResolver和SimpleMappingExceptionResolver SpringMVC提供了自定义的异常处理器SimpleMappingExceptionResolver，使用方式： &lt;bean class=&quot;org.springframework.web.servlet.handler.SimpleMappingExceptionResolver&quot;&gt; &lt;property name=&quot;exceptionMappings&quot;&gt; &lt;props&gt; &lt;!-- properties的键表示处理器方法执行过程中出现的异常 properties的值表示若出现指定异常时，设置一个新的视图名称，跳转到指定页面 --&gt; &lt;prop key=&quot;java.lang.ArithmeticException&quot;&gt;error&lt;/prop&gt; &lt;!--当出现ArithmeticException异常时就会跳转到error视图页面--&gt; &lt;/props&gt; &lt;/property&gt; &lt;!-- exceptionAttribute属性设置一个属性名，将出现的异常信息在请求域中进行共享 然后，我们可以在返回error页面使用&lt;p th:text=&quot;$&#123;ex&#125;&quot;&gt;&lt;/p&gt;的方式将错误信息显示出来 --&gt; &lt;property name=&quot;exceptionAttribute&quot; value=&quot;ex&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 2、基于注解的异常处理//@ControllerAdvice将当前类标识为异常处理的组件 @ControllerAdvice public class ExceptionController &#123; //@ExceptionHandler用于设置所标识方法处理的异常 @ExceptionHandler(ArithmeticException.class) //value可以是一个异常数组，value=&#123;&#125; //ex表示当前请求处理中出现的异常对象 public String handleArithmeticException(Exception ex, Model model)&#123; model.addAttribute(&quot;ex&quot;, ex); return &quot;error&quot;; &#125; &#125; 十二、注解配置SpringMVC使用配置类和注解代替web.xml和SpringMVC配置文件的功能 1、创建初始化类，代替web.xml在Servlet3.0环境中，容器会在类路径中查找实现javax.servlet.ServletContainerInitializer接口的类，如果找到的话就用它来配置Servlet容器。Spring提供了这个接口的实现，名为SpringServletContainerInitializer，这个类反过来又会查找实现WebApplicationInitializer的类并将配置的任务交给它们来完成。Spring3.2引入了一个便利的WebApplicationInitializer基础实现，名为AbstractAnnotationConfigDispatcherServletInitializer，当我们的类扩展了AbstractAnnotationConfigDispatcherServletInitializer并将其部署到Servlet3.0容器的时候，容器会自动发现它，并用它来配置Servlet上下文 //web工程的初始化配置类，代替web.xml public class WebInit extends AbstractAnnotationConfigDispatcherServletInitializer &#123; /** * 指定spring的配置类 * @return */ @Override protected Class&lt;?&gt;[] getRootConfigClasses() &#123; return new Class[]&#123;SpringConfig.class&#125;; &#125; /** * 指定SpringMVC的配置类 * @return */ @Override protected Class&lt;?&gt;[] getServletConfigClasses() &#123; return new Class[]&#123;WebConfig.class&#125;; &#125; /** * 指定DispatcherServlet的映射规则，即url-pattern * @return */ @Override protected String[] getServletMappings() &#123; return new String[]&#123;&quot;/&quot;&#125;; &#125; /** * 添加过滤器 * @return */ @Override protected Filter[] getServletFilters() &#123; CharacterEncodingFilter encodingFilter = new CharacterEncodingFilter(); encodingFilter.setEncoding(&quot;UTF-8&quot;); encodingFilter.setForceRequestEncoding(true); HiddenHttpMethodFilter hiddenHttpMethodFilter = new HiddenHttpMethodFilter(); return new Filter[]&#123;encodingFilter, hiddenHttpMethodFilter&#125;; &#125; &#125; 2、创建SpringConfig配置类，代替spring的配置文件@Configuration public class SpringConfig &#123; //ssm整合之后，spring的配置信息写在此类中 //也可以参考之前的Spring笔记 &#125; 3、创建WebConfig配置类，代替SpringMVC的配置文件//代替SpringMVC配置文件 //1、扫描组件 //2、开启MVC注解驱动 //3、视图解析器 //4、view-controller //5、default-servlet-handler //6、文件上传解析器 //7、异常处理 //8、拦截器 @Configuration @ComponentScan(&quot;com.springMVC&quot;) //1、扫描组件 @EnableWebMvc //2、开启MVC注解驱动 public class WebConfig implements WebMvcConfigurer &#123; //3、视图解析器 配置生成模板解析器 @Bean public ITemplateResolver templateResolver() &#123; WebApplicationContext webApplicationContext = ContextLoader.getCurrentWebApplicationContext(); // ServletContextTemplateResolver需要一个ServletContext作为构造参数，可通过WebApplicationContext 的方法获得 ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(webApplicationContext.getServletContext()); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCharacterEncoding(&quot;UTF-8&quot;); templateResolver.setTemplateMode(TemplateMode.HTML); return templateResolver; &#125; //生成模板引擎并为模板引擎注入模板解析器 @Bean public SpringTemplateEngine templateEngine(ITemplateResolver templateResolver) &#123; SpringTemplateEngine templateEngine = new SpringTemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; &#125; //生成视图解析器并未解析器注入模板引擎 @Bean public ViewResolver viewResolver(SpringTemplateEngine templateEngine) &#123; ThymeleafViewResolver viewResolver = new ThymeleafViewResolver(); viewResolver.setCharacterEncoding(&quot;UTF-8&quot;); viewResolver.setTemplateEngine(templateEngine); return viewResolver; &#125; //4、view-controller 配置视图控制 @Override public void addViewControllers(ViewControllerRegistry registry) &#123; registry.addViewController(&quot;/&quot;).setViewName(&quot;index&quot;); &#125; //5、default-servlet-handler 使用默认的servlet处理静态资源 @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer) &#123; configurer.enable(); &#125; //6、配置文件上传解析器 @Bean public CommonsMultipartResolver multipartResolver()&#123; return new CommonsMultipartResolver(); &#125; //7、异常处理 @Override public void configureHandlerExceptionResolvers(List&lt;HandlerExceptionResolver&gt; resolvers) &#123; SimpleMappingExceptionResolver exceptionResolver = new SimpleMappingExceptionResolver(); Properties prop = new Properties(); prop.setProperty(&quot;java.lang.ArithmeticException&quot;, &quot;error&quot;); //设置异常映射 exceptionResolver.setExceptionMappings(prop); //设置共享异常信息的键 exceptionResolver.setExceptionAttribute(&quot;exceptionInfo&quot;); resolvers.add(exceptionResolver); &#125; //8、配置拦截器 @Override public void addInterceptors(InterceptorRegistry registry) &#123; FirstInterceptor firstInterceptor = new FirstInterceptor(); registry.addInterceptor(firstInterceptor).addPathPatterns(&quot;/**&quot;); &#125; &#125; 十三、SpringMVC执行流程1、SpringMVC常用组件 DispatcherServlet：前端控制器，不需要工程师开发，由框架提供 作用：统一处理请求和响应，整个流程控制的中心，由它调用其它组件处理用户的请求 HandlerMapping：处理器映射器，不需要工程师开发，由框架提供 作用：根据请求的url、method等信息查找Handler，即控制器方法（controller） Handler：处理器，需要工程师开发（即平时写的controller方法） 作用：在DispatcherServlet的控制下Handler对具体的用户请求进行处理 HandlerAdapter：处理器适配器，不需要工程师开发，由框架提供 作用：通过HandlerAdapter对处理器（控制器方法）进行执行 即在一个控制器方法的执行过程中，由HandlerMapping负责找到我们的控制器方法，然后交给HandlerAdapter去调用执行 image-20220504160653908 ViewResolver：视图解析器，不需要工程师开发，由框架提供 作用：进行视图解析，得到相应的视图，例如：ThymeleafView、InternalResourceView、RedirectView View：视图 作用：将模型数据通过页面展示给用户 2、DispatcherServlet初始化过程DispatcherServlet 本质上是一个 Servlet，所以天然的遵循 Servlet 的生命周期。所以宏观上是 Servlet 生命周期来进行调度。 继承关系： public class DispatcherServlet extends FrameworkServlet&#123;&#125; ↓继承 public abstract class FrameworkServlet extends HttpServletBean implements ApplicationContextAware &#123;&#125; ↓继承 public abstract class HttpServletBean extends HttpServlet implements EnvironmentCapable, EnvironmentAware &#123;&#125; ↓继承 public abstract class HttpServlet extends GenericServlet &#123;&#125; ↓继承 public abstract class GenericServlet implements Servlet, ServletConfig, Serializable &#123;&#125; ↓继承 public interface Servlet &#123;&#125; 初始化大致过程： image-20220504173626189 注：在第六步中，应该是initServletBean去调用initWebApplicationContext方法，然后再由initWebApplicationContext方法去调用createWebApplicationContext方法；另外，在第九步中，DispatcherServlet的onRefresh方法应该是去调用自己的initStrategies方法，在initStrategies中才进行各种初始化（画图时由于是通过截屏进行编辑的，中间又不能退出，记不清过程就漏掉了） 下方是源码中的初始化实现过程（从FrameworkServlet的initServletBean方法开始） a&gt;初始化WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet image-20220504174714246 image-20220504174859776 b&gt;创建WebApplicationContext所在类：org.springframework.web.servlet.FrameworkServlet image-20220504175104551 c&gt;DispatcherServlet初始化策略FrameworkServlet创建WebApplicationContext后，刷新容器，调用onRefresh(wac) image-20220504175511923 此方法在DispatcherServlet中进行了重写，调用了initStrategies(context)方法，初始化策略，即初始化DispatcherServlet的各个组件 所在类：org.springframework.web.servlet.DispatcherServlet protected void initStrategies(ApplicationContext context) &#123; initMultipartResolver(context); initLocaleResolver(context); initThemeResolver(context); initHandlerMappings(context); initHandlerAdapters(context); initHandlerExceptionResolvers(context); initRequestToViewNameTranslator(context); initViewResolvers(context); initFlashMapManager(context); &#125; 3、DispatcherServlet调用组件处理请求处理请求的大致流程图： （第一个框错了，应该是service方法） image-20220504185121356 a&gt;processRequest()FrameworkServlet重写HttpServlet中的service()和doXxx()，这些方法最终都会去调用processRequest(HttpServletRequest, HttpServletResponse) 所在类：org.springframework.web.servlet.FrameworkServlet protected final void processRequest(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; long startTime = System.currentTimeMillis(); Throwable failureCause = null; LocaleContext previousLocaleContext = LocaleContextHolder.getLocaleContext(); LocaleContext localeContext = buildLocaleContext(request); RequestAttributes previousAttributes = RequestContextHolder.getRequestAttributes(); ServletRequestAttributes requestAttributes = buildRequestAttributes(request, response, previousAttributes); WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); asyncManager.registerCallableInterceptor(FrameworkServlet.class.getName(), new RequestBindingInterceptor()); initContextHolders(request, localeContext, requestAttributes); try &#123; // 执行服务，调用doService()方法，是一个抽象方法，在DispatcherServlet中进行了重写 doService(request, response); &#125; catch (ServletException | IOException ex) &#123; failureCause = ex; throw ex; &#125; catch (Throwable ex) &#123; failureCause = ex; throw new NestedServletException(&quot;Request processing failed&quot;, ex); &#125; finally &#123; resetContextHolders(request, previousLocaleContext, previousAttributes); if (requestAttributes != null) &#123; requestAttributes.requestCompleted(); &#125; logResult(request, response, failureCause, asyncManager); publishRequestHandledEvent(request, response, startTime, failureCause); &#125; &#125; b&gt;doService()所在类：org.springframework.web.servlet.DispatcherServlet @Override protected void doService(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; logRequest(request); // Keep a snapshot of the request attributes in case of an include, // to be able to restore the original attributes after the include. Map&lt;String, Object&gt; attributesSnapshot = null; if (WebUtils.isIncludeRequest(request)) &#123; attributesSnapshot = new HashMap&lt;&gt;(); Enumeration&lt;?&gt; attrNames = request.getAttributeNames(); while (attrNames.hasMoreElements()) &#123; String attrName = (String) attrNames.nextElement(); if (this.cleanupAfterInclude || attrName.startsWith(DEFAULT_STRATEGIES_PREFIX)) &#123; attributesSnapshot.put(attrName, request.getAttribute(attrName)); &#125; &#125; &#125; // Make framework objects available to handlers and view objects. request.setAttribute(WEB_APPLICATION_CONTEXT_ATTRIBUTE, getWebApplicationContext()); request.setAttribute(LOCALE_RESOLVER_ATTRIBUTE, this.localeResolver); request.setAttribute(THEME_RESOLVER_ATTRIBUTE, this.themeResolver); request.setAttribute(THEME_SOURCE_ATTRIBUTE, getThemeSource()); if (this.flashMapManager != null) &#123; FlashMap inputFlashMap = this.flashMapManager.retrieveAndUpdate(request, response); if (inputFlashMap != null) &#123; request.setAttribute(INPUT_FLASH_MAP_ATTRIBUTE, Collections.unmodifiableMap(inputFlashMap)); &#125; request.setAttribute(OUTPUT_FLASH_MAP_ATTRIBUTE, new FlashMap()); request.setAttribute(FLASH_MAP_MANAGER_ATTRIBUTE, this.flashMapManager); &#125; RequestPath requestPath = null; if (this.parseRequestPath &amp;&amp; !ServletRequestPathUtils.hasParsedRequestPath(request)) &#123; requestPath = ServletRequestPathUtils.parseAndCache(request); &#125; try &#123; // 调用doDispatch()方法处理请求和响应 doDispatch(request, response); &#125; finally &#123; if (!WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Restore the original attribute snapshot, in case of an include. if (attributesSnapshot != null) &#123; restoreAttributesAfterInclude(request, attributesSnapshot); &#125; &#125; if (requestPath != null) &#123; ServletRequestPathUtils.clearParsedRequestPath(request); &#125; &#125; &#125; c&gt;doDispatch()所在类：org.springframework.web.servlet.DispatcherServlet protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123; HttpServletRequest processedRequest = request; HandlerExecutionChain mappedHandler = null; boolean multipartRequestParsed = false; WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request); try &#123; ModelAndView mv = null; Exception dispatchException = null; try &#123; processedRequest = checkMultipart(request); multipartRequestParsed = (processedRequest != request); // Determine handler for the current request. /* mappedHandler：调用链 包含handler、interceptorList、interceptorIndex handler：浏览器发送的请求所匹配的控制器方法 interceptorList：处理控制器方法的所有拦截器集合 interceptorIndex：拦截器索引，控制拦截器afterCompletion()的执行 */ mappedHandler = getHandler(processedRequest); if (mappedHandler == null) &#123; noHandlerFound(processedRequest, response); return; &#125; // Determine handler adapter for the current request. // 通过控制器方法创建相应的处理器适配器，调用所对应的控制器方法 HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler()); // Process last-modified header, if supported by the handler. String method = request.getMethod(); boolean isGet = &quot;GET&quot;.equals(method); if (isGet || &quot;HEAD&quot;.equals(method)) &#123; long lastModified = ha.getLastModified(request, mappedHandler.getHandler()); if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123; return; &#125; &#125; // 调用拦截器的preHandle() if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123; return; &#125; // Actually invoke the handler. // 由处理器适配器调用具体的控制器方法，最终获得ModelAndView对象 mv = ha.handle(processedRequest, response, mappedHandler.getHandler()); if (asyncManager.isConcurrentHandlingStarted()) &#123; return; &#125; applyDefaultViewName(processedRequest, mv); // 调用拦截器的postHandle() mappedHandler.applyPostHandle(processedRequest, response, mv); &#125; catch (Exception ex) &#123; dispatchException = ex; &#125; catch (Throwable err) &#123; // As of 4.3, we&#39;re processing Errors thrown from handler methods as well, // making them available for @ExceptionHandler methods and other scenarios. dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err); &#125; // 后续处理：处理模型数据和渲染视图 processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException); &#125; catch (Exception ex) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, ex); &#125; catch (Throwable err) &#123; triggerAfterCompletion(processedRequest, response, mappedHandler, new NestedServletException(&quot;Handler processing failed&quot;, err)); &#125; finally &#123; if (asyncManager.isConcurrentHandlingStarted()) &#123; // Instead of postHandle and afterCompletion if (mappedHandler != null) &#123; mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response); &#125; &#125; else &#123; // Clean up any resources used by a multipart request. if (multipartRequestParsed) &#123; cleanupMultipart(processedRequest); &#125; &#125; &#125; &#125; d&gt;processDispatchResult()private void processDispatchResult(HttpServletRequest request, HttpServletResponse response, @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv, @Nullable Exception exception) throws Exception &#123; boolean errorView = false; if (exception != null) &#123; if (exception instanceof ModelAndViewDefiningException) &#123; logger.debug(&quot;ModelAndViewDefiningException encountered&quot;, exception); mv = ((ModelAndViewDefiningException) exception).getModelAndView(); &#125; else &#123; Object handler = (mappedHandler != null ? mappedHandler.getHandler() : null); mv = processHandlerException(request, response, handler, exception); errorView = (mv != null); &#125; &#125; // Did the handler return a view to render? if (mv != null &amp;&amp; !mv.wasCleared()) &#123; // 处理模型数据和渲染视图 render(mv, request, response); if (errorView) &#123; WebUtils.clearErrorRequestAttributes(request); &#125; &#125; else &#123; if (logger.isTraceEnabled()) &#123; logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;); &#125; &#125; if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123; // Concurrent handling started during a forward return; &#125; if (mappedHandler != null) &#123; // Exception (if any) is already handled.. // 调用拦截器的afterCompletion() mappedHandler.triggerAfterCompletion(request, response, null); &#125; &#125; 4、SpringMVC的执行流程 用户向服务器发送请求，请求被SpringMVC 前端控制器 DispatcherServlet捕获。 DispatcherServlet对请求URL进行解析，得到请求资源标识符（URI），判断请求URI对应的映射： a) 不存在 i. 再判断是否配置了mvc:default-servlet-handler ii. 如果没配置，则控制台报映射查找不到，客户端展示404错误 image-202205041904853 image-202205041905142 iii. 如果有配置，则访问目标资源（一般为静态资源，如：JS,CSS,HTML），找不到客户端也会展示404错误 image-202205041905293 image-202205041906372 b) 存在则执行下面的流程 根据该URI，调用HandlerMapping获得该Handler配置的所有相关的对象（包括Handler对象以及Handler对象对应的拦截器），最后以HandlerExecutionChain执行链对象的形式返回。 DispatcherServlet 根据获得的Handler，选择一个合适的HandlerAdapter。 如果成功获得HandlerAdapter，此时将开始执行拦截器的preHandler(…)方法【正向】 提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)方法，处理请求。在填充Handler的入参过程中，根据你的配置，Spring将帮你做一些额外的工作： (a) HttpMessageConveter： 将请求消息（如Json、xml等数据）转换成一个对象，将对象转换为指定的响应信息 (b) 数据转换：对请求消息进行数据转换。如String转换成Integer、Double等 (c) 数据格式化：对请求消息进行数据格式化。 如将字符串转换成格式化数字或格式化日期等 (d) 数据验证： 验证数据的有效性（长度、格式等），验证结果存储到BindingResult或Error中 Handler执行完成后，向DispatcherServlet 返回一个ModelAndView对象。 此时将开始执行拦截器的postHandle(…)方法【逆向】。 根据返回的ModelAndView（此时会判断是否存在异常：如果存在异常，则执行HandlerExceptionResolver进行异常处理）选择一个适合的ViewResolver进行视图解析，根据Model和View，来渲染视图。 渲染视图完毕执行拦截器的afterCompletion(…)方法【逆向】。 将渲染结果返回给客户端。","categories":[{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://rainvex.com/tags/SpringMVC/"}]},{"title":"Ubuntu下搭建Hadoop分布式集群","slug":"Ubuntu下搭建Hadoop分布式集群","date":"2022-04-30T10:37:34.000Z","updated":"2022-04-30T10:37:34.000Z","comments":true,"path":"categories/教程/Ubuntu下搭建Hadoop分布式集群.html","link":"","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/Ubuntu%E4%B8%8B%E6%90%AD%E5%BB%BAHadoop%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4.html","excerpt":"","text":"Ubuntu下搭建Hadoop分布式集群应课程要求，这学期学习到了云计算与大数据，这次实验就是让我们在ubuntu中配置好hadoop分布式集群，这两天就从网上一边搜寻教程并结合课本（课本上是使用的centos，而且版本较老，不太适用）一边自己动手做，顺便自己也写一篇教程记录一下，其中也包含一些遇到的问题及解决方法。因为第一次接触到这方面所以有很多不足的地方，也有写的不清楚的地方，见谅！ 在搭建的过程中，发现几篇写得很详细且文章排版清晰的博客，可供参考： https://blog.csdn.net/zyw2002/article/details/123486055 http://dblab.xmu.edu.cn/blog/2775-2/ https://blog.csdn.net/Pro_MikeXiao/article/details/108740821 另外，教程中涉及到存放路径等操作可以视自己情况而定，只需要在操作时注意改成自己的路径即可 一、准备工作注：笔者虚拟机环境是ubuntu20.04.3，教程中步骤大多属于命令行操作，这也是为了让自己回顾一下Linux命令行操作方式，如果对Linux操作不太熟悉的可以根据教程的描述进行窗口化的操作，当遇到某些操作需要管理员权限的再用命令行 教程配置的是分布式Hadoop集群，所以请先准备好两台虚拟机（master和slave）分别作为主从机，其中有些配置是主从机都需要做的配置（比如前要配置中的前三点和JDK的配置），有些是只用在主机上配置（比如前要配置中的第四点和Hadoop的配置），然后复制到从机即可（在进行这些步骤之前我都会提示是否需要对两台虚拟机进行相同操作） 为了省掉很多命令中因终端位置与操作目录位置不一致带来的麻烦，你可以在窗口界面进入到需要操作的目录后，右键单击，选择在终端中打开，然后再输入命令进行操作 image-20220501145549350 1.1 下载JDK前往oracle官网，找到需要下载的版本（这里我选择的是jdk8，可以根据自己选择其他jdk版本），选择linux的x64版本，然后点击下载 也可以使用我分享的链接（提取码: 4xt3） image-20220430215832297 1.2 下载Hadoop前往apache下的Hadoop官网（可能会出现进不去的情况，需要文明上网一下），点击下载 也可以使用我分享的链接（提取码: ufxv） image-20220430220126570 在下载页面选择要下载的版本，点击Release notes下的Announcement image-20220430220217098 然后点击下载即可 image-20220430220331866 1.3 传输文件将下载的JDK和Hadoop从windows传输到Ubuntu中，可以使用Xftp（前提是已安装并开启ssh服务，可参考[2.2节](#2.2 确保Ubuntu环境已安装ssh)）或是直接复制过去（前提是虚拟机安装了vmtools，不清楚的可以试试直接复制到虚拟机） 将这两个文件移动到ubuntu中的/usr文件夹中 image-20220430222343101 如果传输的过程中出现失败，原因为permission is not allowed说明被传输的文件夹权限不够，只需在ubuntu终端中输入sudo chmod 777 文件夹名称更改文件夹的权限 注：r表是读 (Read) 、w表示写 (Write) 、x表示执行 (execute)读、写、运行三项权限可以用数字表示，就是r=4,w=2,x=1，777就是rwxrwxrwx，即给所有用户赋予对该目录的读、写和执行权限 因为本人在传输时就遇到该问题，然后通过这篇文章解决 二、前要配置这些配置大多是安装配置Hadoop需要的，也可以放到安装好JDK后进行 2.1 查看防火墙是否关闭在终端输入sudo ufw status 如果出现inactive说明防火墙是关闭的，active说明防火墙是开启的，若防火墙是关闭的就可以跳过这一步了 关闭防火墙命令：sudo ufw disable 开启防火墙命令：sudo ufw enable 2.2 确保Ubuntu环境已安装ssh在ubuntu终端中输入sudo ps -e |grep ssh 如果有sshd的项说明已经安装ssh或是ssh服务已启动 image-20220430220942704 如果已安装ssh但是查看ssh状态却没有sshd项，则说明ssh服务未开启，使用sudo service ssh start开启ssh服务 如果未安装ssh，则在终端输入sudo apt-get update和sudo apt-get install openssh-server安装ssh，然后再查看ssh是否开启 2.3 配置主机名和hosts列表这个根据个人安装的Linux发行版以及对应版本的不同而会有所差异（比如CentOS和Ubuntu配置主机名的文件就不一样），如果由于使用的Linux发行版及版本与笔者不一样，则只能自己再去百度一下 ①配置主机名 在终端输入sudo vi /etc/hostname，更改hostname文件中的主机名为master（另一台虚拟机命名为slave） ②配置hosts列表 注：两个虚拟机都需要进行同样的操作 输入sudo vi /etc/hosts，将hosts文件中的127.0.1.1那一行内容删除 然后添加 (你自己的虚拟机的ip地址加上主机名) 192.168.228.128 master 192.168.228.129 slave 虚拟机的IP地址需要使用ifconfig命令查询得到 然后重启虚拟机，再打开终端，即可发现虚拟机主机名已改变 image-20220430233810751 ③测试 在master和slave中均输入ping master -c 4和ping slave -c 4进行测试（表示ping4次就结束），若出现如下图所示则说明主机名和hosts列表配置成功 image-20220430234941547 参考博客 2.4 配置ssh免密匙登录注：请确保已安装好ssh 这儿配置的是master免密登录到slave 2.4.1 在master下进行操作在终端输入ssh-keygen -t rsa命令生成密匙，出现以下提示 image-20220501131836959 此时按下回车确认将ssh的密匙文件保存到默认文件夹下，然后会再出现两次提示，都按下回车键确认即可 按下三次回车键后，出现这种图示说明生成密匙成功 image-20220501132145146 然后我们可以使用cd和ls命令去到/home/你的用户名/.ssh文件夹中并查看是否有名为id_rsa和id_rsa.pub的文件，这就是生成的公钥和私钥文件 如果不想使用命令，也可以在窗口进入.ssh文件夹查看，如果在/home/你的用户名中没有看到.ssh文件夹，需要在右上方的勾选显示隐藏文件 image-20220501132555423 然后，继续输入cat id_rsa.pub &gt;&gt; authorized_keys复制一份公钥文件 注：由于刚刚我是进入到了/home/你的用户名/.ssh文件夹中，所以此时我所在位置就是在.ssh文件夹中，那么我就可以直接这样复制，如果你所在位置并不是在.ssh文件夹中则需要在命令中写好具体路径，比如，cat ~/.ssh/id_rsa.pub &gt;&gt; ~/.ssh/authorized_keys或cat /home/你的用户名/.ssh/id_rsa.pub &gt;&gt; /home/你的用户名/.ssh/authorized_keys 然后，修改authorized_keys文件的权限，命令为：chmod 600 ~/.ssh/authorized_keys 修改后我们可以在.ssh文件夹中使用ls -l命令查看到该文件的权限，如果为-rw------说明修改成功 image-20220501135221827 然后，将authorized_keys文件复制到slave节点的根目录下，命令为scp ~/.ssh/authorized_keys 你的虚拟机用户名@虚拟机主机名:~/，比如我的命令就为scp ~/.ssh/authorized_keys 用户名@slave:~/ image-20220501134442538 输入命令为出现以上提示，输入yes，回车 然后按提示输入slave的登录密码，验证通过后他会自动将authorized_keys文件复制到slave结点 image-20220501135726126 此时我们在slave结点输入cd ~/和ls命令即可看见被复制过来authorized_keys文件 image-20220501140009361 2.4.2 在slave下进行操作同样，使用ssh-keygen -t rsa命令生成密匙 然后，将从master复制到slave的authorized_keys文件移动到slave中的.ssh文件夹中，命令为mv ~/authorized_keys ~/.ssh/ 然后，修改slave中的authorized_keys文件的权限，命令：chmod 600 ~/.ssh/authorized_keys，修改后，我们同样可以使用上面说到的方法查看authorized_keys文件的权限是否修改成功 2.4.3 测试将以上两步配置成功后，我们在master中输入ssh slave，如果未提示输入密码而是直接出现欢迎提示，说明配置成功 image-20220501141623776 三、安装配置JDK注：主从机都需要进行同样操作 3.1 新建文件夹在/usr文件夹中新建一个文件夹用来存放jdk（存放位置可以自己决定，但是后面配置环境变量等就需要注意一下改成自己的存放路径） 在终端中依次使用sudo mkdir /usr/java和sudo mkdir /usr/java/jdk 3.2 解压jdk在终端输入命令sudo tar -xvf /usr/jdk-8u331-linux-x64.tar.gz -C /usr/java/jdk将jdk解压到指定文件夹（-C 文件夹名即是指定解压到哪个目录） 解压完成后，我们就可以在/usr/java/jdk中看到一个名为jdk1.8.0_331的文件夹，为了一会儿配置环境变量方便，这里我们将其重命名一下 使用sudo mv /usr/java/jdk/jdk1.8.0_331 /usr/java/jdk/jdk8将其重命名 Tips：mv指令：移动文件与目录或重命名基本语法：mv oldNameFile newNameFile(功能描述：重命名)mv /temp/movefile /targetFolder(功能描述：移动文件) 3.3 配置环境变量在终端中输入sudo vi /etc/profile编辑profile文件（这种方式是为该系统下所有用户配置，若只想为当前用户配置则编辑~/.bashrc） 在profile文件末尾追加： # JDK8 export JAVA_HOME=/usr/java/jdk/jdk8 export JRE_HOME=$JAVA_HOME/jre export export CLASSPATH=.:%JAVA_HOME%/lib:%JAVA_HOME%/lib/dt.jar:%JAVA_HOME%/lib/tools.jar export PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin # JDK 11后的环境变量配置方法 export JAVA_HOME=/usr/java/jdk-11.0.12 export CLASSPATH=$JAVA_HOME/lib export PATH=$PATH:$JAVA_HOME/bin 然后按ESC返回正常模式，再按:键，输入wq保存退出 输入source /etc/profile使配置的环境变量生效 3.4 测试是否安装成功输入命令java -version，出现以下提示说明成功 image-20220430225547535 注：如果我们新建一个终端窗口，再执行这个命令会出现java not found之类的错误，我们只需要重启一下虚拟机即可，因为每次当虚拟机开启时都会加载/etc/profile文件，从而才会加载配置的jdk环境变量 参考博客，写的挺详细的 四、安装配置Hadoop4.1 新建文件夹在/usr文件夹中新建一个文件夹用来存放hadoop 在终端中使用sudo mkdir /usr/hadoop来创建一个新文件夹 4.2 解压hadoop在终端输入命令sudo tar -xvf /usr/hadoop-3.2.3.tar.gz -C /usr/hadoop将下载好的hadoop解压到指定文件夹 解压完成后，我们就可以在/usr/hadoop中看到一个名为hadoop-3.2.3的文件夹，同样为了配置环境变量方便，这里我们将其重命名一下 使用sudo mv /usr/hadoop/hadoop-3.2.3 /usr/hadoop/hadoop将其重命名 4.3 配置环境变量在终端中输入sudo vi /etc/profile编辑profile文件（与jdk一样，这种方式是为该系统下所有用户配置，若只想为当前用户配置则编辑~/.bashrc） 在profile文件末尾追加： export HADOOP_HOME=/usr/hadoop/hadoop export CLASSPATH=$HADOOP_HOME/bin/hadoop export HADOOP_COMMON_LIB_NATIVE_DIR=$HADOOP_HOME/lib/native export PATH=$PATH:$HADOOP_HOME/bin:$HADOOP_HOME/sbin 然后按ESC返回正常模式，再按:键，输入wq保存退出 输入source /etc/profile使配置的环境变量生效，或是重启一下虚拟机（建议，不重启的话重新开一个终端进行测试会和测试jdk一样报错hadoop找不到的错误） 输入hadoop version，出现以下类似信息说明成功 image-20220501151641615 4.4 配置hadoop（以下均在主节点master的hadoop中进行配置） 这里的操作都可以直接打开需要编辑的文件进行编辑，不需要使用vi或vim 为了快捷，除了第一小节后面的配置我都是用的文本编辑器直接编辑 这里配置的文件都在/usr/hadoop/hadoop/etc/hadoop文件夹中 4.4.1 配置环境变量hadoop-env.sh在/usr/hadoop/hadoop/etc/hadoop（注意位置！！）文件夹中使用终端打开 image-20220501152420189 使用命令vi hadoop-env.sh，打开并编辑这个文件，在末尾添加： # 你自己jdk的保存位置，也是你配置jdk环境变量时的java_home的值 export JAVA_HOME=/usr/java/jdk/jdk8 export HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_HOME&#125;/lib/native&quot; # 这个是后面我遇到问题加的，建议直接加上 按esc回到正常模式，输入:wq保存退出 4.4.2 配置环境变量yarn-env.sh这个和配置hadoop-env.sh一样，在末尾添加export JAVA_HOME=/usr/java/jdk/jdk8即可 4.4.3 配置核心组件core-site.xml使用文本编辑器打开并编辑core-site.xml文件，在标签中添加： &lt;property&gt; &lt;name&gt;fs.defaultFS&lt;/name&gt; &lt;value&gt;hdfs://master:9000&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;hadoop.tmp.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop/tmp&lt;/value&gt; &lt;!--不需要我们提前建好文件夹，如果没有，等会儿格式化名称节点时它会帮我们自动创建--&gt; &lt;/property&gt; 4.4.4 配置文件系统hdfs-site.xml使用文本编辑器打开并编辑hdfs-site.xml文件，在标签中添加： &lt;property&gt; &lt;name&gt;dfs.replication&lt;/name&gt; &lt;value&gt;1&lt;/value&gt; &lt;!--对于Hadoop的分布式文件系统HDFS而言，一般都是采用冗余存储，冗余因子通常为3，也就是说，一份数据保存三份副本。但是，本教程只有一个Slave节点作为数据节点，即集群中只有一个数据节点，数据只能保存一份，所以，dfs.replication的值还是设置为 1--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop/tmp/dfs/name&lt;/value&gt; &lt;!--不需要我们提前建好文件夹，如果没有，等会儿格式化名称节点时它会帮我们自动创建--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop/tmp/dfs/data&lt;/value&gt; &lt;!--不需要我们提前建好文件夹，如果没有，等会儿格式化名称节点时它会帮我们自动创建--&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;dfs.namenode.http-address&lt;/name&gt; &lt;value&gt;master:50070&lt;/value&gt; &lt;/property&gt; 4.4.5 配置文件系统yarn-site.xml使用文本编辑器打开并编辑yarn-site.xml文件，在标签中添加： &lt;property&gt; &lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt; &lt;value&gt;mapreduce_shuffle&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt; &lt;value&gt;master&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.address&lt;/name&gt; &lt;value&gt;master:18040&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.scheduler.address&lt;/name&gt; &lt;value&gt;master:18030&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.resource-tracker.address&lt;/name&gt; &lt;value&gt;master:18025&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.admin.address&lt;/name&gt; &lt;value&gt;master:18141&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.resourcemanager.webapp.address&lt;/name&gt; &lt;value&gt;master:18088&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!--这一点是后面我测试的时候出错添加的，如果不加后面测试可能会出现找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster的错误--&gt; &lt;!--这个配置的值可以通过hadoop classpath命令获取，然后将其复制到此处，后面的mapred-site.xml文件中也添加了这个配置，但是name不一样--&gt; &lt;name&gt;yarn.application.classpath&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop/etc/hadoop:/usr/hadoop/hadoop/share/hadoop/common/lib/*:/usr/hadoop/hadoop/share/hadoop/common/*:/usr/hadoop/hadoop/share/hadoop/hdfs:/usr/hadoop/hadoop/share/hadoop/hdfs/lib/*:/usr/hadoop/hadoop/share/hadoop/hdfs/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/lib/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/*:/usr/hadoop/hadoop/share/hadoop/yarn:/usr/hadoop/hadoop/share/hadoop/yarn/lib/*:/usr/hadoop/hadoop/share/hadoop/yarn/* &lt;/value&gt; &lt;/property&gt; 4.4.6 配置计算框架mapred-site.xml使用文本编辑器打开并编辑mapred-site.xml文件，在标签中添加： &lt;property&gt; &lt;name&gt;mapreduce.framework.name&lt;/name&gt; &lt;value&gt;yarn&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt; &lt;value&gt;master:10020&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt; &lt;value&gt;master:19888&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;yarn.app.mapreduce.am.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/usr/hadoop/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.map.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/usr/hadoop/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;name&gt;mapreduce.reduce.env&lt;/name&gt; &lt;value&gt;HADOOP_MAPRED_HOME=/usr/hadoop/hadoop&lt;/value&gt; &lt;/property&gt; &lt;property&gt; &lt;!--这一点是后面我测试的时候出错添加的，如果不加可能会出现找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster的错误--&gt; &lt;!--这个配置的值可以通过hadoop classpath命令获取，然后将其复制到此处--&gt; &lt;name&gt;mapreduce.application.classpath&lt;/name&gt; &lt;value&gt;/usr/hadoop/hadoop/etc/hadoop:/usr/hadoop/hadoop/share/hadoop/common/lib/*:/usr/hadoop/hadoop/share/hadoop/common/*:/usr/hadoop/hadoop/share/hadoop/hdfs:/usr/hadoop/hadoop/share/hadoop/hdfs/lib/*:/usr/hadoop/hadoop/share/hadoop/hdfs/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/lib/*:/usr/hadoop/hadoop/share/hadoop/mapreduce/*:/usr/hadoop/hadoop/share/hadoop/yarn:/usr/hadoop/hadoop/share/hadoop/yarn/lib/*:/usr/hadoop/hadoop/share/hadoop/yarn/* &lt;/value&gt; &lt;/property&gt; 4.4.7 配置主从结点使用文本编辑器打开并编辑workers文件（hadoop版本3.x以下是slaves文件），将其中的localhost修改为slave即可 4.5 复制到从节点slave我们在/usr/hadoop文件夹中使用终端打开，然后使用命令scp -r hadoop 你的用户名@slave:/usr/hadoop/将配置好的hadoop整个文件夹复制到从节点slave中（因为我们已经配置好了ssh免密登录，所以可以直接复制过去，记得复制过去后在slave中也要配置好hadoop的环境变量！！！） 由于我master和slave节点对jdk和hadoop的存放位置及配置都一样，所以在slave中我就不需要再做其它修改了 image-20220501163515256 等待一会儿即可复制完成 4.6 启动Hadoop集群启动hadoop集群只需要在master节点下进行即可 在/usr/hadoop/hadoop/bin中打开终端 image-20220501165827074 执行命令hdfs namenode -format，如果中间出现提示，按提示输入Y或yes即可（这个只需要在第一次启动集群时执行一次，以后启动就不需要执行了） image-20220501170056265 执行完成后，再进入/usr/hadoop/hadoop/sbin文件夹中执行start-all.sh image-20220501170359974 在主节点master使用命令jps查看进程是否启动，出现了如下几个进程 image-20220501231624470 再在从节点slave中使用jps查看，出现如下几个进程 image-20220501171940540 然后，我们在master节点中打开firefox浏览器，输入http://master:50070/,如图所示 image-20220501172346442 再输入http://master:18088/，如图所示 image-20220501172440779 我们还可以在master节点中使用命令hdfs dfsadmin -report查看数据节点是否正常启动，如果屏幕信息中的“Live datanodes”不为 0 ，则说明集群启动成功。由于我们只有1个slave节点充当数据节点，因此，数据节点启动成功以后，会显示如下图所示信息 image-20220501232116810 最后，再进入到/usr/hadoop/hadoop/share/hadoop/mapreduce文件夹中，执行hadoop jar /usr/hadoop/hadoop/share/hadoop/mapreduce/hadoop-mapreduce-examples-3.2.3.jar pi 10 10测试PI实例 image-20220501172828082 正常的情况下应该是类似这样的： image_20220501233122 但是因为遇到一个问题（我在4.7中第4点提到的）一直解决不了，也就运行不出来 4.7 启动中遇到的问题1、当我在/usr/hadoop/hadoop/sbin文件夹中执行start-all.sh命令时，虽然启动成功了，但是出现WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable的警告，这也导致了我在测试PI实例时也报错，说明其没有加载hadoop的本地库，我们只需在hadoop-env.sh文件中添加export HADOOP_OPTS=&quot;-Djava.library.path=$&#123;HADOOP_HOME&#125;/lib/native&quot;即可 2、启动hadoop后，测试PI实例出现了找不到或无法加载主类 org.apache.hadoop.mapreduce.v2.app.MRAppMaster，此错误的解决方法就是在yarn-site.xml和mapred-site.xml文件添加classpath值，而classpath的值通过hadoop classpath命令获取，这里在4.4.5和4.4.6已经提到过 3、当我多次测试PI实例出现报错org.apache.hadoop.hdfs.server.namenode.SafeModeException: Cannot create directory /user/xk/QuasiMonteCarlo_1651405036380_1661124003/in. Name node is in safe mode，原因：安全模式是hdfs所处的一种特殊状态，在这种状态下，文件系统只接受读数据请求，而不接受删除、修改等变更请求 解决方法：执行改命令关闭安全模式hdfs dfsadmin -safemode leave 4、解决完上面的问题后再测试PI实例报错ipc.Client: Retrying connect to server: slave/192.168.228.129:41589. Already tried 0 time(s); retry policy is RetryUpToMaximumCountWithFixedSleep(maxRetries=3, sleepTime=1000 MILLISECONDS)，造成这个问题的原因在C站的文章评论中已经有小伙伴提出来了，原因是pi后面的10 10让机器太久没跑出来导致崩溃了（应该是这个原因），所以将10 10改成两个小一点的数就OK了。 教程中对hadoop的配置项有点多，我也是把几篇参考教程里面的综合起来的，至于为什么，有什么用，除了有几个配置项是知道的，其他也不是很清楚，这个就需要大家去参考参考官方文档😆 以上就是搭建hadoop分布式集群的全部内容了","categories":[{"name":"教程","slug":"教程","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://rainvex.com/tags/Ubuntu/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://rainvex.com/tags/Hadoop/"}]},{"title":"Typora+PicGo+腾讯云COS搭建图床","slug":"Typora-PicGo-腾讯云COS搭建图床","date":"2022-04-04T06:29:40.000Z","updated":"2022-04-04T06:29:40.000Z","comments":true,"path":"categories/教程/Typora-PicGo-腾讯云COS搭建图床.html","link":"","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/Typora-PicGo-%E8%85%BE%E8%AE%AF%E4%BA%91COS%E6%90%AD%E5%BB%BA%E5%9B%BE%E5%BA%8A.html","excerpt":"","text":"Typora+PicGo+腾讯云COS搭建图床就在前不久，Gitee图床废了！博客文章中使用到的所有图片全部变成了Gitee的图标，甚至很多使用Gitee作为图床的开源项目文档也受到了影响，还有一些作者引流、打赏的二维码图片都变成了Gitee图标，直接影响了他们的收入。如果图床中图片太多，要想转移、更改文章中图片的工作量也是非常巨大的。那么为什么Gitee图床会无缘无故废掉了呢？Gitee因为访问外链太多，给图片添加了防盗链，从而导致不能直接通过url访问到图片，具体原理可以参考这篇文章。 知晓情况后的我立马跑去之前发布过文章的平台中进行查看，发现平台上的文章并没有受影响，应该是在我们写完文章发布时平台都将这些图片存放到了自己的服务器上，但是本地的文章就无一幸免了，不出意外的图片全变成了Gitee图标😭。后来考虑到Github图床访问太慢于是就决定使用腾讯云的对象存储COS重新搭建一个图床来使用了，毕竟白嫖人家的CDN带宽和容量空间确实不太好🤭，而且使用对象存储也不贵，我们还可以在上面存储文件之类的 那么，接下来就正式开始使用Typora+PicGo+腾讯云COS搭建图床了 1.下载Typora和PicGo1.1 下载TyporaTypora从1.0.0版本以后开始收费了，功能更加齐全稳定，如果有更多的需求，还是建议购买，不过测试版的功能已经满足了用户大部分的需求了，如果需要最后一个免费使用的版本，可以点击网盘链接进行下载（提取码: fr4c），也可以从官网中找到所有的老版本，然后下载Old Beta 0.11.18版，只要以后不更新即可白嫖 Typora官网下载链接 安装过程就是一直下一步，更改文件下载路径即可 1.2 下载PicGo进入PicGo官网，点击免费下载即可进入到PicGo在Github上的项目下载地址 然后找到最新的稳定正式版 image-20220404162505254 找到安装包下载链接，点击下载即可 image-20220404162605642 安装同样很简单，这里就在赘述 2.设置Typora首先，打开刚刚下载的Markdown编辑器Typora，点击文件&gt;偏好设置&gt;图像 然后进行以下设置 image-20220404163134962 3.开通配置腾讯云对象存储进入腾讯云官网，注册登录腾讯云账号，如还未进行实名认证，需要先实名认证 然后，在首页找到产品&gt;存储&gt;对象存储，点击对象存储 image-20220404164027060 然后，进入到对象存储页面，点击立即使用 image-20220404164425628 然后，进入到对象存储的控制台，如果是第一次使用，这里会显示开通对象存储COS服务，点击开通即可 开通成功后，点击图中的创建存储桶 image-20220404164750370 然后进入到存储桶列表页面，在该界面再次点击创建存储桶 image-20220404165643505 然后，对存储桶进行以下设置 image-20220404170912979 image-20220404171049488 image-20220404171144792 创建成功后，会进入到刚刚创建的存储桶的文件列表中，即我们存放文件的地方，在这里我们可以新建文件夹来存储相关类型的文件，便于管理；这儿我们新建一个名为images的文件夹，表示存放图片 image-20220404173037257 点击图中上方的返回桶列表，然后在左侧菜单栏找到密钥管理，点击访问密钥 image-20220404171751864 点击访问密钥后，进入到以下界面，在高风险提示中，如果不会子账号的相关操作，点击继续使用主账号也行 image-20220404172134964 然后，点击新建密钥 image-20220404172554016 新建密钥成功后，我们就得到了需要的AAPID、SecretId和SecretKey的值 然后，返回到存储桶列表，点击刚刚创建的存储桶 然后在这个存储桶的概览中找到基本信息，获取到存储桶名称、所属地域 image-20220404174359355 4.设置PicGo打开PicGo，点击PicGo设置，根据个人需要进行一些简单设置，也可以和我设置一样 image-20220404163413743 点击图床设置&gt;腾讯云COS将上方我们获取到的SecretId、SecretKey、APPID、存储空间名、**存储区域(地域)**分别填入下方 由于刚刚我们在存储桶的文件列表新建了一个images文件夹来存放图片，那么在下方的存储路径我们就需要指定相应文件夹 然后点击确定，并设为默认图床 image-20220404173544803 5.验证是否成功在Typora中，仍是偏好设置&gt;图像，点击验证图片上传 image-20220404175711915 如果出现以下提示即代表搭建图床成功 image-20220404175755855 然后我们就可以在创建的存储桶中查看已上传的图片了 注：这种方式搭建的图床有一个弊端：如果我们在PicGo中删除一张不需要的图片后，对象存储中对应的这张图片不会同步删除，而是需要我们去到对象存储控制台手动删除才行 6.Gitee图床文件转移注：如果之前并没未使用过Gitee作为图床可忽略 在已有的Gitee图床中将所有文件下载下来并解压 image-20220404180232224 然后进入创建好的存储桶的文件列表中，进入到images文件夹 然后点击上传文件 image-20220404180802570 在窗口中点击选择文件，然后选中刚刚下载下来的Gitee图床中所有图片文件 image-20220404181121149 选择好所有文件后，点击参数配置 image-20220404181433278 设置对象属性，对这些文件进行以下设置（可根据需要自行修改） image-20220404181536403 然后点击上传等待上传成功即可 image-20220404181742322 然后，根据刚刚在Typora验证图片上传成功后的提示可以知道我们刚刚搭建的对象存储的url地址，比如，上传成功后的url地址为https://xxxx.myqcloud.com/images/202204041817436.png，我们只需复制https://xxxx.myqcloud.com/images/这一部分 同时，我们也可以通过查看存储桶的域名信息知道存储桶的访问域名https://xxxx.myqcloud.com/ image-20220404212853236 然后，打开我们需要更改图片地址的文章，复制之前Gitee图床的url地址（同样也只需要复制xxxx.png即文件名前面一部分） 然后，按下Ctrl+H，使用对象存储的url地址替换掉Gitee图床的url地址 image-20220404183046353 注：因为我们在PicGo设置中设置了图片上传使用时间戳重命名，所有图片名称都是没变的，所以我们只需更改url路径即可 结语：其实整个过程是很简单的，如果对于对象存储想有更高级的使用，比如给对象存储设置防盗链、存储桶的权限管理、域名与传输管理等，可参考一下腾讯云中的官方文档，仔细研究一下还是很容易看懂的。可能很多人害怕对象存储的费用很高，其实不用担心，费用真的很少，他是默认按量计费，我用了半个月才用了几分钱（可能我请求量之类的比较少），如果存放在对象存储上的文件访问的比较少，可以将它们设置为低频存储之类，费用就会更少 到此，Typora+PicGo+腾讯云COS搭建图床和图床文件转移就结束了！有不足之处望指出！😄","categories":[{"name":"教程","slug":"教程","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/"}],"tags":[{"name":"Typora","slug":"Typora","permalink":"http://rainvex.com/tags/Typora/"},{"name":"PicGo","slug":"PicGo","permalink":"http://rainvex.com/tags/PicGo/"},{"name":"图床","slug":"图床","permalink":"http://rainvex.com/tags/%E5%9B%BE%E5%BA%8A/"}]},{"title":"Linux学习笔记（上）","slug":"Linux学习笔记","date":"2022-03-27T14:14:34.000Z","updated":"2022-03-27T14:14:34.000Z","comments":true,"path":"categories/Linux/Linux学习笔记.html","link":"","permalink":"http://rainvex.com/categories/Linux/Linux%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"这是去年暑假快结束时看视频学习做的笔记，当时看了一半开学了后来就再也没看过，但是也足够应付日常学习使用了，现在基本也已经忘得差不多了😆等以后腾出时间了再看后面的 Linux学习笔记学习架构： image-20210814172313078 一、Linux基础1.1 Linux介绍1.1.1 Linux简介Linux是一款操作系统，免费，开源，安全，高效，稳定，处理高并发非常强悍，现在很多的企业级的项目都部署到Linux/unix服务器运行 Linux 内核最初只是由芬兰人林纳斯·托瓦兹（Linus Torvalds）在赫尔辛基大学上学时出于个人爱好而编写的 Linux 是一套免费使用和自由传播的类 Unix 操作系统，是一个基于 POSIX 和 UNIX 的多用户、多任务、支持多线程和多 CPU 的操作系统 Linux 能运行主要的UNIX工具软件、应用程序和网络协议。它支持 32 位和 64 位硬件。Linux 继承了 Unix 以网络为核心的设计思想，是一个性能稳定的多用户网络操作系统 目前主要的操作系统有：Windows、Android、Linux、IOS、MacOS、车载系统等 1.1.2 Linux发行版Linux 的发行版说简单点就是将 Linux 内核与应用软件做一个打包 Linux主要的发行版：Ubuntu(乌班图)、RedHat(红帽)、CentOS、Debain(蝶变)、Fedora、SuSE、OpenSUSE image-20210813104850192 1.1.3 Linux应用领域现如今各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，各种场合都有使用各种 Linux 发行版，从嵌入式设备到超级计算机，并且在服务器领域确定了地位，通常服务器使用 LAMP（Linux + Apache + MySQL + PHP）或 LNMP（Linux + Nginx+ MySQL + PHP）组合 image-20210814175025164 image-20210814175117344 image-20210814175308356 1.1.4 Linux与Unix的关系1.UNIX的来历image-20210814180911436 2.Linux的来历image-20210814181029762 3.UNIX和Linux的关系image-20210814181201417 1.1.5 Linux和Windows的比较 比较 Windows Linux 界面 界面统一，外壳程序固定所有 Windows 程序菜单几乎一致，快捷键也几乎相同 图形界面风格依发布版不同而不同，可能互不兼容。GNU/Linux 的终端机是从 UNIX 传承下来，基本命令和操作方法也几乎一致 驱动程序 驱动程序丰富，版本更新频繁。默认安装程序里面一般包含有该版本发布时流行的硬件驱动程序，之后所出的新硬件驱动依赖于硬件厂商提供。对于一些老硬件，如果没有了原配的驱动有时很难支持。另外，有时硬件厂商未提供所需版本的 Windows 下的驱动，也会比较头痛 由志愿者开发，由 Linux 核心开发小组发布，很多硬件厂商基于版权考虑并未提供驱动程序，尽管多数无需手动安装，但是涉及安装则相对复杂，使得新用户面对驱动程序问题（是否存在和安装方法）会一筹莫展。但是在开源开发模式下，许多老硬件尽管在Windows下很难支持的也容易找到驱动。HP、Intel、AMD 等硬件厂商逐步不同程度支持开源驱动，问题正在得到缓解 使用 使用比较简单，容易入门。图形化界面对没有计算机背景知识的用户使用十分有利 图形界面使用简单，容易入门。文字界面，需要学习才能掌握 学习 系统构造复杂、变化频繁，且知识、技能淘汰快，深入学习困难 系统构造简单、稳定，且知识、技能传承性好，深入学习相对容易 软件 每一种特定功能可能都需要商业软件的支持，需要购买相应的授权 大部分软件都可以自由获取，同样功能的软件选择较少 安全性 三天两头打补丁安装系统安全更新,还是会中病毒木马 要说Linux没有安全问题，那当然是不可能的,这―点仁者见仁智者见智，相对来说肯定比Windows平台要更加安全 可定制性 封闭的，系统可定制性很差 开源，可定制化非常强 应用场景 桌面操作系统主要使用的是windows 支撑百度,谷歌,淘宝等应用软件和服务的,是后台成千上方的Linux服务器主机。世界上大部分软件和服务都是运行在Linux之上的 1.2 Linux安装学习Linux需要一个环境，我们需要创建一个虚拟机，然后在虚拟机上安装一个Centos系统来学习 先安装virtual machine ,vm12 再安装Linux (CentOS 6.8) 原理示意图 image-20210813114435396 1.2.1 VM安装(Virtual Machine16)下载链接：https://www.vmware.com/products/workstation-pro/workstation-pro-evaluation.html 安装步骤参考博客：https://blog.csdn.net/qq_40950957/article/details/80467513 1.2.2 CentOS(8.4)安装 创建虚拟机 开始安装系统(CentOS) 1.创建虚拟机image-20210813140324364 image-20210813140455830 image-20210813140802838 image-20210813141342050 image-20210813141914033 image-20210813142000323 点击完成后，出现此页面 image-20210813142301179 2.编辑虚拟机配置①设置内存 image-20210813142651409 ②设置处理器 image-20210813145038255 ③设置网络适配器 image-20210813150256348 说明： 网络连接类型的选择，网络连接类型一共有桥接、NAT、仅主机和不联网四种。 桥接：选择桥接模式的话虚拟机和宿主机在网络上就是平级的关系，相当于连接在同一交换机上 NAT：NAT模式就是虚拟机要联网得先通过宿主机才能和外面进行通信 仅主机：虚拟机与宿主机直接连起来 image-20210813150926963 image-20210814183433435 3.开始安装CentOS①在虚拟机设置中选择下载好的镜像文件，然后启动虚拟机 image-20210813205002332 ②启动后会出现此页面，利用“↑和↓键”选择第一项，然后Enter image-20210814152521546 ③等待一段时间后，出现下方界面，然后搜索”chinese”，点击中文，选择简体中文，然后点击继续 image-20210813205848078 ④然后在出现的此界面进行相应设置 image-20210814145800843 首先，设置时区和日期 image-20210814142100918 然后，设置要安装的软件 image-20210814153516061 然后，设置安装目标位置 image-20210814153933635 然后会弹出一个页面，在此页面中设置分区大小 image-20210814155116665 image-20210814155248764 image-20210814155852518 image-20210814160109595 image-20210814160930075 注：linux分区介绍 image-20210814154748176 然后，设置KDUMP image-20210814161216554 然后，设置网络和主机名 image-20210814161454414 然后，安全策略可以不用管，显示为没有找到内容 然后，设置Root密码，类似windows的密码，用于登录系统 image-20210814142511862 然后，创建用户 image-20210814162030103 最后，确认所有设置无误后，点击开始安装 image-20210814162339607 ⑤安装完成，重启系统 image-20210814164515812 ⑥重启成功后，接收许可证信息，完成配置 image-20210814164944505 ⑦选择用户，输入密码，登录系统 image-20210814165142832 ⑧进入系统，进行使用配置 image-20210814165345388 image-20210814165438081 image-20210814165521731 image-20210814165540765 image-20210814165600033 image-20210814165828731 ⑨安装完成 image-20210814165912479 1.3 虚拟机系统管理1.3.1 虚拟机克隆方式1：直接拷贝一份安装好的虚拟机文件首先，找到已有的虚拟机文件夹，点击复制粘贴到想复制存放的位置 image-20210814184615770 然后，打开VMware Workstation，点击选项卡中的文件，点击打开 image-20210814184840125 最后，在弹窗中找到复制的文件夹，选择.vmx文件，点击打开即可 image-20210814185130636 方式2：使用VMware的克隆操作注意：克隆时，需要先关闭linux系统 首先，打开VMware，右键单击将被克隆的虚拟机，在管理项点击克隆 image-20210814185805858 然后，点击下一页 image-20210814185923841 然后，再点击下一页 image-20210814190001421 然后，选择创建完整克隆，再点击下一页 image-20210814190109420 最后，输入新虚拟机名称，选择存放位置，点击完成即可 image-20210814190234812 1.3.2 虚拟机快照如果你在使用虚拟机系统的时候(比如Linux)，你想回到原先的某一个状态，也就是说你担心可能有些误操作造成系统异常，需要回到原先某个正常运行的状态，VMware也提供了这样的功能，就叫快照管理 应用实例： 安装好系统以后，先做一个快照A 进入到系统。创建一个文件夹，再保存一个快照B 回到系统刚刚安装好的状态，即快照A 试试看，是否还能再次回到快照B image-20210814205828065 具体操作： 首先，右键单击需要被快照的虚拟机，选择快照，点击拍摄快照 image-20210814205232489 然后，在弹出的窗口给快照命名，添加描述，再点击拍摄快照 image-20210814205419056 然后，拍摄好的快照可在快照管理器中看到 image-20210814205510419 最后，如果我们要回到到某个快照的状态，只需要在快照管理器中点击要回到的快照状态，然后点击转到即可 image-20210814205653365 1.3.3 虚拟机迁移和删除虚拟系统安装好后，它的本质就是文件(放在文件夹的) 因此虚拟系统的迁移很方便，可以把安装好的虚拟系统这个文件夹整体拷贝或者剪切到另外位置使用 删除也很简单，用VMware进行移除，再点击菜单-&gt;从磁盘删除即可，或者直接手动删除虚拟系统对应的文件夹即可 1.3.4 vmtools安装参考链接：https://www.pianshen.com/article/81381979583/ 1.vmtools的作用 vmtools安装后，可以让我们在windows下更好的管理vm虚拟机 可以设置windows和centos的共享文件夹 设置共享文件夹的具体步骤：（为了方便，可以设置一个共享文件夹，比如d:/myshare） 菜单-&gt;vm-&gt;setting，如图设置即可注意：设置选项为always enable，这样可以读写了 image-20210816102943273 windows和centos可共享d:/myshare目录可以读写文件了 共享文件夹在centos的/mnt/hgfs/下 注意事项和细节说明： windows和contos就可以共享文件了，但是在实际开发中，文件的上传下载是需要使用远程方式完成的 远程方式登录，后面会具体讲解 2.安装vmtools的步骤注：CentOS8.X版本已经自带vmtools，不用自己安装 进入centos 点击vm菜单的-&gt;install vmware tools centos会出现一个vm的安装包，xx.tar.gz image-20210815131157018 拷贝到/opt image-20210815131345378 image-20210815131602434 使用解压命令tar，得到一个安装文件（在终端使用命令 cd /opt 进入到opt文件夹，ls查看这个文件夹中的文件，tar -zxvf解压文件夹） image-20210815132144324 image-20210815132903256 进入该vm解压的目录，/opt目录下 image-20210815133545684 安装./vmware-install.pl image-20210815134239706 全部使用默认设置即可，就可以安装成功（安装过程中全部回车即可） 注意：安装vmtools需要有gcc 进行完上述操作之后，还需要重启下虚拟机才行。这里可以测试一下是否安装成功，在本机复制一个文件，然后在虚拟机中粘贴，若粘贴成功就表明 VMware Tools 安装成功了 3.重新安装vmtools不能点击的解决办法image-20210815125723711 image-20210815125900331 image-20210815125932435 image-20210815130228189 image-20210815130457927 1.4 Linux目录结构1.4.1 基本介绍1.linux的文件系统是采用级层式的树状目录结构，在此结构中的**最上层是根目录”/“**，然后在此目录下再创建其他的目录 2.深刻理解linux树状文件目录是非常重要的 3.在Linux世界里，一切皆文件 image-20210816103910457 1.4.2 目录结构详解具体的目录结构 /bin：(常用)(usr/bin、/usr/local/bin)是Binary的缩写，这个目录存放着最经常使用的命令 /sbin：(/usr/sbin、/usr/local/sbin) s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序 /home：(常用)存放普通用户的主目录，在Linux中每个用户都有一个自己的目录，一般该目录名是以用户的账号命名 /root：(常用)该目录为系统管理员，也称作超级权限者的用户主目录 /lib：系统开机所需要最基本的动态连接共享库，其作用类似于Windows里的DLL文件。几乎所有的应用程序都需要用到这些共享库 /lost+found：这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件 /etc：(常用)所有的系统管理所需要的配置文件和子目录，比如安装mysql数据库my.conf /usr：(常用)这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似与windows下的program files目录 /boot：(常用)存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件 /proc：这个目录是一个虚拟的目录，它是系统内存的映射，访问这个目录来获取系统信息 /srv：service缩写，该目录存放一些服务启动之后需要提取的数据 /sys：这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统sysfs /tmp：这个目录是用来存放一些临时文件 /dev：类似于windows的设备管理器，把所有的硬件用文件的形式存储 /media：(常用)linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下 /mnt：(常用)系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将外部的存储挂载在/mnt/上，然后进入该目录就可以查看里的内容了。比如共享文件夹d:/myshare /opt：这是给主机额外安装软件所摆放的目录。如安装ORACLE数据库就可放到该目录下。默认为空 /usr/local：(常用)这是另一个给主机额外安装软件所安装的目录。一般是通过编译源码方式安装的程序 /var：(常用)这个目录中存放着在不断扩充着的东西，习惯将经常被修改的目录放在这个目录下。包括各种日志文件 /selinux：(security-enhanced linux)SELinux是一种安全子系统，它能控制程序只能访问特定文件，有三种工作模式，可以自行设置 二、Linux实操2.1 远程登录为什么需要远程登陆？ linux服务器是开发小组共享 正式上线的项目是运行在公网 因此程序员需要远程登录到Linux进行项目管理或者开发 远程登录客户端有Xshell6，Xftp6，学习使用Xshell和 Xftp6，其它的远程工具大同小异 Xshell和Xftp下载链接：https://www.netsarang.com/en/free-for-home-school/ 2.1.1 使用Xshell远程登录首先，在虚拟机Linux系统的终端中使用**ifconfig命令**查看本虚拟机的IP image-20210816114840241 然后，打开下载安装好的Xshell软件，此时会弹出一个新建会话的窗口，点击新建 image-20210816115008857 然后，在弹出的窗口进行会话信息填写，然后关闭新建会话的窗口 image-20210816115322679 然后，双击新建的这个会话 image-20210816115738652 然后，输入登录的用户名和密码 image-20210816115922266 image-20210816120151236 最后，查看是否登陆成功 image-20210816120205231 2.1.2 使用Xftp远程文件传输同样，Xftp也需要像Xshell一样新建会话才能进行文件传输 首先，进入Xftp会弹出新建会话的窗口，在此窗口点击新建 image-20210816142009785 然后，在弹出的窗口输入相关信息 image-20210816142342337 然后，又会出现和Xshell一样的让你选择是一次性连接还是保存连接 image-20210816142608088 最后，连接成功 image-20210816142846972 上图中出现Linux文件名乱码的情况，解决办法如下：此方法是针对所有会话，若只想针对一个会话进行设置，只需点击打开后，右键单击想要设置的会话，点击属性进行设置即可 image-20210816143209970 连接成功后，我们就可以选择想要传输的文件，选择要传输到哪个位置，然后右键单击文件，选择传输即可(Windows –&gt; Linux或Linux –&gt; Windows) 2.2 Vi和Vim编辑器2.2.1 Vi和Vim的介绍Linux系统会内置Vi文本编辑器 Vim具有程序编辑的能力，可以看做是Vi的增强版本，可以主动的以字体颜色辨别语法的正确性，方便程序设计。代码补完、编译及错误跳转等方便编程的功能特别丰富，在程序员中被广泛使用 2.2.2 Vi和Vim的三种模式 一般/正常模式：以vim打开一个档案就直接进入一般模式了(这是默认的模式)。在这个模式中，你可以使用【上下左右】按键来移动光标，你可以使用「删除宇符」或「删除整行」来处理档案内容,也可以使用「复制、粘贴」来处理你的文件数据 插入模式 按下i，I，o，O，a，A，r，R等任何一个字母之后才会进入编辑模式，一般来说按i即可 命令行模式 在这个模式当中，可以提供你相关指令，完成读取、存盘、替换、离开vim、显示行号等的动作则是在此模式中达成的；从插入模式转换到命令行模式：先按下esc再输入一个冒号：即可 image-20210816151348069 2.2.3 Vi和Vim的使用1.方法一：Xshell中使用首先，在Xshell连接成功后输入vim hello.java，按回车 image-20210816145333825 然后，就创建了一个新文件，进入了vim的正常模式 image-20210816150031122 然后，按i，I，o，O，a，A，r，R键中任意一个字母就可进入插入模式进行编辑 然后，按Esc键再输入冒号:即可进入命令行模式，然后再输入wq，按回车，就可保存编辑的内容并退出vim image-20210816150639510 此时我们能在虚拟机系统中看到这个新建的文件 image-20210816150749412 2.虚拟机系统中使用首先在要存放文件的文件的位置右键单击，选择在终端打开输入vim 文件名 image-20210816162124932 然后在终端中就可以像Xshell中一样进行文件的编辑了 或是直接点击打开要进行编辑的文件（也可以使用touch 文件名指令创建一个新文件），就能用图形界面进行编辑，如下图 image-20210817145456270 2.2.4 Vi和Vim的快捷键快捷键使用练习： 拷贝当前行 yy，拷贝当前行向下的5行 5yy，并粘贴（输入p）[正常模式下] **删除当前行 dd，删除当前行向下的5行 5dd **[正常模式下] 在文件中查找某个单词[命令行下 /关键字，回车查找，输入n就是查找下一个] 设置文件的行号，取消文件的行号[命令行下：set nu和：set nonu] 编辑/etc/profile文件，使用快捷键到该文档的最末行[G]和最首行[gg] [正常模式下] 在一个文件中输入”hello”，然后又撤销这个动作 u [正常模式下] 编辑/etc/profile 文件，并将光标移动到20行，输入20，再shift+g [正常模式下] 2.2.5 Vi和Vim键位图image-20210816155813164 2.3 开机、重启和用户登录注销image-20210816162451855 image-20210816163455963 2.4 用户管理Linux系统是一个多用户多任务的操作系统，任何一个要使用系统资源的用户，都必须首先向系统管理员申请一个账号，然后以这个账号的身份进入系统 2.4.1 添加用户基本语法：useradd 用户名 应用案例案例1：添加一个用户milan，默认该用户的家目录在/home/milan（useradd milan） 细节说明1.当创建用户成功后，会自动的创建和用户同名的家目录2也可以通过useradd -d 指定目录 新的用户名，给新创建的用户指定家目录 2.4.2 指定/修改密码基本语法：passwd 用户名 应用案例给milan指定密码（passwd milan） 补充：显示当前用户所在的目录 pwd 2.4.3 删除用户基本语法：userdel 用户名 应用案例1.删除用户milan，但是要保留家目录（userdel milan）2.删除用户以及用户主目录（userdel -r milan） 细节说明是否保留家目录的讨论?一般情况下，建议保留 2.4.4 查询用户信息指令基本语法：id 用户名 应用实例案例：请查询root信息（id root） 细节说明当用户不存在时，返回无此用户 2.4.5 切换用户介绍在操作Linux中，如果当前用户的权限不够，可以通过su - 指令，切换到高权限用户，比如root 基本语法：su - 切换用户名 应用实例创建一个用户jack，指定密码，然后切换到 jack（useradd jack passwd jack su - jack） 细节说明1.从权限高的用户切换到权限低的用户，不需要输入密码，反之需要2.当需要返回到原来用户时，使用exit/logout指令 2.4.6 查看当前用户/登录用户基本语法：whoami/who am i 查询的是第一次登录当前服务器的用户（比如，第一次使用root登录，然后切换到jack，再使用该命令查询到的依然是root） 2.4.7 用户组介绍类似于角色，系统可以对有共性的多个用户进行统一的管理 新增组指令：groupadd 组名 删除组指令(基本语法)：groupdel 组名 增加用户时直接加上组指令(基本语法)：useradd -g 用户组 用户名若增加用户时没有指定将用户添加到哪个组，会默认创建一个与用户名同名的组，将用户存放在其中增加一个用户zwj，直接将他指定到wudang（groupadd wudang useradd -g wudang zwj） 修改用户的组指令(基本语法)：usermod -g 用户组 用户名 2.4.8 用户和组相关文件/etc/passwd文件：用户(user)的配置文件，记录用户的各种信息每行的含义：用户名:口令:用户标识号:组标识号:注释性描述:主目录:登录Shell /etc/shadow文件：口令的配置文件每行的含义：登录名:加密口令:最后一次修改时间:最小时间间隔:最大时间间隔:警告时间:不活动时间:失效时间:标志 /etc/group文件：组(group)的配置文件，记录Linux包含的组的信息每行含义：组名:口令:组标识号:组内用户列表 2.5 实用指令2.5.1 指定运行级别1.init指令切换运行级别的命令：init [0123456] 运行级别说明： 0：关机 1：单用户【找回丢失密码】 2∶多用户状态没有网络服务 3∶多用户状态有网络服务 4∶系统未使用保留给用户 5：图形界面 6∶系统重启 常用运行级别是3和5，也可以指定默认运行级别 CentOS7后运行级别说明：在CentOS7以前，都在/etc/inittab文件中来修改默认运行级别 在CentOS7之后进行了简化，如下： multi-user.target：analogous to runlevel 3（即multi-user.target相当于运行级别3） graphical.target：analogous to runlevel 5（即graphical.target相当于运行级别5） To view current default target，run：systemctl get-default（想要**查看当前默认target，在终端输入systemctl get-default**即可查看） To set a default target，run：systemctl set-default TARGET.target（想要**设置默认target，在终端输入systemctl set-default TARGET.target**即可设置成相对应的默认target） 2.5.2 找回root密码面试题如何找回root密码 课堂练习1.假设root密码忘记了，请问如何找回密码2.设置运行级别，linux运行后，直接进入到命令行终端(3) 步骤（CentOS7.6为例）：1.首先，启动系统，进入开机界面，在界面中按“e”进入编辑界面 如图 image-20210817112711386 2.进入编辑界面，使用键盘上的上下键把光标往下移动，找到以”Linux16”开头内容所在的行数，在行的最后面输入：init=bin/sh 如图 image-20210817112918459 3.接着，输入完成后，直接按快捷键：Ctrl+x 进入单用户模式4.接着，在光标闪烁的位置中输入：mount -o remount,rw /(注意：各个单词间有空格)，完成后按键盘的回车键(Enter)如图 image-20210817113238436 5.在新的一行最后面输入：passwd，完成后按键盘的回车键〈Enter)。输入密码，然后再次确认密码即可(密码长度最好8位以上，但不是必须的)，密码修改成功后，会显示passwd…..的样式，说明密码修改成功 image-20210817113403201 6.接着，在鼠标闪烁的位置中（最后一行中）输入：touch /.autorelabel(注意：touch与/后面有一个空格)，完成后按键盘的回车键(Enter)7.继续在光标闪烁的位置中，输入：exec /sbin/init(注意：exec与/后面有一个空格)，完成后按键盘的回车键(Enter)，等待系统自动修改密码(这个过程时间可能有点长，耐心等待)，完成后，系统会自动重启，新的密码生效了 步骤（CentOS8为例）：参考链接1：https://blog.csdn.net/qq_37960324/article/details/107709858 参考链接2：https://www.jb51.net/article/182993.htm 1.启动前按“e”进入启动配置编辑模式 image-20210817120518106 2.修改启动权限配置。将ro改为rw，在末尾加入：init=/bin/sh，图中init后面的\\是系统加的，不用管 image-20210817120608582 3.ctrl + x 进入紧急模式 4.更改密码 输入passwd设置新密码（建议明文修改，保不准万一键入问题被搞死），修改完成后运行命令touch /.autorelabel使SELinux生效，密码生效，然后输入exec /sbin/init快速启动 image-20210817120951267 2.5.3 帮助指令1.man指令man指令：获得帮助信息基本语法：man [命令或配置文件]应用案例：查看ls命令的帮助信息（man ls） 2.help指令help指令：获得shell内置命令的帮助信息基本语法：help 命令应用实例：案例：查看cd命令的帮助信息（help cd） 在linux下，隐藏文件是以.开头，选项可以组合使用比如ls -al是显示当前文件夹下的所有目录以单列形式列出；比如ls -al /root是将root文件夹之下的所有目录以单列形式列出 2.5.4 文件目录指令1.pwd指令pwd指令：显示当前工作目录的绝对路径基本语法：pwd 2.ls指令ls指令：查看指定目录中的文件和目录基本语法：ls [选项] [目录或是文件]常用选项-a：显示当前目录所有的文件和目录，包括隐藏的-l：以列表的方式显示信息应用实例：查看当前目录的所有内容信息（ls -al） 3.cd指令cd指令：切换到指定目录基本语法：cd [参数]理解：绝对路径和相对路径cd ~或者cd：回到自己的家目录，比如，现在我们是使用root账户登录，则cd ~就是返回到/rootcd ..回到当前目录的上一级目录应用实例：案例1：使用绝对路径切换到root目录（cd /root）案例2：使用相对路径到/root目录，比如在/home/tom下（cd ../../root）案例3：表示回到当前目录的上一级目录（cd ..）案例4：回到家目录（cd ~） 4.mkdir指令mkdir指令：用于创建目录基本语法：mkdir [选项] 要创建的目录常用选项：-p：创建多级目录应用实例：案例1：创建一个目录/home/dog（mkdir /home/dog）案例2：创建多级目录/home/animal/tiger（mkdir -p /home/animal/tiger） 5.rmdir指令rmdir指令：删除空目录基本语法：rmdir [选项] 要删除的空目录应用实例：案例：删除一个目录/home/dog（rmdir /home/dog）使用细节：rmdir 删除的是空目录，如果目录下有内容时无法删除的提示：如果需要删除非空目录，需要使用rm -rf 要删除的目录（比如，rm -rf /home/animal） 6.touch指令touch指令：创建空文件基本语法：touch 文件名称应用实例：案例：创建一个空文件hello.txt（touch hello.txt） 7.cp指令cp指令：拷贝文件到指定目录基本语法：cp [选项] source dest（source指要拷贝的文件，dest指要拷贝到的目录）常用选项：-r：递归复制整个文件夹应用实例：案例1：将/home/hello.txt拷贝到/home/bbb目录下（mkdir /home/bbb cp /home/hello.txt /home/bbb）案例2：递归复制整个文件夹，举例，比如将/home/bbb整个目录，拷贝到/opt（cp -r /home/bbb /opt）使用细节：强制覆盖不提示的方法：\\cp 8.rm指令rm指令：移除文件或目录基本语法：rm [选项] 要删除的文件或目录常用选项：-r：递归删除整个文件夹-f：强制删除不提示应用实例：案例1：将/home/hello.txt删除（rm /home/hello.txt）案例2：递归删除整个文件夹/home/bbb（rm -r /home/bbb）使用细节：强制删除不提示的方法：带上-f参数即可 9.mv指令mv指令：移动文件与目录或重命名基本语法：mv oldNameFile newNameFile(功能描述：重命名)mv /temp/movefile /targetFolder(功能描述：移动文件)应用实例：案例1：将/home/cat.txt文件重新命名为pig.txt（mv cat.txt pig.txt）案例2：将/home/pig.txt文件移动到/root目录下（mv /home/pig.txt /root）案例3：将/home/pig.txt文件移动到/root目录下并重命名为cow.txt（mv /home/pig.txt /root/cow.txt）案例4：将/opt/bbb整体移动到/home下（mv /opt/bbb /home） 10.cat指令cat指令：查看文件内容基本语法：cat [选项] 要查看的文件常用选项：-n：显示行号应用实例：案例1：/ect/profile文件内容，并显示行号（cat -n /etc/profile）使用细节：cat只能浏览文件，而不能修改文件，为了浏览方便，一般会带上管道命令 | more进行交互（比如，查看/etc/profile文件，cat -n /etc/profile | more） 11.more指令more指令是一个基于VI编辑器的文本过滤器，它以全屏幕的方式按页显示文本文件的内容。more指令中**内置了若干快捷键(交互的指令)**，详见操作说明基本语法：more 要查看的文件应用实例：案例：采用more查看文件/etc/profile（more /etc/profile）操作说明，如图： image-20210817160222592 12.less指令less指令用来分屏查看文件内容，它的功能与more指令类似，但是比more指令更加强大，支持各种显示终端。less指令在显示文件内容时，并不是一次将整个文件加载之后才显示，而是根据显示需要加载内容，对于显示大型文件具有较高的效率基本语法：less 要查看的文件应用实例：案例：采用less查看一个大文件/opt/杂文.txt（less /opt/杂文.txt）操作说明，如图： image-20210817161240067 13.echo指令echo指令：输出内容到控制台基本语法：echo [选项] [输出内容]应用实例：案例1：使用echo指令输出环境变量$PATH（echo $PATH）案例2：使用echo指令输出hello,world!（echo hello,world!） 14.head指令head指令：用于显示文件的开头部分内容，默认情况下head指令显示文件的前10行内容基本语法：head 文件(功能描述:：查看文件头10行内容)head -n 5 文件(功能描述：查看文件头5行内容，5可以是任意行数)应用实例：案例：查看/etc/profile的前面5行代码（head -n 5 /etc/profile） 15.tail指令tail指令：用于输出文件中尾部的内容，默认情况下tail指令显示文件的最后10行内容基本语法：tail 文件(功能描述：查看文件尾10行内容)tail -n 5 文件(功能描述：查看文件尾5行内容，5可以是任意行数)tail -f 文件(功能描述：实时追踪该文档的所有更新)应用实例：案例1：查看/etc/profile最后5行的代码（tail -n 5 /etc/profile）案例2：实时监控mydate.txt，看看当文件有变化时，是否看到实时的追加内容（tail -f mydate.txt） 16.&gt;指令和&gt;&gt;指令&gt;指令：输出重定向&gt;&gt;指令：追加基本语法：ls -l &gt; 文件(功能描述：列表的内容写入文件中(覆盖写))ls -al &gt;&gt; 文件(功能描述：列表的内容追加到文件的末尾)cat 文件1 &gt; 文件2(功能描述：将文件1的内容覆盖到文件2)echo &quot;内容&quot; &gt;&gt; 文件（功能描述：将内容追加到文件中）应用实例：案例1：将/home目录下的文件列表写入到/home/info.txt中（ls -l /home &gt; /home/info.txt，如果info.txt不存在会自动创建）案例2：将当前日历信息追加到/home/mycal文件中（cal &gt;&gt; /home/mycal.txt） 17.ln指令ln指令：软链接也称为符号链接，类似于windows里的快捷方式，主要存放了链接其他文件的路径基本语法：ln -s [原文件或目录] [软链接名] (功能描述：给原文件创建一个软链接)应用实例：案例1：在/home目录下创建一个软连接myroot，连接到/root目录（ls -s /root /home/myroot）案例2：删除软连接myroot（rm /home/myroot）细节说明：当我们使用pwd指令查看目录时，仍然看到的是软链接所在目录 18.history指令history指令：查看已经执行过历史命令，也可以执行历史指令基本语法：history(功能描述：查看已经执行过历史命令)应用实例：案例1：显示所有的历史命令（history）案例2：显示最近使用过的10个指令（history 10）案例3∶执行历史编号为5的指令（!5） 2.5.5 时间日期类指令1.date指令date指令：显示当前日期基本语法：date(功能描述：显示当前时间)date +%Y(功能描述：显示当前年份)date +%m(功能描述：显示当前月份)date +%d(功能描述：显示当前是哪一天)date &quot;+%Y-%m-%d %H:%M:%S&quot;(功能描述：显示年月日时分秒)应用实例：案例1：显示当前时间信息（date）案例2：显示当前时间年月日（date &quot;+%Y-%m-%d&quot;）案例3：显示当前时间年月日时分秒（date &quot;+%Y-%m-%d %H:%M:%S&quot;） date指令：设置日期基本语法：date -s 字符串时间应用实例：案例1：设置系统当前时间，比如设置成2021-11-11 11:22:22（date -s &quot;2021-11-11 11:22:22&quot;） 2.cal指令cal指令：查看日历指令基本语法：cal [选项] (功能描述：不加选项，显示本月日历)应用实例：案例1：显示当前日历（cal）案例2：显示2020年日历（cal 2020） 2.5.6 搜索查找类指令1.find指令find指令：将从指定目录向下递归地遍历其各个子目录，将满足条件的文件或者目录显示在终端基本语法：find [搜索范围] [选项]选项说明：-name&lt;查询方式&gt;：按照指定的文件名查找模式查找文件-user&lt;用户名&gt;：查找属于指定用户名所有文件-size&lt;文件大小&gt;：按照指定的文件大小查找文件应用实例：案例1：按文件名：根据名称查找/home目录下的hello.txt文件（find /home -name hello.txt）案例2∶按拥有者：查找/opt目录下，用户名称为nobody的文件（find /opt -user nobody）案例3：查找整个linux系统下大于200M的文件(+n大于 -n小于 n等于，单位有k，M，G)（find / -size +200M） 2.locate指令locate指令可以快速定位文件路径locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件locate指令无需遍历整个文件系统，查询速度较快。为了保证查询结果的准确度，管理员必须定期更新locate时刻基本语法：locate 搜索文件特别说明：由于locate指令基于数据库进行查询，所以第一次运行前，必须使用updatedb指令创建locate数据库应用实例：案例1：请使用locate指令快速定位hello.txt文件所在目录（updatedb locate hello.txt） which指令，可以查看某个指令在哪个目录下，比如ls指令在哪个目录（which ls） 3.grep指令和管道符号 “|”grep指令：过滤查找管道符”|”：表示将前一个命令的处理结果输出传递给后面的命令处理基本语法：grep [选项] 查找内容 源文件常用选项：-n：显示匹配行及行号-i：忽略字母大小写应用实例：案例1：请在hello.txt文件中，查找”yes”所在行，并且显示行号（写法一：cat /home/hello.txt | grep -n &quot;yes&quot;写法二：grep -n &quot;yes&quot; /home/hello.txt） 2.5.7 压缩和解压1.gzip和gunzip指令gzip指令：用于压缩文件gunzip指令：用于解压文件基本语法：gzip 文件（功能描述：压缩文件，只能将文件压缩为*.gz文件）gunzip 文件.gz（功能描述：解压压缩文件命令)应用实例：案例1：gzip压缩，将/home下的hello.txt文件进行压缩（gzip /home/hello.txt）案例2：gunzip压缩，将/home下的hello.txt.gz文件进行解压缩（gunzip /home/hello.txt） 2.zip/unzip 指令zip指令：用于压缩文件unzip指令：用于解压文件，这个在项目打包发布中很有用基本语法：zip [选项] XXX.zip 将要压缩的内容（功能描述：压缩文件和目录到当前目录下)unzip [选项] XXX.zip（功能描述：解压压缩文件到当前目录下）zip常用选项：-r ：递归压缩，即压缩目录unzip的常用选项：-d&lt;目录&gt;：指定解压后文件的存放目录应用实例：案例1：将/home下的所有文件/文件夹进行压缩成myhome.zip（zip -r myhome.zip /home）案例2：将myhome.zip解压到/opt/tmp目录下（unzip -d /opt/tmp /home/myhome.zip，解压到的目录若不存在会自动创建） 3.tar指令tar指令：打包指令，最后打包后的文件是.tar.gz的文件基本语法：tar [选项] XXX.tar.gz 打包的内容（功能描述：打包目录，压缩后的文件格式.tar.gz)选项说明：-c：产生.tar打包文件-v：显示详细信息-f：指定压缩后的文件名-z：打包同时压缩-x：解包.tar文件-C：指定解压到哪个目录应用实例：案例1：压缩多个文件，将/home/pig.txt和/home/cat.txt压缩成 pc.tar.gz（tar -zcvf pc.tar.gz /home/pig.txt /home/cat.txt）案例2：将/home文件夹压缩成myhome.tar.gz（tar -zcvf myhome.tar.gz /home）案例3：将pc.tar.gz解压到当前目录（tar -zxvf /home/pc.tar.gz）案例4：将myhome.tar.gz解压到/opt/tmp2目录下（mkdir /opt/tmp2 tar -zxvf /home/myhome.tar.gz -C /opt/tmp2） 2.6 组管理和权限管理在linux中的每个用户必须属于一个组，不能独立于组外。在linux中每个文件有所有者、所在组、其它组的概念。 2.6.1 文件/目录的所有者一般为文件的创建者，谁创建了该文件，就自然的成为该文件的所有者 查看文件的所有者指令：ls -ahl image-20210820153459616 修改文件所有者指令：chown 用户名 文件名 应用案例：使用root创建一个文件apple.txt，然后将其所有者修改成tom（touch /home/apple.txt chown tom /home/apple.txt） 2.6.2 文件/目录的所在组1.新建组基本指令：groupadd 组名应用实例：案例1：创建一个组monster（groupadd monster）案例2：创建一个用户fox，并放入到monster组中（useradd -g monster fox） 2.修改文件/目录所在组当某个用户创建了一个文件后，这个文件的所在组就是该用户所在的组查看文件/目录所在组基本指令：ls -ahl修改文件所在的组基本指令：chgrp 组名 文件名应用实例：使用root用户创建文件orange.txt，看看当前这个文件属于哪个组，然后将这个文件所在组，修改到fruit组","categories":[{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/tags/Linux/"},{"name":"CentOS","slug":"CentOS","permalink":"http://rainvex.com/tags/CentOS/"},{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Spring框架笔记","slug":"Spring5学习笔记","date":"2022-03-27T14:10:43.000Z","updated":"2022-03-27T14:10:43.000Z","comments":true,"path":"categories/后端/Spring5学习笔记.html","link":"","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/Spring5%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"Spring5学习笔记一、概述1.Spring5框架概述1、Spring 是轻量级的开源的 JavaEE 框架 2、Spring 可以解决企业应用开发的复杂性 3、Spring 有两个核心部分：IOC 和 Aop （1）IOC：控制反转，把创建对象过程交给 Spring 进行管理 （2）Aop：面向切面，不修改源代码进行功能增强 4、Spring 特点 （1）方便解耦，简化开发 （2）Aop 编程支持 （3）方便程序测试 （4）方便和其他框架进行整合 （5）方便进行事务操作 （6）降低 API 开发难度 image-20220308202302709 二、入门案例1.下载官网：https://spring.io/ 可直接访问下载网址：https://repo.spring.io/ui/native/release/org/springframework/spring/ 第一步： image-20220227181557405 第二步： image-20220227181701207 第三步： image-20220227181851984 第四步： image-20220227181916576 第五步： image-20220227182609774 第六步： image-20220227182958960 第七步： image-20220227183035642 注：由于现在已会使用maven进行项目管理，则使用maven来构建Spring项目，而不是用上方下载jar导入项目的方式 2.项目构建第一步： image-20220301201231373 第二步： image-20220301201351320 第三步： image-20220301200616590 第四步： image-20220301202711022 第五步： image-20220301203024594 第六步： 编写测试代码，点击进行测试 image-20220301204420285 测试时报出以下异常：（这是由于运行时找不到Spring配置文件造成的）image-20220301204519561 解决方法： image-20220301210622099 解决方法参考博客：https://blog.csdn.net/qq_32575047/article/details/78243314 https://blog.csdn.net/weixin_39903133/article/details/87258360 测试通过结果： image-20220301210735063 三、IOCIOC：控制反转(Inversion of Control，缩写为lOC)，是面向对象编程中的一种设计原则，可以用来减低计算机代码之间的耦合度。其中最常见的方式叫做依赖注入（Dependency Injection，简称DI），还有一种方式叫“依赖查找”（Dependency Lookup）。通过控制反转，对象在被创建的时候，由一个调控系统内所有对象的外界实体将其所依赖的对象的引用传递给它。也可以说，依赖被注入到对象中。（简单理解：控制反转，把对象创建和对象之间的调用过程，交给 Spring 进行管理） 3.1 IOC 底层原理 xml 解析 工厂模式 反射 image-20220301220541819 image-20220301221203917 IOC底层原理的实现例子： image-20220301221642352 3.2 IOC接口1、IOC 思想基于 IOC 容器完成，IOC 容器底层就是对象工厂 2、Spring 提供 IOC 容器实现两种方式：（两个接口） BeanFactory：IOC 容器基本实现，是Spring内部的使用接口，不提供开发人员进行使用 加载配置文件时候不会创建对象，在获取对象（使用）才去创建对象 ApplicationContext：BeanFactory接口的子接口，提供更多更强大的功能，一般由开发人员进行使用 加载配置文件时候就会把在配置文件对象进行创建（虽然这种方式会浪费时间，但我们仍使用这种方式，因为我们应该把耗时的操作留给服务器来进行，而不应该让程序在使用时来耗时） 3、ApplicationContext 接口主要是有以下两个实现类 image-20220301224329322 public class TestSpring5 &#123; @Test public void testAdd()&#123; //1.加载Spring配置文件 ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); //2.获取配置文件创建的对象 User user = context.getBean(&quot;user&quot;, User.class); System.out.println(user); user.add(); &#125; &#125; 在上方测试程序中，加载Spring配置文件时，若使用FileSystemXmlApplicationContext类则在传参时应该使用“Spring配置文件在盘符中的位置”即盘符路径作为参数；若使用ClassPathXmlApplicationContext类则应使用类路径即classpath作为参数 具体实现说明如下： image-20220301230003760 image-20220301230120528 image-20220301230420412 4、BeanFactory接口 image-20220301231315597 3.3 IOC操作Bean管理 什么是 Bean 管理 Bean 管理指的是两个操作 Spring 创建对象 Spirng 注入属性 Bean 管理操作有两种方式 基于 xml 配置文件方式实现 基于注解方式实现 3.3.1 基于XML配置文件方式1.基于xml方式创建对象（1）在 spring 配置文件中，使用 bean 标签，标签里面添加对应属性，就可以实现对象创建（2）在 bean 标签有很多属性，介绍常用的属性 id 属性：唯一标识 class 属性：类全路径（包类路径）（3）创建对象时候，默认是执行无参数构造方法完成对象创建 如下图： image-20220301203024594 2.基于xml方式注入属性DI：依赖注入，就是注入属性（要在创建好对象后才能进行） ①第一种注入方式：使用set方法进行注入（1）创建类，定义属性和对应的 set 方法 public class Book &#123; //创建属性 private String bname; private String bauthor; //创建属性对应的 set 方法 public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125; //重写了toString方法 &#125; （2）在 spring 配置文件配置对象创建，配置属性注入 &lt;!--2 set 方法注入属性--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.atguigu.spring5.Book&quot;&gt; &lt;!--使用 property完成属性注入 name：类里面属性名称 value：向属性注入的值--&gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;&gt;&lt;/property&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩老祖&quot;&gt;&lt;/property&gt; &lt;/bean&gt; 编写测试代码 @Test public void testBook()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); Book book = context.getBean(&quot;book&quot;, Book.class); System.out.println(book); //Book&#123;bname=&#39;易筋经&#39;, bauthor=&#39;达摩&#39;&#125; &#125; //从输入结果可以看出在配置文件成功创建对象并给属性赋值 ②第二种注入方式：使用有参构造函数进行注入（1）创建类，定义属性和对应有参构造函数 public class Book &#123; private String bname; private String bauthor; public Book(String bname, String bauthor) &#123; this.bname = bname; this.bauthor = bauthor; &#125; //重写了toString方法 （2）在 spring 配置文件配置利用有参构造函数创建对象同时给属性赋值 &lt;bean id=&quot;book&quot; class=&quot;Bean.Book&quot;&gt; &lt;!--使用constructor-arg标签调用有参构造创建对象完成--&gt; &lt;constructor-arg name=&quot;bname&quot; value=&quot;生死疲劳&quot;/&gt; &lt;constructor-arg name=&quot;bauthor&quot; value=&quot;莫言&quot;/&gt; &lt;!--同样也可以使用&lt;constructor-arg index=&quot;0&quot; value=&quot;生死疲劳&quot;/&gt;进行配置，其中index表示有参构造函数中的第几个参数，0表示第一个参数--&gt; &lt;/bean&gt; 编写测试代码 @Test public void testBook()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); Book book = context.getBean(&quot;book&quot;, Book.class); System.out.println(book); //Book&#123;bname=&#39;生死疲劳&#39;, bauthor=&#39;莫言&#39;&#125; &#125; ③使用p名称空间注入(了解)使用 p 名称空间注入，可以简化基于 xml 配置方式（1）第一步 添加 p 名称空间在配置文件中 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt; （2）第二步 进行属性注入，在 bean 标签里面进行操作 &lt;bean id=&quot;book&quot; class=&quot;Bean.Book&quot; p:bname=&quot;九阳真经&quot; p:bauthor=&quot;无名氏&quot;/&gt; 注：这种方式的底层仍是使用set方法进行注入，只是对写法的一种简化，所以实体类也应该具备对属性的set方法和无参构造函数 3.基于xml方式注入属性-字面量①注入null值比如，要给下方Book类的address属性注入空值 public class Book &#123; private String bname; private String bauthor; private String address; public void setBname(String bname) &#123; this.bname = bname; &#125; public void setBauthor(String bauthor) &#123; this.bauthor = bauthor; &#125; public void setAddress(String address) &#123; this.address = address; &#125; &#125; 则可以通过&lt;null/&gt;标签进行注入 &lt;bean id=&quot;book&quot; class=&quot;Bean.Book&quot;&gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;/&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩&quot;/&gt; &lt;property name=&quot;address&quot;&gt; &lt;null/&gt; &lt;/property&gt; &lt;/bean&gt; ②注入特殊符号 把&lt;&gt;使用 &amp;lt; &amp;gt;进行转义 把带特殊符号内容写到 CDATA &lt;bean id=&quot;book&quot; class=&quot;Bean.Book&quot;&gt; &lt;property name=&quot;bname&quot; value=&quot;易筋经&quot;/&gt; &lt;property name=&quot;bauthor&quot; value=&quot;达摩&quot;/&gt; &lt;!--注入特殊符号--&gt; &lt;property name=&quot;address&quot;&gt; &lt;value&gt;&lt;&#123;% gallery %&#125;![CDATA[]]> ``` ##### 4.基于xml方式注入属性-外部bean （1）创建两个类 service 类和 dao 类 （2）在 service 中需要调用 dao 里面的方法 （3）在 spring 配置文件中进行配置 ```java public class UserDaoImpl implements UserDao &#123; @Override public void update() &#123; System.out.println(\"daoImpl update........\"); &#125; &#125; ``` ```java public class UserService &#123; //需要创建UserDao对象属性 private UserDao userDao; //声明set方法 public void setUserDao(UserDao userDao) &#123; this.userDao = userDao; &#125; public void add()&#123; System.out.println(\"service add........ \"); userDao.update(); &#125; &#125; ``` ```xml ``` ```java //测试程序 @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean2.xml\"); UserService userService = context.getBean(\"userService\", UserService.class); userService.add(); //service add........ //daoImpl update........ //从输入结果可以看出userService在调用自身的add方法时同样也调用了userDao的update方法，说明对象创建成功并且成功给外部bean属性赋值 &#125; ``` ##### 5.基于xml方式注入属性-内部bean （1）一对多关系：部门和员工 一个部门有多个员工，一个员工属于一个部门 部门是一，员工是多 （2）在实体类之间表示**一对多**关系，员工表示所属部门，使用对象类型属性进行表示 ```java //首先创建出员工类和部门类，并表示出它们的关联关系 public class Department &#123; private String dname; public void setDname(String dname) &#123; this.dname = dname; &#125; &#125; public class Employee &#123; private String ename; private String egender; //员工属于某个部门，用对象形式表示 private Department department; public void setEname(String ename) &#123; this.ename = ename; &#125; public void setEgender(String egender) &#123; this.egender = egender; &#125; public void setDepartment(Department department) &#123; this.department = department; &#125; &#125; //均重写了toString方法 ``` ```xml ``` ```java //测试代码 @Test public void testDepartment()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean3.xml\"); Employee employee = context.getBean(\"employee\", Employee.class); System.out.println(employee);//Employee&#123;ename='lucy', egender='女', department=Department&#123;dname='安保部'&#125;&#125; &#125; ``` ##### 6.基于xml方式注入属性-级联赋值 同样使用内部bean的例子 ###### ①第一种方式：与外部bean的写法相同 ```xml ``` ###### ②第二种方式： ```xml ``` **注：这种方式需要在赋值类提供被赋值类的get方法，以便于能获取到被赋值类对象，然后对被赋值类的属性进行赋值**。比如，上述例子若使用第二种方式的级联赋值时，应在employee类中提供一个getDepartment方法返回department对象属性 另外，由于在测试第二种方式时并未删除``，但又添加了``，而输出结果又是财务部，可以发现**第二种方式的优先级要高于第一种方式** ##### 7.基于xml方式注入集合类型属性 ###### ①注入集合类型属性 （1）创建好例子实体类，包括数组，List，Map，Set类型属性，生成对应set方法 ```java public class Student &#123; //1.数组类型属性 private String[] courses; //2.List类型属性 private List list; //3.Map类型属性 private Map map; //4.Set类型属性 private Set set; public void setCourses(String[] courses) &#123; this.courses = courses; &#125; public void setList(List list) &#123; this.list = list; &#125; public void setMap(Map map) &#123; this.map = map; &#125; public void setSet(Set set) &#123; this.set = set; &#125; &#125; ``` （2）配置Spring文件 ```xml java课程 数据库课程 张三 小三 MySQL Redis ``` 测试代码 ```java @Test public void testStudent()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\"); Student student = context.getBean(\"student\", Student.class); System.out.println(student);//Student&#123;courses=[java课程, 数据库课程], list=[张三, 小三], map=&#123;JAVA=java, PHP=php&#125;, set=[MySQL, Redis]&#125; &#125; ``` ###### ②在集合属性中设置对象类型 首先，新创建一个类Family，包含属性fname并提供set方法 然后，在上述例子Student类的基础上再添加一个`List`类型属性`families`，用于并提供set方法 然后，再在上例的String配置文件中创建多个Family对象，并使用下方方式注入到student对象的families属性 ```xml ``` 测试结果如下： ```java @Test public void testStudent()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean4.xml\"); Student student = context.getBean(\"student\", Student.class); System.out.println(student);//Student&#123;courses=[java课程, 数据库课程], list=[张三, 小三], map=&#123;JAVA=java, PHP=php&#125;, set=[MySQL, Redis], families=[Family&#123;fname='爸爸'&#125;, Family&#123;fname='妈妈'&#125;]&#125; &#125; ``` ###### ③提取集合属性公共部分 防止混乱，重新创建一个类 ```java public class BookList &#123; private List bookList; public void setBookList(List bookList) &#123; this.bookList = bookList; &#125; &#125; ``` 然后，在Spring配置文件中配置注入到属性 ```xml Java课程设计 数据结构与算法 操作系统 ``` 测试代码 ```java @Test public void testBookList()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean5.xml\"); BookList books = context.getBean(\"books\", BookList.class); System.out.println(books); //BookList&#123;bookList=[Java课程设计, 数据结构与算法, 操作系统]&#125; &#125; ``` #### 3.3.2 Bean管理 ##### 1.工厂Bean 1、Spring 有两种类型 bean，一种**普通 bean**，另外一种**工厂 bean（FactoryBean）** 2、普通 bean：在**配置文件中定义的bean类型就是返回类型**（前方举例创建的Bean对象都是普通Bean） 3、工厂 bean：在**配置文件定义的bean类型可以和返回类型不一样** 第一步 创建类，让这个类作为工厂 bean，**实现接口 FactoryBean** 第二步 实现接口里面的方法，在**实现的方法中定义返回的 bean 类型** ```java //工厂Bean举例 public class MyBeanFactory implements FactoryBean &#123;//指定工厂Bean返回的泛型对象类型为Course //实现接口中定义的抽象方法 @Override public Course getObject() throws Exception &#123; Course course = new Course(); course.setCname(\"abc\"); //在实现的getObject方法中指定工厂Bean返回的对象类型为Course return course; &#125; @Override public Class getObjectType() &#123; return null; &#125; @Override public boolean isSingleton() &#123; return false; &#125; &#125; ``` ```xml ``` ```java //测试代码 @Test public void test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean.xml\"); Course course = context.getBean(\"myBeanFactory\", Course.class); System.out.println(course);//Course&#123;cname=\"abc\"&#125; &#125; ``` ##### 2.Bean的作用域 1、在 Spring 里面，创建 bean 实例**分为单实例还是多实例** 2、在 Spring 里面，**默认情况下 bean 是单实例对象** ```xml ``` ```java @Test public void test() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"bean.xml\"); Book book1 = context.getBean(\"book\", Book.class); Book book2 = context.getBean(\"book\", Book.class); System.out.println(book1);//Bean.Book@5d11346a System.out.println(book2);//Bean.Book@5d11346a &#125; //从测试结果可以看出单实例对象两次创建的对象相同 ``` 3、配置Bean对象为多实例对象 （1）在spring配置文件 bean 标签里面有**属性（scope）**用于设置单实例还是多实例 （2）scope 属性值 第一个值 默认值**singleton，表示是单实例对象** 第二个值 **prototype，表示是多实例对象** ```xml ``` 4、singleton 和 prototype **区别** * 第一 singleton 单实例，prototype 多实例 * 第二 设置 scope 值是 singleton 时，**加载 spring 配置文件时候就会创建单实例对象** ​ 设置 scope 值是 prototype 时，不是在加载 spring 配置文件时候创建 对象，在**调用getBean 方法时候创建多实例对象** * 另外，scope还有两个值分别为request，session；request表示这个实例对象的**作用域为一次请求**，而session表示这个实例对象的**作用域为一次会话** ##### 3.Bean的生命周期 1、生命周期 （1）从对象**创建到销毁的过程** 2、bean 生命周期 （1）通过构造器**创建 bean 实例**（无参数构造） （2）为 bean 的**属性设置值**和引用其他 bean（调用 set 方法） （3）调用 **bean 的初始化**的方法（需要进行配置初始化的方法） （4）**bean 可以使用**了（对象获取到了） （5）当**容器关闭**时候，**调用 bean 的销毁的方法**（需要进行配置销毁的方法） 3、实例演示 ```java //创建一个Order实体类 public class Order &#123; private String oname; public Order()&#123; System.out.println(\"执行无参构造函数创建bean实例\"); &#125; public void setOname(String oname) &#123; this.oname = oname; System.out.println(\"调用set方法为属性注入值\"); &#125; public void initMethod()&#123; System.out.println(\"执行初始化方法\"); &#125; public void destroyMethod()&#123; System.out.println(\"执行销毁方法\"); &#125; &#125; ``` ```xml ``` ```java //测试代码 @Test public void testOrder()&#123; //ApplicationContext context = new ClassPathXmlApplicationContext(\"orderBean.xml\"); ClassPathXmlApplicationContext context = new ClassPathXmlApplicationContext(\"orderBean.xml\"); Order order = context.getBean(\"order\", Order.class); System.out.println(\"成功创建bean实例对象\"); System.out.println(order); //手动销毁bean实例 context.close();//这个close方法是ApplicationContext的子接口ConfigurableApplicationContext新增的方法， //然后在AbstractApplicationContext抽象类中实现，而ClassPathXmlApplicationContext类是继承了该类的子孙类， //所以这里的context对象的类型不能是ApplicationContext //输出结果： //执行无参构造函数创建bean实例 //调用set方法为属性注入值 //执行初始化方法 //成功创建bean实例对象 //Bean.Order@10dba097 //执行销毁方法 &#125; //从输出结果即可看出Bean的生命周期：①调用构造器创建bean实例→②调用set方法给属性注入值和引用其他bean→③调用初始化方法→④成功创建bean对象→⑤销毁bean对象 ``` 4、bean的后置处理器，bean生命周期有七步（即在bean生命周期的基础上多了两步） （1）通过构造器创建 bean 实例（无参数构造） （2）为 bean 的属性设置值和引用其他 bean（调用 set 方法） （3）**把 bean 实例传递给 bean 后置处理器的方法 postProcessBeforeInitialization** （4）调用 bean 的初始化的方法（需要进行配置初始化的方法） （5）**把 bean 实例传递给 bean 后置处理器的方法 postProcessAfterInitialization** （6）bean 可以使用了（对象获取到了） （7）当容器关闭时候，调用 bean 的销毁的方法（需要进行配置销毁的方法） 5、实例演示 ```java //创建一个后置处理器实体类，实现BeanPostProcessor接口 public class MyBeanPost implements BeanPostProcessor &#123; @Override public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"在初始化前执行\"); return bean; &#125; @Override public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123; System.out.println(\"在初始化后执行\"); return bean; &#125; &#125; ``` ```xml ``` ```java 再次执行测试代码，运行结果如下： ①执行无参构造函数创建bean实例 ②调用set方法为属性注入值 ③在初始化前执行 ④执行初始化方法 ⑤在初始化后执行 ⑥成功创建bean实例对象 Bean.Order@eb21112 ⑦执行销毁方法 ``` ##### 4.xml自动装配 什么时自动装配？根据**指定装配规则**（属性名称或者属性类型），Spring **自动将匹配的属性值进行注入** 如何实现自动装配？ * bean 标签属性 autowire，配置自动装配 * autowire 属性常用两个值： * byName 根据属性名称注入 * byType 根据属性类型注入 ###### ①根据属性名自动注入 ```java //创建两个有关联的实体类 public class Department &#123; @Override public String toString() &#123; return \"Department&#123;&#125;\"; &#125; &#125; public class Employee &#123; private Department department; public void setDepartment(Department department) &#123; this.department = department; &#125; @Override public String toString() &#123; return \"Employee&#123;\" + \"department=\" + department + '&#125;'; &#125; &#125; ``` ```xml ``` ```java //测试代码 @Test public void testAutowire()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(\"autowire.xml\"); Autowire.Employee employee = context.getBean(\"employee\", Autowire.Employee.class); System.out.println(employee); //Employee&#123;department=Department&#123;&#125;&#125; //测试结果说明实现自动装配成功 &#125; ``` ###### ②根据属性类型自动装配 ```xml ``` 需要注意的是，当使用`autowire=\"byType\"`时，若当前配置文件中有多个相同类型的bean对象则会报错，此时只能使用byName实现自动装载 ##### 5.引入外部属性文件 以配置数据库信息为例： （1）配置德鲁伊连接池 （2）引入德鲁伊连接池依赖 jar 包(druid.jar)(此处本人使用maven直接导入) ```xml ``` **引入外部属性文件配置数据库连接池** （1）创建外部属性文件，properties 格式文件，写好数据库信息 &#123;% gallery %&#125;![image-20220302233927691](https://rainvex-1305747533.cos.ap-chengdu.myqcloud.com/images/202203022339872.png)&#123;% endgallery %&#125; （2）把外部 properties 属性文件引入到 spring 配置文件中 ①引入 context 名称空间 ```xml &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; ②在 spring 配置文件使用标签引入外部属性文件 &lt;!--引入外部属性文件--&gt; &lt;context:property-placeholder location=&quot;classpath:jdbc.properties&quot;/&gt; &lt;!--配置连接池--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot;&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;$&#123;prop.driverClass&#125;&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;$&#123;prop.url&#125;&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;$&#123;prop.username&#125;&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;$&#123;prop.password&#125;&quot;/&gt; &lt;/bean&gt; 3.3.3 基于注解方式1、什么是注解（1）注解是代码特殊标记，格式：@注解名称(属性名称=属性值, 属性名称=属性值..)（2）使用注解，注解作用在类上面，方法上面，属性上面（3）使用注解目的：简化 xml 配置 2、Spring 针对 Bean 管理中创建对象提供的注解（1）@Component：Spring提供的一种普通注解，使用它也可以直接创建对象（2）@Service：主要用于service(业务)层（3）@Controller：主要用于web(表现)层（4）@Repository：主要用于dao(持久)层上面四个注解功能是一样的，都可以用来创建 bean 实例，没有特意指明哪个注解必须要用在什么层，只是方便开发时区分 1.基于注解创建对象①引入spring-aop依赖（或使用maven自动导入）image-20220303203220619 ②在Spring配置文件配置开启组件扫描&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--1、引入context名称空间--&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!--2、开启组件扫描 如果需要扫描多个包： 1 多个包之间使用逗号隔开 2 将被扫描包的上层目录赋值给base-package属性 --&gt; &lt;!--&lt;context:component-scan base-package=&quot;com.bean,com.service,com.dao&quot;/&gt;--&gt; &lt;context:component-scan base-package=&quot;com&quot;/&gt; &lt;/beans&gt; ③创建类，添加注解便于创建对象//在注解里面 value 属性值可以省略不写 //默认值是类名称，首字母小写 //UserService -- userService，等同于xml配置方式中bean标签的id属性值 @Service(value = &quot;userService&quot;) //等同于&lt;bean id=&quot;userService&quot; class=&quot;..&quot;/&gt; public class UserService &#123; public void add()&#123; System.out.println(&quot;userService add......&quot;); &#125; &#125; 测试 @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanCreate.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class);//其中的userService就是注解中value属性的值 System.out.println(userService); userService.add(); //com.service.UserService@790a251b //userService add...... //测试通过，输出了userService对象引用并且调用了方法说明通过注解创建对象成功 &#125; 2.组件扫描配置细节&lt;!--默认情况--&gt; &lt;context:component-scan base-package=&quot;com&quot;/&gt; &lt;!--默认扫描包中所有类--&gt; &lt;!--示例 1 use-default-filters=&quot;false&quot; 表示现在不使用默认 filter，自己配置 filter context:include-filter，设置扫描哪些内容 --&gt; &lt;context:component-scan base-package=&quot;com&quot; use-default-filters=&quot;false&quot;&gt; &lt;context:include-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Service&quot;/&gt; &lt;!--表示只扫描带有org.springframework.stereotype.Service注解的类--&gt; &lt;/context:component-scan&gt; &lt;!--示例 2 这个配置仍是扫描包所有内容 但是不扫描context:exclude-filter标签设置的内容 --&gt; &lt;context:component-scan base-package=&quot;com&quot;&gt; &lt;context:exclude-filter type=&quot;annotation&quot; expression=&quot;org.springframework.stereotype.Controller&quot;/&gt; &lt;!--表示不扫描带有org.springframework.stereotype.Controller注解的类--&gt; &lt;/context:component-scan&gt; 3.基于注解实现属性注入①@Autowire注解@Autowire：根据属性类型进行自动装配 第一步 创建 service 和 dao 对象：在 service 和 dao 类添加创建对象注解（同时要在配置文件开启组件扫描确保这些类能被扫描到） public interface UserDao &#123; public void add(); &#125; @Repository(value = &quot;userDaoImpl1&quot;) //默认value = &quot;userDaoImpl&quot;，这里设置value属性的值是为了解释使用@Qulifiler等其他注解的情况 public class UserDaoImpl implements UserDao &#123; @Override public void add() &#123; System.out.println(&quot;userDaoImpl add......&quot;); &#125; &#125; 第二步 在 service 注入 dao 对象：在 service 类添加 dao 类型属性，在属性上面使用注解 @Service public class UserService &#123; //定义 dao 类型属性 //不需要添加 set 方法 //添加注入属性注解 @Autowired //根据类型注入 private UserDao userDao; public void add()&#123; System.out.println(&quot;userService add......&quot;); userDao.add(); &#125; &#125; 测试代码 @Test public void testService()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;beanCreate.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class);//其中的userService就是注解中value属性的值 System.out.println(userService); userService.add(); //com.service.UserService@702b06fb //userService add...... //userDaoImpl add...... &#125; ②@Qualifier注解@Qualifier：根据名称进行注入，这个注解的使用需要和@Autowired配合使用 //在下方类中使用@Autowired和@Qualifiler @Service public class UserService &#123; @Autowired //根据类型注入 @Qualifiler(value = &quot;userDaoImpl1&quot;) //当value = &quot;userDaoImpl1&quot;时就可以找到UserDaoImpl类并将其作为对象属性进行注入，否则就会找不到需要注入的对象类导致无法创建userDao对象 private UserDao userDao; public void add()&#123; System.out.println(&quot;userService add......&quot;); userDao.add(); &#125; &#125; ③@Resource注解@Resource：可以根据类型注入，可以根据名称注入 @Service public class UserService &#123; //@Resource 根据类型进行注入 @Resource(value = &quot;userDaoImpl1&quot;) //根据名称进行注入 private UserDao userDao; public void add()&#123; System.out.println(&quot;userService add......&quot;); userDao.add(); &#125; &#125; ④@Value注解@Value：注入普通类型属性 @Service public class UserService &#123; @Value(value = &quot;abc&quot;) //使用@Value注解给普通类型属性注入值 private String name; public String getName()&#123; return name; &#125; &#125; //给这个普通属性提供get方法后，就可在测试方法中通过userService对象得到这个name属性的值 4.完全注解开发创建配置类，替代 xml 配置文件（这种开发模式主要是在SpringBoot中使用） @Configuration //标记该类为配置类，替代xml配置文件 @ComponentScan(basePackages = &#123;&quot;com&quot;&#125;) //表示开启组件扫描，需要扫描的类通过basePackages属性指定其上级目录 //另外，ComponentScan注解还有一个basePackageClasses属性，根据属性名可以知道是通过指定某些类的类名来标记其为被扫描对象；而basePackages是根据指定某些软件包的包名来标记其中的类能被扫描 public class SpringConfig &#123; &#125; 测试代码 @Test public void testService()&#123; ApplicationContext context = new AnnotationConfigApplicationContext(SpringConfig.class);//使用AnnotationConfigApplicationContext类加载配置类 UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService); userService.add(); System.out.println(userService.getName()); //com.service.UserService@475646d4 //userService add...... //userDaoImpl add...... //abc &#125; 四、AOP4.1 基本概念概念：AOP（Aspect Oriented Programming），意为：面向切面（方面）编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。AOP是OOP的延续，是软件开发中的一个热点，也是Spring框架中的一个重要内容，是函数式编程的一种衍生范型。 优点：利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 主要意图：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码（即不通过修改源代码方式，在主干功能里面添加新功能）。 例子： image-20220305135908354 4.2 底层原理AOP 底层使用动态代理，有两种情况动态代理： 第一种 有接口情况，使用 JDK 动态代理创建接口实现类的代理对象，增强类的方法 image-20220305140808202 第二种 没有接口情况，使用 CGLIB 动态代理创建子类的代理对象，增强类的方法 image-20220305141102643 4.3 JDK动态代理使用 JDK 动态代理，使用 Proxy 类里面的方法创建代理对象 Proxy类： image-20220305141624034 创建对象使用的方法： image-20220305141713745 方法有三个参数：第一参数，类加载器第二参数，增强方法的所在类，这个类实现的接口（支持多个接口），也可以理解成代理类需要实现的接口第三参数，实现 InvocationHandler 这个接口，创建代理对象，写增强的部分 实例： ①创建接口，定义方法 public interface UserService &#123; public void add(); public int update(int a,int b); &#125; ②创建接口实现类，实现方法 public class UserServiceImpl implements UserService&#123; @Override public void add() &#123; System.out.println(&quot;UserServiceImpl的add方法执行了...&quot;); &#125; @Override public int update(int a, int b) &#123; System.out.println(&quot;UserServiceImpl的update方法执行了...&quot;); return a + b; &#125; &#125; ③创建代理对象类，实现InvocationHandler接口 //创建的一个UserService接口代理对象类 public class UserServiceProxy implements InvocationHandler &#123; //通过有参构造函数把需要被代理的对象传给代理类 //这儿使用的Object可以改为具体的被代理类的对象的类型，使用Object类型只是为了能达到可以代理多个对象的目的 private Object obj; public UserServiceProxy(Object obj)&#123; this.obj = obj; &#125; //将原先功能需要增强的业务逻辑写在这里面 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; //执行被增强方法之前 System.out.println(&quot;方法执行之前...&quot;); System.out.println(&quot;执行的方法是：&quot; + method.getName()); System.out.println(&quot;传递的参数是：&quot; + Arrays.toString(args)); //执行被增强的方法 Object invoke = method.invoke(obj, args); //底层的方法调用，这个方法可以在java基础的反射那一章节查看具体的，或在java.lang.reflect包中的Method类中查看该方法的具体讲解 //执行被增强方法之后 System.out.println(&quot;方法执行之后...&quot;); System.out.println(&quot;该方法返回的值：&quot; + invoke); System.out.println(&quot;执行该方法的对象是：&quot; + obj); //System.out.println(proxy); 为什么这儿我想输出proxy会让程序一直执行导致堆栈溢出异常，希望如果有大佬仔细看见了能帮我解答一下 return invoke; &#125; //InvocationHandler接口的invoke方法介绍：（个人根据文档的简易理解） //proxy - 调用该方法的代理实例 //method - 使用代理对象调用的方法 //args - 代理对象调用的方法所需要的参数阵列 //返回结果 - 被调用方法的返回值 //返回结果原文介绍：从代理实例上的方法调用返回的值。如果接口方法的声明返回类型是原始类型，则此方法返回的值必须是对应的基本包装类的实例; // 否则，它必须是可声明返回类型的类型。 如果此方法返回的值是null和接口方法的返回类型是基本类型，那么NullPointerException将由代理实例的方法调用抛出。 // 如上所述，如果此方法返回的值，否则不会与接口方法的声明的返回类型兼容，一个ClassCastException将代理实例的方法调用将抛出。 &#125; ④使用Proxy类创建接口代理对象 public class JDKProxy &#123; public static void main(String[] args) &#123; //创建接口实现类的代理对象 Class[] interfaces = &#123;UserService.class&#125;; //创建出的代理对象需要实现的接口类型 //1、通过创建InvocationHandler匿名实现类对象来创建UserService接口实现类的代理对象的方式 //Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new InvocationHandler() &#123; // @Override // public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; // return null; // &#125; //&#125;); //2、通过创建InvocationHandler实现类的对象来创建UserService接口实现类的代理对象的方式 UserServiceImpl userServiceImplProxied = new UserServiceImpl(); //创建接口实现类对象（被代理类对象） System.out.println(&quot;被代理的接口实现类对象：&quot; + userServiceImplProxied); //创建出UserService接口实现类UserServiceImpl的代理对象 UserService userServiceImplProxy = (UserService) Proxy.newProxyInstance(JDKProxy.class.getClassLoader(), interfaces, new UserServiceProxy(userServiceImplProxied)); userServiceImplProxy.add(); //创建出的代理对象调用被代理对象的方法 //执行结果： //被代理的接口实现类对象：com.spring5.UserServiceImpl@61bbe9ba //方法执行之前... //执行的方法是：add //传递的参数是：null //UserServiceImpl的add方法执行了... //方法执行之后... //该方法返回的值：null //执行该方法的对象是：com.spring5.UserServiceImpl@61bbe9ba &#125; &#125; 4.4 操作术语AOP中有四个常用的操作术语，分别是： 连接点 一个类中可以被增强的方法就叫连接点 切入点 实际被增强的方法叫切入点 通知（增强） 实际增强的逻辑代码部分称为通知 通知的几种类型： 前置通知 后置通知 环绕通知 异常通知 最终通知 切面 是一个动作，即把通知应用到切入点的过程叫切面 4.5 AOP操作4.5.1 准备工作1、Spring 框架一般都是基于 AspectJ 实现 AOP 操作 AspectJ 不是 Spring 组成部分，独立 AOP 框架，一般把 AspectJ 和 Spirng 框架一起使用，进行 AOP 操作 2、基于 AspectJ 实现 AOP 操作 基于 xml 配置文件实现 基于注解方式实现（通常使用） 3、在项目工程里面引入 AOP 相关依赖 image-20220305170319714 &lt;!--maven导入--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aop&lt;/artifactId&gt; &lt;version&gt;5.3.15&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-aspects&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjrt&lt;/artifactId&gt; &lt;version&gt;1.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.9.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;aopalliance&lt;/groupId&gt; &lt;artifactId&gt;aopalliance&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;net.sourceforge.cglib&lt;/groupId&gt; &lt;artifactId&gt;com.springsource.net.sf.cglib&lt;/artifactId&gt; &lt;version&gt;2.2.0&lt;/version&gt; &lt;/dependency&gt; 4、切入点表达式 切入点表达式作用：知道对哪个类里面的哪个方法进行增强 语法结构： execution([权限修饰符] [返回类型] [类全路径] [方法名称]([参数列表])) 举例 1：对 com.spring5.dao.BookDao 类里面的 add 方法进行增强execution(* com.spring5.dao.BookDao.add(..)) 举例 2：对 com.spring5.dao.BookDao 类里面的所有的方法进行增强execution(* com.spring5.dao.BookDao.* (..)) 举例 3：对 com.spring5.dao 包里面所有类中的所有方法进行增强execution(* com.atguigu.dao.*.* (..)) 4.5.2 基于aspectj的注解方式1.注解方式实现AOP1、创建类，在类里面定义方法 public class User &#123; public void add()&#123; System.out.println(&quot;user add...&quot;); &#125; &#125; 2、创建增强类（编写增强逻辑），在增强类里面，创建方法，让不同方法代表不同通知类型 //代理类 public class UserProxy &#123; public void before()&#123; System.out.println(&quot;前置通知...&quot;); &#125; &#125; 3、进行通知的配置①在spring配置文件中，开启注解扫描（也可用注解方式开启注解扫描） //注解方式 @Configuration @ComponentScan(basePackages = &#123;&quot;com.spring5.aopannotation&quot;&#125;) public class SpringConfig &#123; &#125; &lt;!--配置文件方式--&gt; &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.spring5.aopannotation&quot;&gt;&lt;/context:component-scan&gt; &lt;/beans&gt; ②使用注解创建User和 UserProxy对象 @Component public class User &#123; public void add()&#123; System.out.println(&quot;user add...&quot;); &#125; &#125; @Component public class UserProxy &#123; public void before()&#123; System.out.println(&quot;前置通知...&quot;); &#125; &#125; ③在增强（代理）类上面添加注解@Aspect @Component @Aspect public class UserProxy &#123; public void before()&#123; System.out.println(&quot;前置通知...&quot;); &#125; &#125; ④在spring配置文件中开启生成代理对象 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:aop=&quot;http://www.springframework.org/schema/aop&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/aop http://www.springframework.org/schema/aop/spring-aop.xsd&quot;&gt; &lt;!-- 开启注解扫描 --&gt; &lt;context:component-scan base-package=&quot;com.spring5.aopannotation&quot;/&gt; &lt;!-- 开启 Aspect 生成代理对象--&gt; &lt;aop:aspectj-autoproxy/&gt; &lt;/beans&gt; 4、配置不同类型的通知，在增强类中作为通知方法的上面添加通知类型注解，使用切入点表达式配置 @Component @Aspect public class UserProxy &#123; //前置通知 //@Before 注解表示作为前置通知 @Before(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; //最终通知——不管执行过程中有没有异常都会执行 @After(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; //后置通知（返回通知）——执行过程中出现异常就不执行 @AfterReturning(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void afterReturning()&#123; System.out.println(&quot;afterReturning...&quot;); &#125; //异常通知 @AfterThrowing(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void afterThrowing()&#123; System.out.println(&quot;afterThrowing...&quot;); &#125; //环绕通知 @Around(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void around(ProceedingJoinPoint proceedingJoinPoint) throws Throwable &#123; System.out.println(&quot;环绕之前...&quot;); //执行被增强的方法 proceedingJoinPoint.proceed(); System.out.println(&quot;环绕之后...&quot;); &#125; &#125; 5、测试 public class TestSpring5 &#123; @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); user.add(); //环绕之前... //before... //user add... //afterReturning... //after... //环绕之后... //后面三个可能由于Spring版本原因输出结果不一样，弹幕中好像有人说从5.3.7开始底层就改变了 &#125; &#125; //另外，在Around通知的方法中如果使用try-catch处理异常的话当代码执行出现异常时“环绕之后”仍会执行输出，但如果使用throws的方式处理异常的话当代码出现异常时“环绕之后”则不会执行输出 2.提取公共切入点@Pointcut(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void pointDemo()&#123; &#125; //前置通知 //@Before 注解表示作为前置通知 @Before(&quot;pointDemo()&quot;) public void before()&#123; System.out.println(&quot;before...&quot;); &#125; //最终通知 @After(&quot;pointDemo()&quot;) public void after()&#123; System.out.println(&quot;after...&quot;); &#125; 3.多个增强类的优先级当有多个增强类对同一个方法进行增强时，可以通过在增强类上添加@Order(数字类型值)注解设置增强类的优先级，数字类型值越小优先级越高 //PersonProxy增强类 @Component @Aspect @Order(1) public class PersonProxy &#123; @Pointcut(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void pointDemo()&#123; &#125; //前置通知 @Before(&quot;pointDemo()&quot;) public void before()&#123; System.out.println(&quot;personProxy before...&quot;); &#125; //最终通知 @After(&quot;pointDemo()&quot;) public void after()&#123; System.out.println(&quot;personProxy after...&quot;); &#125; &#125; //UserProxy增强类 @Component @Aspect @Order(3) public class UserProxy &#123; @Pointcut(&quot;execution(* com.spring5.aopannotation.User.add())&quot;) public void pointDemo()&#123; &#125; //前置通知 //@Before 注解表示作为前置通知 @Before(&quot;pointDemo()&quot;) public void before()&#123; System.out.println(&quot;userProxy before...&quot;); &#125; //最终通知 @After(&quot;pointDemo()&quot;) public void after()&#123; System.out.println(&quot;userProxy after...&quot;); &#125; &#125; //测试 @Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean1.xml&quot;); User user = context.getBean(&quot;user&quot;, User.class); user.add(); //personProxy before... //userProxy before... //user add... //userProxy after... //personProxy after... &#125; 4.完全注解开发//创建配置类，不需要创建 xml 配置文件 @Configuration @ComponentScan(basePackages = &#123;&quot;com.spring5.aopannotation&quot;&#125;) @EnableAspectJAutoProxy(proxyTargetClass = true) //开启Aspect生成代理对象 public class ConfigAop &#123; &#125; 4.5.3 基于aspectj的xml配置文件方式1、创建两个类，增强类和被增强类，创建方法 public class Book &#123; public void buy()&#123; System.out.println(&quot;book buy...&quot;); &#125; &#125; public class BookProxy &#123; public void before() &#123; System.out.println(&quot;bookProxy before...&quot;); &#125; &#125; 2、在 spring 配置文件中创建两个类对象 &lt;!--创建对象--&gt; &lt;bean id=&quot;book&quot; class=&quot;com.spring5.aopxml.Book&quot;/&gt; &lt;bean id=&quot;bookProxy&quot; class=&quot;com.spring5.aopxml.BookProxy&quot;/&gt; 3、在 spring 配置文件中配置切入点 &lt;!--需要引入aop名称空间--&gt; &lt;!--配置aop增强--&gt; &lt;aop:config&gt; &lt;!--配置切入点--&gt; &lt;aop:pointcut id=&quot;proxied&quot; expression=&quot;execution(* com.spring5.aopxml.Book.buy())&quot;/&gt; &lt;!--配置切面(切面)--&gt; &lt;aop:aspect ref=&quot;bookProxy&quot;&gt; &lt;!--增强作用在具体的方法上(通知)--&gt; &lt;aop:before method=&quot;before&quot; pointcut-ref=&quot;proxied&quot;/&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; 测试 @Test public void test1()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean2.xml&quot;); Book book = context.getBean(&quot;book&quot;, Book.class); book.buy(); //bookProxy before... //book buy... &#125; 五、JdbcTemplate5.1 概述和准备工作5.1.1 概述什么是 JdbcTemplate？Spring 框架对 JDBC 进行封装，使用 JdbcTemplate 方便实现对数据库操作 5.2.2 准备工作1.引入jar包image-20220306135513471 &lt;!--maven依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;druid&lt;/artifactId&gt; &lt;version&gt;1.2.8&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.27&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-orm&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; 2.在Spring配置文件中配置数据库连接池&lt;!--配置创建 DataSource 数据池对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/user_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;/bean&gt; 3.配置JdbcTemplate对象，注入DataSource&lt;!-- 配置创建 JdbcTemplate 对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入 dataSource--&gt; &lt;!--通过查看源码发现，JdbcTemplate继承自JdbcAccessor类，创建JdbcTemplate对象时会将DataSource对象通过有参构造传入，然后通过调用set方法来将传入的DataSource对象赋值给JdbcAccessor类中的DataSource类型属性--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 4.创建 service 类，dao 类，在 dao 注入 jdbcTemplate 对象①配置开启组件扫描&lt;!-- 配置文件方式配置开启组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.spring5&quot;&gt;&lt;/context:component-scan&gt; ②创建Service和Dao使用注解方式创建Service对象和Dao对象 @Service public class UserService &#123; //注入dao @Autowired private UserDao userDao; &#125; public interface UserDao &#123; public void add(User user); &#125; @Repository public class UserDaoImpl implements UserDao &#123; //注入JdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; &#125; 5.2 JdbcTemplate操作数据库5.2.1 添加操作1.创建实体类//根据数据库表结构创建对应实体类 public class User &#123; private Integer id; private String username; private String password; private String status; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getUsername() &#123; return username; &#125; public void setUsername(String username) &#123; this.username = username; &#125; public String getPassword() &#123; return password; &#125; public void setPassword(String password) &#123; this.password = password; &#125; public String getStatus() &#123; return status; &#125; public void setStatus(String status) &#123; this.status = status; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, username=&#39;&quot; + username + &#39;\\&#39;&#39; + &quot;, password=&#39;&quot; + password + &#39;\\&#39;&#39; + &quot;, status=&#39;&quot; + status + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; &#125; 2.编写service和dao层添加用户的操作@Service public class UserService &#123; //注入dao @Autowired private UserDao userDao; public void addUser(User user)&#123; userDao.add(user); &#125; &#125; @Repository public class UserDaoImpl implements UserDao &#123; //注入jdbcTemplate @Autowired private JdbcTemplate jdbcTemplate; @Override public void add(User user) &#123; //创建sql语句 String sql = &quot;insert into t_user values (?,?,?,?)&quot;; //调用方法实现 Object[] args = &#123;user.getId(),user.getUsername(),user.getPassword(),user.getStatus()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update); &#125; &#125; 3.测试@Test public void testJdbcTemplate() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); User user = new User(); user.setId(1); user.setUsername(&quot;admin&quot;); user.setPassword(&quot;12345&quot;); user.setStatus(&quot;1&quot;); userService.addUser(user); &#125; //执行测试后可以发现数据库中被添加了一条新数据 5.2.2 修改删除操作修改和删除操作基本均和添加操作一样 //在UserService中添加方法 public void updateUser(User user)&#123; userDao.update(user); &#125; public void deleteUser(Integer id)&#123; userDao.delete(id); &#125; //在UserDao中添加方法 @Override public void update(User user) &#123; //创建sql语句 String sql = &quot;update t_user set username=?,status=? where id=?&quot;; //调用方法实现 Object[] args = &#123;user.getUsername(), user.getStatus(), user.getId()&#125;; int update = jdbcTemplate.update(sql, args); System.out.println(update); &#125; @Override public void delete(Integer id) &#123; //创建sql语句 String sql = &quot;delete from t_user where id=?&quot;; //调用方法实现 int update = jdbcTemplate.update(sql, id); System.out.println(update); &#125; 测试代码 @Test public void testJdbcTemplate1() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); User user = new User(); user.setId(1); user.setUsername(&quot;admin1&quot;); user.setPassword(&quot;12345&quot;); user.setStatus(&quot;2&quot;); userService.updateUser(user); &#125; @Test public void testJdbcTemplate2() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.deleteUser(1); &#125; 5.2.3 查询操作1.查询返回某个值使用 JdbcTemplate 实现查询返回某个值代码queryForObject(String sql,Class&lt;T&gt; requiredType) 第一个参数：sql 语句 第二个参数：返回值类型 Class //Service层添加方法 public int selectCount()&#123; return userDao.selectCount(); &#125; //Dao层添加方法 @Override public Integer selectCount() &#123; String sql = &quot;select count(*) from t_user&quot;; return jdbcTemplate.queryForObject(sql, Integer.class); &#125; @Test public void testJdbcTemplate3() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService.selectCount());//3 &#125; 2.查询返回对象使用JdbcTemplate方法实现查询返回集合queryForObject(String sql,RowMapper&lt;T&gt; rowMapper,Object... args) 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口的实现类完成数据封装 第三个参数：sql 语句值 //Service层添加方法 public User selectUser(Integer id)&#123; return userDao.selectUser(id); &#125; //Dao层添加方法 @Override public User selectUser(Integer id) &#123; String sql = &quot;select * from t_user where id = ?&quot;; return jdbcTemplate.queryForObject(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class), id); &#125; @Test public void testJdbcTemplate4() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService.selectUser(2));//User&#123;id=2, username=&#39;admin1&#39;, password=&#39;12345&#39;, status=&#39;2&#39;&#125; &#125; 3.查询返回列表调用 JdbcTemplate 方法实现查询返回集合query(String sql,RowMapper rowMapper,Object... args) 第一个参数：sql 语句 第二个参数：RowMapper 是接口，针对返回不同类型数据，使用这个接口的实现类完成数据封装 第三个参数：sql 语句值（可选） //Service层添加方法 public List&lt;User&gt; selectAllUser()&#123; return userDao.selectAllUser(); &#125; //Dao层添加方法 @Override public List&lt;User&gt; selectAllUser() &#123; String sql = &quot;select * from t_user&quot;; return jdbcTemplate.query(sql, new BeanPropertyRowMapper&lt;User&gt;(User.class)); &#125; @Test public void testJdbcTemplate5() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); System.out.println(userService.selectAllUser()); //[User&#123;id=1, username=&#39;admin&#39;, password=&#39;12345&#39;, status=&#39;1&#39;&#125;, //User&#123;id=2, username=&#39;admin1&#39;, password=&#39;12345&#39;, status=&#39;2&#39;&#125;, //User&#123;id=3, username=&#39;admin2&#39;, password=&#39;12345&#39;, status=&#39;3&#39;&#125;] &#125; 5.3 JdbcTemplate批量操作其实添加、修改、删除的操作都一样，都是调用batchUpdate(String sql,List&lt;Object[]&gt; batchArgs)方法，只是sql语句不一样…该方法返回的是一个int类型数组，保存的是添加每条数据的成功与否，成功则元素均为1 5.3.1 批量添加操作使用JdbcTemplate中的batchUpdate(String sql,List&lt;Object[]&gt; batchArgs)实现批量添加操作 第一个参数：sql 语句 第二个参数：List 集合，添加多条记录数据 //Service层添加方法 public void batchAdd(List&lt;Object[]&gt; batchArgs)&#123; userDao.batchInsert(batchArgs); &#125; //Dao层添加方法 @Override public void batchInsert(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;insert into t_user (username,password,status) values (?,?,?)&quot;; int[] ints = jdbcTemplate.batchUpdate(sql, batchArgs); &#125; //测试 @Test public void testJdbcTemplate6() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); List&lt;Object[]&gt; list = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;admin3&quot;,&quot;12345&quot;,&quot;4&quot;&#125;; Object[] o2 = &#123;&quot;admin4&quot;,&quot;12345&quot;,&quot;5&quot;&#125;; Object[] o3 = &#123;&quot;admin5&quot;,&quot;12345&quot;,&quot;6&quot;&#125;; list.add(o1); list.add(o2); list.add(o3); userService.batchAdd(list); &#125; 5.3.2 批量修改操作使用JdbcTemplate中的batchUpdate(String sql,List&lt;Object[]&gt; batchArgs)实现批量修改操作 第一个参数：sql 语句 第二个参数：List 集合，修改多条记录数据 //Service层添加方法 public void batchUpdate(List&lt;Object[]&gt; batchArgs)&#123; userDao.batchUpdate(batchArgs); &#125; //Dao层添加方法 @Override public void batchUpdate(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;update t_user set username=?,password=?,status=? where id=?&quot;; int[] update = jdbcTemplate.batchUpdate(sql, batchArgs); &#125; //测试 @Test public void testJdbcTemplate7() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); List&lt;Object[]&gt; list = new ArrayList&lt;&gt;(); Object[] o1 = &#123;&quot;admin3+&quot;,&quot;123456&quot;,&quot;4+&quot;,&quot;4&quot;&#125;; Object[] o2 = &#123;&quot;admin4+&quot;,&quot;123456&quot;,&quot;5+&quot;,&quot;5&quot;&#125;; Object[] o3 = &#123;&quot;admin5+&quot;,&quot;123456&quot;,&quot;6+&quot;,&quot;6&quot;&#125;; list.add(o1); list.add(o2); list.add(o3); userService.batchUpdate(list); &#125; 5.3.3 批量删除操作使用JdbcTemplate中的batchUpdate(String sql,List&lt;Object[]&gt; batchArgs)实现批量删除操作 第一个参数：sql 语句 第二个参数：List 集合，删除多条记录数据 //Service层添加方法 public void batchDelete(List&lt;Object[]&gt; batchArgs)&#123; userDao.batchDelete(batchArgs); &#125; //Dao层添加方法 @Override public void batchDelete(List&lt;Object[]&gt; batchArgs) &#123; String sql = &quot;delete from t_user where id=?&quot;; int[] delete = jdbcTemplate.batchUpdate(sql, batchArgs); &#125; //测试 @Test public void testJdbcTemplate8() &#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); List&lt;Object[]&gt; list = new ArrayList&lt;&gt;(); Object[] o1 = &#123;4&#125;; Object[] o2 = &#123;5&#125;; list.add(o1); list.add(o2); userService.batchDelete(list); &#125; 六、事务6.1 事务概念1、什么事务 事务是数据库操作最基本单元，逻辑上一组操作，要么都成功，如果有一个失败所有操作都失败 典型场景：银行转账 lucy 转账 100 元 给 mary lucy 少 100，mary 多 100 2、事务四个特性（ACID） 原子性：过程中不可分割，要么都成功，要么就失败 一致性：操作之前和操作之后总量是不变的 隔离性：多事务操作时不会相互影响 持久性：事务提交后数据库表的数据跟着变化 6.2 搭建事务操作环境image-20220306210559365 1.创建数据库，添加记录image-20220306211319455 2.配置组件扫描、DataSource和JdbcTemplate对象&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt; &lt;!-- 配置文件方式配置开启组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.spring5&quot;/&gt; &lt;!--配置创建 DataSource 数据池对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/user_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置创建 JdbcTemplate 对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入 dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;/beans&gt; 3.创建service，dao层，完成对象创建、注入关系及方法创建//service层 @Service public class UserService &#123; @Autowired private UserDao userDao; //转账方法 public void transfer()&#123; userDao.reduce();//mary账户转账100 userDao.add();//lucy账户转入100 &#125; &#125; //dao层 public interface UserDao &#123; public void reduce(); public void add(); &#125; @Repository public class UserDaoImpl implements UserDao &#123; @Autowired private JdbcTemplate jdbcTemplate; //实现mary转账100给lucy @Override public void reduce() &#123; String sql = &quot;update t_account set money=money-? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;mary&quot;); &#125; @Override public void add() &#123; String sql = &quot;update t_account set money=money+? where username=?&quot;; jdbcTemplate.update(sql,100,&quot;lucy&quot;); &#125; &#125; 4.测试@Test public void test()&#123; ApplicationContext context = new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); UserService userService = context.getBean(&quot;userService&quot;, UserService.class); userService.transfer(); &#125; //测试执行正常，mary的账户money剩下900，lucy剩1100 //但是我的没有正常执行，不知道为什么产生死锁了，但是事务处理的大致思路就是这样 5.模拟异常上面代码，如果正常执行没有问题的，但是如果代码执行过程中出现异常则会有问题 //转账方法 public void transfer()&#123; userDao.reduce();//mary账户转账100 //模拟异常 int i = 10/0; userDao.add();//lucy账户转入100 &#125; //如上，如果在执行过程中出现异常，此时查看数据库会发现mary账户只剩900，但是lucy的账户仍是1000，并没有得到mary转的100 出现异常如何处理？使用事务进行处理 //转账方法 public void transfer()&#123; try &#123; //第一步，开启事务 //第二步，进行业务操作 userDao.reduce();//mary账户转账100 //模拟异常 int i = 10/0; userDao.add();//lucy账户转入100 //第三步，若没有异常，提交事务 &#125; catch (Exception e) &#123; //第四步，事务回滚 e.printStackTrace(); &#125; &#125; 6.3 事务管理1、事务添加到 JavaEE 三层结构里面 Service 层（业务逻辑层） 2、在 Spring 进行事务管理操作有两种方式：编程式事务管理和声明式事务管理（一般使用声明式） 编程式事务管理就是编写代码进行事务管理，这种方式特别麻烦，如果需要对多个业务进行事务管理就会造成代码冗余，重复，所以一般不使用这种方式 3、声明式事务管理 基于注解方式（使用） 基于 xml 配置文件方式 4、在 Spring 进行声明式事务管理，底层使用 AOP 原理 5、Spring 事务管理提供的 API 提供一个接口，代表事务管理器，这个接口针对不同的框架提供不同的实现类 image-20220307173251063 6.3.1 声明式事务管理1.注解方式实现声明式事务管理①开启注解方式事务管理以下操作均在上面搭建好的事务管理操作环境的xml配置文件基础上添加 1、在Spring配置文件中配置事务管理器 &lt;!--创建配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;!--在源码中同样可发现此实现类也是通过set方法来配置DataSource对象--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 2、在Spring配置文件中开启事务注解 &lt;!--首先要引入tx名称空间--&gt; &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:context=&quot;http://www.springframework.org/schema/context&quot; xmlns:tx=&quot;http://www.springframework.org/schema/tx&quot; xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd&quot;&gt; &lt;!--开启事务注解--&gt; &lt;tx:annotation-driven transaction-manager=&quot;transactionManager&quot;/&gt; 3、在 service 类上面（或者 service 类里面方法上面）添加事务注解 @Transactional这个注解添加到类上面，也可以添加方法上面 如果把这个注解添加类上面，这个类里面所有的方法都添加事务 如果把这个注解添加方法上面，为这个方法添加事务 @Service @Transactional public class UserService &#123; &#125; ②事务管理参数配置通过查看@Transactional注解可知道有以下参数： image-20220307181026286 1、propagation：事务传播行为 多事务方法直接进行调用，这个过程中事务是如何进行管理的，比如， 一个有事务的方法去调用一个没有事务的方法 一个没有事务的方法去调用一有事务的方法 一个有事务的方法去调用另一个有事务的方法 还有多个事务方法之间的调用等，在这些过程中事务的管理是怎样的，这就是事务传播行为 image-20220307182111322 事务传播行为的几种方式： image-20220307182234498 @Service @Transactional(propagation = Propagation.REQUIRED) public class UserService &#123; &#125; 2、ioslation：事务隔离级别 事务有一个特性为隔离性，多事务操作之间不会产生影响。不考虑隔离性就会产生很多问题 有三个读问题：脏读、不可重复读、虚读（幻读） 脏读：一个未提交事务读取到另一个未提交事务的数据 image-20220307195803475 不可重复读：一个未提交事务读取到另一提交事务修改的数据 image-20220307200224956 虚读：一个未提交事务读取到另一提交事务添加数据 解决以上几种问题的方法就是：通过设置事务隔离级别，解决读问题 image-20220307200859709 @Service @Transactional(isolation = Isolation.REPEATABLE_READ) public class UserService &#123; &#125; 3、timeout：超时时间 事务需要在一定时间内进行提交，如果不提交进行回滚 默认值是 -1 ，设置时间以秒单位进行计算 4、readOnly：是否只读 读：查询操作，写：添加修改删除操作 readOnly 默认值 false，表示可以查询，可以添加修改删除操作 设置 readOnly 值是 true，只能查询 5、rollbackFor：回滚 设置出现哪些异常进行事务回滚 6、noRollbackFor：不回滚 设置出现哪些异常不进行事务回滚 2.xml配置文件方式实现声明式事务管理1、配置事务管理器 这一步和使用注解方式实现事务管理一样，只是不需要开启事务注解的配置 &lt;!-- 配置文件方式配置开启组件扫描 --&gt; &lt;context:component-scan base-package=&quot;com.spring5&quot;/&gt; &lt;!--配置创建 DataSource 数据池对象--&gt; &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSource&quot; destroy-method=&quot;close&quot;&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/bank_db&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot; /&gt; &lt;property name=&quot;password&quot; value=&quot;xk123&quot; /&gt; &lt;property name=&quot;driverClassName&quot; value=&quot;com.mysql.cj.jdbc.Driver&quot; /&gt; &lt;/bean&gt; &lt;!-- 配置创建 JdbcTemplate 对象 --&gt; &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt; &lt;!--注入 dataSource--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; &lt;!--创建配置事务管理器--&gt; &lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt; &lt;!--注入数据源--&gt; &lt;!--在源码中同样可发现此实现类也是通过set方法来配置DataSource对象--&gt; &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt; &lt;/bean&gt; 2、配置通知 &lt;!--配置通知(即配置要增强的功能，这里就是配置事务功能)--&gt; &lt;tx:advice id=&quot;txadvice&quot; transaction-manager=&quot;transactionManager&quot;&gt; &lt;!--配置事务参数--&gt; &lt;tx:attributes&gt; &lt;!--指定在哪种规则的方法上面添加事务--&gt; &lt;!--下面就是在这个方法名的方法上添加事务--&gt; &lt;tx:method name=&quot;transfer&quot; propagation=&quot;REQUIRES_NEW&quot;/&gt; &lt;!--在这个标签里面还可以配置属性的值来配置事务的参数--&gt; &lt;!--&lt;tx:method name=&quot;*&quot;/&gt;--&gt; &lt;!--这种在所有方法上添加事务--&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 3、配置切入点和切面 &lt;!--配置切入点和切面--&gt; &lt;aop:config&gt; &lt;!--配置切入点(即配置要增强功能的方法，在这儿其实就是配置要给哪些方法添加事务)--&gt; &lt;aop:pointcut id=&quot;pt&quot; expression=&quot;execution(* com.spring5.service.UserService.*(..))&quot;/&gt; &lt;!--表示给该类中所有方法添加事务--&gt; &lt;!--配置切面(即配置将增强的功能增强到切入点的具体过程)--&gt; &lt;aop:advisor advice-ref=&quot;txadvice&quot; pointcut-ref=&quot;pt&quot;/&gt; &lt;/aop:config&gt; 3.完全注解实现声明式事务@Configuration //配置类 @ComponentScan(basePackages = &quot;com.spring5&quot;) //开启组件扫描 @EnableTransactionManagement //开启事务管理 public class SpringConfig &#123; //创建数据库连接池 @Bean public DruidDataSource getDruidDataSource() &#123; DruidDataSource dataSource = new DruidDataSource(); dataSource.setDriverClassName(&quot;com.mysql.cj.jdbc.Driver&quot;); dataSource.setUrl(&quot;jdbc:mysql://localhost:3306/user_db&quot;); dataSource.setUsername(&quot;root&quot;); dataSource.setPassword(&quot;root&quot;); return dataSource; &#125; //创建 JdbcTemplate 对象 @Bean public JdbcTemplate getJdbcTemplate(DataSource dataSource) &#123; //到 ioc 容器中根据类型找到 dataSource JdbcTemplate jdbcTemplate = new JdbcTemplate(); //注入 dataSource jdbcTemplate.setDataSource(dataSource); return jdbcTemplate; &#125; //创建事务管理器 @Bean public DataSourceTransactionManager getDataSourceTransactionManager(DataSource dataSource) &#123; DataSourceTransactionManager transactionManager = new DataSourceTransactionManager(); transactionManager.setDataSource(dataSource); return transactionManager; &#125; &#125; //通过测试可以发现数据库中的数据因为出现异常发生事务回滚，所以数据均没有发生改变 七、Spring5新功能整个 Spring5 框架的代码基于 Java8，运行时兼容 JDK9，许多不建议使用的类和方法已从代码库中删除 7.1 整合日志框架Spring 5.0 框架自带了通用的日志封装 Spring5 已经移除 Log4jConfigListener，官方建议使用 Log4j2 7.1.1 Spring5 框架整合 Log4j21、导入jar包 image-20220307213147567 &lt;!--maven依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-api&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-core&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.logging.log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j-slf4j-impl&lt;/artifactId&gt; &lt;version&gt;2.17.0&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha6&lt;/version&gt; &lt;/dependency&gt; &lt;!--下面这个依赖在slf4j的1.8版本后需要加上，否则会报no SLF4J provider were found，具体原因可查看报错时给出的链接进行查看--&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-nop&lt;/artifactId&gt; &lt;version&gt;2.0.0-alpha6&lt;/version&gt; &lt;/dependency&gt; 2、创建log4j2.xml配置文件（配置文件名必须为log4j2.xml） &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;!--日志级别以及优先级排序: OFF &gt; FATAL &gt; ERROR &gt; WARN &gt; INFO &gt; DEBUG &gt; TRACE &gt; ALL --&gt; &lt;!--Configuration 后面的 status 用于设置 log4j2 自身内部的信息输出，可以不设置，当设置成 trace 时，可以看到 log4j2 内部各种详细输出--&gt; &lt;configuration status=&quot;INFO&quot;&gt; &lt;!--先定义所有的 appender--&gt; &lt;appenders&gt; &lt;!--输出日志信息到控制台--&gt; &lt;console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;!--控制日志输出的格式--&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/console&gt; &lt;/appenders&gt; &lt;!--然后定义 logger，只有定义 logger 并引入的 appender，appender 才会生效--&gt; &lt;!--root：用于指定项目的根日志，如果没有单独指定 Logger，则会使用 root 作为默认的日志输出--&gt; &lt;loggers&gt; &lt;root level=&quot;info&quot;&gt; &lt;appender-ref ref=&quot;Console&quot;/&gt; &lt;/root&gt; &lt;/loggers&gt; &lt;/configuration&gt; 3、测试代码（手动打印日志） import org.apache.logging.log4j.LogManager; import org.apache.logging.log4j.Logger; public class UserLog &#123; private static final Logger logger = LogManager.getLogger(UserLog.class); public static void main(String[] args) &#123; logger.info(&quot;hello log4j2 info...&quot;); logger.warn(&quot;hello log4j2 warn...&quot;); &#125; &#125; 在测试代码时因看视频中的Logger和LogFactory是从org.slf4j包中导入的，所以我在测试时也是导入的这个包，但是当我运行时发现没有任何日志信息打印出来，此时我就去搜查了一下，原来视频中的那种写法是log4j的写法，其实用于log4j2是错误的，我也不清楚为什么视频中就能测试出来，于是我看了下面这篇博客后导入正确的包才成功解决了这个问题https://blog.csdn.net/zqg4919/article/details/78321580 7.2 支持@Nullable注解@Nullable 注解可以使用在方法上面，属性上面，参数上面，表示方法返回可以为空，属性值可以为空，参数值可以为空 public class NullableTest &#123; //注解使用在属性上面，属性值可以为空 @Nullable private String name; //注解用在方法上面，方法返回值可以为空 @Nullable public void testNullable(@Nullable String parameter)&#123;//注解使用在方法参数里面，方法参数可以为空 &#125; &#125; 7.3 函数式风格Spring5 核心容器支持函数式风格 GenericApplicationContext 我们知道，在Spring框架中，对象的创建都有Spring容器自己完成，但是当我们想使用new关键字自己创建对象时Spring容器是得不到这个对象的 举例：（为了方便实体类使用上述的NullableTest类） NullableTest nullableTest = new NullableTest(); //当我们像上方那样创建好对象后，如果我们想通过getBean方法获取到这个对象或将它注入到其他地方，那么Spring容器是不能识别到这个对象从而进行这些行为的 //此时我们就需要用到Spring5的新功能 @Test public void testGenericApplicationContext() &#123; //1 创建 GenericApplicationContext 对象 GenericApplicationContext context = new GenericApplicationContext(); //2 调用 context 的方法对象注册 context.refresh(); //registerBean方法中需要传入——创建的对象名，创建的对象类型，创建的对象——作为参数，其中对象名可以省略 //context.registerBean(NullableTest.class,() -&gt; new NullableTest());//这种是省略对象名的写法 context.registerBean(&quot;nullableTest&quot;,NullableTest.class,() -&gt; new NullableTest());//这种是不省略对象名的写法 //3 获取在 spring 注册的对象 //NullableTest nullableTest = (NullableTest) context.getBean(&quot;com.spring5.NullableTest&quot;);//省略对象名注册对象的方式 NullableTest nullableTest = (NullableTest) context.getBean(&quot;nullableTest&quot;);//不省略对象名注册对象的方式 //上述两种方式均能将我们自己创建的对象注册到Spring容器中 System.out.println(nullableTest);//com.spring5.NullableTest@78452606 &#125; 7.4 整合JUnit5单元测试框架7.4.1 JUnit41、引入Spring测试相关依赖或导入jar包 &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.13.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; 2、编写测试类 //创建测试类，使用注解方式完成 @RunWith(SpringJUnit4ClassRunner.class) //单元测试框架 //@ContextConfiguration(&quot;classpath:bean.xml&quot;) //读取配置文件的的方式，这儿可以自己看看这个注解的具体源码就知道了 @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) //读取配置类的方式 public class TestSpring5 &#123; @Autowired private NullableTest nullableTest; //自动装载 @Test public void testJUnit()&#123; System.out.println(nullableTest);//com.spring5.NullableTest@5aac4250 //当我们需要用到nullableTest对象时它会帮我们自动创建并装载，此时我们就不需要再通过ClassPathXmlApplicationContext类或AnnotationConfigApplicationContext类来获取对象了 &#125; &#125; 从这里也就解决了我在前面提到的疑惑“为什么每次测试我们仍需要通过getBean方法来获取service对象”，原来是测试类没有获取到配置文件或配置类的配置并且测试类也没有没有注入到Spring容器中，就不能获取到配置从而就不能自动创建对象了 7.4.2 JUnit51、引入JUnit5相关依赖或导入jar包 &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;5.3.16&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt; &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt; &lt;version&gt;5.8.2&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; 2、编写测试类 //创建测试类，使用注解方式完成 //方式几乎和JUnit4一样，只不过需要注意导入的包必须要是junit-jupiter-api @ExtendWith(SpringExtension.class) //@ContextConfiguration(&quot;classpath:bean.xml&quot;) @ContextConfiguration(classes = &#123;SpringConfig.class&#125;) public class TestJUnit5 &#123; @Autowired private NullableTest nullableTest; @Test public void testJUnit5()&#123; System.out.println(nullableTest);//com.spring5.NullableTest@6ffab045 &#125; &#125; 另外，在JUnit5中，测试类上方的两个注解可以用一个复合注解代替，即@SpringJUnitConfig(locations = &quot;classpath:bean1.xml&quot;)或@SpringJUnitConfig(classes = &#123;SpringConfig.class&#125;) 7.5 Webflux7.5.1 基本概念Webflux是 Spring5 添加新的模块，用于 web 开发的，功能和 SpringMVC 类似的，Webflux 使用当前一种比较流行的响应式编程出现的框架。 目前使用的传统 web 框架，比如 SpringMVC，这些都是基于 Servlet 容器。 Webflux 是一种异步非阻塞的框架，异步非阻塞的框架在 Servlet3.1 以后才支持，核心是基于 Reactor 的相关 API 实现的。 什么是异步非阻塞？ 异步和同步 非阻塞和阻塞 上面两种术语针对对象不一样 异步和同步针对调用者，调用者发送请求，如果等着对方回应之后才去做其他事情就是同步，如果发送请求之后不用等对方回应就去做其他事情就是异步（调用者需要等到一个请求被响应后才能发出下一个请求就是同步，调用者发出一个请求后还可以发送其他请求就是异步） 阻塞和非阻塞针对被调用者，被调用者受到请求之后，做完请求任务之后才给出反馈就是阻塞，受到请求之后马上给出反馈然后再去做事情就是非阻塞（被调用者处理完请求后再响应是阻塞，被调用者响应后再处理请求是非阻塞） Webflux的特点： 非阻塞式：在有限资源下，提高系统吞吐量和伸缩性，以 Reactor 为基础实现响应式编程 函数式编程：Spring5 框架基于 java8，Webflux 使用 Java8 函数式编程方式实现路由请求 Spring WebFlux和Spring MVC的异同： 两个框架都可以使用注解方式，都运行在 Tomcat 等容器中 SpringMVC 采用命令式编程，Webflux 采用异步响应式编程 image-20220309150348716 7.5.2 响应式编程什么是响应式编程？ 响应式编程是一种面向数据流和变化传播的编程范式。这意味着可以在编程语言中很方便地表达静态或动态的数据流，而相关的计算模型会自动将变化的值通过数据流进行传播。比如，Excel的电子表格就是响应式编程的一个例子，单元格可以包含字面值或类似”=B1+C1”的公式，而包含公式的单元格的值会依据其他单元格的值的变化而变化。 1.Java实现响应式编程在JDK8 及之前的版本中提供了观察者模式的两个类 Observer 和 Observable 其中，观察者类需要实现Observer接口，被观察者类需要继承Observable类 public class ObserverDemo extends Observable &#123; public static void main(String[] args) &#123; ObserverDemo observerDemo = new ObserverDemo(); observerDemo.addObserver((o, arg) -&gt; &#123; System.out.println(&quot;数据发生了变化&quot;); &#125;); observerDemo.addObserver((o, arg) -&gt; &#123; System.out.println(&quot;收到观察者通知&quot;); &#125;); observerDemo.addObserver((o, arg) -&gt; &#123; System.out.println(&quot;收到观察者通知1&quot;); &#125;); //若没有下方使数据改变并且通知观察者的代码，则不会输出任何语句 observerDemo.setChanged();//使数据发生改变 observerDemo.notifyObservers();//通知观察者 //收到被观察者通知1 //收到被观察者通知 //数据发生了变化 //从输出顺序可以看出，观察者被通知的顺序是就近原则，可能是这三个观察者对象被存放到了类似栈的数据结构中（个人认为） &#125; &#125; 在JDK9中，Observer和Observable就被Flow类替代了，在Flow类中，通过内部接口Publisher中的subscribe方法实现观察者模式 public class ObserverDemo extends Observable &#123; public static void main(String[] args) &#123; //subscriber——订阅者/观察者，Publisher——发布者/被观察者 //在这里面subscriber应该是充当观察者，当观察到有数据变化publisher则做出相应处理方式 Flow.Publisher&lt;String&gt; publisher = subscriber -&gt; &#123; subscriber.onNext(&quot;1&quot;); subscriber.onNext(&quot;2&quot;); subscriber.onError(new RuntimeException(&quot;出错&quot;)); &#125; &#125; &#125; 想要弄懂这里需要了解什么是观察者模式？ 观察者模式其实也是发布/订阅模式，这是一种对象间一对多（一是被观察者，多是观察者）的依赖关系，每当一个对象状态发生改变时，与其依赖的对象都会得到通知并自动更新。 2.Reactor实现响应式编程Reactor官网文档：https://projectreactor.io/docs/core/release/reference/ 响应式编程操作中，需要满足 Reactive 规范，而Reactor就是满足 Reactive 规范的一种框架 Reactor 有两个核心类，Mono 和 Flux，这两个类实现接口 Publisher，提供丰富的操作符。Flux 对象实现发布者，返回 N 个元素；而Mono 实现发布者，返回 0 或者 1 个元素 Flux 和 Mono 都是数据流的发布者，使用 Flux 和 Mono 都可以发出三种数据信号：元素值，错误信号，完成信号（错误信号和完成信号都代表终止信号，终止信号用于告诉订阅者数据流结束了，错误信号终止数据流同时把错误信息传递给订阅者） image-20220309164859260 代码演示 &lt;!--导入maven依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;io.projectreactor&lt;/groupId&gt; &lt;artifactId&gt;reactor-core&lt;/artifactId&gt; &lt;version&gt;3.4.14&lt;/version&gt; &lt;/dependency&gt; //测试代码 public class ReactorTest &#123; public static void main(String[] args) &#123; //just 方法直接声明数据流 Flux.just(1,2,3,4); Mono.just(1); //其他的方法 Integer[] array = &#123;1,2,3,4&#125;; Flux.fromArray(array); //数组形式 List&lt;Integer&gt; list = Arrays.asList(array); Flux.fromIterable(list); //集合形式 Stream&lt;Integer&gt; stream = list.stream(); Flux.fromStream(stream); //流形式 &#125; &#125; //调用 just 或者其他方法只是声明数据流，数据流并没有发出，只有进行订阅之后才会触发数据流，不订阅什么都不会发生的 //只有像这样调用subscribe方法订阅后才会触发数据流 Flux.just(1,2,3,4).subscribe(System.out::println); Mono.just(1).subscribe(System.out::println); 三种信号特点 错误信号和完成信号都是终止信号，不能共存的 如果没有发送任何元素值，而是直接发送错误或者完成信号，表示是空数据流 如果没有错误信号，没有完成信号，表示是无限数据流 3.操作符操作符是对数据流进行一道道操作，最终得到我们想要的数据流，比如工厂流水线，其中对产品进行加工的一道道工序就是相当于是操作符 常见的操作符： map ：将元素映射为新元素 image-20220309172319837 flatMap：将元素映射为流，把每个元素转换流，把转换之后的多个流合并大的流 image-20220309172528291 7.5.3 执行流程和核心APISpringWebflux 基于 Reactor，默认使用容器是 Netty，Netty 是高性能的 NIO 框架，异步非阻塞的框架 1.NIO框架 image-20220309181506266 image-20220309181630432 2.SpringWebflux 执行过程和 SpringMVC 相似 SpringWebflux 核心控制器 DispatcherHandler 类，该类实现接口 WebHandler，实现了接口 WebHandler 中的一个方法 handle image-20220309182159482 该方法在DispatcherHandler类中的具体实现：(需要创建SpringBoot项目导入spring-boot-starter-webflux依赖才能查看) image-20220309222340273 WebHandler接口不同实现类的不同功能： image-20220309223609662 3.SpringWebflux 里面 DispatcherHandler，负责请求的处理 HandlerMapping：请求查询到处理的方法 HandlerAdapter：真正负责请求处理 HandlerResultHandler：响应结果处理 4.SpringWebflux 实现函数式编程，两个接口：RouterFunction（路由处理）和 HandlerFunction（处理函数） 7.5.4 注解编程模型SpringWebflux 实现方式有两种：注解编程模型和函数式编程模型 使用注解编程模型的方式，和 SpringMVC 使用相似，只需要把相关依赖配置到项目中，SpringBoot 自动配置相关运行容器，默认情况下使用 Netty 服务器 首先，通过代码实现注解编程模型 1.创建一个SpringBoot项目 在新建项目中选择新建Spring Initializr项目 image-20220310195120697 完成项目创建 image-20220310195328649 2.导入依赖 在pom文件中将spring-boot-starter-web依赖更改为spring-boot-starter-webflux image-20220310195512385 3.在配置文件中配置服务器端口号 image-20220310195651363 4.创建好相关包和类 //实体类 public class User &#123; private String name; private String gender; private Integer age; public User(String name, String gender, Integer age) &#123; this.name = name; this.gender = gender; this.age = age; &#125; //省略setter，getter和toString方法 &#125; //service @Service public class UserServiceImpl implements UserService &#123; //由于为了方便不连接数据库，所以这里设置一个Map来存放数据 private final Map&lt;Integer,User&gt; users = new HashMap&lt;&gt;(); //在构造函数中对数据进行初始化 public UserServiceImpl()&#123; this.users.put(1,new User(&quot;Eric&quot;,&quot;男&quot;,23)); this.users.put(2,new User(&quot;Jack&quot;,&quot;男&quot;,26)); this.users.put(3,new User(&quot;Lucy&quot;,&quot;女&quot;,20)); &#125; //根据id查询用户 @Override public Mono&lt;User&gt; getUserById(Integer id) &#123; return Mono.justOrEmpty(this.users.get(id)); //justOrEmpty方法：创建一个新的 Mono ，如果非 null 则发出指定的项目，否则只发出 完成 &#125; //查询所有用户 @Override public Flux&lt;User&gt; getAllUser() &#123; return Flux.fromIterable(this.users.values()); //fromXxx方法 //fromArray（从数组）、fromIterable（从迭代器）、fromStream（从 Java Stream 流） 的方式来创建 Flux &#125; //添加新用户 @Override public Mono&lt;Void&gt; addUser(Mono&lt;User&gt; user) &#123; return user.doOnNext(person -&gt; &#123; //doOnNext方法：添加行为时触发 Mono 成功发出数据 //向集合添加新数据 int id = users.size() + 1; users.put(id,person); &#125;).thenEmpty(Mono.empty());//生成一个空的有限流，这儿用来终止数据流 &#125; &#125; //controller @RestController public class UserController &#123; @Autowired private UserService userService; //id 查询 @GetMapping(&quot;/user/&#123;id&#125;&quot;) public Mono&lt;User&gt; getUserById(@PathVariable int id) &#123; return userService.getUserById(id); &#125; //查询所有 @GetMapping(&quot;/users&quot;) public Flux&lt;User&gt; getUsers() &#123; return userService.getAllUser(); &#125; //添加 @PostMapping(&quot;/addUser&quot;) public Mono&lt;Void&gt; saveUser(@RequestBody User user) &#123; Mono&lt;User&gt; userMono = Mono.just(user);//just方法的作用：将数据作为流发出并结束这段数据流 return userService.addUser(userMono); &#125; &#125; //若以上方法不清楚功能，可以返回到7.5.2节的第二部分中点击链接查看Reactor官网文档 5.启动项目 启动项目可以在控制台发现SpringBoot项目使用的是Netty容器，并且使用的端口是配置的8081端口 image-20220310205118911 然后在浏览器访问数据，数据在浏览器中成功显示则代表成功 image-20220310205304480 注解编程模型实现的说明： SpringMVC 方式实现——是同步阻塞的方式，基于 SpringMVC+Servlet+Tomcat SpringWebflux 方式实现——异步非阻塞方式，基于 SpringWebflux+Reactor+Netty 7.5.5 函数式编程模型在使用函数式编程模型操作时候，需要自己初始化服务器 基于函数式编程模型时候，有两个核心接口：RouterFunction（实现路由功能，请求转发给对应的 handler）和 HandlerFunction（处理请求，生成响应的函数）。核心任务就是定义这两个函数式接口的实现类并且启动需要的服务器 SpringWebflux 请求和响应不再是 ServletRequest 和 ServletResponse ，而是ServerRequest 和 ServerResponse 函数式编程各个部分之间的联系： image-20220310213521825 1.构建项目 在注解编程模型的基础上删除controller层，保留service和entity 2.创建Handler public class UserHandler &#123; private final UserService userService; public UserHandler(UserService userService) &#123; this.userService = userService; &#125; //根据 id 查询 public Mono&lt;ServerResponse&gt; getUserById(ServerRequest request) &#123; //获取 id 值 int userId = Integer.parseInt(request.pathVariable(&quot;id&quot;)); //空值处理 Mono&lt;ServerResponse&gt; notFound = ServerResponse.notFound().build();//没有找到对应数据就创建一个空数据 //调用 service 方法得到数据 Mono&lt;User&gt; userMono = this.userService.getUserById(userId); //把 userMono 进行转换返回 //使用 Reactor 操作符 flatMap return userMono.flatMap(person -&gt; ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(fromObject(person))).switchIfEmpty(notFound); //如果userMono不为空，服务响应成功，并将userMono转换成json数据格式并流化处理，将其作为响应返回；如果userMono为空，则返回刚刚创建的空数据 //从方法名可以看出： //contentType方法是设置数据的格式类型，body方法是设置响应体的数据，switchIfEmpty方法是判断我们要传的数据是否为空 &#125; //查询所有 public Mono&lt;ServerResponse&gt; getAllUsers() &#123; //调用 service 得到结果 Flux&lt;User&gt; users = this.userService.getAllUser(); return ServerResponse.ok().contentType(MediaType.APPLICATION_JSON).body(users,User.class); &#125; //添加 public Mono&lt;ServerResponse&gt; saveUser(ServerRequest request) &#123; //得到 user 对象 Mono&lt;User&gt; userMono = request.bodyToMono(User.class); return ServerResponse.ok().build(this.userService.addUser(userMono)); &#125; &#125; 3.初始化服务器，编写router public class Server &#123; //1 创建 Router 路由 public RouterFunction&lt;ServerResponse&gt; routingFunction() &#123; //创建 hanler 对象 UserService userService = new UserServiceImpl(); UserHandler handler = new UserHandler(userService); //设置路由 return RouterFunctions.route(GET(&quot;/users/&#123;id&#125;&quot;).and(accept(APPLICATION_JSON)),handler::getUserById) .andRoute(GET(&quot;/users&quot;).and(accept(APPLICATION_JSON)),handler::getAllUsers); //设置 请求的方式、接收数据类型、处理请求的具体方法 //被路由的方法中都需要有ServerRequest参数，否则这里会无法解析 &#125; //2 创建服务器完成适配 public void createReactorServer() &#123; //路由和 handler 适配 RouterFunction&lt;ServerResponse&gt; route = routingFunction();//创建路由对象 HttpHandler httpHandler = toHttpHandler(route); ReactorHttpHandlerAdapter adapter = new ReactorHttpHandlerAdapter(httpHandler); //创建服务器 HttpServer httpServer = HttpServer.create(); httpServer.handle(adapter).bindNow(); &#125; &#125; 4.调用 public static void main(String[] args) throws Exception&#123; Server server = new Server(); server.createReactorServer(); System.out.println(&quot;enter to exit&quot;); System.in.read(); &#125; 运行main方法，在控制台可以看到开启的服务器及端口 image-20220310215734447 在浏览器中访问路径，得到数据 在控制台还可以看见请求响应的具体信息： image-20220310220034275 5.使用WebClient调用 public class Client &#123; public static void main(String[] args) &#123; //调用服务器地址 WebClient webClient = WebClient.create(&quot;http://127.0.0.1:55642&quot;); //根据 id 查询 String id = &quot;1&quot;; User user = webClient.get().uri(&quot;/users/&#123;id&#125;&quot;, id).accept(MediaType.APPLICATION_JSON).retrieve().bodyToMono(User.class).block(); System.out.println(user);//User&#123;name=&#39;Eric&#39;, gender=&#39;男&#39;, age=23&#125; //查询所有 Flux&lt;User&gt; results = webClient.get().uri(&quot;/users&quot;).accept(MediaType.APPLICATION_JSON).retrieve().bodyToFlux(User.class); results.map(stu -&gt; stu.getName()).buffer().doOnNext(System.out::println).blockFirst();//[Eric, Jack, Lucy] &#125; &#125;","categories":[{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"},{"name":"Spring5","slug":"Spring5","permalink":"http://rainvex.com/tags/Spring5/"}]},{"title":"JavaSE学习笔记","slug":"JavaSE学习笔记","date":"2022-03-27T13:38:17.000Z","updated":"2022-03-27T13:38:17.000Z","comments":true,"path":"categories/后端/JavaSE学习笔记.html","link":"","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/JavaSE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0.html","excerpt":"","text":"JavaSE学习笔记JDK8官方文档查看：https://docs.oracle.com/javase/8/docs/api/ 一、Java基础语法1.1 数据类型Java是强类型语言，要求变量的使用要严格符合规定，所有变量必须定义后才能使用 Java的数据类型分为两大类：基本类型和引用类型 位（bit）：是计算机内部数据储存的最小单位 字节（byte）：是计算机中数据处理的基本单位，习惯用大写B表示 1B=8bit，1024B=1KB，1024KB=1M，1024M=1G 1.1.1 基本数据类型基本数据类型又分为数值类型和boolean类型 数值类型 整数类型 byte占1个字节范围：-128~127 short占2个字节范围：-32768~32767 int占4个字节范围：-2147483648~2147483647 long占8个字节范围 浮点类型 float占4个字节 double占8个字节 字符类型 char占2个字节 注：字符串String不是关键字，是类；最好完全使用浮点数进行比较 boolean类型 占1个字节，值只有true和false两个 1.1.2 引用数据类型引用数据类型分为类、接口、数组 1.1.3 类型转换运算中，不同类型的数据先转换为同一类型，然后进行运算 数据类型范围小的数据转化为数据类型范围大的数据不需要进行强制转换；范围大的转化为范围小的需要进行强制转换，但是数据精度可能会有丢失 即， 注：不能对布尔值进行转换；不能把对象类型转换为不相干的类型；转换的时候可能出现内存溢出或者精度问题 1.1.4 赋值问题操作比较大的数的时候，需要注意溢出问题 int money = 1000000000; int year = 20; int total = money*year; //此时的total已经溢出，输出的结果就不是20000000000 long total2 = money*year; //此时输出total2的值也是错的，因为money*year作为int类型赋值给long类型的total2之前得到的值就已经出现了问题，所以应该在计算之前就进行转换，即第三种 long total3 = (long)money*year; //此时因为将money强制转化为long类型，所以运算是按照数据范围更大的long类型进行运算，所以此时输出total3是正确的值；money*(long)year也行 1.2 变量1.2.1 变量声明Java是一种强类型语言，每个变量都必须声明其类型 Java变量是程序中最基本的存储单元，其要素包括变量名，变量类型和作用域 type varName[=value] [&#123;,varName[=value]&#125;] ; //数据类型变量名=值;可以使用逗号隔开来声明多个同类型变量。 int a=1,b=2,c=3; String name = &quot;xk&quot;; char x = &#39;x&#39;; double pi = 3.14; float f = 2.454f; long L = 34532847L; 注：每个变量都有类型，类型可以是基本类型，也可以是引用类型；变量名必须是合法的标识符；变量声明是一条完整的语句，因此每一个声明都必须以分号结束。 1.2.2 变量分类及作用域变量分为类变量、实例变量、局部变量 局部变量①局部变量声明在方法、构造方法或者语句块中 ②局部变量在方法、构造方法、或者语句块被执行的时候创建，当它们执行完成后，变量将会被销毁 ③访问修饰符不能用于局部变量 ④局部变量只在声明它的方法、构造方法或者语句块中可见 ⑤局部变量是在栈上分配的 ⑥局部变量没有默认值，所以局部变量被声明后，必须经过初始化，才可以使用 public class Test&#123; public void pupAge()&#123; int age = 0; age = age + 7; System.out.println(&quot;小狗的年龄是: &quot; + age); &#125; public static void main(String[] args)&#123; Test test = new Test(); test.pupAge(); &#125; &#125; 实例变量①实例变量声明在一个类中，但在方法、构造方法和语句块之外 ②当一个对象被实例化之后，每个实例变量的值就跟着确定 ③实例变量在对象创建的时候创建，在对象被销毁的时候销毁 ④实例变量的值应该至少被一个方法、构造方法或者语句块引用，使得外部能够通过这些方式获取实例变量信息 ⑤实例变量可以声明在使用前或者使用后 ⑥访问修饰符可以修饰实例变量 ⑦实例变量对于类中的方法、构造方法或者语句块是可见的。一般情况下应该把实例变量设为私有，通过使用访问修饰符可以使实例变量对子类可见 ⑧实例变量具有默认值。数值型变量的默认值是0，布尔型变量的默认值是false，引用类型变量的默认值是null。变量的值可以在声明时指定，也可以在构造方法中指定 ⑨实例变量可以直接通过变量名访问。但在静态方法以及其他类中，就应该使用完全限定名：ObejectReference.VariableName（对象名.变量名） public class Employee&#123; // 这个实例变量对子类可见 public String name; // 私有变量，仅在该类可见 private double salary; //在构造器中对name赋值 public Employee (String empName)&#123; name = empName; &#125; //设定salary的值 public void setSalary(double empSal)&#123; salary = empSal; &#125; // 打印信息 public void printEmp()&#123; System.out.println(&quot;名字 : &quot; + name ); System.out.println(&quot;薪水 : &quot; + salary); &#125; public static void main(String[] args)&#123; Employee empOne = new Employee(&quot;RUNOOB&quot;); empOne.setSalary(1000.0); empOne.printEmp(); &#125; &#125; 类变量（静态变量）①类变量也称为静态变量，在类中以 static 关键字声明，但必须在方法之外 ②无论一个类创建了多少个对象，类只拥有类变量的一份拷贝（所有对象共享一份静态变量） ③静态变量除了被声明为常量外很少使用，静态变量是指声明为public/private，final 和 static 类型的变量。静态变量初始化后不可改变 ④静态变量储存在静态存储区。经常被声明为常量，很少单独使用 static 声明变量 ⑤静态变量在第一次被访问时创建，在程序结束时销毁 ⑥与实例变量具有相似的可见性。但为了对类的使用者可见，大多数静态变量声明为 public 类型 ⑦默认值和实例变量相似。数值型变量默认值是 0，布尔型默认值是 false，引用类型默认值是 null。变量的值可以在声明的时候指定，也可以在构造方法中指定。此外，静态变量还可以在静态语句块中初始化 ⑧静态变量可以通过：ClassName.VariableName（类名.变量名）的方式访问，也可以通过对象名.静态变量进行访问但java不推荐这样做 ⑨类变量被声明为 public static final 类型时，类变量名称一般建议使用大写字母。如果静态变量不是 public 和 final 类型，其命名方式与实例变量以及局部变量的命名方式一致 public class Employee &#123; //salary是静态的私有变量 private static double salary; // DEPARTMENT是一个常量 public static final String DEPARTMENT = &quot;开发人员&quot;; public static void main(String[] args)&#123; salary = 10000; System.out.println(DEPARTMENT+&quot;平均工资:&quot;+salary); &#125; &#125; //注：如果其他类想要访问该变量，可以这样访问：Employee.DEPARTMENT 1.2.3 常量常量(Constant)：初始化(initialize)后不能再改变值!不会变动的值 所谓常量可以理解成一种特殊的变量，它的值被设定后，在程序运行过程中不允许被改变。 final 常量名=值；final double PI=3.14； 常量名一般使用大写字符，final是指该变量只准被修改一次 1.3 运算符Java支持的运算符： 算术运算符：+、-、*、/、%、++、– 赋值运算符：= 关系运算符：&gt;、&lt;、&gt;=、&lt;=、==、!=、instanceof 逻辑运算符：&amp;&amp;、||、! 位运算符：&amp;、|、^、~、&gt;&gt;、&lt;&lt;、&gt;&gt;&gt;(了解) 条件运算符（三元运算符）：？： 扩展赋值运算符：+=、-=、*=、/= 1.3.1 自增(++)、自减(–)运算符int a = 3; int b = a++; //先给b赋值，再自增 int c = ++a; //先自增，再给b赋值 1.3.2 逻辑运算符、位运算符逻辑运算符：与（and）、或（or）、非（!） 逻辑与运算、逻辑或运算又分为短路与(&amp;&amp;)、长路与(&amp;)、短路或(||)、长路或(|) 区别： 短路与和长路与：长路与 两侧都会被运算；短路与 只要第一个是false，第二个就不会进行运算了 短路或和长路或：长路或 两侧都会被运算；短路或 只要第一个是true，第二个就不会进行运算了 //与（and） 或（or） 非（取反） boolean a = true; boolean b = false; System.out.println(a&amp;&amp;b); //与运算，都为真结果才能为真 System.out.println(a||b); //或运算，其中一个为真，结果就为真 System.out.println(!(a&amp;&amp;b)); //如果a&amp;&amp;b是真，结果为假；否则为真 位运算符：长路与(&amp;)、长路或(|)、异或(^)、非(~)、左移(&lt;&lt;)、右移(&gt;&gt;) //位运算，效率极高！！ A = 0011 1100; B = 0000 1101; A&amp;B = 0000 1100; //与，都为1才为1 A|B = 0011 1101; //或，其中一个为1就为1 A^B = 1100 1110; //异或运算，相同为真，不同为假 ~B = 1111 0010; //位取反 /* 2*8=16 2*2*2*2 &lt;&lt; 相当于*，根据一个整数的二进制表达，将其每一位都向左移动，最右边补0 &gt;&gt; 相当于/，根据一个整数的二进制表达，将其每一位都向右移动 0000 0010 2 0000 1000 8 0001 0000 16 */ System.out.println(2&lt;&lt;3); //结果为16，即将2的二进制表达的每一位向左移动3位，也相当于2*2*2*2 1.3.3 三元运算符、字符串连接符//字符串连接符 + int a = 10; int b = 20; System.out.println(&quot;a+b&quot;+a+b); //输出a+b1020,因为a+b在String类型的&quot;a+b&quot;之后，会将a和b的值直接在其后面进行拼接 System.out.println(a+b+&quot;a+b&quot;); //输出30a+b，因为a+b在String类型的&quot;a+b&quot;之前，会先将a+b进行运算后再拼接 //三元运算符 x ? y : z //如果x=true，结果为y；如果x=false，结果为z 1.3.4 运算符优先级所有的数学运算都认为是从左向右运算的，Java 语言中大部分运算符也是从左向右结合的，只有单目运算符、赋值运算符和三目运算符例外，其中，单目运算符、赋值运算符和三目运算符是从右向左结合的，也就是从右向左运算 乘法和加法是两个可结合的运算，也就是说，这两个运算符左右两边的操作数可以互换位置而不会影响结果。运算符有不同的优先级，所谓优先级就是在表达式运算中的运算顺序 一般而言，单目运算符优先级较高，赋值运算符优先级较低。算术运算符优先级较高，关系和逻辑运算符优先级较低。多数运算符具有左结合性，单目运算符、三目运算符、赋值运算符具有右结合性 Java 语言中运算符的优先级共分为 14 级，其中 1 级最高，14 级最低。在同一个表达式中运算符优先级高的先执行。表 1 列出了所有的运算符的优先级以及结合性 运算符优先级： 优先级 运算符 结合性 1 ()、[]、{} 从左向右 2 !、+、-、~、++、– 从右向左 3 *、/、% 从左向右 4 +、- 从左向右 5 «、»、&gt;&gt;&gt; 从左向右 6 &lt;、&lt;=、&gt;、&gt;=、instanceof 从左向右 7 ==、!= 从左向右 8 &amp; 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 =、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;= 从右向左 使用优先级为 1 的小括号可以改变其他运算符的优先级，即如果需要将具有较低优先级的运算符先运算，则可以使用小括号将该运算符和操作符括起来 二、Java流程控制2.1 Scanner对象java.util.Scanner是Java5的新特征，我们可以通过Scanner类来获取用户的输入。 基本语法： Scanner s = new Scanner(System.in); 通过Scanner类的next()与nextLine()方法获取输入的字符串，在读取前我们一般需要使用hasNext()与hasNextLine()判断是否还有输入的数据 next()： 1、一定要读取到有效字符后才可以结束输入。 2、对输入有效字符之前遇到的空白，next()方法会自动将其去掉 3、只有输入有效字符后才将其后面输入的空白作为分隔符或者结束符。 4、next()不能得到带有空格的字符串。 nextLine()： 1、以Enter为结束符,也就是说nextLine()方法返回的是输入回车之前的所有字符。 2、可以获得空白。 2.2顺序结构Java本身执行代码的结构就是顺序结构，除非特别指明，否则就是按照顺序一句一句执行代码；它是由若干个一次执行的处理步骤组成的，它是任何一个算法都离不开的一种基本算法结构 2.3选择结构2.3.1 if单选择结构if(布尔表达式) &#123; 如果布尔表达式为真，则执行的代码语句 &#125; 2.3.2 if…else双选择结构if(布尔表达式) &#123; 如果布尔表达式为真，则执行的代码语句 &#125; else &#123; 如果布尔表达式为假，则执行的代码语句 &#125; 2.3.3 if…else if…else多选择结构if(布尔表达式1) &#123; 如果布尔表达式1为真，则执行的代码语句 &#125; else if(布尔表达式2) &#123; 如果布尔表达式2为真，则执行的代码语句 &#125; else &#123; 如果上面的布尔表达式都不为真，则执行的代码语句 &#125; //只要有一个else if的布尔表达式为true，就会跳过其余所有的else if和else 2.3.4 嵌套的if选择结构if(布尔表达式1) &#123; 如果布尔表达式1为真，则执行的代码语句 if(布尔表达式2) &#123; 如果布尔表达式2为真，则执行的代码语句 &#125; &#125; //也就是说可以另一个if或者else if里面使用if或else if语句；可以像if语句那样嵌套eles if ...else 2.3.5 Switch多选择结构switch(expression) &#123; case value : //语句 break;//可选 case value : //语句 break;//可选 default : //可选 //语句 &#125; //expression变量类型可以是byte、short、int或者char；从Java SE7开始，switch支持String类型了；同时case标签必须为字符串常量或字面量 2.4 循环结构循环结构分为while循环结构、do…while结构、for循环结构，JDK5中引入了一种主要用于数组的增强型for循环 2.4.1 while循环结构while(布尔表达式) &#123; //需要先判断布尔表达式再执行语句。只要布尔表达式为true，就会一直执行；要使其停止循环需要改变布尔表达式的值 &#125; 2.4.2 do…while循环结构do &#123; //先执行一次循环体语句，再判断布尔表达式 &#125; while(布尔表达式) 2.4.3 for循环结构for循环语句是支持迭代的一种通用结构，是最有效、最灵活的循环结构 for循环执行的次数是在执行前就确定的 for(初始化循环变量; 布尔表达式 ; 更新循环变量) &#123; //代码语句 &#125; //打印九九乘法表 for (int i=1;i&lt;10;i++) &#123; for(int j=1;j&lt;=i;j++) &#123; System.out.print(i+&quot;*&quot;+j+&quot;=&quot;+i*j); System.out.print(&quot; &quot;); &#125; System.out.println(); &#125; //打印三角形 for(int i=1;i&lt;=5;i++) &#123; //打印第i行 for(int j=5;j&gt;=i;j--) &#123; //第i行首先打印j-i+1个空格 System.out.print(&quot; &quot;); &#125; for(int j=1;j&lt;=i;j++) &#123; //第i行再打印一个*号 System.out.print(&quot;*&quot;); &#125; for(int j=1;j&lt;i;j++) &#123; //最后第i行打印i-1个*号 System.out.print(&quot;*&quot;); &#125; System.out.println(); //打印完一行换行 &#125; 2.4.4 增强for循环JDK5引入了一种主要应用于数组的增强for循环 for(声明语句 : 表达式) &#123; //代码语句 &#125; //声明语句:声明新的局部变量，该变量的类型必须和数组元素的类型匹配。其作用域限定在循环语句块，其值与此时数组元素的值相等。 //表达式:表达式是要访问的数组名，或者是返回值为数组的方法。 int[] numbers = &#123;10,20,30,40,50&#125;; for(int x:numbers) &#123; System.out.println(x); &#125; 2.4.5 break、continue、gotobreak：break在任何循环语句的主体部分，均可用break控制循环的流程。break用于强行退出循环，不执行循环中剩余的语句(break语句也在switch语句中使用) continue：continue语句用在循环语句体中，用于终止某次循环过程，即跳过循环体中尚未执行的语句，接着进行下一次是否执行循环的判定 goto： goto关键字很早就在程序设计语言中出现。尽管goto仍是Java的一个保留字，但并未在语言中得到正式使用;Java没有goto。然而，在break和continue这两个关键字的身上，我们仍然能看出一些goto的影子—带标签的break和continue. “标签”是指后面跟一个冒号的标识符，例如: label: 对Java来说唯一用到标签的地方是在循环语句之前。而在循环之前设置标签的唯一理由是:我们希望在其中嵌套另一个循环，由于break和continue关键字通常只中断当前循环，但若随同标签使用，它们就会中断到存在标签的地方 三、Java方法Java方法是语句的集合，它们在一起执行一个功能。 方法是解决一类问题的步骤的有序组合 方法包含于类或对象中 方法在程序中被创建，在其他地方被引用 设计方法的原则:方法的本意是功能块，就是实现某个功能的语句块的集合。我们设计方法的时候，最好保持方法的原子性，就是一个方法只完成1个功能，这样利于我们后期的扩展 3.1 方法的定义和调用3.1.1 方法的定义Java的方法类似于其它语言的函数，是一段用来完成特定功能的代码片段，一般情况下，定义一个方法包含以下语法: 方法包含一个方法头和一个方法体。下面是一个方法的所有部分: 访问修饰符：这是可选的，告诉编译器如何调用该方法。定义了该方法的访问类型 Java中，可以使用访问控制符来保护对类、变量、方法和构造方法的访问。Java 支持 4 种不同的访问权限： default (即默认，什么也不写）: 在同一包内可见，不使用任何修饰符。使用对象：类、接口、变量、方法。 private : 在同一类内可见。使用对象：变量、方法。 注意：不能修饰类（外部类） public : 对所有类可见。使用对象：类、接口、变量、方法 protected : 对同一包内的类和所有子类可见。使用对象：变量、方法。 注意：不能修饰类（外部类） 修饰符 当前类 同一包内 子孙类(同一包) 子孙类(不同包) 其他包 public Y Y Y Y Y protected Y Y Y Y/N N default Y Y Y N N private Y N N N N 返回值类型∶方法可能会返回值。returnValueType是方法返回值的数据类型；有些方法执行所需的操作，但没有返回值，在这种情况下,returnValueType是关键字void 方法名:是方法的实际名称。方法名和参数表共同构成方法签名 参数类型:参数像是一个占位符。当方法被调用时，传递值给参数。这个值被称为实参或变量。参数列表是指方法的参数类型、顺序和参数的个数。参数是可选的，方法可以不包含任何参数 形式参数:在方法被调用时用于接收外界输入的数据 实参:调用方法时实际传给方法的数据 方法体:方法体包含具体的语句，定义该方法的功能。 修饰符 返回值类型 方法名(参数类型 参数名) &#123; ... 方法体 ... return 返回值; &#125; 3.1.2 方法的调用实例方法： 调用方法：无论方法与方法的调用是否在同一个类中,都是先声明定义一个对象,然后通过对象名.方法名（实参列表）进行调用 当方法返回一个值时，方法调用通常被当做一个值 当方法返回为void时，方法调用是一条语句 Test test = new Test(); //方法有返回值时，如下 int max = test.max(10,20); //方法返回void时，如下 test.max(10,20); 类方法（静态方法）： 调用方法：如果方法与方法调用在同一个类中发生，可通过方法名直接调用；如果方法与方法调用没有发生在同一个类中，需要通过类名.方法名（实参列表）进行调用 方法返回值的情况与实例方法相同 class A &#123; public static void test() &#123; //代码块 &#125; test(); //方法和方法调用发生在同一个类中 &#125; class B &#123; A.test(); //方法和方法调用发生在不同类中 &#125; 3.1.3 形参和实参形参 顾名思义:就是形式参数，用于定义方法的时候使用的参数，是用来接收调用者传递的参数的。 形参只有在方法被调用的时候，虚拟机才会分配内存单元，在方法调用结束之后便会释放所分配的内存单元。 因此,形参只在方法内部有效，所以针对引用对象的改动也无法影响到方法外 实参 顾名思义:就是实际参数，用于调用时传递给方法的参数。实参在传递给别的方法之前是要被预先赋值的 Tips：在 值传递调用过程中，只能把实参的值传递给形参，而不能把形参的值反向作用到实参上。在函数调用过程中，形参的值发生改变，而实参的值不会发生改变 在 引用传递调用的机制中，实际上是将实参引用的地址传递给了形参，所以任何发生在形参上的改变也会发生在实参变量上 值传递和引用传递又是什么呢？参考3.1.4 3.1.4 值传递和引用传递(重点\\难点)参考链接: https://blog.csdn.net/qq_40574571/article/details/90765349 https://www.cnblogs.com/zhangshiwen/p/5830062.html 值传递是对基本型变量而言的,传递的是该变量的一个副本,改变副本不影响原变量 引用传递一般是对于对象型变量而言的,传递的是该对象地址的一个副本, 并不是原对象本身 一般认为,java内的基础类型数据传递都是值传递. java中实例对象的传递是引用传递 值传递： 指的是在方法的调用中，传递的参数是按照值的拷贝传递 特点：传递的是值的拷贝，传递后就互不相关了image-20210722170825089 引用传递： 指的是在方法调用时，传递的参数是按引用进行传递，其实传递的是引用的地址，也就是变量所对应的内存空间的地址。 特点：传递的是参数的引用值，也就是传递前和传递后都指向同一个引用（即同一个内存空间） image-20210722172443947 Tips： “在Java里面参数传递都是按值传递”这句话的意思是：按值传递是传递的值的拷贝，按引用传递其实传递的是引用的地址值，所以统称按值传递 在Java里面只有基本类型和按照直接使用双引号定义字符串方式：String str = “Java私塾”这种定义方式的String是按值传递，其它的都是按引用传递 image-20210711171056907 3.2 方法的重载重载就是在一个类中，有相同的函数名称，但形参不同的函数 方法的重载的规则: 方法名称必须相同 参数列表必须不同(个数不同、或类型不同、参数排列顺序不同等) 方法的返回类型可以相同也可以不相同 仅仅返回类型不同不足以成为方法的重载 实现理论: 方法名称相同时，编译器会根据调用方法的参数个数、参数类型等去逐个匹配，以选择对应的方法，如果匹配失败，则编译器报错。 3.3 命令行传递参数在控制台的命令行进行编译.java文件时传参 public class Test &#123; public static void main(String[] args) for(int i = 0; i &lt; args.length; i++) &#123; System.out.println(&quot;args[&quot; + i + &quot;]:&quot; + args[i]); &#125; &#125; //如果在命令行编译成功后输入命令：java Test this is test //则运行程序时命令行会输出：args[0]:this args[1]:is args[2]:test 3.4 可变参数JDK5开始，Java支持传递同类型的可变参数给一个方法 在方法声明中，在指定参数类型后加一个省略号(…) 一个方法只能制定一个可变参数，它必须是方法的最后一个参数。任何参数必须在它之前声明 test(1,3,4); //可以随意传n个参数 test(new Double[]&#123;1,2,3&#125;); public void test(double... numbers) &#123; //方法体 &#125; 3.4 递归tips：深度较大的时候运行速度太慢，方便程序员，劳累电脑 递归就是:A方法调用A方法!就是自己调用自己 利用递归可以用简单的程序来解决一些复杂的问题。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的程序就可描述出解题过程所需要的多次重复计算，大大地减少了程序的代码量。递归的能力在于用有限的语句来定义对象的无限集合 递归结构包括两个部分: 递归头:什么时候不调用自身方法。如果没有头，将陷入死循环 递归体:什么时候需要调用自身方法 //计算阶乘 public static void main(String[] args) &#123; System.out.println(test(5)); &#125; public static int test(int i) &#123; if(i == 1) &#123; return 1; //递归头（尽头） &#125; else &#123; return i*test(i-1); &#125; &#125; 如图： image-20210711182627099 四、Java数组数组是相同类型数据的有序集合 数组描述的是相同类型的若干个数据,按照一定的先后次序排列组合而成 其中,每一个数据称作一个数组元素,每个数组元素可以通过一个下标来访问它们 4.1 数组的声明创建首先必须先声明数组变量，才能在程序中使用数组 dataType[] arrayRefVar; //首选方法 dataType arrayRefVar[]; //效果相同，但不是首选方法 //Java使用new操作符来创建数组 dataType[] arrayRefVar = new dataType[arraySize]; 数组元素通过索引访问，数组索引从0开始 获取数组长度：arrays.length image-20210712112802160 4.2 Java内存分析及三种初始化4.2.1 Java内存分析image-20210712113429404 先申请再创建 image-20210712113741570 4.2.2 三种初始化方式静态初始化 int[] a = &#123;1,2,3&#125;; Man[] mans = &#123;new Man(1,1),new Man(2,2)&#125;; 动态初始化（包括默认初始化） int[] a = new int[2]; a[0] = 1; a[1] = 2; 数组的默认初始化 数组是引用类型，它的元素相当于类的实例变量，因此数组一经分配空间，其中的每个元素也被按照实例变量同样的方式被隐式初始化（比如int类型的默认值都为0） 4.2.3 下标越界问题数组的四个基本特点 其长度是确定的。数组一旦被创建，它的大小就是不可以改变的 其元素必须是相同类型,不允许出现混合类型 数组中的元素可以是任何数据类型，包括基本类型和引用类型 数组变量属引用类型，数组也可以看成是对象，数组中的每个元素相当于该对象的成员变量。数组本身就是对象，Java中对象是在堆中的，因此数组无论保存原始类型还是其他对象类型，数组对象本身是在堆中的 若对数组下标的操作超过数组声明创建时的下标，就会出现下标越界问题，报ArrayIndexOutOfBounds异常 4.3 数组的使用for-each循环 int[] arrays = &#123;1,2,3,4,5&#125;; for (int array : arrays) &#123; //执行语句 &#125; 数组作方法入参 public static void printArray(int[] arrays) &#123; //执行语句 &#125; 数组作返回值 //反转数组 public static void main(String[] args) &#123; int[] arrays = &#123;1,2,3,4,5&#125;; for (int array : arrays) &#123; System.out.print(array + &quot; &quot;); &#125; System.out.println(); int[] results = reverse(arrays); for (int result : results) &#123; System.out.print(result + &quot; &quot;); &#125; &#125; public static int[] reverse(int[] arrays) &#123; int[] result = new int[arrays.length]; for (int i = 0; i &lt; arrays.length; i++) &#123; result[i] = arrays[arrays.length-1-i]; &#125; return result; &#125; 4.4 多维数组多维数组可以看成是数组的数组，比如二维数组是一个特殊的一维数组，其每一个元素都是一个一维数组 如，二维数组：int[][] a = new int[2][5]; 可以看成一个二行五列的数组 image-20210712140511164 二维数组的arrays.length输出的是第一层数组的长度，比如new int[2][5]的长度就是2；如果要得到第二层数组的长度，应表示为arrays[0].length 4.5 Arrays工具类由于数组对象本身并没有什么方法可以供我们调用,但API中提供了一个数组的工具类java.util.Arrays供我们使用,从而可以对数据对象进行一些基本的操作（查看JDK帮助文档） Arrays类中的方法都是static修饰的静态方法,在使用的时候可以直接使用类名进行调用,而”不用”使用对象来调用(注意:是”不用”而不是”不能”) Arrays类具有以下常用功能: 给数组赋值:通过fill方法 对数组排序:通过sort方法,按升序 比较数组:通过equals 方法比较数组中元素值是否相等 查找数组元素:通过binarySearch方法能对排序好的数组进行二分查找法操作 输出数组信息：toString方法 4.6 数组排序冒泡排序是最出名的排序算法之一，总共八大排序方法。即直接插入排序、希尔排序、简单选择排序、堆排序、冒泡排序、快速排序、归并排序、桶排序/基数排序 冒泡排序： 比较数组中，两个相邻的元素，如果第一个数比第二个数大，我们就交换他们的位置 每一次比较，都会产生出一个最大，或者最小的数字 下一轮则可以少一次排序 依次循环，直到结束 //冒泡排序 for(int n=1;n&lt;a.length;n++) &#123; //第n轮排序 for(int i=0;i&lt;a.length-n;i++) &#123; //调换位置，i&lt;a.length-n是因为每次比较后都会产出一个最大或最小的数，那么下一次就不用再比较它 if(a[i]&gt;a[i+1]) &#123; int temp=a[i]; a[i]=a[i+1]; a[i+1]=temp; &#125; &#125; &#125; 选择排序： 选择数组中第i+1个数，依次与其后面的数进行比较，若比后面的数大就调换位置，这样每次都会将这轮比较最小的数放在最前面 //选择排序 for(int i=0;i&lt;a.length;i++) &#123; //第i+1轮排序 for(int j=i+1;j&lt;a.length;j++) &#123; //调换位置 if(a[j]&lt;a[i]) &#123; int temp=a[i]; a[i]=a[j]; a[j]=temp; &#125; &#125; &#125; 4.7 稀疏数组image-20210712152206816 例子： private static int sum = 0; //统计原始数组中有多少个非0数 private static int[][] primary; //声明定义原始数组 private static int[][] sparse; //声明定义稀疏数组 private static int[][] recover; //声明定义恢复数组 public static void main(String[] args) &#123; CreateArrays(); CreateSparse(); RecoverArrays(); &#125; //创建一个原始数组 public static void CreateArrays() &#123; primary = new int[6][6]; primary[0][3] = 2; primary[1][1] = 3; primary[3][5] = 5; primary[5][3] = 1; System.out.println(&quot;输出原始数组：&quot;); for (int[] ints : primary) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); if(anInt != 0) &#123; sum++; //非0数个数加1 &#125; &#125; System.out.println(); &#125; System.out.println(&quot;================&quot;); &#125; //创建稀疏数组存储原始数组的数据 public static void CreateSparse() &#123; int count = 0; //由于稀疏数组中一行存储的是原始数组中非0数的行、列、值，所以需要用到一个count来决定非0数存储在稀疏数组的第几行 sparse = new int[sum+1][3]; sparse[0][0] = primary.length; //存放primary的行数 sparse[0][1] = primary[0].length; //存放primary的列数 sparse[0][2] = sum; //存放primary中非0数的个数 for (int i = 0; i &lt; primary.length; i++) &#123; for (int j = 0; j &lt; primary[i].length; j++) &#123; if (primary[i][j] != 0) &#123; //循环遍历primary数组，将非0数的所在行列和值保存在sparse中 count++; sparse[count][0] = i; sparse[count][1] = j; sparse[count][2] = primary[i][j]; &#125; &#125; &#125; System.out.println(&quot;输出稀疏数组：&quot;); System.out.println(&quot;行&quot; + &quot;\\t&quot; + &quot;列&quot; + &quot;\\t&quot; + &quot;值&quot; + &quot;\\t&quot;); for (int[] ints : sparse) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; System.out.println(&quot;================&quot;); &#125; //通过稀疏数组恢复原始数组 public static void RecoverArrays() &#123; recover = new int[sparse[0][0]][sparse[0][1]]; //还原数组的行数等于稀疏数组的第一行第一列的数，列数等于稀疏数组第一行第二列的数 for (int i = 1; i &lt; sparse.length; i++) &#123; recover[sparse[i][0]][sparse[i][1]] = sparse[i][2]; //遍历稀疏数组，通过获取到的行列和数将其填充到到还原数组中 &#125; System.out.println(&quot;输出还原数组：&quot;); for (int[] ints : recover) &#123; for (int anInt : ints) &#123; System.out.print(anInt + &quot;\\t&quot;); &#125; System.out.println(); &#125; &#125; 五、Java面向对象5.1 什么是面向对象（面试：面向过程和面向对象的区别） 面向过程思想（线性思维）： 步骤清晰简单，第一步做什么，第二步做什么…… 面向过程适合处理一些较为简单的问题 面向对象思想： 物以类聚，分类的思维模式，思考问题首先会解决问题需要哪些分类，然后对这些分类进行单独思考。最后，才对某个分类下的细节进行面向过程的思索 面向对象适合处理复杂的问题，适合处理需要多人协作的问题 对于复杂的事物，从宏观上，从整体上合理分析，需要用到面向对象的思维进行分析；具体到微观的操作上，又需要面向过程的思路去处理 面向对象编程（oop）的本质：以类的方式组织代码，以对象的方式组织（封装）数据 三大特性：封装、继承、多态 从认识论角度考虑是先有对象后有类。对象，是具体的事物。类，是抽象的，是对对象的抽象 从代码运行角度考虑是先有类后有对象。类是对象的模板 5.2 方法回顾和加深image-20210712210504188 方法的调用和参数传递见3.1.2和3.1.3 静态方法在类加载时随类一起加载，而非静态方法只有在类被实例化之后才存在 5.3 对象的创建分析5.3.1 类与对象的关系类是一种抽象的数据类型，它是对某一类事物整体描述/定义，但是并不能代表某一个具体的事物 对象就是抽象概念的具体化实例 5.3.2 创建对象使用new关键字创建对象 使用new关键字创建的时候，除了分配内存空间之外，还会给创建好的对象进行默认的初始化以及对类中构造器的调用。 类中的构造器也称为构造方法，是在进行创建对象的时候必须要调用的。并且构造器有以下俩个特点: 必须和类的名字相同 必须没有返回类型,也不能写void 构造器必须要掌握 5.3.3 构造器（构造方法）每个类即使没有显式的写出构造方法，Java也会给类写一个默认的构造方法 使用new关键字创建对象的本质是在调用构造器 构造器分为无参构造器和有参构造器，一旦定义了有参构造器，就必须显式的定义无参构造器 构造器的作用是初始化对象的属性 5.3.4 创建对象内存分析参考链接：https://baijiahao.baidu.com/s?id=1637836912223474691&amp;wfr=spider&amp;for=pc JVM内存结构： 虚拟机栈：即平时提到的栈结构，我们将局部变量存储在栈结构中（对于main方法来说，对象引用就是一个局部变量，所以会存储在栈中） 堆：我们将new出来的对象结构（比如，数组、对象）加载在堆空间中。对象的非static属性存储在堆空间 方法区：存储类的加载信息、常量池、静态域 //实例 public class Application &#123; public static void main(String[] args)&#123; Pet dog = new Pet(); dog.name = &quot;旺财&quot;; dog.age = 3; dog.shout(); &#125; &#125; public class Pet &#123; public String name; public int age; public void shout() &#123; System.out.println(&quot;叫了一声&quot;); &#125; &#125; image-20210713105310543 tip：JDK1.8方法区叫做元数据区，方法区（non-heap，非堆）不是在堆中（画图有误） 什么是引用类型：除了8大基本类型都可以叫做引用类型，对象是通过引用来操作的 new的实例对象存放在堆中，而我们操作的是存放在栈中的对象引用，其值就是实例对象在堆中的地址 5.4 面向对象三大特性5.4.1 封装该露的露，该藏的藏；我们的设计要追求“高内聚，低耦合”；高内聚就是类的内部数据操作细节由自己完成，不允许外部干涉；低耦合就是仅暴露少量的方法给外部使用 封装（数据的隐藏）：通常，应禁止直接访问一个对象中数据的实际表示，而应通过操作接口来访问，这称为信息隐藏；记住：属性私有，get/set public class Student &#123; private String name; private int age; private char sex; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public char getSex() &#123; return sex; &#125; public void setSex(char sex) &#123; this.sex = sex; &#125; &#125; 5.4.2 继承参考链接：https://blog.csdn.net/hxhaaj/article/details/81174764 1.概述及特点： 继承关系的俩个类，一个为子类(派生类),一个为父类(超类)。 子类继承父类,使用关键字extends来表示；extends的意思是“扩展”，子类是父类的扩展； 子类和父类之间,从意义上讲应该具有”is a”的关系 继承是从已有类中派生出新的类，新的类能吸收已有类的属性和方法，并且能拓展新的属性和行为 子类继承父类，表明子类是一种特殊的父类，子类拥有父类的属性和方法，并且子类可以拓展具有父类所没有的一些属性和方法 子类即是不扩展父类，也能维持拥有父类的操作 Java类只有单继承，没有多继承，但支持多重继承（单继承，多实现，多重继承，即一个子类只能有一个父类，一个父类可以有多个子类，一个子类又可以被一个孙类继承） 继承是类和类之间的一种关系。除此之外,类和类之间的关系还有依赖、组合、聚合等 object类是所有类的父类，在Java中即使一个类没有显式继承一个类，但也默认继承了Object类 final类不能被继承 2.继承的特性： 成员变量和方法： 子类拥有父类非 private 的属性、方法，但是可以通过父类提供的public的setter方法和getter方法进行间接地访问和操作private属性 子类不能继承父类的静态方法和属性，因为静态的方法和属性是属于类本身的，但子类可以访问父类的静态方法和属性 子类可以拥有自己的属性和方法，即子类可以对父类进行扩展 子类可以用自己的方式实现父类的方法（方法重写），但子类和父类中同名的static变量和方法都是相互独立的，并不存在任何的重写的关系 对于子类可以继承父类中的成员变量和成员方法，如果子类中出现了和父类同名的成员变量和成员方法时，父类的成员变量会被隐藏，父类的成员方法会被覆盖。需要使用父类的成员变量和方法时，就需要使用super关键字来进行引用（隐藏是针对成员变量和静态方法，覆盖是针对普通方法） 父类严格上来说不能调用子类的方法和成员变量，但可以从以下几种方法进行考虑： 在父类中直接new子类相关对象或者通过构造函数传入子类对象，然后调用其方法 将子类相关方法声明为static，在父类中调用子类的static方法 在父类中通过反射调用子类的相关方法 通过注册监听，然后通过回调接口调用子类相关方法 相关链接：https://www.jianshu.com/p/204e5d76ec11 当创建一个子类对象时，即使子类定义了与父类中同名的实例变量，不仅会为该类的实例变量分配内存，也会为它从父类继承得到的所有实例变量分配内存。 即依然会为父类中定义的、被隐藏的变量分配内存 如果子类中的实例变量被私有了 ，其父类中的同名实例变量没有被私有，那么子类对象就无法直接调用该变量（子类中的），但可以通过先将对象变量强制向上转型为父类型，在通过该对象引用变量来访问那个实例变量，就会得到的是父类中的那个实例变量 构造器： 子类不能继承获得父类的构造方法，但是可以通过super关键字来访问父类构造方法 在一个构造器中调用另一个重载构造器使用this调用完成，在子类构造器中调用父类构造器使用super调用来完成 super 和 this 的调用都必须是在第一句，否则会产生编译错误，this和super只能存在一个 不能进行递归构造器调用，即多个构造器之间互相循环调用。 如果父类有无参构造时，所有构造方法（包含任意有参构造）自动默认都会访问父类中的空参构造方法（自带super();） 因为继承的目的是子类获取和使用父类的属性和行为，所以子类初始化之前，一定要先完成父类数据的初始化 在Java中，每个类都会默认继承Object超类，所以每一个构造方法的第一条默认语句都是super() 如果父类没有无参构造，反而有其他的有参构造方法时，子类继承父类后，子类必须显式的创建构造器，不论子类的构造器是否和父类构造器中参数类型是否一致，都必须在子类的构造器中显式的通过super关键字调用和父类构造器相应参数的构造方法。否则编译都通不过；也可以使用this先调用子类中的构造方法，再间接调用父类中的有参构造方法 结论：当父类中没有无参构造器时，子类继承父类，子类中的构造器方法类型可以和父类中的构造器不同，但是必须每个构造器都显式的使用super关键字调用父类中的某个有参构造器，也可以使用this调用子类中的某个有参构造器，但这个有参构造器必须通过super访问父类中的有参构造器 super关键字： super用于限定该对象调用它从父类继承得到的实例变量或方法 super和this相同，都不能出现在静态方法中，因为静态方法属于类的，调用静态方法的可能是个类，而不是对象，而super和this都是限定对象调用 super同样也可以在子类中调用父类中被子类隐藏和覆盖的同名实例变量和同名方法 在构造器中使用super，则super会用于限定于该构造器初始化的是该对象从父类继承得到的实例变量，而不是该类自己定义的实例变量。意思就是调用父类的构造器 super限定：super后紧跟一个点，super.name，super.walk() super调用：super后紧跟圆括号，super(无参或有参); this关键字： this关键字指向的是当前对象的引用 this.属性名称指的是访问类中的成员变量，用来区分成员变量和局部变量 this.方法名称用来访问本类的成员方法 this();访问本类的构造方法 this关键字把当前对象传递给其他方法method(this); 当需要返回当前对象的引用时，常常使用return this; 继承的代码执行顺序问题： 构造器执行顺序 当调用子类构造器实例化子类对象时，父类构造器总是在子类构造器之前执行 创建任何对象总是从该类所在继承树最顶层类的构造器开始执行，然后依次向下执行，最后才执行本类的构造器。如果父类通过this调用了同类中的重载构造器，就会依次执行此父类的多个构造器 静态域执行顺序 当调用子类构造器实例化子类对象时，父类优先于子类进行加载到内存，所以会先执行父类中的静态域 从该类所在继承树最顶层类开始加载，并执行其静态域，依次向下执行，最后执行本类。 静态域优先于main方法，优先于构造器执行 3.方法重写前提：需要有继承关系，子类重写父类的方法 方法重写规则： 两同： 方法名、形参列表相同 两小： 子类方法返回值类型应比父类方法返回值类型更小或相等 子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等 一大：子类方法的访问权限应比父类方法访问权限更大或相等 方法重写Tips： 父类中的私有方法不能被重写，该方法对于子类是隐藏的，因此其子类无法访问该方法，也无法重写 父类静态方法，子类也必须通过静态方法进行覆盖，即静态只能覆盖静态 子类重写父类方法时，最好声明得一模一样 如果子类中定义了一个与父类private方法具有相同的方法名、相同的形参列表、相同的返回值类型的方法，依然不是重写，只是在子类中重新定义了一个新的方法，所以该新方法不会受父类方法的任何限制 static方法（属于类，不属于实例）、final方法（常量）、private方法不能被重写 重写静态方法：方法的调用只和左边定义的引用相关 class A &#123; private static void test() &#123; System.out.println(&quot;A=&gt;test&quot;); &#125; &#125; class B extends A &#123; private static void test() &#123; System.out.println(&quot;B=&gt;test&quot;); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; B b = new B(); b.test(); //输出B=&gt;test A a = new B(); //向上转型，a引用指向B对象 a.test(); //输出A=&gt;test &#125; &#125; 重写非静态方法：方法的调用需要看左边的引用指向new的哪个对象 class A &#123; public void test() &#123; System.out.println(&quot;A=&gt;test&quot;); &#125; &#125; class B extends A &#123; public void test() &#123; System.out.println(&quot;B=&gt;test&quot;); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; B b = new B(); b.test(); //输出B=&gt;test A a = new B(); //向上转型，a引用指向B对象 a.test(); //输出B=&gt;test &#125; &#125; 方法重写和方法重载： Override 和 Overload 的区别？Overload能改变返回值类型吗？ Override是重写，Overload是重载。重载可以改变返回值类型，它是方法名相同，参数列表不同，与返回值类型无关 方法重写：子类中出现和父类中方法声明一模一样的方法。返回值类型相同（或者是子父类，多态），方法名和参数列表一模一样。主要发生在子类和父类的同名方法之间 方法重载：本类中出现方法名相同，参数列表不同的方法，和返回值类型无关，可以改变。主要发生同一类的多个同名方法之间 子类对象调用方法时，先找子类本身的方法，再找父类中的方法 5.4.3 多态1.相关规则及概念多态即同一方法可以根据发送对象的不同而采用多种不同的行为方式。一个对象的实际类型是确定的，但可以指向对象的引用的类型有很多 多态存在的条件 有继承关系 子类重写父类方法父类引用指向子类对象 注意:多态是方法的多态，属性没有多态性。 public class Person &#123; public void run() &#123; System.out.println(&quot;Person&quot;); &#125; &#125; public class Student extends Person &#123; public void run() &#123; System.out.println(&quot;Student&quot;); &#125; public void eat() &#123; System.out.println(&quot;Student eat&quot;); &#125; &#125; public class Test &#123; public static void main(String[] args) &#123; //一个对象的实际类型是确定的 //new Person() //new Student(); //可以指向的引用类型就不确定了：自身类的引用指向自身，父类的引用指向子类 Student s1 = new Student(); //能调用的都是自己扩展的和继承父类的方法 Person s2 = new Student(); //父类引用指向子类对象，不能调用子类自身扩展的，只能调用子类重写的实例方法 Object s3 = new Student(); s1.run(); //输出Student。因为子类重写了父类的方法 s2.run(); //当子类中没有任何方法时，会输出Person，因为子类继承了父类的run方法 //当子类中重写了父类方法，会输出Student，因为Person类引用s2指向Student的对象，则会执行Student中的run方法 s2.eat(); //这个写法是错误的，因为引用s2是作为Student对象的向上转型，不能调用子类Student自身扩展的方法 //如果要调用eat()方法，需要将s2转换成Student引用类型(向下转型)，即((Student)s2).eat(),此时才能调用eat()方法 &#125; &#125; 2.向上转型和向下转型： 向上转型：子类对象转为父类，父类可以是接口；注意：向上转型不要强制转型。向上转型后父类的引用所指向的属性是父类的属性，如果子类重写了父类的方法，那么父类引用指向的或者调用的方法是子类的方法,这个叫动态绑定。向上转型后父类引用不能调用子类自身扩展的方法，如果调用不能编译通过 public class Human &#123; public void sleep() &#123; System.out.println(&quot;Human sleep..&quot;); &#125; public static void main(String[] args) &#123; Human h = new Male();// 向上转型 h.sleep(); Male m = new Male(); m.sleep();// h.speak();此方法不能编译，报错说Human类没有此方法 &#125; &#125; class Male extends Human &#123; @Override public void sleep() &#123; System.out.println(&quot;Male sleep..&quot;); &#125; public void speak() &#123; System.out.println(&quot;I am Male&quot;); &#125; &#125; 向下转型：父类对象转为子类，需要进行强制转换; 向下转型需要考虑安全性，如果父类引用的对象是父类本身，那么在向下转型的过程中是不安全的，编译不会出错，但是运行时会出现java.lang.ClassCastException错误。它可以使用instanceof来避免出错此类错误即能否向下转型，只有先经过向上转型的对象才能继续向下转型 没有继承关系的两个类，互相转换，一定会失败 3.instanceofboolean result = obj instanceof Class 其中 obj 为一个对象，Class 表示一个类或者一个接口；当 obj 为 Class 的对象，或者是其直接或间接子类的对象，或者是其接口的实现类的对象，结果result 都返回 true，否则返回false。（说明Class只有大于等于obj时为true） 注意： 编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能确定类型，则通过编译，具体看运行时定 如果obj为null，那么则返回false 在编译状态中，Class可以是obj对象的父类，自身类，子类。在这三种情况下Java编译时不会报错。 在运行转态中，Class可以是obj对象的父类，自身类，不能是子类(class小于了obj)。在前两种情况下result的结果为true，最后一种为false。但是class为子类时编译不会报错。运行结果为false。 （大致就是判断表达式：class 变量=(class)object的引用 是否成立） 5.5 static和final关键字及代码块5.5.1 static关键字详解static关键字的使用： static：静态的 static可以用来修饰：属性、方法、代码块、内部类 使用static修饰属性：静态变量(或类变量) 实例变量：我们创建了类的多个对象，每个对象都独立的拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改 静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的 static修饰属性的其他说明: ①静态变量随着类的加载而加载。可以通过类.静态变量的方式进行调用 ②静态变量的加载要早于对象的创建 ③由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中 类变量 实例变量 类 yes no 对象 yes yes ​ 4.使用static修饰方法：静态方法 ​ 随着类的加载而加载，可以通过类.静态方法的方式进行调用 ​ 静态方法中，只能调用静态的方法或属性；非静态方法中，既可以调用非静态的方法或属性，也可以调用静态的方法或属性 类方法 实例方法 类 yes no 对象 yes yes ​ 5.static注意点：在静态的方法内，不能使用this关键字、super关键字 //静态导入包 import static java.lang.Math.random; import static java.lang.Math.PI; //此时random和PI可以直接使用 5.5.2 final关键字详解final关键字的使用： final：最终的 final修饰一个类：此类不能被继承，比如String类，System类，StringBuffer类 final修饰方法：表明该方法不能被重写，比如Object类中的getClass方法 final修饰变量：此时的“变量”就是一个常量 1 final修饰属性：赋值的位置：显示初始化、代码块中初始化、构造器中初始化 2 final修饰局部变量：尤其是使用final修饰形参时，表明此形参是一个常量。当我们调用此方法时，给常量形参赋一个实参。一旦赋值以后，就只能在方法体内使用此形参，但不能进行重新赋值 static final修饰一个属性：表示它是一个全局常量 //面试题：排错 //1 public class Something &#123; public int add0ne(final int x) &#123; return ++X; //错误，因为返回X前对它进行了改变 //return X + 1; //可以编译通过，因为X没有变化，只是返回的是X加1后的值 &#125; &#125; //2 public class Something &#123; public static void main(String[] args) &#123; Other o = new Other(); new Something().add0ne(o); &#125; public void add0ne(final 0ther o) &#123; //o = new other(); //错误，因为传入的引用被final修饰，所以不能被改变 o.i++; //正确，引用o没变，只是改变其中的变量 &#125; &#125; class Other &#123; public int i; &#125; 5.5.3 代码块代码块的作用：用来初始化类、对象 代码块如果有修饰的话，只能使用static 分类：静态代码块、非静态代码块 静态代码块 内部可以有输出语句 随着类的加载而执行,而且只执行一次 作用：初始化类的信息 如果类中声明了多个静态代码块，则按声明的先后顺序执行 静态代码块优先于非静态代码块执行 不能调用非静态属性和方法，只能调用静态属性和方法 非静态代码块 内部可以有输出语句 随着对象的创建而执行 每创建一个对象，就执行一次非静态代码块 作用：可以在创建对象时，对对象的属性等进行初始化 如果类中声明了多个非静态代码块，则按声明的先后顺序执行 既可以调用静态属性和方法，又可以调用非静态属性和方法 类加载的执行顺序：静态代码块&gt;匿名代码块&gt;构造器 public static void main(String[] args) &#123; new Leaf(); &#125; class Root &#123; static &#123; System.out.println(&quot;Root的静态代码块&quot;); &#125; &#123; System.out.println(&quot;Root的普通代码块&quot;); &#125; public Root() &#123; super(); System.out.println(&quot;Root的无参构造器&quot;); &#125; &#125; class Mid extends Root&#123; static &#123; System.out.println(&quot;Mid的静态代码块&quot;); &#125; &#123; System.out.println(&quot;Mid的普通代码块&quot;); &#125; public Mid() &#123; super(); System.out.println(&quot;Mid的无参构造器&quot;); &#125; &#125; class Leaf extends Mid &#123; static &#123; System.out.println(&quot;Leaf的静态代码块&quot;); &#125; &#123; System.out.println(&quot;Leaf的普通代码块&quot;); &#125; public Leaf() &#123; super(); System.out.println(&quot;Leaf的无参构造器&quot;); &#125; &#125; /*输出为：Root的静态代码块 Mid的静态代码块 Leaf的静态代码块 Root的普通代码块 Root的无参构造器 Mid的普通代码块 Mid的无参构造器 Leaf的普通代码块 Leaf的无参构造器*/ 5.6 抽象类和接口5.6.1 抽象类abstract修饰符可以用来修饰方法也可以修饰类,如果修饰方法,那么该方法就是抽象方法;如果修饰类,那么该类就是抽象类 抽象类中可以没有抽象方法,但是有抽象方法的类一定要声明为抽象类 抽象类,不能使用new关键字来创建对象,它是用来让子类继承的（所以抽象类一定有构造器） 抽象方法,只有方法的声明,没有方法的实现,它是用来让子类实现的 子类继承抽象类,那么就必须要实现抽象类没有实现的抽象方法,否则该子类也要声明为抽象类 1.抽象类的匿名子类对象abstract class Person &#123; public abstract void eat(); &#125; class Worker extends Person &#123; @Override public void eat() &#123; &#125; &#125; public static void main(String[] args) &#123; method(new Worker());//1.非匿名类的匿名对象 Worker worker = new Worker();//2.非匿名类的非匿名对象 //3.创建抽象类匿名子类的非匿名对象 Person person = new Person() &#123; @Override public void eat() &#123; &#125; &#125;; method1(person); //4.抽象类匿名子类的匿名对象 method1(new Person()&#123; @Override public void eat() &#123; &#125; &#125;); &#125; public static void method(Worker worker)&#123; &#125; public static void method1(Person person)&#123; &#125; 2.模板方法设计模式抽象类体现的就是一种模板模式的设计，抽象类作为多个子类的通用模板，子类在抽象类的基础上进行扩展、改造，但子类总体上会保留抽象类的行为方式 解决的问题： 当功能内部一部分实现是确定的，一部分实现是不确定的。这时可以把不确定的部分暴露出去，让子类去实现 换句话说，在软件开发中实现一个算法时，整体步骤很固定、通用，这些步骤已经在父类中写好了。但是某些部分易变，易变部分可以抽象出来，供不同子类实现。这就是一种模板模式 public static void main(String[] args) &#123; SubTemplate t = new SubTemplate(); t.spendTime(); &#125; abstract class Templatet &#123; //计算某段代码执行所需要花费的时间 public void spendTime()&#123; long start = System. currentTimeMillis(); this.code();//不确定的部分、易变的部分 long end = System.currentTimeMillis(); System.out.println(&quot;花费的时间为:&quot;+ (end - start)); &#125; public abstract void code(); &#125; class SubTemplate extends Template&#123; @Override public void code() &#123; //要执行的代码 &#125; &#125; 5.6.2 接口普通类:只有具体实现 抽象类:具体实现和规范(抽象方法)都有 接口:只有规范，没有构造器，意味着不能被实例化 接口就是规范，定义的是一组规则。接口的本质是契约，就像我们人类的法律一样。制定好后大家都遵守 声明类的关键字是class,声明接口的关键字是interface OO的精髓，是对对象的抽象，最能体现这一点的就是接口。为什么我们讨论设计模式都只针对具备了抽象能力的语言（比如c++、java、c#等)，就是因为设计模式所研究的，实际上就是如何合理的去抽象 Tips： 接口中的方法定义都是public abstract，书写时可以省略 接口中的属性都是常量，public static final修饰的，书写时可以省略 实现接口（implements）的类必须重写接口中的所有方法，否则这个实现类还是一个抽象类 接口的实现允许多实现（弥补类不能多继承的局限性，格式class A extends B implements C,D） 接口之间可以继承，而且可以多继承 接口的具体使用，体现出多态性 JDK7及以前接口中只能定义全局常量和抽象方法；JDK8及之后还可以定义静态方法和默认方法 1.Java8中接口的新特性//首先定义一个接口 public interface CompareA &#123; //静态方法 public static void method1() &#123; System.out.println(&quot;CompareA:method1&quot;); &#125; //默认方法 public default void method2() &#123; System.out.println(&quot;CompareA:method2&quot;); &#125; public default void method3() &#123; System.out.println(&quot;CompareA:method3&quot;); &#125; &#125; 1.接口中的静态方法只能通过接口名.静态方法进行调用 2.接口中的默认方法可以通过实现类的对象进行调用，如果实现类重写了这个默认方法，那么调用的还是重写后的方法 public class SubClassTest &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); CompareA.method1(); //输出=&gt;CompareA:method1，1.接口中的静态方法只能通过`接口名.静态方法`进行调用 s.method2();//输出=&gt;CompareA:method2，2.接口中的默认方法可以通过实现类的对象进行调用 s.method3();//输出=&gt;SubClass:method3，2.如果实现类重写了这个默认方法，那么调用的还是重写后的方法 &#125; &#125; class SubClass implements CompareA&#123; @Override public void method3() &#123; System.out.println(&quot;SubClass:method3&quot;); &#125; &#125; 3.如果在子类(或实现类)继承的父类和实现的接口中声明了同名同参数的默认方法，那么子类在没有重写此方法的情况下，默认调用的是父类中的同名同参数的方法—&gt;类优先原则 public class SubClassTest &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); s.method2();//输出=&gt;SuperClass:method2， 3.类优先原则 &#125; &#125; class SubClass extends SuperClass implements CompareA &#123; &#125; class SuperClass &#123; public void method2() &#123; System.out.println(&quot;SuperClass:method2&quot;); &#125; &#125; 4.如果实现类实现了多个接口，而这多个接口中定义了同名同参数的默认方法，那么在实现类没有重写此方法的情况下，出现报错 —&gt;接口冲突。这就需要我们必须在实现类中重写此方法 public class SubClassTest &#123; public static void main(String[] args) &#123; SubClass s = new SubClass(); s.method2();//编译出错 4.接口冲突，需要我们必须在实现类中重写此方法 &#125; &#125; public interface CompareB &#123; //默认方法 public default void method2() &#123; System.out.println(&quot;CompareB:method2&quot;); &#125; &#125; class SubClass implements CompareA,CompareB &#123; &#125; 5.在子类 （或实现类）的方法中调用父类中被重写的方法使用super.方法名，调用接口中被重写的方法使用接口名.super.方法名 class SubClass extends SuperClass implements CompareA &#123; public void method2() &#123; System.out.println(&quot;SubClass:method2&quot;); &#125; public void MyMethod() &#123; method2(); //在自己的方法中调用自己重写的方法 super.method2();//在自己的方法中调用父类中被重写的方法使用super.方法名 CompareA.super.method2();//在自己的方法中调用接口中被重写的方法使用接口名.super.方法名 &#125; &#125; class SuperClass &#123; public void method2() &#123; System.out.println(&quot;SuperClass:method2&quot;); &#125; &#125; 2.接口应用实例：代理模式代理模式是Java开发中使用较多的一种设计模式。代理设计就是为其他对象提供一种代理以控制对这个对象的访问 应用场景： 安全代理：屏蔽对真实角色的直接访问 远程代理：通过代理类处理远程方法调用( RMI) 延迟加载：先加载轻量级的代理对象，真正需要再加载真实对象 分类： 静态代理(静态定义代理类) 动态代理(动态生成代理类)；JDK自带的动态代理，需要反射等知识 public static void main(String[] args)&#123; Server server = new Server(); ProxyServer proxyserver = new ProxyServer(server); proxyServer.browse(); &#125; interface NetWork &#123; public void browse(); &#125; //被代理类 class Server implements NetWork&#123; @Override public void browse() &#123; System.out.println(&quot;真实的服务器访问网络&quot;); &#125; &#125; //代理类 class ProxyServer implements NetWork&#123; private NetWork work; public ProxyServer(NetWork work)&#123; this.work = work; &#125; public void check()&#123; System.out.println(&quot;联网之前的检查工作&quot;); &#125; @Override public void browse()&#123; check(); work.browse(); &#125; &#125; 3.接口应用实例：工厂模式工厂模式：实现了创建者与调用者的分离，即将创建对象的具体过程屏蔽隔离起来，达到提高灵活性的目的 分类： 简单工厂模式：用来生产同一等级结构中的任意产品。(对于增加新的产品，需要修改已有代码) 缺点：对于增加新产品，不修改代码的话，是无法扩展的。违反了开闭原则（对扩展开放，对修改封闭) 工厂方法模式：用来生产同一等级结构中的固定产品。(支持增加任意产品) 抽象工厂模式：用来生产不同产品族的全部产品。(对于增加新的产品，无能为力;支持增加产品族) 5.7 内部类内部类就是在一个类的内部在定义一个类，比如，A类中定义一个B类，那么B类相对A类来说就称为内部类，而A类相对B类来说就是外部类 成员内部类(静态、非静态) VS 局部内部类(方法内、代码块内、构造器内) 参考链接：https://www.jianshu.com/p/79f6d2aca1d8 5.7.1 成员内部类一方面，作为外部类的成员： 调用外部类的结构 可以被static修饰 可以被4种不同的权限修饰 另一方面，作为一个类： 类内可以定义属性、方法、构造器等 可以被final修饰，表示此类不能被继承。言外之意，不使用final，就可以被继承 可以被abstract修饰 //获取内部类对象实例 public class Test &#123; public static void main(String[] args) &#123; Person ricky = new Person(); //获取成员内部类对象实例，方式1：new 外部类.new 内部类 Person.Heart heart = new Person().new Heart(); System.out.println(heart.beat()); //获取成员内部类对象实例，方式1：外部类对象.new 内部类 heart = ricky.new Heart(); //获取成员内部类对象实例，方式2：外部类对象.获取方法 Person.Heart heart2 = ricky.getHeart(); System.out.println(heart2.beat()); &#125; &#125; //成员内部类的使用 public class Person &#123; String name = &quot;大大&quot;; //获取内部类对象方法 public Heart getHeart()&#123; //外部类访问内部类信息，需要通过内部类实例，无法直接访问name new Heart().name = &quot;明明&quot;; return new Heart(); &#125; public void eat()&#123; System.out.println(&quot;人会吃东西&quot;); &#125; //访问修饰符可以任意，设置为private则只能在此外部类中创建实例 private class Heart &#123; String name = &quot;小小&quot;; public String beat()&#123; //同名属性这里优先访问的是内部类中的name String str = name + &quot;的心脏在跳动&quot;; //访问外部类中的同名属性 str = Person.this.name + &quot;的心脏在跳动&quot;; eat();//直接调用eat()优先访问的是内部类中定义的 Person.this.eat(); //调用外部类的同名方法 return str; &#125; //同名方法 public void eat()&#123; System.out.println(&quot;吃东西&quot;); &#125; &#125; &#125; 成员内部类可以无条件访问外部类的属性和方法 外部类想要访问内部类属性或方法时，必须要创建一个内部类对象，然后通过该对象访问内部类的属性或方法 成员内部类里面不能含静态属性或方法 如果成员内部类的属性或者方法与外部类的同名，将导致外部类的这些属性与方法在内部类被隐藏 访问同名属性和方法时优先访问内部类中定义的；访问外部类中的同名属性和方法可按照该格式调用，外部类.this.属性/方法 成员内部类访问权限：成员内部类前可加上四种访问修饰符。 private：仅外部类可访问 protected：同包下或继承类可访问 default：同包下可访问 public：所有类可访问 内部类编译后.class文件的名称：外部类$内部类.class 5.7.2 静态内部类//定义格式 class U &#123; static class I &#123; &#125; &#125; //使用实例 public class Person &#123; String name = &quot;大大&quot;; public static int age = 22; //获取内部类对象方法 public Heart getHeart()&#123; return new Heart(); &#125; public void eat()&#123; System.out.println(&quot;人会吃东西&quot;); &#125; //静态内部类 public static class Heart &#123; String name = &quot;小小&quot;; public static int age = 12; public String beat()&#123; //静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过对象实例 //直接访问eat()会报错 new Person().eat(); //内部类中的成员方法可以直接访问内部类中的非静态成员和静态成员 String str = name + age + &quot;岁的心脏在跳动&quot;; //访问外部类中的非静态成员和同名静态成员 return new Person().name + Person.age + &quot;的心脏在跳动&quot;; &#125; &#125; //测试 public static void main(String[] args) &#123; //获取静态内部类对象实例 Person.Heart heart = new Person.Heart(); System.out.println(heart.beat()); //可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 Person.Heart.age = 15; &#125; &#125; 静态内部类和成员内部类相比多了一个static修饰符，它与类的静态成员变量一样，不依赖于外部类对象 获取静态内部类对象实例：new 外部类名.静态类() 静态内部类中，只能直接访问外部类的静态成员，如果需要调用非静态成员，可以通过外部类对象实例访问 可以通过外部类.内部类.静态成员的方式，访问内部类中的静态成员 当内部类中静态成员与外部类静态成员同名时，默认直接调用内部类中的成员，可以通过 外部类.成员 的方式访问外部类的同名静态成员，而对于外部类中的非静态成员，不管同不同名，都需要通过外部类实例访问 静态内部类也有它的特殊性，因为外部类加载时只会加载静态域，所以静态内部类中不能使用外部类的非静态变量与方法 5.7.3 局部内部类//定义格式 class K&#123; public void say()&#123; class J&#123; &#125; &#125; &#125; //使用实例 public class Person &#123; String name = &quot;大大&quot;; public static int age = 22; public Object getHeart()&#123; int num = 10; //方法内部类：不能使用任何访问修饰符，不能使用static修饰 class Heart &#123; String name = &quot;小小&quot;; //类成员可以使用访问修饰符、final、abstract，但不能使用static修饰 public final int age = 12; public String beat()&#123; System.out.println(num);//内部类想要使用所在方法的局部变量时，该变量必须被声明为final（JDK8及之后不用显示声明） new Person().eat(); //访问外部类的非静态方法，通过实例对象 return name + Person.age + &quot;的心脏在跳动&quot;; //Person.age访问外部类的静态变量 &#125; &#125; return new Heart().beat();//调用内部类的非静态方法 &#125; public void eat()&#123; System.out.println(&quot;人会吃东西&quot;); &#125; //测试 public static void main(String[] args) &#123; Person ricky = new Person(); //调用包含方法内部类的方法 System.out.println(ricky.getHeart()); &#125; &#125; 局部内部类存在于方法中，它与成员内部类的区别在于局部内部类的访问权限和作用范围仅限于方法或作用域内 方法内部类不能使用任何访问修饰符，不能使用static修饰 类中不能包含静态成员，但可以包含final、abstract修饰的成员 5.7.4 匿名内部类//完成一个不同的人进行阅读的操作 //定义抽象父类 public abstract class Person &#123; //阅读方法 public abstract void read(); &#125; //定义子类 public class Man extends Person&#123; @Override public void read() &#123; System.out.println(&quot;男生喜欢看科幻类书籍&quot;); &#125; &#125; public class Women extends Person&#123; @Override public void read() &#123; System.out.println(&quot;女生喜欢读言情小说&quot;); &#125; &#125; //使用传统的多态方式实现以及匿名内部类实现 public class Test &#123; //需求：根据传入的不同的人的类型，调用对应的read方法 public void getRead(Person person)&#123; person.read(); &#125; public static void main(String[] args) &#123; //方案一：利用多态调用对应子类的实现 Test test = new Test(); Man one=new Man(); Woman two=new Woman(); test.getRead(one); test.getRead(two); //方案二：不定义任何子类，使用匿名内部类完成具体的read方法实现 test.getRead(new Person()&#123; @Override public void read() &#123; System.out.println(&quot;男生喜欢看科幻类书籍&quot;); &#125; &#125;); test.getRead(new Person()&#123; @Override public void read() &#123; System.out.println(&quot;女生喜欢读言情小说&quot;); &#125; &#125;); &#125; &#125; //匿名内部类在合适的场景下对于内存的损耗和对系统的性能影响就会相对较小，弊端就是只能使用一次，无法重复使用 5.7.5 适用场景 只用到类的一个实例 类在定义后马上用到 给类命名并不会导致代码更容易被理解 //1.继承式的匿名内部类 public class Demo &#123; public static void main(String[] args) &#123; //继承式的匿名内部类(相当于定义了一个匿名的Thread子类,目的是重写其方法) Thread thread = new Thread() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; System.out.println(i + &quot; &quot;); &#125; &#125; &#125;; thread.start(); &#125; &#125; //2.接口式的匿名内部类 public class Demo &#123; public static void main(String[] args) &#123; //接口式的匿名内部类(相当于创建了一个实现了接口的匿名类) Runnable r = new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; System.out.println(i + &quot; &quot;); &#125; &#125; &#125;; Thread thread = new Thread(r); thread.start(); &#125; &#125; //3.参数式的匿名内部类 public class Demo &#123; public static void main(String[] args) &#123; //参数式的匿名内部类 Thread thread = new Thread(new Runnable() &#123; @Override public void run() &#123; for (int i = 0; i &lt;= 5; i++) &#123; System.out.println(i + &quot; &quot;); &#125; &#125; &#125;); thread.start(); &#125; &#125; 结论：由上面三个例子可以看出，匿名内部类可以继承一个具体的父类，也可以实现某个接口。只要一个类是抽象的或是一个接口，那么其子类中的方法都可以使用匿名内部类来实现 注意： 匿名内部类没有类型名称、实例对象名称 编译后的文件命名：外部类$数字.class 无法使用访问修饰符、也无法使用abstract、static修饰 无法编写构造方法，也是唯一没有构造方法的内部类，可以添加构造代码块，通过代码块完成匿名内部类的初始化 不能出现静态成员，不能出现抽象方法 匿名内部类可以实现接口也可以继承父类，但是不可兼得 匿名内部类和局部内部类只能访问外部类的final变量 内部类的好处： 完善了Java多继承机制，由于每一个内部类都可以独立的继承接口或类，所以无论外部类是否继承或实现了某个类或接口，对于内部类没有影响 方便写事件驱动程序 5.8 Object类浅析Object类是所有Java类的根父类 如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类 Object类中的功能（属性、方法）具有通用性 Object类只声明了一个空参构造器 public class Person &#123;...&#125;等价于public class Person extends Object &#123;...&#125; //例: method(Object obj)&#123;...&#125;可以接收任何类作为其参数 //Person o=new Person(); //method(o); 5.8.1 Object类中的方法 Object类没有属性 clone()：克隆一个对象并返回 equals()：比较两个对象是否相等 finalize()：JVM进行垃圾回收前要执行的方法，通常情况都是垃圾回收器自动调用，程序员可以通过System.gc()或者Runtime.getRuntime().gc()来通知系统进行垃圾回收，但是系统是否进行依然不确定（垃圾回收机制只回收JVM中堆内存中的对象空间）（面试题：final、finally、finalize的区别） getClass()：获取当前对象的所属类 hashcode()：返回当前对象的哈希值 toString()：对象打印时调用，在Object中是返回当前对象的类名和引用地址，如果被其他类（如String类、Date类、File类、包装类等）重写就会执行重写后的方法 notify()、notifyAll()、wait()：线程相关方法 5.8.2 ==和equals()方法的区别 既可以比较基本类型也可以比较引用类型。对于基本类型就是比较值，对于引用类型就是比较内存地址 equals的话，它是属于java.lang.Object类里面的方法，如果该方法没有被重写过默认也是;我们可以看到string等类的equals方法是被重写过的，而且String类在日常开发中用的比较多，久而久之,形成了equals是比较值的错误观点（比如String类、Date类、File类、包装类等都重写了Object类的equals方法，重写后，不是比较的两个引用的地址是否相同，而是比较两个对象的”实体内容”是否相同） 具体要看自定义类里有没有重写Object的equals方法来判断 通常情况下，重写equals方法，会比较类中的相应属性是否都相等 Object类中equals()方法和==的作用一样，都是比较两个对象的地址值是否相同 //Object类中的equals方法，比较引用地址 public boolean equals(Object obj) &#123; return (this == obj); &#125; //String类中的equals方法，首先比较引用是否相同，如不同再比较两个对象的各个属性值是否相同 public boolean equals(Object anObject) &#123; if (this == anObject) &#123; return true; &#125; if (anObject instanceof String) &#123; String anotherString = (String)anObject; int n = value.length; if (n == anotherString.value.length) &#123; char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false; &#125; 5.8.3 toString()方法toString()方法在Object类中定义，其返回值是String类型，返回类名和它的引用地址 在进行String与其它类型数据的连接操作时，自动调用toString()方法（与基本类型的连接可参考1.3.3） Date now=new Date(); system.out.printIn(&quot;now=&quot;+now);//相当于system.out.printIn(&quot;now=+now.toString());输出=&gt;now=当前时间 可以根据需要在用户自定义类型中**重写toString()**方法如String 类重写了toString()方法，返回字符串的值。 s1=&quot;hello&quot;; system.out.printIn(s1);//相当于System.out.printIn(s1.toString());输出=&gt;hello 基本类型数据转换为String类型时，调用了对应包装类的toString()方法 int a=10; system.out.printIn(&quot;a=&quot;+a); 5.9 包装类5.9.1 装箱和拆箱int num = 10; //装箱 Integer i = new Integer(num); //拆箱 int num1 = Integer.intValue(i); //其他其中基本类型的装箱和拆箱操作也如上 5.9.2 自动拆箱和自动装箱（JDK5版本之后的新特性）int i = 0; //自动装箱 Integer num = i; //自动拆箱 int m = num; //基本数据类型的自动装箱和拆箱只适用于变量的值在相应包装类中缓冲区范围内，超出范围则需要通过5.8.1的方式来进行拆箱和装箱 //比如，int类型对应的Integer包装类中缓冲区的数组范围为-128~127，如果一个int i= 130需要进行装箱，则需要new Integer(i)来进行装箱 //其他几种基本数据类型也能进行装箱拆箱 通过将基本数据类型进行装箱操作后可以调用封装类中的方法和变量，常量 将一个基本数据类型的变量进行封装后可以判断这个变量的值是否为null 5.9.3 基本数据类型和String类型的相互转换//包装类---&gt;String //方法一：连接运算 int num = 10； String str1 = num + &quot;&quot;; //方法二：调用String的ValueOf方法 float f = 12.3f; String str2 = String.ValueOf(f); //String---&gt;基本数据类型、包装类 String str3 = &quot;123&quot;; int num1 = Integer.parseInt(Str3); //错误情况：int num1 = (int)str3;或者Integer i = (Integer)str3; 5.10 单例设计模式设计模式是在大量的实践中总结和理论化之后优选的代码结构、编程风格、以及解决问题的思考方式 设计模式分类： 创建型模式，共5种：工厂方法模式、抽象工厂模式、单例模式、建造者模式、原型模式 结构型模式，共7种：适配器模式、装饰器模式、代理模式、外观模式、桥接模式、组合模式、享元模式 行为型模式，共11种：策略模式、模板方法模式、观察者模式、迭代子模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式、中介者模式、解释器模式 所谓类的单例设计模式，就是采取一定的方法保证在整个的软件系统中，对某个类只能存在一个对象实例，并且该类只提供一个取得其对象实例的方法。如果我们要让类在一个虚拟机中只能产生一个对象，我们首先必须将类的构造器的访问权限设置为private，这样，就不能用new在类的外部创建类的对象了，但在类内部仍可以产生该类的对象。因为在类的外部开始还无法得到类的对象，只能调用该类的某个静态方法以返回类内部创建的对象，静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的（简单来说，单例模式（Singleton模式）指的是一个类，在一个JVM里，只有一个实例存在；且构造方法私有化） 单例模式优点：由于单例模式只生成一个实例，减少了系统性能开销，当一个对象的产生需要比较多的资源时，如读取配置、产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决 5.10.1 单例模式饿汉式饿汉式是无论如何都会创建一个实例对象 class Bank &#123; //1.内部创建类的对象 //2.由于静态方法只能访问静态属性，所以这个对象属性必须为static priavte static Bank instance = new Bank(); //3.构造方法私有化 private Bank() &#123; &#125; //4.提供公共的静态方法返回类的对象 public static Bank getInstance() &#123; return instance; &#125; &#125; 5.10.2 单例模式懒汉式懒汉式只有在调用getInstance的时候，才会创建实例 class Bank &#123; //1.准备一个属性，用于指向一个实例化对象，但是暂时指向null //2.由于静态方法只能访问静态属性，所以这个对象属性必须为static priavte static Bank instance; //3.构造方法私有化 private Bank() &#123; &#125; //4.提供公共的静态方法返回类的对象 public static Bank getInstance() &#123; if(null == instance) &#123; //第一次访问的时候，发现instance没有指向任何对象，这时实例化一个对象 instance = new Bank(); &#125; return instance; //返回instance指向的实例对象 &#125; &#125; 5.10.3 饿汉式和懒汉式的区分饿汉式： 好处：线程安全，只能创建出一个实例对象 坏处：对象加载时间过长 懒汉式： 好处：延迟对象的创建 坏处：线程不安全，有创建出多个实例对象的可能—-&gt;到多线程时再修改 5.11 MVC设计模式MVC是常用的设计模式之一，将整个程序分为三个层次：视图模型层，控制器层，与数据模型层。这种将程序输入输出、数据处理，以及数据的展示分离开来的设计模式使程序结构变的灵活而且清晰，同时也描述了程序各个对象间的通信方式，降低了程序的耦合性 模型层 model主要处理数据 数据对象封装 model.bean/domain 数据库操作类 model.dao 数据库 model.db 视图层 view显示数据 相关工具类 view.utils自定义view view.ui 控制层 controller处理业务逻辑 应用界面相关 controller.activity 存放fragment controller.fragment 显示列表的适配器 controller.adapter 服务相关的 controller.service 抽取的基类 controller.base 六、Java异常和错误6.1 什么是异常?软件程序在运行过程中，非常可能遇到刚刚提到的这些异常问题，我们叫异常，英文是:Exception，意思是例外。这些，例外情况，或者叫异常，怎么让我们写的程序做出合理的处理。而不至于程序崩溃 异常指程序运行中出现的不期而至的各种状况,如:文件找不到、网络连接失败、非法参数等；异常发生在程序运行期间,它影响了正常的程序执行流程。 6.1.1 异常分类检查性异常:最具代表的检查性异常是用户错误或问题引起的异常,这是程序员无法预见的。例如要打开一个不存在文件时，一个异常就发生了，这些异常在编译时不能被简单地忽略 运行时异常:运行时异常是可能被程序员避免的异常。与检查性异常相反，运行时异常可以在编译时被忽略 错误(ERROR):错误不是异常, 而是脱离程序员控制的问题。错误在代码中通常被忽略。例如，当栈溢出时，一个错误就发生了，它们在编译也检查不到的 6.1.2 异常体系结构Java把异常当作对象来处理，并定义一个基类java.lang.Throwable作为所有异常的超类 在Java API中已经定义了许多异常类，这些异常类分为两大类，错误Error和异常Exception image-20210717185030151 6.2.3 ErrorError类对象由Java虚拟机生成并抛出，大多数错误与代码编写者所执行的操作无关 Java虚拟机运行错误(Virtual MachineError) , 当JVM不再有继续执行操作所需的内存资源时，将出现OutOfMemoryError。这些异常发生时，Java虚拟机(JVM) - -般会选择线程终止 还有发生在虚拟机试图执行应用时，如类定义错误(NoClassDefFoundError) 、链接错误(LinkageError)。这些错误是不可查的，因为它们在应用程序的控制和处理能力之外,而且绝大多数是程序运行时不允许出现的状况 6.2.4 Exception在Exception分支中有一个重要的子类RuntimeException (运行时异常)： ArrayIndexOutOfBoundsException (数组下标越界) NullPointerException (空指针异常) ArithmeticException (算术异常) MissingResourceException (丢失资源) ClassNotFoundException (找不到类)等异常，这些异常是不检查异常，程序中可以选 择捕获处理，也可以不处理 这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生 Error和Exception的区别: Error通常是灾难性的致命的错误，是程序无法控制和处理的，当出现这些异常时，Java虚拟机(JVM)一般会选择终止线程; Exception通常情况下是可以被程序处理的，并且在程序中应该尽可能的去处理这些异常 6.2 异常处理机制分为：抛出异常、捕获异常 子类重写的方法抛出的异常不大于父类被重写的方法抛出的异常 异常处理的5个关键字：try、catch、finally、throw、throws //捕获异常 try &#123; //将要执行，被捕获异常的语句，放在try语句块中 &#125; catch(Exception e) &#123; //如果上方语句出现相应异常，则执行catch语句块中的语句 &#125; finally &#123; //无论try中的代码语句是否有被捕获到异常，然后转到catch块进行处理，finally中的语句都会执行 //finally语句块是否使用为可选，可以使用，也可以不使用 &#125; //一个try代码块后面可跟随多个catch代码块，这种情况叫做多重捕获 //若需要捕获多个异常，需要从小到大 //抛出异常 //如果一个方法没有捕获到一个检查性异常，那么该方法必须使用 throws 关键字来声明。throws 关键字放在方法签名的尾部。 //也可以使用 throw 关键字抛出一个异常，无论它是新实例化的还是刚捕获到的 public class Test &#123; //假设方法中处理不了这个异常，则在方法上进行抛出 //一个方法可以抛出多个异常，中间用逗号隔开 public void test() throws Exception &#123; throw new Exception(); //主动抛出异常，一般在方法中使用 &#125; &#125; 开发中如何选择使用try-catch- finally还是使用throws? ①如果父类中被重写的方法没有throws方式处理异常，则子类重写的方法也不能使用throws，意味着如果子类重写的方法中有异常，必须使用try- catch- finally方式处理 ②执行的方法a中，先后又调用了另外的几个方法，这几个方法是递进关系执行的。建议这几个方法使用throws的方式进行处理。而执行的方法a可以考虑使用try- catch-finally方式进行处理 6.3 自定义异常使用Java内置的异常类可以描述在编程时出现的大部分异常情况。除此之外，用户还可以自定义异常。用户自定义异常类,只需继承Exception类即可 编写自己的异常时，需要注意几点： 所有异常都必须是 Throwable 的子类 如果希望写一个检查性异常类，则需要继承 Exception 类 如果你想写一个运行时异常类，那么需要继承 RuntimeException 类 在程序中使用自定义异常类，大体可分为以下几个步骤: 创建自定义异常类 在方法中通过throw关键字抛出异常对象。 如果在当前抛出异常的方法中处理异常,可以使用try-catch语句捕获并处理;否则在方法的声明处通过throws关键字指明要抛出给方法调用者的异常，继续进行下一步操作 在出现异常方法的调用者中捕获并处理异常 //自定义异常 public class MyException extends Exception&#123; //传递数字 private int number; public MyException(int a) &#123; this.number = a; &#125; //toString:异常的打印信息 @Override public String toString() &#123; return &quot;MyException&#123;&quot; + &quot;number=&quot; + number + &#39;&#125;&#39;; &#125; &#125; //使用自定义异常 public class test06 &#123; public static void main(String[] args) &#123; try &#123; addNumber(11); //因为传给addNumbers方法的值为11，所以 报错输出MyException=&gt;MyException&#123;number=11&#125; &#125; catch (Exception e) &#123; System.out.println(&quot;MyException=&gt;&quot; + e); &#125; &#125; private static void addNumber(int a) throws MyException&#123; if (a &gt; 10) &#123; throw new MyException(a); &#125; System.out.println(a); &#125; &#125; //为什么第21行输出e会自动调用toString方法？ //因为在MyException中重写了父类中的toString方法，System.out.println则会调用子类重写的这个toString方法，否则他就会调用父类中的toS 方法 七、Java多线程7.1 基本概念：程序、进程、线程程序(program)是为完成特定任务、用某种语言编写的一组指令的集合。即指一段静态的代码，静态对象 进程(process)是程序的一次执行过程，或是正在运行的一个程序。是一个动态的过程：有它自身的产生、存在和消亡的过程。——生命周期 如:运行中的QQ，运行中的MP3播放器 程序是静态的，进程是动态的 进程作为资源分配的单位，系统在运行时会为每个进程分配不同的内存区域 线程(thread)，进程可进一步细化为线程，是一个程序内部的一条执行路径 若一个进程同一时间并行执行多个线程，就是支持多线程的 **线程作为调度和执行的单位，每个线程拥有独立的运行栈和程序计数器(pc)**，线程切换的开销小 一个进程中的多个线程共享相同的内存单元/内存地址空间-&gt;它们从同一堆中分配对象，可以访问相同的变量和对象。这就使得线程间通信更简便、高效。但多个线程操作共享的系统资源可能就会带来安全的隐患 JVM结构： image-20210724213734378 7.1.1 CPU、并行与并发的理解单核CPU和多核CPU的理解 单核CPU，其实是一种假的多线程，因为在一个时间单元内，也只能执行一个线程的任务。例如：虽然有多车道，但是收费站只有一个工作人员在收费，只有收了费才能通过，那么CPU就好比收费人员。如果有某个人不想交钱，那么收费人员可以把他“挂起”(晾着他，等他想通了，准备好了钱，再去收费）。但是因为CPU时间单元特别短，因此感觉不出来 如果是多核的话，才能更好的发挥多线程的效率(现在的服务器都是多核的） 一个Java应用程序java.exe，其实至少有三个线程：main()主线程，gc()垃圾回收线程，异常处理线程。当然如果发生异常，会影响主线程 并行与并发 并行：多个CPU同时执行多个任务（多个人同时做不同的事(多对多)，如，篮球场上的人(多个CPU)同时在做不同的事(多个任务)） 并发：一个CPU(采用时间片)同时执行多个任务（一个人同时做不同的事(一对多)，比如，篮球场(一个CPU)上每个人做的事(多个任务)） 7.1.2 多线程的优点 提高应用程序的响应。对图形化界面更有意义，可增强用户体验 提高计算机系统CPU的利用率 改善程序结构。将既长又复杂的进程分为多个线程，独立运行，利于理解和修改 7.1.3 什么时候需要多线程 程序需要同时执行两个或多个任务 程序需要实现一些需要等待的任务时，如用户输入、文件读写操作、网络操作、搜索等 需要一些后台运行的程序时 7.1.4 线程的分类Java中的线程分为两类：一种是守护线程，一种是用户线程 它们在几乎每个方面都是相同的，唯一的区别是判断JVM何时离开 守护线程是用来服务用户线程的，通过在start()方法前调用thread.setDaemon(true)可以把一个用户线程变成一个守护线程 Java垃圾回收就是一个典型的守护线程 若JVM中都是守护线程，当前JVM将退出 7.2 线程的创建和使用7.2.1 线程的调度调度策略： 时间片：每个线程占用CPU一段时间 抢占式：高优先级的线程抢占CPU Java的调度方法 同优先级线程组成先进先出队列（先到先服务），使用时间片策略 对高优先级，使用优先调度的抢占式策略 线程的优先级等级 MAX_PRIORITY：10 MIN_PRIORITY：1 NORM_PRIORITY：5 涉及的方法 getPriority()：返回线程优先值 setPriority(int newPriority)：改变线程的优先级 说明 线程创建时继承父线程的优先级 低优先级只是获得调度的概率低，并非一定是在高优先级线程之后才被调用 线程通信：wait()、notify()、notifyAll()此三个方法定义在Object类中 7.2.2 多线程的创建1.方法一：继承Thread类 创建一个继承于Thread类的子类 重写Thread类的run() —&gt;将此线程要执行的操作声明在run()中 创建Thread类的子类的对象 通过此对象调用start() —&gt;①启动当前线程 ②调用当前线程的run()方法 ③每个线程只能start一次 不能直接调用run()方法，否则相当于普通方法的调用在main线程中执行，不会有线程之间的交互进行 public class ThreadTest01 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); //3.在main线程中创建一个新的线程 myThread.start(); //4.调用start()方法，开始执行这个线程的操作，此时会从主线程另外分出一个线程执行命令 System.out.println(&quot;**************&quot;); //下面是主线程需要执行的操作，从输出结果可以看出两个线程的交互执行 for (int i = 0; i &lt; 100; i++) &#123; //遍历100以内的奇数 if(i % 2 != 0) System.out.println(i + &quot;main()&quot;); &#125; &#125; &#125; class MyThread extends Thread &#123; //1.继承Thread类 @Override public void run() &#123; //2.重写run()方法 for (int i = 0; i &lt; 100; i++) &#123; //遍历100以内的偶数 if(i % 2 == 0) System.out.println(i); &#125; &#125; &#125; //创建两个分线程，一个打印100以内的偶数，一个打印100以内的奇数 public static void main(String[] args) &#123; //方法一：创建两个线程子类，再分别创建一个对象，在各自的run方法中重写不同操作 //方法二：创建两个线程的匿名子类对象，如下： new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 == 0) System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;.start(); new Thread()&#123; @Override public void run() &#123; for (int i = 0; i &lt; 100; i++) &#123; if(i % 2 != 0) System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125;.start(); &#125; 2.方法二：实现Runnable接口 创建一个实现了Runnable接口的类 实现类去实现Runnable中的抽象方法: run( ) 创建实现类的对象 将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 通过Thread类的对象调用start(） class MyThread implements Runnable &#123; //1.创建一个实现了Runnable接口的类 @Override public void run() &#123; //2.实现类去实现Runnable中的抽象方法: run() for (int i = 0; i &lt; 100; i++) &#123; if(i%2==0) &#123; System.out.println(i); &#125; &#125; &#125; &#125; public class ThreadTest03 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); //3.创建实现类的对象 Thread t1 = new Thread(myThread); //4.将此对象作为参数传递到Thread类的构造器中，创建Thread类的对象 t1.start(); //5.通过Thread类的对象调用start(） &#125; &#125; //多窗口抢票实例 //目前存在线程安全问题，即第100张票可能被多个窗口同时卖出，等到7.4节得以解决 class window extends Thread &#123; private static int stick = 100; //必须加上static才能让三个线程共享100张票，否则会出现每个线程都有100张票的情况 @Override //因为这种线程创建的方式是一个线程为一个对象，而实现接口的方式是一个对象创建三个线程 public void run() &#123; while (true) &#123; if(stick &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + stick); stick--; &#125; else &#123; break; &#125; &#125; &#125; &#125; class window implements Runnable &#123; private int stick = 100; //不用加上static也能让三个线程共享100张票，因为这三个线程都是由同一个对象创建的 @Override public void run() &#123; while (true) &#123; if(stick &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + stick); stick--; &#125; else &#123; break; &#125; &#125; &#125; &#125; public class ThreadTest02 &#123; public static void main(String[] args) &#123; //继承Thread类的方式实现 window t1 = new window(); window t2 = new window(); window t3 = new window(); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); //实现Runnable接口的方式 window window = new window(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.setName(&quot;窗口1&quot;); t2.setName(&quot;窗口2&quot;); t3.setName(&quot;窗口3&quot;); t1.start(); t2.start(); t3.start(); &#125; &#125; 3.两种线程创建方式的比较开发中优先选择：实现Runnable接口的方式 原因： 实现的方式没有类的单继承性的局限性 实现的方式更适合来处理多个线程有共享数据的情况 联系: public class Thread implements Runnable 相同点：两种方式都需要重写run()，将线程要执行的逻辑声明在run( )中 7.2.3 Thread类中的有关方法（使用） void start()：启动线程，并执行对象的run()方法 run()：线程在被调度时执行的操作 String getName()：返回线程的名称 void setName(String name)：设置该线程名称 static Thread currentThread()：返回当前线程。在Thread子类中就是this，通常用于主线程和Runnable实现类 static void yield()：线程让步 暂停当前正在执行的线程，把执行机会让给优先级相同或更高的线程 若队列中没有同优先级的线程，忽略此方法 join()：当某个程序执行流中调用其他线程的 join()方法时，调用线程将被阻塞，直到join()方法加入的join 线程执行完为止 低优先级的线程也可以获得执行 static void sleep(long millis)：(指定时间:毫秒) 令当前活动线程在指定时间段内放弃对CPU控制，使其他线程有机会被执行，时间到后重排队 抛出InterruptedException异常 stop()：强制线程生命期结束，不推荐使用，已过时 boolean isAlive()：返回boolean，判断线程是否还活着 7.3 线程的生命周期JDK中用Thread.State类定义了线程的几种状态 要想实现多线程，必须在主线程中创建新的线程对象。Java语言使用Thread类及其子类的对象来表示线程，在它的一个完整的生命周期中通常要经历如下的五种状态： 新建：当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状态 就绪：处于新建状态的线程被start()后，将进入线程队列等待CPU时间片，此时它已具备了运行的条件，只是还没分配到CPU资源 运行：当就绪的线程被调度并获得CPU资源时,便进入运行状态，run()方法定义了线程的操作和功能 阻塞：在某种特殊情况下，被人为挂起或执行输入输出操作时，让出CPU并临时中止自己的执行，进入阻塞状态 死亡：线程完成了它的全部工作或线程被提前强制性地中止或出现异常导致结束 image-20210726120906987 7.4 线程的同步7.4.1 线程的安全问题问题提出： 多个线程执行的不确定性引起执行结果的不稳定 多个线程对账本的共享，会造成操作的不完整性，会破坏数据 如，7.2.2中多窗口卖票实例若run()中加了sleep()的可能会出现： image-20210726152643935 image-20210726152750501 7.4.2 线程安全问题的解决办法(同步和Lock)7.2.2实例出现的问题：卖票过程中，出现了重票、错票–&gt;出现了线程的安全问题 问题出现的原因：当某个线程操作车票的过程中，尚未操作完成时，其他线程参与进来，也操作车票 如何解决：当一个线程a在操作ticket的时候，其他线程不能参与进来。直到线程a操作完ticket时，其他线程才可以开始操作ticket。这种情况即使线程a出现了阻塞，ticket也不能被改变 在Java中，我们通过同步机制和Lock来解决线程安全问题 利用同步机制解决线程安全问题的优缺点： 同步的方式，解决了线程的安全问题 —好处 操作同步代码时，只能有一个线程参与，其他线程等待。相当于是一个单线程的过程，效率低 —缺点 1.方式一：同步代码块synchronized(同步监视器)&#123; //需要被同步的代码 &#125; //1.操作共享数据的代码，即为需要同步的代码 ---&gt;不能包含代码多了，也不能包含少了 //2.共享数据：多个线程共同操作的变量，比如ticket就是共享数据 //3.同步监视器，俗称：锁;任何一个类的对象，都可以充当锁 // 要求：多个线程必须要公用同一个锁 //补充：在实现Runnable接口实现创建多线程的方式中，我们可以考虑使用this充当同步监视器 // 在继承Thread类创建多线程的方式中，慎用this充当同步监视器，考虑使用当前类作为同步监视器 ①解决实现Runnable的线程安全问题 class window implements Runnable &#123; private int ticket = 100; Object obj = new Object(); @Override public void run() &#123; while (true) &#123; synchronized(obj)&#123; //synchronized(this)这种方式在实现Runnable的方式中也可以，因为这个this代表的是 if(ticket &gt; 0) &#123; //window的对象window，此时仍然是三个线程公用一把锁 System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; ②解决继承Thread的线程安全问题 class window extends Thread &#123; private static int ticket = 100; private static Object obj = new Object();//必须用static修饰，因为继承Thread的方式需要每创建一个线程就声明一个 @Override //对象，如果不加static就会让每个对象都有一把锁，就违背了多个线程必须共用一把锁的要求 public void run() &#123; while (true) &#123; synchronized(obj) &#123; //synchronized(this)这种方式在继承Thread的方式中就不可以，因为这个this代表的是当 if(ticket &gt; 0) &#123; //前线程的对象t1、t2、t3，即一个线程一把锁 //但我们可使用synchronized(window.class)作为锁的方式来实现，因为window.class也是一个对象，此时三个线程也是公用一把锁 System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; &#125; &#125; &#125; 2.方式二：同步方法如果操作共享数据的代码完整的声明在一个方法中，我们不妨将此方法声明为同步的 ①解决实现Runnable接口的线程安全问题 class MyThread implements Runnable &#123; private int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); if(ticket &lt;= 0) break; &#125; &#125; public synchronized void show() &#123; //同步方法 if(ticket &gt; 0) &#123; //同步监视器：this System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125; &#125; public class ThreadTest03 &#123; public static void main(String[] args) &#123; MyThread myThread = new MyThread(); Thread t1 = new Thread(myThread); Thread t2 = new Thread(myThread); Thread t3 = new Thread(myThread); t1.start(); t2.start(); t3.start(); &#125; &#125; ②解决继承Thread类的线程安全问题 class MyThread extends Thread &#123; private static int ticket = 100; @Override public void run() &#123; while (true) &#123; show(); if (ticket &lt;= 0) break; &#125; &#125; public static synchronized void show() &#123; //若不加static，同步监视器：t1、t2、t3 if(ticket &gt; 0) &#123; //加上static，同步监视器：MyThread.Class即这个类本身充当对象作为锁（反射机制） System.out.println(Thread.currentThread().getName() + &quot;：卖票，票号为：&quot; + ticket); ticket--; &#125; &#125; &#125; public class ThreadTest03 &#123; public static void main(String[] args) &#123; MyThread t1 = new MyThread(); MyThread t2 = new MyThread(); MyThread t3 = new MyThread(); t1.start(); t2.start(); t3.start(); &#125; &#125; 关于同步方法的总结： 同步方法仍然涉及到同步监视器，只是不需要我们显式的声明 非静态的同步方法，同步监视器是: this 静态的同步方法，同步监视器是：当前类本身 3.方式三：Lock锁 —JDK5.0新增从JDK5.0开始，Java提供了更强大的线程同步机制——通过显式定义同步锁对象来实现同步。同步锁使用Lock对象充当 java.util.concurrent.locks.Lock接口是控制多个线程对共享资源进行访问的工具。锁提供了对共享资源的独占访问，每次只能有一个线程对Lock对象加锁，线程开始访问共享资源之前应先获得Lock对象 ReentrantLock类实现了Lock ，它拥有与synchronized相同的并发性和内存语义，在实现线程安全的控制中，比较常用的是ReentrantLock，可以显式加锁、释放锁 public class ThreadTest06 &#123; public static void main(String[] args) &#123; Window window = new Window(); Thread t1 = new Thread(window); Thread t2 = new Thread(window); Thread t3 = new Thread(window); t1.start(); t2.start(); t3.start(); &#125; &#125; class Window implements Runnable &#123; private int ticket = 100; //1.实例化ReentrantLock private ReentrantLock lock = new ReentrantLock(true); @Override public void run() &#123; while(true) &#123; try&#123; //使用try-finally代码块是为了让同步代码无论是否执行完最终都要释放锁，否则会出现执行的某一次没有解锁 //2.调用lock()上锁 lock.lock(); if (ticket &gt; 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;:售票,票号为:&quot; + ticket); ticket--; &#125; else &#123; break; &#125; &#125; finally &#123; //3.调用unlock()解锁 lock.unlock(); &#125; &#125; &#125; &#125; synchronized和Lock的对比： Lock是显式锁（手动开启和关闭锁，别忘记关闭锁），synchronized是隐式锁，出了作用域自动释放 Lock只有代码块锁，synchronized有代码块锁和方法锁 使用Lock锁，JVM将花费较少的时间来调度线程，性能更好。并且具有更好的扩展性（提供更多的子类） 优先使用顺序：Lock&gt;同步代码块（已经进入了方法体，分配了相应资源）&gt;同步方法(在方法体之外) 面试题: synchronized 与Lock的异同? 相同：二者都可以解决线程安全问题 不同：synchronized机制在执行完相应的同步代码以后，自动的释放同步监视器 ​ Lock需要手动的启动同步(上锁Lock() )，同时也需要手动的结束同步(解锁unlock() ) 面试题：如何解决线程安全问题？有几种方式？ 使用synchronized关键字 使用synchronized修饰代码块，使其成为同步代码块（包住操作共享数据的代码） 使用synchronized修饰方法，使其成为同步方法（方法体是操作共享数据的代码块） 使用Lock锁的方式（常用ReentrantLock类） 7.4.3 线程安全的单例模式之懒汉式Class Bank &#123; private Bank()&#123;&#125; private static Bank instance = null; public static Bank getInstance() &#123; //方式一：效率稍差 synchronized(Bnak.class) &#123; if(instance == null) &#123; instance = new Bank(); &#125; return instance; &#125; //方式二：效率更高 if(instance == null) &#123; //第一个if是为了后面的线程可以直接返回instance，而不用进入同步方法块里再进行判断，以此来提高效率 synchronized(Bnak.class) &#123; if(instance == null) &#123; //这个if不能删除，如果删除仍然存在线程安全问题，因为可能存在多个线程同时调用这个方法，就会同时进入第一个if语句内，这样这些线程就会逃过判空的环节等待进入同步代码块，等到自己使用CPU时又会new一个新的bank对象，那么这个第二个if判断就是第二重保险 instance = new Bank(); &#125; &#125; &#125; return instance; &#125; &#125; 7.4.4 线程的死锁问题死锁： 不同的线程分别占用对方需要的同步资源不放弃，都在等待对方放弃自己需要的同步资源，就形成了线程的死锁 出现死锁后，不会出现异常，不会出现提示，只是所有的线程都处于阻塞状态，无法继续 我们使用同步时要避免出现死锁 死锁产生的四个必要条件： 1、互斥使用，即当资源被一个线程使用(占有)时，别的线程不能使用 2、不可抢占，资源请求者不能强制从资源占有者手中夺取资源，资源只能由资源占有者主动释放 3、请求和保持，即当资源请求者在请求其他的资源的同时保持对原有资源的占有 4、循环等待，即存在一个等待队列：P1占有P2的资源，P2占有P3的资源，P3占有P1的资源。这样就形成了一个等待环路 当上述四个条件都成立的时候，便形成死锁。当然，死锁的情况下如果打破上述任何一个条件，便可让死锁消失 解决方法： 专门的算法、原则 尽量减少同步资源的定义 尽量避免嵌套同步 //死锁实例 public static void main(String[] args) &#123; StringBuffer s1 = new StringBuffer(); StringBuffer s2 = new StringBuffer(); new Thread()&#123; //第一个线程 @Override public void run() &#123; synchronized (s1) &#123; //以对象s1作为第一把锁 s1.append(&quot;a&quot;); s2.append(&quot;1&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s2) &#123; //以对象s2作为第二把锁 s1.append(&quot;b&quot;); s2.append(&quot;2&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;.start(); new Thread(new Runnable() &#123; //第二个线程 @Override public void run() &#123; synchronized (s2) &#123; ////以对象s2作为第一把锁 s1.append(&quot;c&quot;); s2.append(&quot;3&quot;); try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized (s1) &#123; //以对象s1作为第二把锁 s1.append(&quot;d&quot;); s2.append(&quot;4&quot;); System.out.println(s1); System.out.println(s2); &#125; &#125; &#125; &#125;).start(); &#125; //该程序形成死锁原因： //第一个线程执行拿到第一把锁s1，然后会执行sleep进行睡眠，同时第二个线程也开始执行，拿到第一把锁s2 //第一个线程睡眠结束，需要第二把锁s2，但是第二个线程正在占用s2，s2得不到释放，则第一个线程就会一直等待第二个线程释放s2 //但是，此时第二个线程睡眠结束，需要用到锁s1，但第一个线程又因为无法使用锁s2，会一直占用s1导致s1得不到释放，那么第二个线程也就需要等待第一个线程释放锁s1 //由此便产生了第一个线程拿不到s2的同时又不释放s1，而第二个线程拿不到s1的同时也不释放s2，这样就使两个线程都不到互相需要的锁，进入无限循环等待资源的死锁状态 7.5 线程的通信7.5.1 线程通信的介绍涉及到的三个方法： wait()：一旦执行此方法，当前线程就进入阻塞状态，并释放同步监视器 notify()：一旦执行此方法，就会唤醒被wait()的一个线程。如果有多个线程被wait，就唤醒优先级高的线程 notifyAll()：一旦执行此方法，就会唤醒**所有被wait()**的线程 说明： wait()，notify()，notifyAll()三个方法必须使用在同步代码块或同步方法中 wait()，notify()，notifyAll()三个方法的调用者必须是同步代码块或同步代码中的同步监视器，否则，会出现IllegalMonitorStateException异常 wait()，notify()，notifyAll()三个方法是定义在java.lang.Object类中在· 面试题：sleep()和wait()的异同？ 相同点：一旦执行方法，都可以使得当前的线程进入阻塞状态 不同点： 两个方法声明的位置不同：sleep()声明在Thread类中，wait()声明在object类中 调用的要求不同: sleep()可以在任何需要的场景下调用，wait()必须使用在同步代码块或同步方法中 关于**是否释放同步监视器(锁)**：如果两个方法都使用在同步代码块或同步方法中，sleep()不会释放同步监视器，而wait()会释放同步监视器 //线程通信的例子：使用两个线程打印1-100，线程1和线程2交替打印 public class ThreadTest08 &#123; public static void main(String[] args) &#123; Number number = new Number(); Thread t1 = new Thread(number); Thread t2 = new Thread(number); t1.setName(&quot;线程1&quot;); t2.setName(&quot;线程2&quot;); t1.start(); t2.start(); &#125; &#125; class Number implements Runnable &#123; private int number = 1; @Override public void run() &#123; while(true) &#123; synchronized (this)&#123; notify(); //唤醒被阻塞的 if(number &lt;= 100) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + number); number++; try &#123; wait(); //使调用wait()方法的线程进入阻塞状态，且释放锁(sleep阻塞但不会释放锁) &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;else&#123; break; &#125; &#125; &#125; &#125; &#125; 7.5.2 线程通信的应用经典例题：生产者/消费者问题 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20），如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下，如果店中有产品了再通知消费者来取走产品 这里可能出现两个问题： 生产者比消费者快时，消费者会漏掉一些数据没有取到 消费者比生产者快时，消费者会取同样的数据 /* 生产者和消费者问题 生产者(Productor)将产品交给店员(Clerk)，而消费者(Customer)从店员处取走产品，店员一次只能持有固定数量的产品(比如:20）， 如果生产者试图生产更多的产品，店员会叫生产者停一下，如果店中有空位放产品了再通知生产者继续生产；如果店中没有产品了，店员会告诉消费者等一下， 如果店中有产品了再通知消费者来取走产品 */ public class ThreadTest09 &#123; public static void main(String[] args) &#123; Clerk clerk = new Clerk(); Productor productor1 = new Productor(clerk); //定义生产者线程 Productor productor2 = new Productor(clerk); Customer customer1 = new Customer(clerk); //定义消费者线程 Customer customer2 = new Customer(clerk); Customer customer3 = new Customer(clerk); productor1.setName(&quot;生产者1&quot;); productor2.setName(&quot;生产者2&quot;); customer1.setName(&quot;消费者1&quot;); customer2.setName(&quot;消费者2&quot;); customer3.setName(&quot;消费者3&quot;); productor1.start(); productor2.start(); customer1.start(); customer2.start(); customer3.start(); &#125; &#125; class Clerk &#123; private int product = 0; //店员拥有的产品数 public int getProduct() &#123; return product; &#125; public void addProduct() &#123; product++; &#125; public void reduceProduct() &#123; product--; &#125; &#125; class Productor extends Thread &#123; private Clerk clerk; //声明Clerk对象，方便对于产品数的操作 public Productor(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; while(true) &#123; try &#123; Thread.sleep(100); //阻塞线程，让其他线程有争夺的时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(Clerk.class) &#123; if(clerk.getProduct() &lt; 20)&#123; //如果商品的数量小于20，则生产者会持续生产 System.out.println(Thread.currentThread().getName() + &quot;开始生产......&quot;); System.out.println(Thread.currentThread().getName() + &quot;正在准备生产第&quot; + (clerk.getProduct()+1) + &quot;个产品&quot;); clerk.addProduct(); System.out.println(Thread.currentThread().getName() + &quot;已经完成生产第&quot; + clerk.getProduct() + &quot;个产品&quot;); Clerk.class.notify(); //唤醒因一些原因被执行wait()的线程 &#125; else &#123; //生产者生产过快，店员让生产者等待 try &#123; Clerk.class.wait(); //生产者生产太快，商品数量过多，被店员叫停休息 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; class Customer extends Thread &#123; private Clerk clerk; //声明Clerk对象，方便对于产品数的操作 public Customer(Clerk clerk) &#123; this.clerk = clerk; &#125; @Override public void run() &#123; while(true) &#123; try &#123; Thread.sleep(500); //阻塞线程，让其他线程有争夺的时间 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; synchronized(Clerk.class) &#123; if(clerk.getProduct() &gt; 0)&#123; //如果商品数量大于0，则消费者可以进行消费 System.out.println(Thread.currentThread().getName() + &quot;开始消费......&quot;); System.out.println(Thread.currentThread().getName() + &quot;正在准备消费第&quot; + clerk.getProduct() + &quot;个产品&quot;); System.out.println(Thread.currentThread().getName() + &quot;已经完成消费第&quot; + clerk.getProduct() + &quot;个产品&quot;); clerk.reduceProduct(); Clerk.class.notify(); //唤醒因一些原因被执行wait()的线程 &#125; else &#123; //消费者消费过快，店员让消费者等待 try &#123; Clerk.class.wait(); //消费者消费过快，商品数量不足，店员告诉消费者稍等 &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; &#125; &#125; /* 此实例实现过程中遇到的问题： 1.因为使用while循环，会导致一个线程一旦抢到CPU使用权后就不易被其他线程抢占，所以在进入同步代码块或同步方法前加上sleep来让其他线程有抢占CPU的机会 2.在同步代码块或同步方法中使用notify()和wait()时要注意调用者一定要是同步监视器，否则会报错IllegalMonitorStateException异常 */ 7.5.3 哪些操作会释放锁，哪些不会释放锁？1.释放锁的操作 当前线程的同步方法、同步代码块执行结束 当前线程在同步代码块、同步方法中遇到break、return终止了该代码块、该方法的继续执行 当前线程在同步代码块、同步方法中出现了未处理的Error或Exception，导致异常结束 当前线程在同步代码块、同步方法中执行了线程对象的wait()方法，当前线程暂停，并释放锁 2.不会释放锁的操作 线程执行同步代码块或同步方法时，程序调用**Thread.sleep()、Thread.yield()**方法暂停当前线程的执行 线程执行同步代码块时，其他线程调用了该线程的suspend()方法将该线程挂起，该线程不会释放锁（同步监视器） 应尽量避免使用suspend()和resume()来控制线程 7.6 JDK5新增的线程创建方式7.6.1 方法一：实现Callable接口与使用Runnable相比，Callable功能更强大些 相比run()方法，可以有返回值 方法可以抛出异常 支持泛型的返回值 需要借助FutureTask类，比如获取返回结果 Future接口： 可以对具体Runnable、Callable任务的执行结果进行取消、查询是否完成、获取结果等 FutrueTask是Futrue接口的唯一的实现类 FutureTask同时实现了Runnable，Future接口。它既可以作为Runnable被线程执行，又可以作为Future得到Callable的返回值 /* * 实现Callable接口创建线程 * * 如何理解实现Callable接口的方式创建多线程比实现Runnable接口创建多线程方式强大? * 1. calL()可以有返回值的 * 2. calL()可以抛出异常，被外面的操作捕获，获取异常的信息 * 3. Callable是支持泛型的 */ //1.创建一个实现Callable接口的实现类 class NumThread implements Callable &#123; //2.实现call方法，将此线程需要执行的操作声明在call()中 @Override public Object call() throws Exception &#123; //相当于run()方法 int sum = 0; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0) &#123; System.out.println(i); sum += i; &#125; &#125; return sum; &#125; &#125; public class ThreadTest10 &#123; public static void main(String[] args) &#123; //3.创建Callable接口实现类的对象 NumThread numThread = new NumThread(); //4.将此Callable接口实现类的对象传递到FutureTask构造器中，创建FutureTask的对象 FutureTask futureTask = new FutureTask(numThread); //5.将FutureTask的对象传递到Thread类中，创建线程对象，并调用start()方法 Thread thread = new Thread(futureTask); thread.start(); try &#123; //6.获取Callable中call()的返回值(如果需要的话) //get()方法的返回值即为FutureTask构造参数Callable实现类重写的call()的返回值 Object sum = futureTask.get(); System.out.println(&quot;总和为：&quot; + sum); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 7.6.2 方法二：线程池背景：经常创建和销毁、使用量特别大的资源，比如并发情况下的线程，对性能影响很大 思路：提前创建好多个线程，放入线程池中，使用时直接获取，使用完放回池中。可以避免频繁创建销毁、实现重复利用。类似生活中的公共交通工具 好处： 提高响应速度（减少了创建新线程的时间) 降低资源消耗（重复利用线程池中线程，不需要每次都创建) 便于线程管理 corePoolSize：核心池的大小 maximumPoolSize：最大线程数 keepAliveTime：线程没有任务时最多保持多长时间后会终止 线程池相关的API： JDK5.0起提供了线程池相关API：ExecutorService和 Executors ExecutorService：真正的线程池接口。常见子类ThreadPoolExecutor void execute(Runnable command)：执行任务/命令，没有返回值，一般用来执行Runnable Future submit(Callable task)：执行任务，有返回值，一般用来执行Callable void shutdown()：关闭连接池 Executors：工具类、线程池的工厂类，用于创建并返回不同类型的线程池 Executors.newCachedThreadPool()：创建一个可根据需要创建新线程的线程池 Executors.newFixedThreadPool(n)：创建一个可重用固定线程数的线程池 Executors.newSingleThreadExecutor()：创建一个只有一个线程的线程池 Executors.newScheduledThreadPool(n)：创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行 /* 创建新线程方式四：使用线程池 面试题：创建多线程的几种方法？四种 */ class NumberThread implements Runnable &#123; @Override public void run() &#123; for (int i = 1; i &lt;= 100; i++) &#123; if(i % 2 == 0) &#123; System.out.println(Thread.currentThread().getName() + &quot;:&quot; + i); &#125; &#125; &#125; &#125; public class ThreadTest11 &#123; public static void main(String[] args) &#123; //1.提供指定线程数量的线程池 ExecutorService service = Executors.newFixedThreadPool(10); //创建出一个ThreadPoolExecutor类型的线程池，返回一个ExecutorService接口，从源码关系可以看出这儿相当于向上转型 //如果想设置线程池的一些相关属性,需要将接口对象service向下转成实现类ThreadPoolExecutor对象才能调用其自身拥有的方法 ThreadPoolExecutor service1 = (ThreadPoolExecutor)service; service1.setCorePoolSize(15);//比如设置最大连接数 //2.执行指定的线程的操作，需要提供实现Runnable或Callable接口的实现类的对象 service.execute(new NumberThread());//适合使用于Runnable //执行的是创建出的线程池类型对应类中的execute()方法 //service.submit(Callable callable);//适合适用于Callable //3.关闭线程池 service.shutdown(); &#125; &#125; 八、Java常用类8.1 字符串相关的类8.1.1 String类1.String的特性 String类：代表字符串。Java程序中的所有字符串字面值（如 “abc”)都作为此类的实例实现 String是一个final类，代表不可变的字符序列 字符串是常量，用双引号引起来表示。它们的值在创建之后不能更改 String对象的字符内容是存储在一个字符数组value[]中的 String实现了serializable接口：表示字符串是支持序列化的 String实现了Comparable接口：表示String可以比较大小 String内部定义了final char[ ] value用于存储字符串数据 String：代表不可变的字符序列。简称：不可变性 当对字符串重新赋值时，会重写指定内存区域赋值，不能使用原有的value进行赋值 当对现有的字符串进行连接操作时，也会重新指定内存区域赋值，不能使用原有的value进行赋值 当调用String的replace()方法修改指定字符或字符串时，也会重新指定内存区域赋值 通过字面量的方式(区别于new）给一个字符串赋值，此时的字符串值声明在字符串常量池中 字符串常量池中是不会存储已有相同内容的字符串的 String s1 = &quot;abc&quot;; //字面量的定义方式 String s2 = &quot;abc&quot;; System.out.println(s1 == s2);//返回true s2 = &quot;hello&quot;; System.out.println(s1 == s2);//返回false System.out.println(s1);//abc System.out.println(s2);//hello String s3 = &quot;abc&quot;; System.out.print1n(s3);//abc s3 += &quot;def&quot;; System.out.print1n(s3);//abcdef String s4 = &quot;abc&quot;; String s5 = s4.replace(&#39;a&#39;,&#39;m&#39;); System.out.println(s4); //abc System.out.println(s5); //mbc 2.String 对象的创建面试题：String s = new String(“abc”)方式创建对象，在内存中创建了几个对象?两个：一个是堆空间中new结构，另一个是char[]对应的常量池中的数据：”abc” String str = &quot;he1lo&quot;; //字面量定义 String s1 = new String(); //本质上this.value = new char[0]; String s2 = new String(String original); //this.value = original.value; //this.value = Arrays.copy0f(value, value.length); String s3 = new String(char[] a); String s4 = new String(char[] a,int startIndex , int count) ; Person p1 = new Person(&quot;Tom&quot;,12); Person p2 = new Person(&quot;Tom&quot;,12); System.out.println(p1.name.equals(p2.name));//true System.out.println(p1.name == p2.name);//true //如果想改变名字，如p1.name = &quot;Jerry&quot;,还在常量池中又新开辟一个空间存储&quot;Jerry&quot; image-20210729172439917 3.String不同拼接操作的比较String s1 = &quot;javaEE&quot;; String s2 = &quot;hadoop&quot;; String s3 = &quot;javaEEhadoop&quot; ; String s4 = &quot;javaEE&quot; + &quot;hadoop&quot;; String s5 = s1 + &quot;hadoop&quot; ; String s6 = &quot;javaEE&quot; + s2; String s7 = s1 + s2; final String s8 = &quot;javaEE&quot;;//常量 String s9 = s9 + &quot;hadoop&quot;; System.out.println(s3 == s4);//true System.out.println(s3 == s5);//false System.out.println(s3 == s6);//false System.out.print1n(s3 == s7);//false System.out.println(s5 == s6);//false System.out.print1n(s5 == s7);//false System.out.println(s6 == s7);//false System.out.println(s3 == s9);//true，s8为final修饰，所以s9是常量加常量，也存储在常量池，所以为true String s8 = s5.intern();//返回值得到的s8使用的是常量池中已经存在的javaEEhadoop&quot; //str5调用intern()方法时，Java查找常量池中是否有相同Unicode的字符串常量，如果有，则返回其的引用，如果没有，则在常量池中增加一个Unicode等于str的字符串并返回它的引用 System.out.println(s3 == s8);//true image-20210729173652497 结论： 常量与常量的拼接结果在常量池。且常量池中不会存在相同内容的常量 只要其中有一个是变量，结果就在堆中 如果拼接的结果调用intern(方法，返回值就在常量池中 //练习：面试题 String str = new String(&quot;good&quot;); //此时str指向堆中的new String(&quot;good&quot;) char[] ch = &#123; &#39;t&#39;, &#39;e&#39;, &#39;s&#39;, &#39;t&#39; &#125;;//同样，ch指向堆中的test public void change(String str, char ch[]) &#123;//传入str和ch指向的对象的引用值 str = &quot;test ok&quot;; //此时是字面量创建，所以会创建在常量池中，但change外的str指向并没有变，所以输出仍是good ch[0] = &#39;b&#39;;//根据传入的数组的引用值，将其ch[0]的值改变了，所以输出best public static void main(String[] args) &#123; StringTest ex = new StringTest(); ex.change(ex.str, ex.ch); System.out.println(ex.str);//good System.out.println(ex.ch);//best &#125; 4.JVM中涉及字符串的内存结构JDK1.6：字符串常量池在方法区（具体实现：永生代）中 JDK1.7：字符串常量池在堆中 JDK1.8：字符串常量池在方法区（具体实现：元空间）中 5.String常用方法 int length()：返回字符串的长度: return value.length char charAt(int index)：返回某索引处的字符return value[index] boolean isEmpty()：判断是否是空字符串: return value.length == 0 String tol owerCase()：使用默认语言环境，将String中的所有字符转换为小写 String toUpperCase()：使用默认语言环境，将String中的所有字符转换为大写 String trim()：返回字符串的副本，忽略前导空白和尾部空白 boolean equals(Object obj)：比较字符串的内容是否相同 boolean equalslgnoreCase(String anotherString)：与equals方法类似， 忽略大小写 String concat(String str)：将指定字符串连接到此字符串的结尾。等价于用 “+” int compare To(String anotherString)：比较两个字符串的大小 String substring(int beginlndex)：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串 String substring(int beginIndex, int endIndex)：返回一个新字符串，它是此字符串从beginlndex开始截取到endIndex(不包含)的一个子字符串 String replace(char oldChar, char newChar)：返回一个新的字符串，它是通过用newChar替换此字符串中出现的所有oldChar得到的 String replace(CharSequence target, CharSequence replacement)：使用指定的字面值替换序列替换此字符串所有匹配字面值目标序列的子字符串 String replaceAll(String regex, String replacement)：使用给定的replacement替换此字符串所有匹配给定的正则表达式的子字符串 String replaceFirst(String regex, String replacement)：使用给定的replacement替换此字符串匹配给定的正则表达式的第一个子字符串 boolean matches(String regex)：告知此字符串是否匹配给定的正则表达式 String[] split(String regex)：根据给定正则表达式的匹配拆分此字符串 String[] split(String regex, int limit)：根据匹配给定的正则表达式来拆分此字符串，最多不超过limit个，如果超过了，剩下的全部都放到最后一个元素中 boolean endsWith(String suffix)：测试此字符串是否以指定的后缀结束 boolean startsWith(String prefix)：测试此字符串是否以指定的前缀开始 boolean startsWith(String prefix, int toffset)：测试此字符串从指定索引开始的子字符串是否以指定前缀开始 boolean contains(CharSequence s)：当且仅当此字符串包含指定的char值序列时，返回true //调用此方法的字符串是否含有传入的字符串 String str1 = &quot;helloworld&quot;; String str2 = &quot;wo&quot;; System.out.println(str1.contains(str2));//true int indexOf(String str)：返回指定子字符串在此字符串中第一次出现处的索引 int indexOf(String str, int fromlndex)：返回指定子字符串在此字符串中第一次出现处的索引，从指定的索引开始 int lastlndexOf(String str)：返回指定子字符串在此字符串中最右边出现处的索引 int lastlndexOf(String str, int fromIndex)：返回指定子字符串在此字符串中最后一次出现处的索引，从指定的索引开始反向搜索 注：indexOf和lastIndexOf方法如果未找到都是返回-1，如果只出现一次该子字符串，返回值相同 6.String与其他结构之间的转换①String与基本数据类型、包装类之间的转换//String --&gt;基本数据类型、包装类:调用包装类的静态方法: parseXx(str) String str1 = &quot;123&quot;; int num = (int)str1;//错误的 int num = Integer.parseInt(str1); //基本数据类型、包装类--&gt; String: 调用String重载的value0f(xxx) String str2 = String.valueOf(num);//&quot;123&quot; String str3 = num + &quot;&quot;; System.out.println(str1 == str3);//false，str1在常量池中，str3在堆中 ②String与char[]之间的转换//String --&gt; char[]: 调用String的toCharArray() String str1 = &quot;abc123&quot;; char[] charArray = str1. toCharArray(); for (int i = 0; i &lt; charArray.1ength; i++) &#123; System.out.print1n( charArray[i]); &#125; //char[] --&gt; String: 调用String的构造器 char[] arr = new char[]&#123;&#39;h&#39;,&#39;e&#39;,&#39;1&#39;,&#39;1&#39;,&#39;o&#39;&#125;; String str2 = new String(arr); System.out.println(str2); ③String与byte[]之间的转换//编码:字符串--&gt;字节 (看得懂 ---&gt; 看不懂的二进制数据) //解码:字节--&gt;字符串(看不懂的二进制数据 ---&gt;看得懂) //编码: String --&gt; byte[]:调用String的getBytes() //说明:解码时，要求解码使用的字符集必须与编码时使用的字符集一致，否则会出现乱码 String str1 = &quot;abc123中国&quot;; byte[] bytes = str1.getBytes();//使用默认的字符集，进行转换 System.out.println(Arrays.toString(bytes)); byte[] gbks = str1.getBytes(charsetName: &quot;gbk&quot; );//使用gbk字符集进行编码 System.out.println(Arrays.toString(gbks)); //解码: byte[] --&gt; String:调用String的构造器 String str2 = new String(bytes);//使用默认的字符集（UTF-8），进行解码 System. out. println(str2); String str3 = new String(gbks) ; System.out.println(str3);//出现乱码。原因:编码集和解码集不一致 7.String常见的算法题目 模拟一个trim()方法，去除字符串两端的空格 将一个字符串进行反转。将字符串中指定部分进行反转。比如“abcdefg”反转为”abfedcg” 获取一个字符串在另一个字符串中出现的次数，比如：获取”ab”在”abkkcadkabkebfkabkskab”中出现的次数 获取两个字符串中最大相同子串。比如：str1 = “abcwerthelloyuiodef”；str2 = “cvhellobnm” 提示：将短的那个串进行长度依次递减的子串与较长的串比较 对字符串中字符进行自然顺序排序 提示：①字符串变成字符数组 ②对数组排序，选择，冒泡，Arrays sor() ③将排序后的数组变成字符串 8.1.2 StringBuffer和StringBuilder1.StringBuffer类java.lang.StringBuffer代表可变的字符序列，JDK1.0中声明，可以对字符串内容进行增删，此时不会产生新的对象 很多方法都和String相同 作为参数传递时，方法内部可以改变值 在StringBuffer类中char[] value没有用final声明，value可以不断扩容；int count有效字符的个数 //源码分析 String str = new String();// &lt;=&gt; char[] value = new char[0]; String str1 = new String( &quot;abc&quot;);// &lt;=&gt; char[] value = new char[]&#123;&#39;a&#39;, &#39;b&#39;,&#39;c&#39;&#125;; StringBuffer sb1 = new StringBuffer();// &lt;=&gt; char[] value = new char[16]; 底层创建了一个长度是16的字符数组 System.out.println(sb1.Length());//输出0，因为该类的length()方法是返回数组中有效字符的个数即return count; sb1.append(&#39;a&#39;);//value[0] = &#39;a&#39;; sb1.append(&#39;b&#39;)://value[1] = &#39;b&#39;; StringBuffer sb2 = new StringBuffer( &quot;abc&quot;);//char[] value = new char[&quot;abc&quot;.Length()+16] //问题1. System.out.println(sb2.Length());//3 //问题2.扩容问题:如果要添加的数据底层数组盛不下了，那就需要扩容底层的数组。 //默认情况下，扩容为原来容量的2倍+ 2,同时将原有数组中的元素复制到新的数组中。 //指导意义:开发中建议大家使用: StringBuffer(int capacity) 或StringBuilder(int capacity) String str = nu1l; StringBuffer sb = new StringBuffer(); sb.append(str);//源码抽象类AbstractStringBuilder中会判断str是否为null，如果是则会调用appendNull()方法将null当作字符串拼接在sb后面 System.out.println(sb.1ength());//输出4 System.out.print1n(sb);//输出字符串&quot;null&quot; StringBuffer sb1 = new StringBuffer(str);//抛出NullPointerException异常 System.out.println(sb1); 2.StringBuilder类StringBuilder和StringBuffer非常类似，均代表可变的字符序列，而且提供相关功能的方法也一样 面试题：对比String、StringBuffer、 StringBuilder三者的异同String(JDK1.0)：不可变字符序列StringBuffer(JDK1.0)：可变字符序列、效率低、线程安全StringBuilder(JDK5.0)：可变字符序列、效率高、线程不安全 注意：作为参数传递的话，方法内部String不会改变其值，StringBuffer和StringBuilder会改变其值 3.StringBuffer和StringBuilder中的一些方法： StringBuffer append(xxx)：提供了很多的append()方法， 用于进行字符串拼接 StringBuffer delete(int start,int end)：删除指定位置的内容 StringBuffer replace(int start, int end, String str)：把[start,end)位置替换为str StringBuffer insert(int offset, xxX)：在指定位置插入xxx StringBuffer reverse()：把当前字符序列逆转 public int index0f(String str) public String substring(int start, int end) public int Length( ) public char charAt(int n) public void setCharAt(int n , char ch) 总结： 增：append(xxx)删：delete(int start, int end)改：setCharAt(int n ,char ch) / replace(int start, int end, String str)查：charAt(int n )插：insert(int offset, xxx) .长度：Length();遍历：for() + charAt() / toString() 4.String、StringBuffer、StringBuilder三者的效率对比//初始设置 long startTime = 0L; long endTime = 0L; String text = &quot;&quot;; StringBuffer buffer = new StringBuffer(&quot;&quot;); StringBuilder builder = new StringBuilder(&quot;&quot;); //开始对比 startTime = System.currentTimeMillis(); for(int i=0; i&lt;20000; i++)&#123; buffer.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuffer的执行时间: &quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for(int i=0; i&lt;20000; i++)&#123; builder.append(String.valueOf(i)); &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;StringBuilder的执行时间: &quot; + (endTime - startTime)); startTime = System.currentTimeMillis(); for(int i=0; i&lt;20000; i++)&#123; text = text + i; &#125; endTime = System.currentTimeMillis(); System.out.println(&quot;String的执行时间: &quot; + (endTime - startTime)); //StringBuilder&gt;StringBuffer&gt;String 8.2 日期时间相关的类8.2.1 java.lang.System类（JDK8之前）System类提供的public static long currentTimeMillis()用来返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差（此方法适于计算时间差） long time = System.currentTimeMillis(); //返回当前时间与1970年1月1日0时0分0秒之间以毫秒为单位的时间差 //称为时间戳 System.out.println(time); 计算世界时间的主要标准有： UTC(Coordinated Universal Time) GMT(Greenwich Mean Time) CST(Central Standard Time) 8.2.2 java.util.Date类（JDK8之前）表示特定的瞬间，精确到毫秒 构造器： Date():使用无参构造器创建的对象可以获取本地当前时间 Date(long date) 常用方法： getTime()：返回自 1970 年1月1日00:00:00 GMT 以来此Date对象表示的毫秒数 toString()：把此 Date对象转换为以下形式的String: dow mon dd hh:mm:ss zzz yyyy 其中: dow 是一周中的某一天 (Sun, Mon, Tue, Wed, Thu, Fri, Sat)，zzz是时间标准 其它很多方法都过时了 //构造器一：Date()，返回当前时间的Date对象 Date date = new Date(); System.out.println(date.toString());//Fri Jul 30 11:20:58 CST 2021 System.out.println(date.getTime());//1627615258490 //构造器二：Date(long date)，返回指定毫秒数的Date对象 Date date1 = new Date(372846236919L); System.out.println(date1);//Sun Oct 25 16:23:56 CST 1981 java.sql.Date对应着数据库中的日期类型的变量 如何实例化 java.sql.Date date2 = new java.sql.Date(9837592502580L); System.out.println(date2);//2281-09-28 如何将java.util.Date对象转换为java.sql.Date对象 //情况一: Date date4 = new java.sql.Date(2343243242323L); //子类转父类 java.sql.Date date5 = (java.sql.Date)date4; //可以赋值给子类对象 //情况二: Date date6 = new Date(); java.sq1.Date date7 = (java.sql.Date)date6 //父类直接向下转成子类，报错 java.sq1.Date date7 = new java.sq1.Date(date6.getTime()); //先将获得父类对象的毫秒数再利用构造器转换成sql中的日期 8.2.3 java.text.SimpleDateFormat类（JDK8之前）Date类的API不易于国际化，大部分被废弃了，java.text.SimpleDateFormat类是一个不与语言环境有关的方式来格式化和解析日期的具体类 它允许进行格式化：日期 -&gt; 文本、 解析：文本 -&gt; 日期 格式化：SimpleDateFormat()：默认的模式和语言环境创建对象public SimpleDateFormat(String pattern)：该构造方法可以用参数pattern指定的格式创建一个对象， 该对象调用:public String format(Date date)方法格式化时间对象date 解析：public Date parse(String source)：从给定字符串的开始解析文本，以生成一个日期 //使用默认构造器实例化SimpleDateFormat对象 SimpleDateFormat simpleDateFormat = new SimpleDateFormat(); //格式化：日期 --&gt; 字符串 Date date = new Date(); String format = simpleDateFormat.format(date); System.out.println(format); //解析：字符串 --&gt; 日期 String str = &quot;21-7-31 上午10:23&quot;;//使用SimpleDateFormat默认构造器实例化的对象必须使用这种这种格式，否则会抛出异常 Date date1 = simpleDateFormat.parse(str); System.out.println(date1); //按照指定格式进行格式化和解析：调用带参的构造器 System.out.println(&quot;============指定格式==============&quot;); SimpleDateFormat sdf = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;);//传入的参数即为日期要格式化和解析的格式 //格式化 Date date2 = new Date(); String format1 = sdf.format(date2); System.out.println(format1); //解析：要求字符串必须是符合SimpleDateFormat的格式 String str1 = &quot;2021-07-31 10:34:45&quot;; Date date3 = sdf.parse(str1); System.out.println(date3); 8.2.4 java.utils.Calendar(日历)类（JDK8之前）Calendar是一个抽象基类，主用用于完成日期字段之间相互操作的功能 获取Calendar实例的方法： 使用**Calendar.getInstance()**方法 调用它的子类GregorianCalendar的构造器 一个Calendar的实例是系统时间的抽象表示，通过get(int field)方法来取得想要的时间信息。比如YEAR、MONTH、DAY_OF_ _WEEK、HOUR_OF_DAY 、MINUTE、SECOND public void set(int field,int value) public void add(int field,int amount) public final Date getTime() public final void setTime(Date date) 注意： 获取月份时：一月是0，二月是1，以此类推，12月是11 获取星期时：周日是1，周二是2，。。。。周六是7 //1.实例化 //方式一：创建其子类（GregorianCalendar）的对象 //方式二：调用其静态方法getInstance() Calendar calendar = Calendar.getInstance();//返回的其实还是子类GregorianCalendar的对象 //2.常用方法 int days = calendar.get(Calendar.DAY_OF_MONTH);//get(),获取当前calendar对象对应字段的值 System.out.println(days); System.out.println(&quot;==============&quot;); calendar.set(Calendar.DAY_OF_MONTH,22);//set(),设置当前calendar对象的属性字段值， days = calendar.get(Calendar.DAY_OF_MONTH); System.out.println(days); System.out.println(&quot;==============&quot;); calendar.add(Calendar.DAY_OF_MONTH,4);//add(),在当前calendar对象对应字段值的基础上加减 System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); System.out.println(&quot;==============&quot;); Date date = calendar.getTime();//getTime(),日历类 --&gt; Date System.out.println(date); System.out.println(&quot;==============&quot;); Date date1 = new Date(); calendar.setTime(date1);//setTime(),Date --&gt; 日历类 System.out.println(calendar.get(Calendar.DAY_OF_MONTH)); 8.2.5 java.time（JDK8中）Java8吸收了Joda-Time的精华，以一个新的开始为Java创建优秀的API 新的java.time中包含了所有关于本地日期(LocalDate) 、本地时间(LocalTime)、本地日期时间(LocalDateTime) 、时区( ZonedDate Time)和持续时间(Duration)的类。历史悠久的Date类新增了tolnstant() 方法, 用于把Date转换成新的表示形式 LocalDate、LocalTime、LocalDateTime类是其中较重要的几个类，它们的实例是不可变的对象，分别表示使用ISO-8601日历系统的日期、时间、日期和时间。它们提供了简单的本地日期或时间，并不包含当前的时间信息，也不包含与时区相关的信息 LocalDate代表IOS格式(yyyy-MM-dd) 的日期，可以存储生日、纪念日等日期 LocalTime表示一个时间， 而不是日期 LocalDateTime是用来表示日期和时间的，这是一个最常用的类之一 注：ISO-8601日历系统是国际标准化组织制定的现代公民的日期和时间的表示法，也就是公历 1.LocalDate、LocalTime、LocalDateTime类 方法 描述 now() / * now(Zoneld zone) 静态方法，根据当前时间创建对象/指定时区的对象 of() 静态方法，根据指定日期/时间创建对象 getDayOfMonth()/getDayOfYear() 获得月份天数(1-31) /获得年份天数(1-366) getDayOfWeek() 获得星期几(返回一个DayOfWeek枚举值) getMonth() 获得月份，返回一个Month枚举值 getMonthValue()/getYear() 获得月份(1-12)/获得年份 getHour()/getMinute()/getSecond() 获得当前对象对应的小时、分钟、秒 withDayOfMonth()/withDayOfYear()/withMonth()/withYear() 将月份天数、年份天数、月份、年份修改为指定的值并返回新的对象 plusDays(), plusWeeks(),plusMonths(), plusYears(),plusHours() 向当前对象添加几天、几周、几个月、几年、几小时 minusMonths()/minusWeeks()/minusDays()/minus Years()/minusHours 从当前对象减去几月、几周、几天、几年、几小时 //jdk8中的时间API //LocalDate、LocalTime、LocalDateTime获取当前的日期、时间、日期+时间，LocalDateTime使用最多 //方法一：now()实例化对象 LocalDate now = LocalDate.now(); LocalTime now1 = LocalTime.now(); LocalDateTime now2 = LocalDateTime.now(); System.out.println(now); System.out.println(now1); System.out.println(now2); //方法二：of()实例化对象，可指定具体的日期和时间年、月、日、时、分、秒,没有偏移量 LocalDateTime of = LocalDateTime.of(2021, 7, 31, 16, 30, 34); System.out.println(of); //getXxx() System.out.println(of.getDayOfMonth()); System.out.println(of.getDayOfWeek()); System.out.println(of.getMonth()); System.out.println(of.getMonthValue()); System.out.println(of.getMinute()); //withXxxx(),返回新的对象，原对象仍然保存，体现出不可变性 LocalDateTime localDateTime = of.withDayOfMonth(20); System.out.println(localDateTime); //plusXxxx(),返回新的对象，原对象仍然保存，体现出不可变性 LocalDateTime localDateTime1 = of.plusMonths(2); System.out.println(localDateTime1); //minusXxxx(),返回新的对象，原对象仍然保存，体现出不可变性 LocalDateTime localDateTime2 = of.minusHours(2); System.out.println(localDateTime2); 2.Instant类Instant：时间线上的一个瞬时点。这可能被用来记录应用程序中的事件时间戳 在处理时间和日期的时候，我们通常会想到年，月，日，时，分，秒。然而，这只是时间的一个模型，是面向人类的。第二种通用模型是面向机器的，或者说是连续的。在此模型中，时间线中的一个点表示为一个很大的数，这有利于计算机处理。在UNIX中，这个数从1970年开始， 以秒为的单位；同样的，在Java中，也是从1970年开始，但以毫秒为单位 javatime包通过值类型Instant提供机器视图，不提供处理人类意义上的时间单位。Instant表示时间线上的一点，而不需要任何上下文信息，例如，时区。概念上讲，它只是简单的表示自1970年1月1日0时0分0秒(UTC)开始的秒数。因为java.time包是基于纳秒计算的，所以Instant的精度可以达到纳秒级 (1ns= 10^-9s) 1秒= 1000毫秒=10^6微秒=10^9纳秒 方法 描述 now() 静态方法，返回默认UTC时区的Instant类的对象 ofEpochMill(long epochMili) 静态方法，返回在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象 atOffset(ZoneOffset offset) 结合即时的偏移来创建一个OffsetDateTime toEpochMilli() 返回1970-01-01 00:00:00到当前时间的毫秒数，即为时间戳 时间戳是指格林威治时间1970年01月01日00时00分00秒(北京时间1970年01月01日08时00分00秒)起至现在的总秒数 //now(),本初子午线的标准时间 Instant now = Instant.now(); System.out.println(now);//2021-07-31T09:15:43.844Z //atOffset(),添加时间偏移量 OffsetDateTime offsetDateTime = now.atOffset(ZoneOffset.ofHours(8)); System.out.println(offsetDateTime);//2021-07-31T17:15:43.844+08:00 //toEpochMilli(),获取自1970年1月1日0时0分0秒（UTC）开始到当前的毫秒数，类似于getTime() long milli = now.toEpochMilli(); System.out.println(milli);//1627722943844 //ofEpochMilli(),创建在1970-01-01 00:00:00基础上加上指定毫秒数之后的Instant类的对象，类似于new Date(long milli) Instant instant = Instant.ofEpochMilli(1627722943844L); System.out.println(instant);//2021-07-31T09:15:43.844Z 3.java.time.format.DateTimeFormpatter类java.time.format.DateTimeFormpatter类类似于SimpleDateFormat类，都是格式化或解析日期、时间的类 该类提供了三种格式化方法： 预定义的标准格式。如:ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME 本地化相关的格式。 如：ofLocalizedDateTime(FormatStyle.LONG/FormatStyle.MEDIUM/FormatStyLe.SHORT)、ofLocalizedDate(FormatStyLe.FULL/FormatStyLe.LONG/FormatStyLe.MEDIUM/FormatStyLe.SHORT) 自定义的格式。如：ofPattern(“yyyy-MM-dd hh:mm:ss E”) 方法 描述 ofPattern(String pattern) 静态方法，返回一个指定字符串格式的DateTimeFormatter format(TemporalAccessor t) 格式化一个日期、 时间，返回字符串 parse(CharSequence text) 将指定格式的字符序列解析为一个日期、时间 //方法一：预定义的标准格式。如:ISO_LOCAL_DATE_TIME；ISO_LOCAL_DATE；ISO_LOCAL_TIME DateTimeFormatter formatter = DateTimeFormatter.ISO_LOCAL_DATE_TIME; //格式化:日期 ---&gt; 字符串 LocalDateTime now = LocalDateTime.now(); String str = formatter.format(now); System.out.println(now);//2021-07-31T18:00:04.243 System.out.println(str);//2021-07-31T18:00:04.243 //解析:字符串 ---&gt; 日期 TemporalAccessor parse = formatter.parse(&quot;2021-07-31T17:38:27.063&quot;); System.out.println(parse);//&#123;&#125;,ISO resolved to 2021-07-31T17:38:27.063 //方法二： //本地化相关的格式。 如：ofLocalizedDateTime(FormatStyle.LONG) LocalDateTime now1 = LocalDateTime.now(); DateTimeFormatter formatter1 = DateTimeFormatter.ofLocalizedDateTime(FormatStyle.LONG); //格式化 String str1 = formatter1.format(now1); System.out.println(now1);//2021-07-31T18:00:04.251 System.out.println(str1);//2021年7月31日 下午06时00分04秒 //解析 TemporalAccessor parse1 = formatter1.parse(&quot;2021年7月31日 下午05时52分08秒&quot;); System.out.println(parse1);//&#123;&#125;,ISO resolved to 2021-07-31T17:52:08 //本地化相关的格式。 如：ofLocalizedDate(FormatStyle.FULL) LocalDate now2 = LocalDate.now(); DateTimeFormatter formatter2 = DateTimeFormatter.ofLocalizedDate(FormatStyle.FULL); //格式化 String str2 = formatter2.format(now2); System.out.println(now2);//2021-07-31 System.out.println(str2);//2021年7月31日 星期六 //解析 TemporalAccessor parse2 = formatter2.parse(&quot;2021年7月31日 星期六&quot;); System.out.println(parse2);//&#123;&#125;,ISO resolved to 2021-07-31 //方法三：重点：自定义的格式。如：ofPattern(&quot;yyyy-MM-dd hh:mm:ss E&quot;) DateTimeFormatter formatter3 = DateTimeFormatter.ofPattern(&quot;yyyy-MM-dd hh:mm:ss&quot;); //格式化 String str3 = formatter3.format(LocalDateTime.now()); System.out.println(str3);//2021-07-31 06:06:53 //解析 TemporalAccessor parse3 = formatter3.parse(&quot;2021-07-31 06:06:37&quot;); System.out.println(parse3);//&#123;SecondOfMinute=37, HourOfAmPm=6, MicroOfSecond=0, NanoOfSecond=0, MinuteOfHour=6, MilliOfSecond=0&#125;,ISO resolved to 2021-07-31 4.其他APIZoneId：该类中包含了所有的时区信息，一个时区的ID，如Europe/Paris ZonedDateTime：一个在IS0-8601日历系统时区的日期时间，如2007-12-03T10:15:30+01:00 Europe/Paris 其中每个时区都对应着ID，地区ID都为“{区域}{城市}”的格式，例如：Asia/Shanghai等 Clock：使用时区提供对当前即时、日期和时间的访问的时钟 持续时间: Duration, 用于计算两个“时间”间隔 日期间隔: Period， 用于计算两个“日期”间隔 TemporalAdjuster：时间校正器。有时我们可能需要获取例如：将日期调整到“下一个工作日”等操作 TemporalAdjusters：该类通过静态方法(firstDayOfXxx()/lastDayOfXxx()/nextXxx())提供了大量的常用TemporalAdjuster的实现 8.3 Java比较器Java实现对象排序的方式有两种： 自然排序：java.lang.Comparable 定制排序：java.util.Comparator 说明：Java中的对象，正常情况下，只能进行比较：==或!=。不能使用&gt;或&lt;的，但是在开发场景中，我们需要对多个对象进行排序，言外之意，就需要比较对象的大小 如何实现呢?使用两个接口中的任何一个: Comparable 或Comparator 8.3.1 Comparable接口(自然排序)Comparable接口强行对实现它的每个类的对象进行整体排序。这种排序被称为类的自然排序 实现Comparable的类必须实现compare To(Object obj)方法，两个对象即通过compareTo(Object obj)方法的返回值来比较大小。如果当前对象this大于形参对象obj，则返回正整数，如果当前对象this小于形参对象obj，则返回负整数，如果当前对象this等于形参对象obj，则返回零 实现Comparable接口的对象列表(和数组)可以通过Collections.sort或Arrays.sort进行自动排序。实现此接口的对象可以用作有序映射中的键或有序集合中的元素，无需指定比较器 对于类C的每一个e1和e2来说，当且仪当e1.compareTo(e2) == 0与e1.equals(e2)具有相同的boolean值时，类C的自然排序才叫做与equals一致。建议(虽然不是必需的)最好使自然排序与equals一致 //Comparable接口的使用实例： //1.String、包装类等实现了Comparable接口，重写了compareTo(obj)方法，给出了比较两个对象大小的方法 //2.String、包装类重写compareTo()方法以后，进行了从小到大的排列 //3.重写compareTo(obj)的规则: // 如果当前对象上his大于形参对象obj,则返回正整数， // 如果当前对象this小于形参对象obj,则返回负整数， // 如果当前对象this等于形参对象obj,则返回零。 String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;; Arrays.sort(arr);//sort方法底层是通过Comparable接口实现的，即传入数组的元素的类型必须要实现Comparable接口，然后会调用ComparableTo()方法进行各元素间的比较 System.out.println(Arrays.toString(arr));//[AA, CC, DD, GG, JJ, KK, MM] //4.对于自定义类来说,如果需要排序,我们可以让自定义类实现Comparable接口,重写compareTo(obj)方法,在方法中指明如何排序，从另一方面说明了需要进行比较的数组元素类型对应的类必须实现Comparable接口 public class Goods implements Comparable &#123; private String name; private double price; public Goods() &#123; &#125; public Goods(String name, double price) &#123; this.name = name; this.price = price; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public double getPrice() &#123; return price; &#125; public void setPrice(double price) &#123; this.price = price; &#125; @Override public String toString() &#123; return &quot;Goods&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, price=&quot; + price + &#39;&#125;&#39;; &#125; //指明商品比较大小的方式：按价格从低到高 @Override public int compareTo(Object o) &#123; if(o instanceof Goods) &#123; Goods goods = (Goods) o; //方式一： if(this.price &gt; goods.price) return 1; else if(this.price &lt; goods.price) return -1; else return 0; //方式二： //return Double.compare(this.price,goods.price); &#125; throw new RuntimeException(&quot;传入的数据类型不正确&quot;); &#125; &#125; main()&#123; Goods[] goods = new Goods[4]; goods[0] = new Goods(&quot;lenovoMouse&quot;,34); goods[1] = new Goods(&quot;dellMouse&quot;,43); goods[2] = new Goods(&quot;xiaomiMouse&quot;,20); goods[3] = new Goods(&quot;huaweiMouse&quot;,65); Arrays.sort(goods); System.out.println(Arrays.toString(goods));//[Goods&#123;name=&#39;xiaomiMouse&#39;, price=20.0&#125;, Goods&#123;name=&#39;lenovoMouse&#39;, price=34.0&#125;, Goods&#123;name=&#39;dellMouse&#39;, price=43.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=65.0&#125;] &#125; 8.3.2 Comparator接口(定制排序)当元素的类型没有实现java.lang.Comparable接口而又不方便修改代码，或者实现了java.lang.Comparable接口的排序规则不适合当前的操作，那么可以考虑使用Comparator 的对象来排序，强行对多个对象进行整体排序的比较 重写compare(Object o1,Object o2)方法，比较o1和o2的大小：如果方法返回正整数，则表示o1大于o2；如果返回0，表示相等；返回负整数，表示o1小于o2 可以将Comparator传递给sort方法(如Collections.sort或Arrays.sort)，从而允许在排序顺序上实现精确控制 还可以使用Comparator来控制某些数据结构（如有序set或有序映射）的顺序，或者为那些没有自然顺序的对象collection提供排序 //Comparator接口 //String类测试 String[] arr = new String[]&#123;&quot;AA&quot;,&quot;CC&quot;,&quot;KK&quot;,&quot;MM&quot;,&quot;GG&quot;,&quot;JJ&quot;,&quot;DD&quot;&#125;; Arrays.sort(arr,new Comparator()&#123; //字符串从大到小进行排列 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof String &amp;&amp; o2 instanceof String) &#123; String s1 = (String) o1; String s2 = (String) o2; return -s1.compareTo(s2); &#125; throw new RuntimeException(&quot;输入的数据类型不一致&quot;); &#125; &#125;); System.out.println(Arrays.toString(arr));//[MM, KK, JJ, GG, DD, CC, AA] //自定义类测试 Goods[] goods = new Goods[5]; goods[0] = new Goods(&quot;lenovoMouse&quot;,34); goods[1] = new Goods(&quot;dellMouse&quot;,43); goods[2] = new Goods(&quot;xiaomiMouse&quot;,20); goods[3] = new Goods(&quot;huaweiMouse&quot;,65); goods[4] = new Goods(&quot;huaweiMouse&quot;,165); Arrays.sort(goods,new Comparator() &#123; //商品先按商品名从低到高排，如果商品名一样则按价格从高到低排 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof Goods &amp;&amp; o2 instanceof Goods) &#123; Goods goods1 = (Goods) o1; Goods goods2 = (Goods) o2; if(goods1.getName().equals(goods2.getName()))&#123; return -Double.compare(goods1.getPrice(),goods2.getPrice());//价格从高到低排 &#125;else&#123; return goods1.getName().compareTo(goods2.getName());//商品名字从低到高排序 &#125; &#125; throw new RuntimeException(&quot;比较的类型不一样&quot;); &#125; &#125;); System.out.println(Arrays.toString(goods));//[Goods&#123;name=&#39;dellMouse&#39;, price=43.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=165.0&#125;, Goods&#123;name=&#39;huaweiMouse&#39;, price=65.0&#125;, Goods&#123;name=&#39;lenovoMouse&#39;, price=34.0&#125;, Goods&#123;name=&#39;xiaomiMouse&#39;, price=20.0&#125;] 8.3.3 Comparable接口与Comparator接口的简单对比Comparable接口的方式一旦一定，保证Comparable接口实现类的对象在任何位置都可以比较大小 Comparator接口属于临时性的比较 8.4 System类System类代表系统，系统级的很多属性和控制方法都放置在该类的内部。该类位于java.lang包 由于该类的构造器是private的，所以无法创建该类的对象，也就是无法实例化该类。其内部的成员变量和成员方法都是static的，所以也可以很方便的进行调用。 成员变量 System类内部包含in、out和err三个成员变量，分别代表标准输入流(键盘输入)，标准输出流(显示器)和标准错误输出流(显示器) 成员方法 native long currentTimeMillis()：该方法的作用是返回当前的计算机时间，时间的表达格式为当前计算机时间和GMT时间(格林威治时间)1970年1月1号0时0分0秒所差的毫秒数 void exit(int status)：该方法的作用是退出程序。其中status的值为0代表正常退出，非零代表异常退出。使用该方法可以在图形界面编程中实现程序的退出功能等 void gc()：该方法的作用是请求系统进行垃圾回收。至于系统是否立刻回收，则取决于系统中垃圾回收算法的实现以及系统执行时的情况 String getProperty(String key)：该方法的作用是获得系统中属性名为key的属性对应的值。系统中常见的属性名以及属性的作用如下表所示： 属性名 属性说明 java.version Java运行时环境版本 java.home Java安装目录 os.name 操作系统的名称 os.version 操作系统的版本 user.name 用户的账户名称 user.home 用户的主目录 user.dir 用户的当前工作目录 String javaVersion = System.getProperty(&quot;java.version&quot;); System.out.println(&quot;java的version:&quot; + javaVersion);//java的version:1.8.0_291 String javaHome = System.getProperty(&quot;java.home&quot;); System.out.println(&quot;java的home:&quot; + javaHome);//java的home:C:\\ProgramFiles\\Java\\jdk1.8.0_291\\jre String osName = System.getProperty(&quot;os.name&quot;); System.out.println(&quot;os的name:&quot; + osName );//os的name:Windows 10 String osVersion = System.getProperty(&quot;os.version&quot;); System.out.println(&quot;os的version:&quot; + osVersion);//os的version: 10.0 String userName = System.getProperty(&quot;user.name&quot; ); System.out.println(&quot;user的name:&quot; + userName);//user的name:Administrator String userHome = System.getProperty(&quot;user.home&quot;); System.out.println(&quot;user的home:&quot; + userHome);//user的home:C:\\Users\\Administrator String userDir = System.getProperty(&quot;user.dir&quot;); System.out.println(&quot;user的dir:&quot; + userDir);//user的dir:E:\\JavaProject\\IDEAProject\\自主练习\\Demo 8.5 Math类java.lang.Math提供了一系列静态方法用于科学计算。其方法的参数和返回值类型一般为double型 方法名 用法 abs 绝对值 acos,asin,atan,cos,sin,tan 三角函数 sqrt 平方根 pow(double a,doble b) a的b次幂 log 自然对数 exp e为底指数 max(double a,double b) 取a与b之间的最大值 min(double a,double b) 取a与b之间的最小值 random() 返回0.0到1.0的随机数 long round(double a) double型数据a转换为long型(四舍五入) toDegrees(double angrad) 弧度 –&gt; 角度 toRadians(double angdeg) 角度 –&gt; 弧度 8.6 BigInteger与BigDecimal8.6.1 BigInteger类java.math包的BigInteger可以表示不可变的任意精度的整数。BigInteger提供所有Java的基本整数操作符的对应物，并提供java.lang.Math的所有相关方法。另外，BigInteger 还提供以下运算：模算术、GCD计算、质数测试、素数生成、位操作以及一些其他操作 构造器：BigInteger(String val)：根据字符串构建BigInteger对象 常用方法： public BigInteger abs()：返回此BigInteger的绝对值的BigInteger BigInteger add(BigInteger val)：返回其值为**(this + val)**的BigInteger BigInteger subtract(BigInteger val)：返回其值为**(this - val)**的BigInteger BigInteger multiply(BigInteger val)：返回其值为**(this * val)**的BigInteger BigInteger divide(BigInteger val)：返回其值为**(this / val)的BigInteger。整数相除只保留整数部分** BigInteger remainder(BigInteger val)：返回其值为**(this % val)**的BigInteger BigInteger[] divideAndRemainder(BigInteger val)：返回包含**(this / val)后跟(this % val)**的两个BigInteger的数组 BigInteger pow(int exponent)：返回其值为**(this^exponent)**的BigInteger 8.6.2 BigDecimal类一般的Float类和Double类可以用来做科学计算或工程计算，但在商业计算中，要求数字精度比较高，故用到java.math.BigDecimal类 BigDecimal类支持不可变的、任意精度的有符号十进制定点数 构造器 public BigDecimal(double val) public BigDecimal(String val) 常用方法 public BigDecimal add(BigDecimal augend) public BigDecimal subtract(BigDecimal subtrahend) public BigDecimal multiply(BigDecimal multiplicand) public BigDecimal divide(BigDecimal divisor, int scale, int roundingMode) BigInteger bi = new BigInteger(&quot;12433241123&quot;); BigDecimal bd = new BigDecimal(&quot;12435.351&quot;); BigDecimal bd2 = new BigDecimal(&quot;11&quot;); System.out.println(bi);//12433241123 //System.out.println(bd.divide(bd2)); //除不尽就必须要告诉保留多少位 System.out.println(bd.divide(bd2,BigDecimal.ROUND_HALF_UP));//1130.486 System.out.println(bd.divide(bd2,15,BigDecimal.ROUND_HALF_UP));//1130.486454545454545 九、枚举类和注解9.1 枚举(enum)Java 枚举是一个特殊的类，一般表示一组常量，比如一年的 4 个季节，一个年的 12 个月份，一个星期的 7 天，方向有东南西北等。当需要定义一组常量时，强烈建议使用枚举类 Java 枚举类使用 enum 关键字来定义，类的对象只有有限个，确定的；各个常量使用逗号 , 来分割 JDK5之前自定义一个季节枚举类 class Season&#123; //1.声明Season属性：private final修饰 private final String seasonName; private final String seasonDesc; //2.私有化类的构造器，并给对象赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //3.提供当前枚举类的多个对象 public static final Season SPRING = new Season(&quot;春天&quot; ,&quot;春暖花开&quot;); public static final Season SUMMER = new Season(&quot;夏天&quot;,&quot;夏日炎炎&quot;); public static final Season AUTUMN = new Season(&quot;秋天&quot; ,&quot;秋高气爽&quot;); public static final Season WINTER = new Season(&quot;冬天&quot; ,&quot;冰天雪地&quot;); //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //其他诉求2：提供toString()方法 @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#39;&quot; + seasonName + &#39;\\&#39;&#39; + &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; &#125; JDK5之后自定义一个季节枚举类 //使用enum定义的枚举类默认继承java.lang.Enum类 enum Season &#123; //1.提供当前枚举类的对象，多个对象之间用&quot;,&quot;隔开，最后用&quot;;&quot;结束 SPRING(&quot;春天&quot; ,&quot;春暖花开&quot;), SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;), AUTUMN(&quot;秋天&quot; ,&quot;秋高气爽&quot;), WINTER(&quot;冬天&quot; ,&quot;冰天雪地&quot;); //2.声明Season属性：private final修饰 private final String seasonName; private final String seasonDesc; //3.私有化类的构造器，并给对象赋值 private Season(String seasonName,String seasonDesc)&#123; this.seasonName = seasonName; this.seasonDesc = seasonDesc; &#125; //4.其他诉求1：获取枚举类对象的属性 public String getSeasonName() &#123; return seasonName; &#125; public String getSeasonDesc() &#123; return seasonDesc; &#125; //其他诉求2：提供toString()方法，此时的toString方法可不提供，因为这个枚举类继承自Enum类，打印输出的仍是这个枚举类对象的对象名 @Override public String toString() &#123; return &quot;Season&#123;&quot; + &quot;seasonName=&#39;&quot; + seasonName + &#39;\\&#39;&#39; + &quot;, seasonDesc=&#39;&quot; + seasonDesc + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; &#125; 9.1.1 枚举类成员枚举跟普通类一样可以用自己的变量、方法和构造函数，构造函数只能使用 private 访问修饰符，所以外部无法调用 枚举类既可以包含具体方法，也可以包含抽象方法。 如果枚举类具有抽象方法，则枚举类的每个实例都必须实现它 enum Color &#123; RED, GREEN, BLUE; // 构造函数 private Color() &#123; System.out.println(&quot;Constructor called for : &quot; + this.toString()); &#125; public void colorInfo() &#123; System.out.println(&quot;Universal Color&quot;); &#125; &#125; public class Test &#123; // 输出 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); c1.colorInfo(); &#125; &#125; 枚举类中抽象方法的实现： enum Color &#123; RED &#123; public String getColor()&#123;//枚举对象实现抽象方法 return &quot;红色&quot;; &#125; &#125;, GREEN&#123; public String getColor()&#123;//枚举对象实现抽象方法 return &quot;绿色&quot;; &#125; &#125;, BLUE&#123; public String getColor()&#123;//枚举对象实现抽象方法 return &quot;蓝色&quot;; &#125; &#125;; public abstract String getColor();//定义抽象方法 &#125; 9.1.2 values()，ordinal()和valueOf()方法enum 定义的枚举类默认继承了 java.lang.Enum 类，并实现了 java.lang.Seriablizable 和 java.lang.Comparable 两个接口。 values(), ordinal() 和 valueOf() 方法位于 java.lang.Enum 类中： values()：枚举类中所有的值 ordinal()：可以找到每个枚举常量的索引，就像数组索引一样 valueOf()：返回指定字符串值的枚举常量 toString()：返回当前枚举类对象常量的名称 enum Color &#123; RED, GREEN, BLUE; &#125; public class Test &#123; public static void main(String[] args) &#123; // 调用 values() Color[] arr = Color.values(); // 迭代枚举 for (Color col : arr) &#123; // 查看索引 System.out.println(col + &quot; at index &quot; + col.ordinal()); &#125; // 使用 valueOf() 返回枚举常量，不存在的会报错 IllegalArgumentException System.out.println(Color.valueOf(&quot;RED&quot;)); // System.out.println(Color.valueOf(&quot;WHITE&quot;)); &#125; &#125; 9.1.3 使用Enum关键字定义的枚举类实现接口情况一：实现接口，在enum类中实现抽象方法 情况二：让枚举类的对象分别实现接口中的抽象方法 interface Info&#123; void show(); &#125; enum Season implements Info&#123; //枚举类实现接口情况一：实现接口中的抽象方法 @Override public void show() &#123; System.out.println(&quot;这一个季节&quot;); &#125; //枚举类实现接口情况二：每个枚举类对象独立实现抽象方法 SPRING(&quot;春天&quot; ,&quot;春暖花开&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;这是春天&quot;); &#125; &#125;, SUMMER(&quot;夏天&quot;,&quot;夏日炎炎&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;这是夏天&quot;); &#125; &#125;, AUTUMN(&quot;秋天&quot; ,&quot;秋高气爽&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;这是秋天&quot;); &#125; &#125;, WINTER(&quot;冬天&quot; ,&quot;冰天雪地&quot;)&#123; @Override public void show() &#123; System.out.println(&quot;这是冬天&quot;); &#125; &#125;; &#125; 9.1.4 内部类中使用枚举枚举类可以声明在内部类中： public class Test &#123; enum Color &#123; RED, GREEN, BLUE; &#125; // 执行输出结果 public static void main(String[] args) &#123; Color c1 = Color.RED; System.out.println(c1); //输出为RED &#125; &#125; 每个枚举都是通过 Class 在内部实现的，且所有的枚举值都是 public static final 的。 以上的枚举类 Color 转化在内部类实现： class Color &#123; public static final Color RED = new Color(); public static final Color BLUE = new Color(); public static final Color GREEN = new Color(); &#125; 9.1.5 迭代枚举元素可以使用for语句来迭代枚举元素： enum Color &#123; RED, GREEN, BLUE; &#125; public class MyClass &#123; public static void main(String[] args) &#123; for (Color myVar : Color.values()) &#123; System.out.println(myVar); &#125; &#125; &#125; 9.1.6 在switch中使用枚举类枚举类常运用于switch语句中： enum Color &#123; RED, GREEN, BLUE; &#125; public class MyClass &#123; public static void main(String[] args) &#123; Color myVar = Color.BLUE; switch(myVar) &#123; case RED: System.out.println(&quot;红色&quot;); break; case GREEN: System.out.println(&quot;绿色&quot;); break; case BLUE: System.out.println(&quot;蓝色&quot;); break; &#125; &#125; &#125; 9.2 注解(Annotation)从JDK5.0开始，Java增加了对元数据(MetaData)的支持，也就是Annotation(注解) Annotation其实就是代码里的特殊标记，这些标记可以在编译，类加载，运行时被读取，并执行相应的处理。通过使用Annotation，程序员可以在不改变原有逻辑的情况下,在源文件中嵌入一些补充信息。代码分析工具、开发工具和部署工具可以通过这些补充信息进行验证或者进行部署 Annotation可以像修饰符一样被使用，可用于修饰包，类，构造器，方法，成员变量，参数，局部变量的声明，这些信息被保存在Annotation的“name=value”对中 JavaSE中，注解的使用目的比较简单，例如标记过时的功能，忽略警告等。在JavaEE/Android中注解占据了更重要的角色，例如用来配置应用程序的任何切面，代替JavaEE旧版中所遗留的繁冗代码和XML配置等 未来的开发模式都是基于注解的，JPA是基于注解的，Spring2.5以上都是基于注解的，Hibernate3.x以后也是基于注解的，现在的Struts2有一部分也是基于注解的了，注解是一种趋势，一定程度上可以说：框架=注解＋反射＋设计模式 9.2.1 常见的Annotation示例使用Annotation时要在其前面增加**@**符号，并把该Annotation当成一个修饰符使用。用于修饰它支持的程序元素 示例一：生成文档相关的注解@author 标明开发该类模块的作者，多个作者之间使用”,”分割 @version 标明该类模块的版本 @see 参考转向，也就是相关主题 @since 从哪个版本开始增加的 @param 对方法中某参数的说明，如果没有参数就不能写 @return 对方法返回值的说明，如果方法的返回值类型是void就不能写 @exception 对方法可能抛出的异常进行说明，如果方法没有用throws显式抛出的异常就不能写 其中@param、@return和@exception这三个标记都是只用于方法的 @param的格式要求：@param 形参名 形参类型 形参说明 @return的格式要求：@return 返回值类型 返回值说明 @exception的格式要求：@exception 异常类型 异常说明 @param和@exception可以并列多个 示例二：在编译时进行格式检查(JDK内置的三个基本注解)@Override 限定重写父类方法，该注解只能用于方法 @Deprecated 用于表示所修饰的元素(类，方法等)已过时。通常是因为所修饰的结构危险或存在更好的选择 @suppressWarnings 抑制编译器警告 示例三：跟踪代码依赖性，实现替代配置文件功能@WebServlet Servlet3.0提供了注解(annotation)，使得不再需要在web.xml文件中进行Servlet的部署 @Transactional spring框架中关于“事务”的管理 示例四：Junit单元测试中的注解Junit单元测试中也有大量注解的使用。简单罗列到下面，这里不再赘述@Test 标记在非静态的测试方法上。只有标记@Test的方法才能被作为一个测试方法单独测试。一个类中可以有多个@Test标记的方法，运行时如果只想运行共中一个@Test标记的方法，那么选择这个方法名，然后单独运行，否则整个类的所有标记了@Test的方法都会被执行 @Test(timeout=1000)：设置超时时间，如果测试时间超过了你定义的timeout，测试失败 @Test(expected)：申明出会发生的异常，比如@Test ( expected = Exception.class ) 了解: @BeforeClass 标记在静态方法上。因为这个方法只执行一次。在类初始化时执行 @AfterClass 标记在静态方法上。因为这个方法只执行一次。在所有方法完成后执行 @Before 标记在非静态方法上。在@Test方法前面执行，而且是在每一个@Test方法前面都执行 @After 标记在非静态方法上。在@Test方法后面执行，而且是在每一个@Test方法后面都执行 @Ignore 标记在本次不参与测试的方法上。这个注解的含义就是”某些方法尚未完成，暂不参与此次测试“ @BeforeClass、@AfterClass、@Before、@After、@Ignore都是配合@Test它使用的，单独使用没有意义 9.2.2 自定义注解①注解声明为@interface，并且都会指明两个元注解（Retention、Target） ②自定义注解自动继承了java.lang.annotation.Annotation接口 ③Annotation的成员变量在 Annotation定义中以无参数方法的形式来声明。其方法名和返回值定义了该成员的名字和类型。我们称为配置参数。类型只能是八种基本数据类型、String类型、Class类型、enum类型、Annotation类型以上所有类型的数组 ④可以在定义 Annotation的成员变量时为其指定初始值，指定成员变量的初始值可使用default关键字 ⑤如果只有一个参数成员，建议使用参数名为value ⑥如果定义的注解含有配置参数，那么使用时必须指定参数值，除非它有默认值。格式是“参数名=参数值”，如果只有一个参数成员，且名称为value，可以省略“value=” ⑦没有成员定义的Annotation称为标记；包含成员变量的 Annotation称为元数据Annotation 注意：自定义注解必须配上注解的信息处理流程才有意义 public @interface MyAnnotation &#123; //自定义注解：以@suppressWarnings为例 String value() default &quot;hello&quot;; &#125; @MyAnnotation(value = &quot;hi&quot;) class Test&#123; &#125; 9.2.3 JDK中的元注解JDK的元Annotation用于修饰其他Annotation定义，即对现有的注解进行解释说明的注解 JDK5.0提供了4个标准的meta-annotation类型， 分别是： Retention：指定该Annotation的生命周期，只有声明为RUNTIME的注解才能通过反射获取 Target：指定被修饰的Annotation能用于修饰哪些程序元素 Documented：指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档 Inherited：被它修饰的Annotation将具有继承性 1.Retention@Retention：只能用于修饰一个Annotation定义，用于指定该Annotation的生命周期，@Rentention包含一个RetentionPolicy类型的成员变量，使用@Rentention时必须为该value成员变量指定值： RetentionPolicy.SOURCE：在源文件中有效(即源文件保留)，编译器直接丢弃这种策略的注释 RetentionPolicy.CLASS：在class文件中有效(即class保留)，当运行 Java程序时，JVM不会保留注解。这是默认值 RetentionPolicy.RUNTIME：在运行时有效(即运行时保留)，当运行 Java程序时, JVM会保留注释。程序可以通过反射获取该注释 2.Target@Target：用于修饰Annotation定义，用于指定被修饰的Annotation能用于修饰哪些程序元素。 @Target也包含一个名为value的成员变量： CONSTRUCTOR ：用于描述构造器 FIELD：用于描述域 LOCAL_VARIABLE：用于描述局部变量 METHOD：用于描述方法 PACKAGE：用于描述包 PARAMETER：用于描述参数 TYPE：用于描述类、接口(包括注解类型)或enum声明 3.Documented@Documented：用于指定被该元Annotation修饰的Annotation类将被javadoc工具提取成文档。默认情况下，javadoc 是不包括注解的 定义为Documented的注解必须设置Retention值为RUNTIME 4.Inherited@Inherited：被它修饰的Annotation将具有继承性。如果某个类使用了被@Inherited修饰的Annotation，则其子类将自动具有该注解 比如：如果把标有@Inherited注解的自定义注解标注在类级别上，子类则可以继承父类类级别的注解 实际应用中，使用较少 9.2.4 JDK8中注解的新特性1.可重复注解//JDK8及以后： //①在MyAnnotation上声明@Repeatable，成员值为MyAnnotations.class //②MyAnotation的Target和Retention要与MyAnnotations相同 @Repeatable(value = MyAnnotations.class) @Target(&#123;ElementType.TYPE,ElementType.PARAMETER,ElementType.FIELD,ElementType.METHOD,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE&#125;) @Retention(RetentionPolicy.RUNTIME) public @interface MyAnnotation &#123; String value(); &#125; @Target(&#123;ElementType.TYPE,ElementType.PARAMETER,ElementType.FIELD,ElementType.METHOD,ElementType.CONSTRUCTOR,ElementType.LOCAL_VARIABLE&#125;) @Retention(RetentionPolicy.RUNTIME) pubilc @interface MyAnnotations &#123; MyAnnotation[] value(); &#125; //可重复注解JDK8之前的写法:新建一个容器注解来保存这多个相同类型的注解 //@MyAnnotations(&#123;@MyAnnotation(value = &quot;hi&quot;),@MyAnnotation(value = &quot;hello&quot;)&#125;) @MyAnnotation(value = &quot;hello&quot;) @MyAnnotation(value = &quot;hi&quot;) public class AnnotationTest&#123; &#125; 2.类型注解JDK1.8之后，关于元注解@Target的参数类型ElementType枚举值多了两个：TYPE_ PARAMETER，TYPE_ USE 在Java8之前，注解只能是在声明的地方所使用，Java8开始，注解可以应用在任何地方 ElementType.TYPE_PARAMETER表示该注解能写在类型变量的声明语句中(如：泛型声明) ElementType.TYPE_USE表示该注解能写在使用类型的任何语句中 @Target(&#123;ElementType.TYPE_PARAMETER,ElementType.TYPE_USE&#125;) public @interface MyAnnotation1 &#123; &#125; class Generic&lt;@MyAnnotation1 T&gt;&#123; public void show()&#123; ArrayList&lt;@MyAnnotation1 String&gt; list = new ArrayList&lt;&gt;(); int num = (@MyAnnotation1 int)10L; &#125; &#125; 十、Java集合10.1 Java结合框架概述一方面，面向对象语言对事物的体现都是以对象的形式，为了方便对多个对象的操作，就要对对象进行存储。另一方面，使用Array存储对象方面具有一些弊端，而Java 集合可以动态地把多个对象的引用放入容器中 集合、数组都是对多个数据进行存储操作的结构，简称Java容器（此时的存储主要指内存层面的存储，不涉及到持久化的存储） 数组在内存存储方面的特点： 数组初始化以后，长度就确定了（长度确定） 数组声明的类型，就决定了进行元素初始化时的类型（元素类型确定） 数组在存储数据方面的弊端： 数组初始化以后，长度就不可变了，不便于扩展 数组中提供的属性和方法少，不便于进行添加、删除、插入等操作，且效率不高。同时无法直接获取存储元素的个数 数组存储的数据是有序的、可以重复的。—&gt;存储数据的特点单一 Java集合类可以用于存储数量不等的多个对象，还可用于保存具有映射关系的关联数组 10.1.1 集合框架的使用场景image-20210802145115189 10.1.2 Java集合可分为Collection和Map两种体系 Collection接口：单列数据，定义了存取一组对象的方法的集合 List：元素有序、可重复的集合 —&gt;”动态”数组 实现类：ArrayList、LinkedList、Vector Set：元素无序、不可重复的集合 —&gt;高中学的”集合” 实现类：HashSet、LinkedHashSet、TreeSet Map接口：双列数据，保存具有映射关系“key-value对”的集合 —&gt;高中函数：y=f(x)，x相当于key，y相当于value，可以有多个key指向同一个value（key-&gt;value多对一），不能有一个key指向多个value（value-&gt;key一对一） 实现类：HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 1.Collection接口继承树： image-20210802145632177 2.Map接口继承树： image-20210802145827415 10.2 Collection接口10.2.1 Collection接口中常用方法的使用添加元素：add(Object obj)、addAlI(Collection coll) 获取有效元素的个数：int size() 清空集合：void clear() 是否是空集合：boolean isEmpty() Collection collection = new ArrayList(); //1.add(Object e):将元素e添加到集合collection中 collection.add(&quot;AA&quot;); collection.add(&quot;AA&quot;); collection.add(123);//自动装箱 collection.add(new Date()); //2.size():获取添加的元素个数 System.out.println(collection.size());//4 //3.addAll(Collection collection):将collection集合中的元素添加到当前集合中 Collection collection1 = new ArrayList(); collection1.add(456); collection1.add(&quot;CC&quot;); collection.addAll(collection1); System.out.println(collection.size());//6 System.out.println(collection); //4.clear():清空集合元素 collection.clear();//对象依然存在，只是元素被清空了 //5.isEmpty():判断当前集合是否为空 System.out.println(collection.isEmpty()); 是否包含某个元素： boolean contains(Object obj)：是通过元素的equals方法来判断是否是同一个对象 boolean containsAll(Collection c)：也是调用元素的equals方法来比较的。拿两个集合的元素挨个比较 //6.contains(Object obj):判断当前集合是否包含obj //在判断时会调用obj对象所在类的equals()方法，如果所在类没有重写equals()，则会调用Object类的equals()比较两个对象的引用地址，所以，如果我们要比较两个对象的内容，必须重写equals() Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); //Person p = new Person(&quot;Tom&quot;, 20); //collection.add(p); //System.out.println(collection.contains(p));//true boolean contains = collection.contains(123); System.out.println(contains);//true System.out.println(collection.contains(new String(&quot;Jerry&quot;)));//true，因为String类重写了equals方法，所以这里比较的是内容 System.out.println(collection.contains(new Person(&quot;Tom&quot;, 20)));//false，因为我们的自定义类Person没有重写equals方法，所以是相当于用“==”比较的地址值 //7.containsAll(Collection collection):判断形参collection中的所有元素是否都存在于当前集合中 Collection collection1 = Arrays.asList(123,456);//返回一个List，也是一种创建集合的方式 System.out.println(collection.containsAll(collection1));//true 删除元素： boolean remove(Object obj)：通过元素所属类的equals方法判断是否是要删除的那个元素。只会删除找到的第一个元素 boolean removeAll(Collection coll)：取当前集合的差集 //8.remove(Object obj):从当前集合移除obj元素，返回true、false,移除元素后的集合仍保存在当前集合 Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); boolean remove = collection.remove(123); System.out.println(remove);//true System.out.println(collection);//[456, false, Jerry, Collection.Person@4ee285c6] //9.removeAll(Collection collection):从当前集合中移除collection中的所有元素 Collection collection1 = Arrays.asList(123,456); collection.removeAll(collection1); System.out.println(collection);//[false, Jerry, Collection.Person@4ee285c6] 取两个集合的交集：boolean retainAll(Collection c)：把交集的结果存在当前集合中，不影响c 集合是否相等：boolean equals(Object obj)：如果两个List(有序)集合中的元素内容一样，顺序不一样，则会返回false(List的情况)；如果是Set(无序)集合，顺序不一样内容一样仍为true //10.retainAll(Collection collection):获取当前集合和collection的交集，并将交集保留在当前集合 Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); Collection collection1 = Arrays.asList(123,456); collection.retainAll(collection1); System.out.println(collection);//[123, 456] System.out.println(collection1);//[123, 456] //11.equals():判断当前集合与collection是否相等（比较内容） System.out.println(collection.equals(collection1));//true，因为上方用retainAll取了这两个集合的交集。保存在collection中，而collection1不变，所以这里比较就返回true 转成对象数组：Object[] toArray() 获取集合对象的哈希值：hashCode() Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); //12.HashCode():返回当前对象的Hash值 System.out.println(collection.hashCode()); //13.toArray():集合 --&gt; 数组 Object[] objects = collection.toArray(); for (int i = 0; i &lt; objects.length; i++) &#123; System.out.println(objects[i]); &#125; //扩展:数组 --&gt; 集合:调用Arrays类的静态方法asList() List&lt;String&gt; strings = Arrays.asList(new String[]&#123;&quot;AA&quot;, &quot;BB&quot;, &quot;CC&quot;&#125;); System.out.println(strings); List&lt;int[]&gt; ints = Arrays.asList(new int[]&#123;123, 456&#125;); System.out.println(ints.size());//1，因为int是一个基本数据类型，集合中只能是引用类型，如果用基本数据类型这儿会把它认为是一个元素，而下方使用包装类数据建立的集合就是两个元素 List&lt;Integer&gt; integers = Arrays.asList(new Integer[]&#123;123, 456&#125;); System.out.println(integers.size());//2 遍历：iterator()：返回迭代器对象，用于集合遍历，内部方法：hasNext()，next()，remove() Iterator对象称为迭代器(设计模式的一种)，主要用于遍历Collection集合中的元素 GOF给迭代器模式的定义为：提供一种方法访问一个容器(container)对象中各个元素，而又不需暴露该对象的内部细节。迭代器模式，就是为容器而生 Collection接口继承了java.lang.lterable接口，该接口有一个iterator()方法，那么所有实现了Collection接口的集合类都有一个iterator()方法， 用以返回一个实现了iterator接口的对象 Iterator仅用于遍历集合，Iterator 本身并不提供承装对象的能力。如果需要创建terator对象，则必须有一个被迭代的集合 集合对象每次调用iterator()方法都得到一个全新的迭代器对象，默认游标都在集合的第一个元素之前 image-20210803100049690 //集合元素的遍历操作，使用迭代器Iterator接口 Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); Iterator iterator = collection.iterator(); //遍历方式一： //System.out.println(iterator.next()); //System.out.println(iterator.next()); //System.out.println(iterator.next()); //System.out.println(iterator.next()); //System.out.println(iterator.next()); //System.out.println(iterator.next());//超出集合元素个数范围，抛出NoSuchElementException异常 //遍历方式二：不推荐 for (int i = 0; i &lt; collection.size(); i++) &#123; System.out.println(iterator.next()); &#125; //遍历方式三：推荐 while(iterator.hasNext()) &#123; System.out.println(iterator.next()); &#125; //错误写法一： Iterator iterator = collection.iterator(); while(iterator.next() != null) &#123; System.out.println(iterator.next());//隔空遍历输出，判断时迭代器指针往下移，输出时又往下移，所以造成隔空输出 &#125; //错误写法二： while(collection.iterator().hasNext())&#123; System.out.println(collection.iterator().next());//每次都是输出123，因为每次调用iterator()都会返回一个新的迭代器对象，所以每次都是在遍历第一个元素 &#125; //迭代器移除元素：remove() while(iterator.hasNext())&#123; Object obj = iterator.next(); if(obj.equals(&quot;Jerry&quot;))&#123; iterator.remove(); &#125; &#125; //注意：Iterator可以删除集合的元素，但是是遍历过程中通过迭代器对象的remove方法，不是集合对象的remove方法 //如果还未调用next()或在上一次调用next方法之后已经调用了remove方法，再调用remove都会报IllgalStateException JDK5新增了一个增强for循环foreach，用于遍历集合和数组 Collection collection = new ArrayList(); collection.add(123); collection.add(456); collection.add(false); collection.add(new String(&quot;Jerry&quot;)); collection.add(new Person(&quot;Tom&quot;,20)); //集合中元素的类型 局部变量 : 需要遍历的集合或数组对象 //内部仍是使用迭代器 for(Object obj : collection)&#123; System.out.println(obj); &#125; 10.2.2 Collection的子接口List鉴于Java中数组用来存储数据的局限性，我们通常使用List替代数组 List集合类中元素有序、且可重复，集合中的每个元素都有其对应的顺序索引 List容器中的元素都对应一个整数型的序号记载其在容器中的位置，可以根据字号存取容器中的元素 JDK API中List接口的实现类常用的有: ArrayList、 LinkedList和Vector（list的古老实现类） 面试题：ArrayList、LinkedList、Vector三者的异同？ 同：三个类都实现List接口，存储数据的特点：存储有序、可重复的数据；ArrayList和Vector底层使用Object[]存储，LinkedList使用双向链表 异： |--ArrayList：作为list接口的主要实现类，使用最多；线程不安全，效率高；对于数据的查询效率高，但频繁的插入和删除效率低；底层数组扩容一次为1.5倍 |--LinkedList：线程不安全，效率高；对于频繁的插入、删除操作效率高，但查询效率低；底层使用双向链表存储 |--Vector：作为list接口的古老实现类；线程安全，效率低；底层数组扩容一次2倍 1.ArrayList类ArrayList是List接口的典型实现类、主要实现类 本质上，ArrayList是对象引用的一个”变长”数组 ArrayList的JDK1.8之前与之后的实现区别? JDK1.7：ArrayList像饿汉式，直接创建一个初始容量为10的数组 JDK1.8：ArrayList像懒汉式，一开始创建一个长度为0的数组，当添加第一个元素时再创建一个始容量为10的数组 Arrays.asList(…)方法返回的List集合，既不是ArrayList实例，也不是Vector 实例。Arrays.asList(…)返回值是一个固定长度的List集合 源码分析：JDK7底层存储数据：Object[] elementData ArrayList list = new ArrayList();//底层创建一个初始长度为10的Object数组 //无参构造器源码 public ArrayList() &#123; this(10);//调用有参构造器，传入容量值为10，直接创建this.elementData = new Object[10]; &#125; //add()方法 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 判断是否超出list范围，若超出则会调用扩容的方法grow，grow的内容可参考下方JDK8中的grow方法 elementData[size++] = e;//将数据e添加到扩容后的list return true; &#125; List.add(123);//elementData[0] = new Integer(123); ... list.add(11);//如果此次的添加导致底层elementData数组容量不够，则扩容 默认情况下，扩容为原来的容量的1.5倍，同时需要将原有数组中的数据复制到新的数组中 结论:建议开发中使用带参的构造器: ArrayList list = new ArrayList(int capacity) 源码分析：JDK8中ArrayList的变化底层存储数据：仍为Object[] elementData ArrayList list = new ArrayList();//底层object[] eLementData初始化为&#123;&#125;，并没有创建长度为10的Object数组 //无参构造器源码 public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;//DEFAULTCAPACITY_EMPTY_ELEMENTDATA=&#123;&#125; &#125; list.add(123);//第一次调用add()时，底层才创建了长度10的数组，并将数据123添加到elementData ... 后续的添加和扩容操作与jdk7无异 //add()方法添加数据及调用的一系列方法 public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // 判断是否超出list范围 elementData[size++] = e;//将数据e添加到扩容后的list return true; &#125; private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));//将calculateCapacity返回的容量值传入 &#125; private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;//判断添加的这个数据是否是第一个数据 return Math.max(DEFAULT_CAPACITY, minCapacity);//如果是则返回Object数组默认容量10和添加这个数据后的数组中需要的容量中更大的那个值，第一次添加其实返回的就是默认容量10 &#125; return minCapacity; &#125; private void ensureExplicitCapacity(int minCapacity) &#123;//传入需要的容量值，第一次添加传入的是10 modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0)//传入的需要容量的值是否比数组elementData现有长度大 grow(minCapacity);//如果是，则进行扩容 &#125; private void grow(int minCapacity) &#123;//传入需要用到的容量10 // overflow-conscious code int oldCapacity = elementData.length;//第一次添加数据，length为0 int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//扩容1.5倍 if (newCapacity - minCapacity &lt; 0)//若扩容后的容量值还是需要的小 newCapacity = minCapacity;//则把需要的容量值赋给这个新容量来进行扩容 if (newCapacity - MAX_ARRAY_SIZE &gt; 0)//若扩容后这个需要用到的容量值比Integer.MAX_VALUE-8还大，则调用hugeCapacity() newCapacity = hugeCapacity(minCapacity); //扩容后将原数组的值复制到扩容过后的数组 elementData = Arrays.copyOf(elementData, newCapacity); &#125; 小结：jdk7中的ArrayList的对象的创建类似于单例的饿汉式，而jdk8中的ArrayList的对象的创建类似于单例的懒汉式，延迟了数组的创建，节省内存 2.LinkedList类对于频繁的插入或删除元素的操作，建议使用LinkedList类，效率较高 新增方法： void addFirst(Object obj) void addLast(Object obj) Object getFirst() Object getLast() Object removeFirst() Object removeLast() 源码分析底层存储数据：双向链表 LinkedList linkedList = new LinkedList();//内部声明了Node类型的first和last属性，默认值为null last.add(123);//将123封装在Node中，创建了Node对象 其中，Node定义为： private static class Node&lt;E&gt; &#123; E item;//要添加的数据本身 Node&lt;E&gt; next;//该结点需要指向的下一个结点的地址值 Node&lt;E&gt; prev;//该结点需要指向的上一个结点的地址值 Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; 添加数据时调用的`add()`方法中调用的方法(尾插)： void linkLast(E e) &#123; final Node&lt;E&gt; l = last;//将l和last指向同一个结点 final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);//创建一个新结点，保存新数据，再把新结点的prev指向添加新结点前的最后一个结点 last = newNode;//将新结点作为该链表的最后一个结点 if (l == null)//判断新添加的结点是否是这个链表的第一个结点 first = newNode;//如果是，就让first指向新结点 else l.next = newNode;//如果不是，则让添加新结点前的最后一个结点的next指向新结点 size++;//链表数据数量加1 modCount++; &#125; 3.Vector类源码分析jdk7和jdk8中通过`Vector()`构造器创建对象时，底层都创建了长度为10的数在扩容方面，默认扩容为原来的数组长度的2倍 该类已经不用了，尽管线程安全，但是现有Collections工具类也能把ArrayList变成线程安全的，所以仍用ArrayList替代Vector 4.List接口中的常用方法List除了从Collection集合继承的方法外，List集合里添加了一些根据索引来操作集合元素的方法 void add(int index，Object ele)：在index位置插入ele元素 boolean addAll(int index，Collection eles)：从index位置开始将eles中的所有元素添加进来 Object get(int index)：获取指定index位置的元素 int indexOf(Object obj)：返回obj在集合中首次出现的位置 int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置 Object remove(int index)：移除指定index位置的元素，并返回此元素 Object set(int index，Object ele)：设置指定index位置的元素为ele List subList(int fromIndex，int tolndex)：返回从fromIndex到tolndex位置的子集合 ArrayList arrayList = new ArrayList(); arrayList.add(123); arrayList.add(456); arrayList.add(&quot;AA&quot;); arrayList.add(new Person(&quot;Tom&quot;,20)); arrayList.add(456); System.out.println(arrayList);//[123, 456, AA, Collection.Person@4ee285c6, 456] //1.void add(int index，Object ele)：在index位置插入ele元素 arrayList.add(1,&quot;BB&quot;); System.out.println(arrayList);//[123, BB, 456, AA, Collection.Person@4ee285c6, 456] //2.boolean addAll(int index，Collection eles)：从index位置开始将eles中的所有元素添加进来 List list = Arrays.asList(1,2,3); arrayList.addAll(1,list); System.out.println(arrayList);//[123, 1, 2, 3, BB, 456, AA, Collection.Person@4ee285c6, 456] //3.Object get(int index)：获取指定index位置的元素 System.out.println(arrayList.get(4));//BB //4.int indexOf(Object obj)：返回obj在集合中首次出现的位置 System.out.println(arrayList.indexOf(456));//5 //5.int lastIndexOf(Object obj)：返回obj在当前集合中末次出现的位置 System.out.println(arrayList.lastIndexOf(456));//8 //6.Object remove(int index)：移除指定index位置的元素，并返回此元素 Object remove = arrayList.remove(8); System.out.println(arrayList);//[123, 1, 2, 3, BB, 456, AA, Collection.Person@4ee285c6] System.out.println(remove);//456 //7.Object set(int index，Object ele)：设置指定index位置的元素为ele arrayList.set(5,4567); System.out.println(arrayList);//[123, 1, 2, 3, BB, 4567, AA, Collection.Person@4ee285c6] //8.List subList(int fromIndex，int tolndex)：返回从fromIndex到tolndex位置的左闭右开区间的子集合 List list1 = arrayList.subList(3,6); System.out.println(list1);//[3, BB, 4567] System.out.println(arrayList);//[123, 1, 2, 3, BB, 4567, AA, Collection.Person@4ee285c6]，原list没变 5.List的一道面试笔试题@Test public void test1() &#123; //区分List中remove(int index)和remove(0bject obj) List list = new ArrayList(); list.add(1); list.add(2); list.add(3); updateList(list); System.out.println(list); &#125; private void updateList(List list)&#123; //list.remove(2);//移除索引为2的元素 list.remove(new Integer(2));//移除值为2的元素 &#125; 10.2.3 Collection子接口SetSet接口是Collection的子接口，set接口没有提供额外的方法（即Set中使用的都是Collection接口中声明过的方法） Set集合不允许包含相同的元素，如果试把两个相同的元素加入同一个Set集合中，则添加操作失败 （HashSet和LinkedHashSet）判断两个对象是否相同不是使用==运算符，而是根据equals()方法和hashCode()方法，所以添加的数据所在类一定要重写equals()和hashCode()方法，而（TreeSet）判断对象是否相同通过Comparable接口和Comparator接口 |--Set接口:存储无序的、不可重复的数据--&gt; 高中讲的“集合” |--HashSet:作为Set接口的主要实现类;线程不安全的;可以存储null值 |--LinkedHashSet:作为HashSet的子类; 遍历其内部数据时，可以按照添加的顺序遍历; 在添加数据的同时，每个数据还维护了两个引用，记录此数据前一个数据和后一个数据 对于频繁的遍历操作，LinkedHashSet 效率高于HashSet |--TreeSet:可以按照添加对象的指定属性，进行排序 Set的无序性和不重复性的理解 /* Set:存储无序、不可重复的数据 以HashSet为例说明： 1、无序性：不等于随机性。存储的数据在底层数组中并非按照数组索引的顺序进行添加，而是根据数据的Hash值确定 2、不可重复性：保证添加的元素按照equals()判断时，不能返回true。即:相同的元素只能添加一个 */ Set set = new HashSet(); set.add(456); set.add(123); set.add(123); set.add(&quot;AA&quot;); set.add(&quot;CC&quot;); set.add(new User(&quot;Tom&quot;,20)); set.add(new User(&quot;Tom&quot;,20)); set.add(129); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next());//AA CC 129 User&#123;name=&#39;Tom&#39;, age=20&#125; 456 123 &#125; 1.HashSet类HashSet是Set接口的典型实现，大多数时候使用Set集合时都使用这个实现类 HashSet按Hash算法来存储集合中的元素，因此具有很好的存取、查找、删除性能 HashSet具有以下特点： 不能保证元素的排列顺序 HashSet不是线程安全的 集合元素可以是null HashSet集合判断两个元素相等的标准：两个对象通过hashCode()方法比较相等，并且两个对象的equals()方法返回值也相等 对于存放在Set容器中的对象，对应的类一定要重写equals()和hashCode(Object obj)方法，以实现对象相等规则。即:“ 相等的对象必须具有相等的散列码” 重写HashCode()方法的基本原则： 在程序运行时，同一个对象多次调用hashCode()方法应该返回相同的值 当两个对象的equals()方法比较返回true时，这两个对象的hashCode()方法的返回值也应相等 对象中用作equals()方法比较的Field（属性）, 都应该用来计算hashCode值 HashSet中元素的添加过程： HashSet底层：数组+链表 1.我们向HashSet中添加元素a,首先调用元素a所在类的`hashCode()`方法，计算元素a的哈希值，通过此哈希值再由某种算法计算出元素a应该在HashSet底层数组中的存放位置(即为:索引位置) 2.判断数组此位置上是否已经有元素: (1)如果此位置上没有其他元素，则元素a直接添加到底层数组的此位置上 --&gt;添加成功的情况1 (2)如果此位置上已有其他元素b(或以链表形式存在了多个元素)，则比较元素a与元素b(或这些元素)的hash值: ①如果hash值不相同，则元素a添加成功 --&gt;添加成功的情况2 ②如果hash值相同，进而需要调用元素a所在类的equals()方法: equals()返回true,元素a添加失败 equals()返回false,则元素a添加成功 --&gt;添加成功的情况3 3.说明:对于添加成功的情况2和情况3而言:元素a与已经存在在指定索引位置上的数据以链表的方式存储 jdk7:元素a放到数组中，指向原来的元素 jdk8:原来的元素在数组中，指向元素d 总结：七上八下（JDK7：新元素以头插法放在所有链表数据前面，即数组中；JDK8：新元素以尾插法放在链表数据后面，即链表尾部） image-20210803204939848 2.LinkedHashSet类LinkedHashSet是HashSet的子类 LinkedHashSet根据元素的hashCode值来决定元素的存储位置，但它同时使用双向链表维护元素的次序，这使得元素看起来是以插入顺序保存的 LinkedHashSet插入性能略低于HashSet, 但在迭代访问Set里的全部元素时有很好的性能 LinkedHashSet不允许集合元素重复 //LinkedHashSet的使用 Set set = new LinkedHashSet(); set.add(456); set.add(new String(&quot;AA&quot;)); set.add(456); set.add(new User(&quot;Tom&quot;,30)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next());//456 AA User&#123;name=&#39;Tom&#39;, age=30&#125; &#125; image-20210804101418488 3.TreeSet类TreeSet是SortedSet接口的实现类，TreeSet可以确保集合元素处于排序状态 TreeSet两种排序方法：自然排序(Comparable)和定制排序(Comparator)。默认情况下，TreeSet采用自然排序 TreeSet底层使用红黑树结构存储数据，向TreeSet中添加的数据要求必须是相同类的对象 image-20210804113159347 新增的方法如下：(了解) Comparator comparator() Object first() Object last() Object lower(Object e) Object higher(Object e) SortedSet subSet(fromElement, toElement) SortedSet headSet(toElement) SortedSet tailSet(fromElement) TreeSet默认情况下添加数据： 默认情况（自然排序）下，TreeSet调用add()添加数据时会调用该数据对象的所属类中的compareTo()方法对这些对象数据进行强制排序，所以向TreeSet中添加的数据其所属类必须要实现Comparable接口，重写compareTo()方法，并在其中指明该类型的对象以哪种方法进行排序 自然排序中，比较两个对象是否相同的标准为: compareTo()返回值为0而不再是equals()和hashCode()的比较结果 TreeSet set = new TreeSet(); //添加失败，TreeSet中不能添加不同类的元素 set.add(456); set.add(new String(&quot;AA&quot;)); set.add(456); set.add(new User(&quot;Tom&quot;,30)); //添加成功，举例一：Integer包装类实现了Comparable接口并重写了compareTo()方法，所以添加成功后数据顺序为-34、34、44、65 set.add(34); set.add(-34); set.add(44); set.add(65); //添加成功，举例二： set.add(new User(&quot;Tom&quot;,10)); set.add(new User(&quot;Jack&quot;,50)); set.add(new User(&quot;Jerry&quot;,20)); set.add(new User(&quot;Eric&quot;,25)); /*添加成功后数据顺序为： User&#123;name=&#39;Tom&#39;, age=10&#125; User&#123;name=&#39;Jerry&#39;, age=20&#125; User&#123;name=&#39;Jack&#39;, age=50&#125; User&#123;name=&#39;Eric&#39;, age=25&#125; */ //User类重写的compareTo方法 @Override public int compareTo(Object o) &#123; //先按姓名从大到小排，再按年龄从小到大排 if(o instanceof User)&#123; User user = (User) o; //return -this.name.compareTo(user.name); int compare = -this.name.compareTo(user.name); if(compare != 0)&#123; return compare; &#125;else&#123; return Integer.compare(this.age,user.age); &#125; &#125;else&#123; throw new RuntimeException(&quot;输入的类型不匹配&quot;); &#125; &#125; TreeSet定制排序下添加数据： 定制排序情况下，TreeSet调用add()添加数据时会调用`new TreeSet(comparator)`中传入的Comparator实现类对象重写的compare()方法对这些对象数据进行对应的强制排序 定制排序中，比较两个对象是否相同的标准为: compare()返回值为0而不再是equals()和hashCode()的比较结果 Comparator comparator = new Comparator() &#123; //只考虑年龄的情况下从小到大排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User user1 = (User) o1; User user2 = (User) o2; return Integer.compare(user1.getAge(),user2.getAge()); &#125; throw new RuntimeException(&quot;比较的类型不正确&quot;); &#125; &#125;; TreeSet set = new TreeSet(comparator); set.add(new User(&quot;Tom&quot;,10)); set.add(new User(&quot;Jack&quot;,50)); set.add(new User(&quot;Jerry&quot;,20)); set.add(new User(&quot;Mary&quot;,20));//年龄相等，但是由于Jerry先被添加到TreeSet中，所以Mary进不能再被添加到其中 set.add(new User(&quot;Eric&quot;,25)); Iterator iterator = set.iterator(); while(iterator.hasNext())&#123; System.out.println(iterator.next()); &#125; /* 添加数据后的顺序为： User&#123;name=&#39;Tom&#39;, age=10&#125; User&#123;name=&#39;Jerry&#39;, age=20&#125; User&#123;name=&#39;Eric&#39;, age=25&#125; User&#123;name=&#39;Jack&#39;, age=50&#125; */ 4.Set两道相关面试题//练习:在List内去除重复数字值，要求尽量简单 public static List duplicateList(List list) &#123; HashSet set = new HashSet( ) ; set.addA1l(list); return new ArrayList(set); &#125; public static void main(String[] args)&#123; List list = new ArrayList(); list.add(new Integer(1)); list.add(new Integer(2)); list.add(new Integer(2)); list.add(new Integer(4)); list.add(new Integer(4)); List list2 = duplicatelist(list); for (bject integer : list2) &#123; System.out.println(integer); &#125; &#125; HashSet set = new HashSet(); Person p1 = new Person(1001,&quot;AA&quot;); Person p2 = new Person(1002,&quot;BB&quot;); set.add(p1); set.add(p2); System.out.println(set);//1002,&quot;BB&quot; 1001,&quot;AA&quot; //根据重写后的hashCode()计算出对应存储位置添加到set中后 p1.name = &quot;CC&quot;;//修改p1的name属性,此时set中的p1变为1001,&quot;CC&quot;，但其存储的地址是由1001,&quot;AA&quot;经过重写后的hashCode()和equals()得到的 set.remove(p1); //此时的p1为1001,&quot;CC&quot;，则会使用此时的1001,&quot;CC&quot;通过重写后的hashCode()计算得到其在set中对应的位置，显然计算出的位置是不同的，所以移除1001,&quot;CC&quot;失败 System.out.println(set);//1002,&quot;BB&quot; 1001,&quot;CC&quot; 此时&quot;CC&quot;是&quot;AA&quot;被修改后的数据 set.add(new Person(1001,&quot;CC&quot;));//能添加成功，因为能由上方解释得出1001,&quot;CC&quot;和1001,&quot;AA&quot;经由重写后的hashCode()计算出的存储位置是不同的 System.out.println(set);//1002,&quot;BB&quot; 1001,&quot;CC&quot; 1001,&quot;CC&quot; set.add(new Person(1001,&quot;AA&quot;));//能添加成功，虽然此时新添加的这个1001,&quot;AA&quot;经由重写后的hashCode()计算出的位置和p1相同，但此时会通过equals()判断他们的内容是不是都相等，显然&quot;AA&quot;不等于&quot;CC&quot;，所以这个数据会以链表的形式与p1存储在一起 System.out.println(set);//1002,&quot;BB&quot; 1001,&quot;CC&quot; 1001,&quot;CC&quot; 1001,&quot;AA&quot; //其中Person类中写了hashCode()和equal()方法 10.3 Map接口|--Map:双列数据,存储key-value对的数据 ---类似于高中的函数: y = f(x) |--HashMap:作为Map的主要实现类,使用最多;线程不安全,效率高;能存储null的key-value对; HashMap的底层:数组+链表(jdk7及之前) 数组+链表+红黑树(jdk8) |--LinkedHashMap:保证在遍历map元素时，可以按照添加的顺序实现遍历 原因:在原有的HashMap底层结构基础上添加了一对指针，指向前一个和后一个元素 对于频繁的遍历操作，此类执行效率高于HashMap |-- TreeMap:保证按照添加的key-value对进行排序,实现排序遍历。此时考虑key的自然排序或定制排序 底层采用红黑树结构存储数据 |--Hashtable:作为Map的古老实现类;线程安全,效率低;不能存储null的key-value对 |--Properties:常用来处理配置文件。key和value都是String类型 面试题: 1. HashMap的底层实现原理? 2. HashMap和Hashtable的异同? 3. CurrentHashMap与Hashtable的异同? (暂时不讲) 4. 谈谈你对HashMap中put/get方法的认识?如果了解再谈谈HashMap的扩容机制?默认大小是多少?什么是负载因子(或填充比)?什么是吞吐临界值(或阈值、threshold)? Map结构的理解： Map中的key：无序的、不可重复的，使用Set 存储所有的key —&gt; key所在的类要重写equals()和hashCode() (以HashMap为例)，因为会利用这两个方法决定key的存储位置 Map中的value：无序的、可重复的，使用Collection存储所有的value —&gt;value所在的类要重写equals()，因为以后可能会涉及到value的比较 一个键值对：key-value构成了一个Entry对象，key和value相当于Entry的两个属性 Map中的entry：无序的、不可重复的，使用Set存储所有的entry image-20210804175628724 10.3.1 Map接口中的常用方法添加、删除、修改操作： Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 void putAll(Map m)：将m中的所有key-value对存放到当前map中 Object remove(Object key)：移除指定key的key-value对，并返回value void clear()：清空当前map中的所有数据 Map map = new HashMap(); //Object put(Object key,Object value)：将指定key-value添加到(或修改)当前map对象中 map.put(&quot;AA&quot;,123); map.put(45,123); map.put(&quot;BB&quot;,56); //修改 map.put(&quot;AA&quot;,87); System.out.println(map);//&#123;AA=87, BB=56, 45=123&#125; //void putAll(Map m)：将m中的所有key-value对存放到当前map中 Map map1 = new HashMap(); map1.put(&quot;CC&quot;,123); map1.put(&quot;DD&quot;,432); map.putAll(map1); System.out.println(map);//&#123;AA=87, BB=56, CC=123, DD=432, 45=123&#125; //Object remove(Object key)：移除指定key的key-value对，并返回value System.out.println(map.remove(&quot;AA&quot;));//87 System.out.println(map);//&#123;BB=56, CC=123, DD=432, 45=123&#125; //void clear()：清空当前map中的所有数据 map.clear();//与map=null不同，只是清除map中的元素，map对象还在 System.out.println(map.size());//0 System.out.println(map);//&#123;&#125; 元素查询的操作： Object get(Object key)：获取指定key对应的value boolean containsKey(Object key)：是否包含指定的key boolean containsValue(Object value)：是否包含指定的value int size()：返回map中key-value对的个数 boolean isEmpty()：判断当前map是否为空 boolean equals(Object obj)：判断当前map和参数对象obj是否相等 Map map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,123); map.put(&quot;BB&quot;,56); //Object get(Object key)：获取指定key对应的value System.out.println(map.get(45));//123 System.out.println(map.get(456));//null(不存在) //boolean containsKey(Object key)：是否包含指定的key System.out.println(map.containsKey(&quot;AA&quot;));//true System.out.println(map.containsKey(&quot;CC&quot;));//false //boolean containsValue(Object value)：是否包含指定的value System.out.println(map.containsValue(123));//true System.out.println(map.containsValue(456));//false //int size()：返回map中key-value对的个数 System.out.println(map.size());//3 //boolean isEmpty()：判断当前map是否为空 System.out.println(map.isEmpty());//false map.clear(); System.out.println(map.isEmpty());//true //boolean equals(Object obj)：判断当前map和参数对象obj是否相等 Map map1 = new HashMap(); map1.put(&quot;AA&quot;,123); map1.put(45,123); //map1.put(&quot;BB&quot;,56); System.out.println(map.equals(map1));//false //System.out.println(map.equals(map1));//true 元视图操作的方法(遍历key-value对)： Set keySet()：返回所有key构成的Set集合 Collection values()：返回所有value构成的Collection集合 Set entrySet()：返回所有key-value对构成的Set集合 Map map = new HashMap(); map.put(&quot;AA&quot;,123); map.put(45,1234); map.put(&quot;BB&quot;,56); //Set keySet()：返回所有key构成的Set集合 Set set = map.keySet(); Iterator iterator = set.iterator(); while(iterator.hasNext()) &#123; System.out.println(iterator.next());//AA BB 45 &#125; //Collection values()：返回所有value构成的Collection集合 Collection values = map.values(); for (Object value : values) &#123; System.out.println(value);//123 56 1234 &#125; //Set entrySet()：返回所有key-value对构成的Set集合 Set set1 = map.entrySet(); Iterator iterator1 = set1.iterator(); while(iterator1.hasNext()) &#123; Object obj = iterator1.next(); Map.Entry entry = (Map.Entry) obj; System.out.println(entry); System.out.print(entry.getKey() + &quot; --&gt; &quot;); System.out.println(entry.getValue()); //AA=123 //AA --&gt; 123 //BB=56 //BB --&gt; 56 //45=1234 //45 --&gt; 1234 //System.out.println(iterator1.next()); &#125; 10.3.2 HashMap类1.底层实现原理JDK7 HashMap map = new HashMap(): 在实例化以后，底层创建了长度是16的一维数组Entry[] table ...可能已经执行过多次put后... map.put(key1, value1): 首先，调用key1所在类的hashCode()计算key1哈希值，此哈希值经过某种算法计算以后，得到在Entry数组中的存放位置 如果此位置上的数据为空,此时的entry1（key1-value1）添加成功 ----添加成功情况1 如果此位置上的数据不为空，(意味着此位置上存在一个或多个数据(以链表形式存在)),比较key1和已经存在的一个或多个数据 的哈希值: 如果key1的哈希值与已经存在的数据的哈希值都不相同,此时key1-value1添加成功 ----添加成功情况2 如果key1的哈希值和已经存在的某一个数据(key2-value2) 的哈希值相同，继续比较:调用key1所在类的equals(key2) 如果equals()返回false:此时key1-value1添加成功 ----添加成功情况3 如果equals()返回true:使用value1替换value2 补充:关于情况2和情况3:此时key1-value1和原来的数据以链表的方式存储（JDK7：新元素以头插法放在所有链表数据前面，即数组中；JDK8：新元素以尾插法放在链表数据后面，即链表尾部） 另外，在不断的添加过程中，会涉及到扩容问题，默认的打容方式:扩容为原来容量的2倍，并将原有的数据复制过来 JDK8 jdk8相较于jdk7在底层实现方面的不同: 1. new HashMap():底层没有创建一个长度为16的数组,当首次调用put()方法时，底层才创建长度为16的数组 2. jdk8底层的数组是: Node[],而非Entry[] 3. jdk7底层结构只有:数组+链表。jdk8中底层结构:数组+链表+红黑树。 当数组的某一个索引位置上的元素以链表形式存在的数据个数&gt;8且当前数组的长度&gt;64时，此时此索引位置上的所有数据改为使用红黑树存储 2.源码分析HashMap源码中的重要常量： DEFAULT_INITIAL_CAPACITY : HashMap的默认容量，16 MAXIMUM_CAPACITY : HashMap的最大支持容量， 2^30 DEFAULT_LOAD_FACTOR : HashMap的默认加载因子 TREEIFY_THRESHOLD : Bucket中链表长度大于该默认值，转化为红黑树 UNTREEIFY_THRESHOLD : Bucket中红黑树存储的Node小于该默认值，转化为链表 MIN_TREEIFY_CAPACITY : 桶中的Node被树化时最小的hash表容量。( 当桶中Node的数量大到需要变红黑树时，若hash表容量小于MIN_TREEIFY_CAPACITY时，此时应执行resize扩容操作，这个MIN_TREEIFY_CAPACITY的值至少是TREEIFY_ _THRESHOLD的4倍） table : 存储元素的数组，总是2的n次幂 entrySet : 存储具体元素的集 size : HashMap中存储的键值对的数量 modCount : HashMap扩容和结构改变的次数 threshold : 扩容的临界值，= 容量 * 填充因子 loadFactor : 填充因子 面试题：负载因子值的大小，对HashMap有什么影响 1.负载因子的大小决定了HashMap的数据密度 2.负载因子越大密度越大，发生碰撞的几率越高，数组中的链表越容易长，造成查询或插入时的比较次数增多，性能会下降 3.负载因子越小，就越容易触发扩容，数据密度也越小，意味着发生碰撞的几率越小，数组中的链表也就越短，查询和插入时比较的次数也越小，性能会更高。但是会浪费一定的内容空间。而且经常扩容也会影响性能，建议初始化预设大一点的空间 4.按照其他语言的参考及研究经验，会考虑将负载因子设置为0.7~0.75，此时平均检索长度接近于常数 JDK7 //无参构造器 public HashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);//传入16 0.75到有参构造器 &#125; //有参构造器 public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0)//判断传入的初始化容量是否小于0 throw new IllegalArgumentException(&quot;Illegal initial capacity:&quot; + initialCapacity); if (initialCapacity &gt; MAXIMUM_ CAPACITY)//判断传入的初始化容量是否大于HashMap中预先定义的最大容量 initialCapacity = MAXIMUM_ CAPACITY; if (1oadFactor &lt;= 0 || Float.isNaN(loadFactor))//判断填充因子是否小于等于0或是否为负数 throw new IllegalArgumentException(&quot;Illegal load factor:&quot; + loadFactor); // Find a power of 2 &gt;= initialCapacity int capacity = 1;//定义一个容量变量 while (capacity &lt; initialCapacity)//如果容量值比给定的初始化容量小，则扩大为原来的2倍 capacity &lt;&lt;= 1; this.1oadFactor = loadFactor;//将传入的填充因子赋值给这个新定义的HashMap对象（或是说Entry数组） threshold = (int)Math.min(capacity * loadFactor, MAXIMUM_CAPACITY + 1);//设置扩容临界值，默认16*0.75=12 table = new Entry[capacity];//定义存放entry对象的Entry数组 useAltHashing = sun.misc.VM.isBooted() &amp;&amp; (capacity &gt;= Holder.ALTERNATIVE_HASHING_THRESHOLD); init(); &#125; //从上方就可看出JDK7在实例化后就创建好了一个容量为16的Entry数组 //put方法添加数据 public V put(K key, V value) &#123; if (key == null)//如果key是null，HashMap单独处理放入HashMap中 return putForNullKey(value); int hash = hash(key);//调用hash()计算得到当前key的哈希值 int i = indexFor(hash, table.1ength);//调用indexFor()并传入hash值和Entry数组table的长度计算key-value存放在数组中的哪个位置 for(Entry&lt;K,V&gt; e = table[i]; e != nu1l; e = e.next) &#123;//判断计算出的位置上有没有已存在的数据，如果能进入循环说明该位置上已经有数据了 e.next是指向下一条数据，准备与下一条数据进行比较 Object k; if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123; //if(比较已存在数据和新添加数据的hash值是否相同 且 比较已存在数据和新添加数据的key是否相同) //若其中一个条件为false，则不满足两条数据相同，跳出循环，将新数据添加到HashMap中 //若两个条件都为true，说明两条数据确实相同。则执行下方操作替换掉已存在数据的value V oldValue = e.value; //将已存在数据的value赋值给oldValue e.value = value; //将新添加的数据的value赋值给已存在的数据的value实现覆盖替换 e.recordAccess(this); return oldValue;//将被覆盖替换的值返回，不再执行下方添加数据的代码 &#125; &#125; modCount++; addEntry(hash, key, value, i);//若经过判断后新数据能被添加，则调用addEntry()传入hash值、key-value对和要添加到的位置，将这个需要添加的数据添加到HashMap中 return null; &#125; //计算hash值的方法 final int hash(Object k) &#123; int h=0; if (useAltHashing) &#123;//默认false if (k instanceof String) &#123; return sun.misc.Hashing.stringHash32((String) k); &#125; h = hashSeed; &#125; h ^= k.hashCode();//调用hashCode()得到key的哈希值，然后进行异或计算 // This function ensures that hashCodes that differ only by // constant multiples at each bit position have a bounded // number of collisions (approximately 8 at default Load factor). h ^= (h&gt;&gt;&gt;20) ^ (h&gt;&gt;&gt;12); return h ^ (h&gt;&gt;&gt;7) ^ (h&gt;&gt;&gt;4);//返回经过一些计算后的hash值 &#125; //计算存放位置 static int indexFor(int h, int 1ength) &#123; return h &amp; (1ength-1); &#125; //添加数据Entry对象到HashMap中的具体方法 void addEntry(int hash, K key, V value, int bucketIndex) &#123; if ((size &gt;= threshold) &amp;&amp; (nu1l != table[bucketIndex])) &#123;//判断是否将数组table进行扩容 //if(判断数组table中已存有的key-value对个数是否超过扩容临界值 且 确认需要添加新数据的位置是否已存有其他数据) //如果已存有key-value对个数大于等于扩容临界值，但新数据将要添加到的位置上为null，则不需要进行扩容 //或者如果需要添加新数据的位置上不为null，但已存有key-value对个数不大于等于扩容临界值，也不进行扩容 //即既当需要添加新数据的位置上不为null，又已存有key-value对个数大于等于扩容临界值时才进行扩容 resize(2 * table.length);//扩容为原来容量的2倍，并将原有的数据进行重新计算hash值，然后放入新数组的新位置 hash = (nu1l != key) ? hash(key) : 0;//将这个需要新添加的数据的hash值进行重新计算 bucketIndex = indexFor(hash, table.length);//重新计算存放位置 &#125; //不需要进行扩容或扩容后添加新数据 createEntry(hash, key, value, bucketIndex); &#125; //添加新数据 void createEntry(int hash, K key, V value, int bucketIndex) &#123; Entry&lt;K,V&gt; e = table[bucketIndex];//把此位置上原有的数据取出来 table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);//然后在此位置上new一个新的存放新数据的Entry对象，并将原来的数据传入，以新数据.next=原数据的方式让新数据指向原来的数据 size++;//key-value对的个数加1 &#125; image-20210804211433602 JDK8 //无参构造器 public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; //负载因子（填充因子），默认0.75 &#125; //有参构造器 public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; //从上方可看出实例化HashMap后没有创建好长度为16的Node数组，而是等到下方第一次调用put方法后才创建的 //新增数据调用的方法 public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);//将计算好后的hash值、新数据的key、value等传入putVal() &#125; //计算hash值的方法 static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; //新增数据时内部调用的方法 final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0)//判断是否首次添加数据，若是则给当前HashMap对象创建新数组 n = (tab = resize()).length;//调用resize()给当前HashMap对象创建新数组进行初始化 if ((p = tab[i = (n - 1) &amp; hash]) == null)//经过(n-1)&amp;hash计算后得到新数据存放的位置，并判断此处是否为null tab[i] = newNode(hash, key, value, null);//若是为null，添加成功 else &#123;//不是首次添加且新数据需要的存放位置不为null Node&lt;K,V&gt; e; K k; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) //比较已存在的数据的hash值、key值地址和新数据的hash值、key值地址 || 若hash值一样，key值地址不一样，则比较key值的具体内容 e = p;//若hash值和key值都一样，说明两条数据一样，则将已存在的数据取出赋给e，到下方进行key-value对的value替换操作 else if (p instanceof TreeNode)//若已存在数据和新数据的hash值和key值不一样，判断已存在该位置上的数据是否是以红黑树结构存在 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);//若是，将已存在的数据 else &#123; //已存在数据和新数据的hash值和key值不一样，且已存在该位置上的数据不是以红黑树结构存在 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123;//寻找该位置上以链表形式存在的最后一个数据 p.next = newNode(hash, key, value, null);//让新数据添加到该链表已存在的最后一个数据后面 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash);//如果添加该新数据后，该链表上的数据个数大于等于树化临界值-1，则将该条链表转换为红黑树进行存储 break;//跳出循环 &#125; //寻找该位置上以链表形式存在的最后一个数据时会与该链表上的每个数据进行比较hash值、key值和value值 if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//如果发现有一样的数据，跳出循环 p = e;//若正在进行比较的数据既不是该链表的最后一个也不和新数据一样，则将正在比较的数据赋给p，执行下一次循环p.next，即继续遍历判断下一个数据(p是当前数据，e是下一个数据) &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value;//新value替换旧value if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold)//添加完新数据后判断key-value对的个数是否大于扩容临界值 resize();//若大于扩容临界值，执行扩容操作 afterNodeInsertion(evict); return null; &#125; //扩容的方法 final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table;//第一次添加数据时，table=null int oldCap = (oldTab == null) ? 0 : oldTab.length;//改变容量前的数组的容量，第一次调用则为0 int oldThr = threshold;//改变容量前的数组的扩容临界值，第一次调用默认为0 int newCap, newThr = 0;//声明新容量，新扩容临界值 if (oldCap &gt; 0) &#123;//判断旧数组的容量是否大于0，即是不是第一次调用resize() if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//若旧数组的容量大于等于设置的最大容量 threshold = Integer.MAX_VALUE;//设置扩容临界值为Integer类中的最大值 return oldTab;//返回重新设置了扩容临界值的旧数组 &#125; //旧数组容量小于设置的最大容量，对旧数组进行扩容 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) //if(扩容为原来2倍后的新容量小于最大容量 且 旧数组容量大于等于默认初始化容量16) newThr = oldThr &lt;&lt; 1; //新数组的扩容临界值扩大为原来的2倍 &#125; else if (oldThr &gt; 0) //initial capacity was placed in threshold //判断如果旧数组的容量=0但扩容临界值大于0的情况 //(能到这儿说明是设置了初始化的扩容临界值，未设置容量) newCap = oldThr;//若是，则数组的新容量就为旧的扩容临界值 else &#123; // zero initial threshold signifies using defaults //实例化数组时，容量为0，扩容临界值也为0，进行下方数组的初始化操作 newCap = DEFAULT_INITIAL_CAPACITY;//容量设置为16 newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);//扩容临界值设置为12 &#125; if (newThr == 0) &#123;//判断新的扩容临界值是否还是等于0 float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; //新的扩容临界值不为0，新容量也已设置，准备条件已就绪 threshold = newThr;//将得到的新扩容临界值赋值给当前HashMap对象的扩容临界值 @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//根据新的容量创建一个新数组 table = newTab;//将新数组赋给当前HashMap对象的数组，自此就已创建好新数组，若是实例化第一次调用该方法，到此已结束，只需将新数组返回即可 if (oldTab != null) &#123; //不是第一次时调用该方法的话，扩容后会将原来的数据复制到新数组中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; //添加新数据后该链表的数据个数大于等于树化临界值-1则转换为红黑树 final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;//传入HashMap对象底层的数组table和新数据的hash值 int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize();//判断table是否为null(一般不可能),或者table的长度是否小于最小树化容量，若比它小，则选择进行扩容操作，而不是树化 else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123;//否则，执行下方代码将该链表进行树化 //判断根据新数据的hash值计算出的table中对应的位置上是否为null，不为null则将该位置上的链表进行树化操作 TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125; &#125; image-20210804211515316 10.3.3 LinkedHashMap类底层实现原理Map map = new HashMap(); Map map1 = new LinkedHashMap(); map.put(123,&quot;AA&quot;); map.put(456,&quot;BB&quot;); map.put(789,&quot;CC&quot;); map1.put(123,&quot;AA&quot;); map1.put(456,&quot;BB&quot;); map1.put(789,&quot;CC&quot;); System.out.println(map);//&#123;789=CC, 456=BB, 123=AA&#125; System.out.println(map1);//&#123;123=AA, 456=BB, 789=CC&#125; LinkedHashMap中没有put方法，而是继承自HashMap，在put方法中又调用HashMap的putVal方法，但是在这个putVal方法中有一个newNode方法，而LinkedHashMap重写了这个方法，从此处就能区别开HashMap与LinkedHashMap的存储结构差异 //HashMap中的Node类(仅包括定义的属性) static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; &#125; //继承自HashMap的Entry类 static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after;//新增的属性，用来指明一个数据结点的上一个数据和下一个数据。记录增添数据的先后顺序 Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; //覆盖重写HashMap中的newNode方法。所以LinkedHashMap创建的存储数据的结点会不一样，即多了before和after属性 Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p); return p; &#125; //指明新数据结点的上一个和下一个数据 private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; &#125; 10.3.4 TreeMap类//向TreeMap中添加key-value，要求key必须是由同一个类创建的对象 //因为要按照key进行排序:自然排序、定制排序 //具体细节可看10.2.3中的第3点TreeSet，因为TreeSet的实现底层就是TreeMap。两者相差不大，只是存放的数据类型不同 //自然排序，User类中重写的compareTo()方法是按名字从大到小，再按年龄从小到大排序 TreeMap treeMap = new TreeMap(); User user1 = new User(&quot;Tom&quot;,10); User user2 = new User(&quot;Jack&quot;,50); User user3 = new User(&quot;Jerry&quot;,25); User user4 = new User(&quot;Eric&quot;,20); User user5 = new User(&quot;Eric&quot;,23); treeMap.put(user1,98); treeMap.put(user2,94); treeMap.put(user3,89); treeMap.put(user4,87); treeMap.put(user5,98); Set users = treeMap.entrySet(); Iterator iterator = users.iterator(); while(iterator.hasNext()) &#123; Object obj = iterator.next(); Map.Entry entry = (Map.Entry) obj; System.out.print(entry.getKey() + &quot; --&gt; &quot;); System.out.println(entry.getValue()); //User&#123;name=&#39;Tom&#39;, age=10&#125; --&gt; 98 //User&#123;name=&#39;Jerry&#39;, age=25&#125; --&gt; 89 //User&#123;name=&#39;Jack&#39;, age=50&#125; --&gt; 94 //User&#123;name=&#39;Eric&#39;, age=20&#125; --&gt; 87 //User&#123;name=&#39;Eric&#39;, age=23&#125; --&gt; 98 &#125; //定制排序 Comparator comparator = new Comparator() &#123; //按年龄从小到大排序 @Override public int compare(Object o1, Object o2) &#123; if(o1 instanceof User &amp;&amp; o2 instanceof User)&#123; User user1 = (User) o1; User user2 = (User) o2; return Integer.compare(user1.getAge(),user2.getAge()); &#125; throw new RuntimeException(&quot;比较的类型不正确&quot;); &#125; &#125;; TreeMap treeMap = new TreeMap(comparator); User user1 = new User(&quot;Tom&quot;,10); User user2 = new User(&quot;Jack&quot;,50); User user3 = new User(&quot;Jerry&quot;,25); User user4 = new User(&quot;Eric&quot;,20); User user5 = new User(&quot;Eric&quot;,23); treeMap.put(user1,98); treeMap.put(user2,94); treeMap.put(user3,89); treeMap.put(user4,87); treeMap.put(user5,98); Set users = treeMap.entrySet(); Iterator iterator = users.iterator(); while(iterator.hasNext()) &#123; Object obj = iterator.next(); Map.Entry entry = (Map.Entry) obj; System.out.print(entry.getKey() + &quot; --&gt; &quot;); System.out.println(entry.getValue()); //User&#123;name=&#39;Tom&#39;, age=10&#125; --&gt; 98 //User&#123;name=&#39;Eric&#39;, age=20&#125; --&gt; 87 //User&#123;name=&#39;Eric&#39;, age=23&#125; --&gt; 98 //User&#123;name=&#39;Jerry&#39;, age=25&#125; --&gt; 89 //User&#123;name=&#39;Jack&#39;, age=50&#125; --&gt; 94 &#125; 10.3.5 Properties类对于HashTable来说，Hashtable是个古老的Map实现类，JDK1.0就提供了，也是Map接口的第四个实现类 。不同于HashMap，Hashtable是线程安全的 Hashtable实现原理和HashMap相同，功能相同。底层都使用哈希表结构，查询速度快，很多情况下可以互用 与HashMap不同，Hashtable不允许使用null作为key和value 与HashMap一样，Hashtable 也不能保证其中Key-Value对的顺序 Hashtable判断两个key相等、两个value相等的标准，与HashMap一致 Properties类是Hashtable的子类，该对象用于处理属性文件，由于属性文件里的key、value都是字符串类型，所以Properties 里的key和value都是字符串类型 存取数据时，建议使用setProperty(String key,String value)方法和getProperty(String key)方法 Properties pros = new Properties(); FileInputStream in = new FileInputStream(&quot;jdbc.properties&quot;); pros.load(in); String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);//name = Tom, password = abc123 10.4 Collections工具类面试题：Collection 和Collections的区别? Collection是一个存储单列数据集合的接口，List、Set都继承自它 Collections是一个操作List、Set和Map的工具类 Collections 是一个操作Set、 List和Map等集合的工具类，Collections中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法 10.4.1 Collections中的常用方法1.排序： reverse(List)：反转List中元素的顺序 shuffle(List)：对List集合元素进行随机排序 sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 sort(List, Comparator)：根据指定的Comparator产生的顺序对List 集合元素进行排序 swap(List list，int i，int j)：将指定list集合中的i处元素和j处元素进行交换 List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(-97); list.add(0); System.out.println(list);//[123, 43, 765, -97, 0] //reverse(List)：反转List中元素的顺序 Collections.reverse(list); System.out.println(list);//[0, -97, 765, 43, 123] //shuffle(List)：对List集合元素进行随机排序 Collections.shuffle(list); System.out.println(list);//第一次[0, 123, 43, -97, 765] 第二次[123, 765, 43, -97, 0] //sort(List)：根据元素的自然顺序对指定List集合元素按升序排序 Collections.sort(list); System.out.println(list);//[-97, 0, 43, 123, 765] //swap(List list，int i，int j)：将指定list集合中的i处元素和j处元素进行交换 Collections.swap(list,1,3); System.out.println(list);//[-97, 123, 43, 0, 765] 2.查找、替换： Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object max(Collection，Comparator): 根据Comparator指定的顺序，返回给定集合中的最小元素 Object min(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 Object min(Collection，Comparator)：根据Comparator指定的顺序，返回给定集合中的最小元素 int frequency(Collection, Object)：返回指定集合中指定元素的出现次数 void copy(List dest,List src)：将src中的内容复制到dest中 boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值newVal替换List对象的所有旧值oldVal List list = new ArrayList(); list.add(123); list.add(43); list.add(765); list.add(765); list.add(-97); list.add(765); list.add(0); System.out.println(list);//[123, 43, 765, 765, -97, 765, 0] //Object max(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(Collections.max(list));//765 //Object min(Collection)：根据元素的自然顺序，返回给定集合中的最大元素 System.out.println(Collections.min(list));//-97 //int frequency(Collection, Object)：返回指定集合中指定元素的出现次数 System.out.println(Collections.frequency(list, 765));//3 //void copy(List dest,List src)：将src中的内容复制到dest中 //错误写法: //List list1 = new ArrayList(); //Collections.copy(list1,list); List list1 = Arrays.asList(new Object[list.size()]); Collections.copy(list1,list); System.out.println(list1);//[123, 43, 765, 765, -97, 765, 0] //boolean replaceAll(List list, Object oldVal, Object newVal)：使用新值newVal替换List对象的所有旧值oldVal Collections.replaceAll(list,765,567); System.out.println(list);//[123, 43, 567, 567, -97, 567, 0] 3.转换为线程安全的集合Collections类中提供了多个synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题 在Collections类中有几个定义的SynchronizedXxx的静态内部类，当调用这些SynchronizedXxx()方法时，会在这个方法内部创建一个对应的线程安全的内部类对象，然后返回这个对象。当我们使用返回的对象调用List、Set和Map等的方法时，都会调用到Collections定义的几个静态内部类中重写的相对应的方法，以此来保证线程的安全性 //以List为例 List list = new ArrayList(); List list1 = Collections.synchronizedList(list);//此时返回的list即为线程安全的 //Collections中的synchronizedList()方法 public static &lt;T&gt; List&lt;T&gt; synchronizedList(List&lt;T&gt; list) &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : new SynchronizedList&lt;&gt;(list)); &#125; //定义的SynchronizedList静态内部类类 static class SynchronizedList&lt;E&gt; extends SynchronizedCollection&lt;E&gt; implements List&lt;E&gt; &#123; private static final long serialVersionUID = -7754090372962971524L; final List&lt;E&gt; list; SynchronizedList(List&lt;E&gt; list) &#123; super(list); this.list = list; &#125; SynchronizedList(List&lt;E&gt; list, Object mutex) &#123; super(list, mutex); this.list = list; &#125; public boolean equals(Object o) &#123; if (this == o) return true; synchronized (mutex) &#123;return list.equals(o);&#125; &#125; public int hashCode() &#123; synchronized (mutex) &#123;return list.hashCode();&#125; &#125; public E get(int index) &#123; synchronized (mutex) &#123;return list.get(index);&#125; &#125; public E set(int index, E element) &#123; synchronized (mutex) &#123;return list.set(index, element);&#125; &#125; public void add(int index, E element) &#123; synchronized (mutex) &#123;list.add(index, element);&#125; &#125; public E remove(int index) &#123; synchronized (mutex) &#123;return list.remove(index);&#125; &#125; public int indexOf(Object o) &#123; synchronized (mutex) &#123;return list.indexOf(o);&#125; &#125; public int lastIndexOf(Object o) &#123; synchronized (mutex) &#123;return list.lastIndexOf(o);&#125; &#125; public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; synchronized (mutex) &#123;return list.addAll(index, c);&#125; &#125; public ListIterator&lt;E&gt; listIterator() &#123; return list.listIterator(); // Must be manually synched by user &#125; public ListIterator&lt;E&gt; listIterator(int index) &#123; return list.listIterator(index); // Must be manually synched by user &#125; public List&lt;E&gt; subList(int fromIndex, int toIndex) &#123; synchronized (mutex) &#123; return new SynchronizedList&lt;&gt;(list.subList(fromIndex, toIndex), mutex); &#125; &#125; @Override public void replaceAll(UnaryOperator&lt;E&gt; operator) &#123; synchronized (mutex) &#123;list.replaceAll(operator);&#125; &#125; @Override public void sort(Comparator&lt;? super E&gt; c) &#123; synchronized (mutex) &#123;list.sort(c);&#125; &#125; /** * SynchronizedRandomAccessList instances are serialized as * SynchronizedList instances to allow them to be deserialized * in pre-1.4 JREs (which do not have SynchronizedRandomAccessList). * This method inverts the transformation. As a beneficial * side-effect, it also grafts the RandomAccess marker onto * SynchronizedList instances that were serialized in pre-1.4 JREs. * * Note: Unfortunately, SynchronizedRandomAccessList instances * serialized in 1.4.1 and deserialized in 1.4 will become * SynchronizedList instances, as this method was missing in 1.4. */ private Object readResolve() &#123; return (list instanceof RandomAccess ? new SynchronizedRandomAccessList&lt;&gt;(list) : this); &#125; &#125; 10.4.2 集合练习题1.从键盘随机输入10个整数保存到List中，并按倒序、从大到小的顺序显示出来 2.把学生名与考试分数录入到集合中，并按分数显示前三名成绩学员的名字。TreeSet(Student(name,score,id)); 3.姓氏统计:一个文本文件中存储着北京所有高校在校生的姓名，格式如下 每行一个名字，姓与名以空格分隔: 张 三 李 四 王 小五 现在想统计所有的姓氏在文件中出现的次数，请描述一下你的解决方案 4.对一个Java源文件中的关键字进行计数 提示:Java源文件中的每一个单词，需要确定该单词是否是一个关键字。为了高效处理这个问题，将所有的关键字保存在一个HashSet中。用contains()来测试 File file = new File(&quot;Test.java&quot;); Scanner scanner = new Scanner(file); while(scanner.hasNext())&#123; String word = scanner.next(); System.out.printIn(word); &#125; 十一、Java泛型集合容器类在设计阶段/声明阶段不能确定这个容器到底实际存的是什么类型的对象，所以在JDK1.5之前只能把元素类型设计为Object，JDK1.5之后使用泛型来解决。因为这个时候除了元素的类型不确定，其他的部分是确定的，例如关于这个元素如何保存，如何管理等是确定的，因此此时把元素的类型设计成一个参数，这个类型参数叫做泛型。collection&lt;E&gt;，List&lt;E&gt;，ArrayList&lt;E&gt;这个**就是类型参数，即泛型** 所谓泛型，就是允许在定义类、接口时通过一个标识表示类中某个属性的类型或者是某个方法的返回值及参数类型。这个类型参数将在使用时（例如，继承或实现这个接口，用这个类型声明变量、创建对象时）确定（即传入实际的类型参数，也称为类型实参) 从JDK1.5以后，Java引入了“参数化类型( Parameterized type)”的概念，允许我们在创建集合时再指定集合元素的类型，正如：List，这表明该List只能保存字符串类型的对象 JDK1.5改写了集合框架中的全部接口和类，为这些接口、类增加了泛型支持从而可以在声明集合变量、创建集合对象时传入类型实参 image-20210806095515537 11.1 泛型的使用泛型的使用 1.jdk 5.0新增的特性 2.在集合中使用泛型: 总结: ① 集合接口或集合类在jdk5.0时都修改为带泛型的结构 ② 在实例化集合类时，可以指明具体的泛型类型 ③ 指明完以后，在集合类或接口中凡是定义类或接口时，内部结构（比如:方法、构造器、属性等）使用到类的泛型的位置，都指定为实例化的泛型类型。比如: add(E e) ---&gt; 实例化以后: add(Integer e) ④ 注意点:泛型的类型必须是类，不能是基本数据类型。需要用到基本数据类型的位置，拿包装类替换 ⑤ 如果实例化时，没有指明泛型的类型。默认类型为java.lang.object类型 ArrayList&lt;Integer&gt; list = new ArrayList&lt;Integer&gt;(); list.add(78); list.add(87); list.add(99); list.add(65); //编译时，就会进行类型检查，保证数据的安全 //list.add(&quot;Tom&quot;); //遍历方式一： for(Integer score : list)&#123; //避免了强转操作 int stuScore = score; System.out.println(stuScore); &#125; //遍历方式二： Iterator&lt;Integer&gt; iterator = list.iterator(); while (iterator.hasNext())&#123; int stuScore1 = iterator.next(); System.out.println(stuScore1); &#125; //以HashMap为例 Map&lt;String,Integer&gt; map = new HashMap&lt;String,Integer&gt;(); map.put(&quot;Tom&quot;,87); map.put(&quot;Jerry&quot;,87); map.put(&quot;Jack&quot;,87); //编译报错 //map.put(123,&quot;Mary&quot;); //泛型的嵌套 Set&lt;Map.Entry&lt;String,Integer&gt;&gt; entry = map.entrySet(); Iterator&lt;Map.Entry&lt;String, Integer&gt;&gt; iterator = entry.iterator(); while (iterator.hasNext())&#123; Map.Entry&lt;String, Integer&gt; e = iterator.next(); String key = e.getKey(); Integer value = e.getValue(); System.out.println(key + &quot; --&gt; &quot; + value); &#125; 11.2 自定义泛型11.2.1 自定义泛型类和接口自身定义为泛型类（接口） //如果定义了泛型类，实例化没有指明类的泛型，则认为此泛型类型为Object类型 //要求:如果定义了类是带泛型的，建议在实例化时要指明类的泛型 public class Order&lt;T&gt; &#123; String orderName; int orderId; //类的内部结构可以使用类的泛型 T orderT; public Order() &#123; &#125; public Order(String orderName, int orderId, T orderT) &#123; this.orderName = orderName; this.orderId = orderId; this.orderT = orderT; &#125; public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125; &#125; Order order = new Order(); order.setOrderT(123); order.setOrderT(&quot;ABC&quot;); //实例化时指明类的泛型 Order&lt;String&gt; order1 = new Order&lt;String&gt;(&quot;orderAA&quot;,1001,&quot;order:AA&quot;); order1.setOrderT(&quot;AA:hello&quot;);//此时只能设置String类型 其他类继承泛型类（实现接口） public class SubOrder extends Order&lt;Integer&gt;&#123;//非泛型类 &#125; public class SubOrder1&lt;T&gt; extends Order&lt;T&gt;&#123;//泛型类 &#125; SubOrder subOrder = new SubOrder(); //由于子类在继承带泛型的父类时，指明了泛型类型。则实例化子类对象时，不再需要指明泛型 subOrder.setOrderT(1002);//此时传入的类型只能是继承Order&lt;Integer&gt;时指明的Integer类型，若没有像如此指明类型即是继承自Order&lt;T&gt;，则传入的数据类型是Object类型 SubOrder1&lt;String&gt; subOrder = new SubOrder1&lt;String&gt;();//是泛型类 subOrder1.setOrderT(&quot;order2...&quot;); 自定义类和接口的注意点： 泛型类可能有多个参数，此时应将多个参数一起放在尖括号内。比如：&lt;E1,E2,E3&gt; 泛型类的构造器如下：**public GenericClass()&#123;&#125;。而下面是错误的: public GenericClass(){}，而实例化时需要new Generic&lt;&gt;();** 实例化后，操作原来泛型位置的结构必须与指定的泛型类型一致 泛型不同的引用不能相互赋值。尽管在编译时ArrayList&lt;String&gt;和ArrayList&lt;Integer&gt;是两种类型，但是，在运行时只有一个ArrayList被加载到JVM中 ArrayList&lt;String&gt; list1 = nu1l; ArrayList&lt;Integer&gt; list2 = nul1; list1 = list2;//泛型不同的引用不能相互赋值 Person p1 = null; Person p2=null; p1 = p2;//而这种普通引用可以 泛型如果不指定，将被擦除，泛型对应的类型均按照Object处理，但不等价于Object。 经验：泛型要使用一路都用。要不用，一路都不要用 如果泛型结构是一个接口或抽象类，则不可创建泛型类的对象 jdk1.7, 泛型的简化操作: ArrayList&lt;Fruit&gt; flist = new ArrayList&lt;&gt;(); 泛型的指定中不能使用基本数据类型，可以使用包装类替换 在类/接口上声明的泛型，在本类或本接口中即代表某种类型，可以作为非静态属性的类型、非静态方法的参数类型、非静态方法的返回值类型。但在静态方法中不能使用类的泛型 public static void show(T orderT)&#123;//编译报错 Systrem.out.println(orderT); &#125; //因为泛型是针对实例化对象使用来指定类型的，而静态方法是早于实例化对象创建，在没有实例化对象时也要进行创建和调用 异常类不能是泛型的 不能使用new E[]。但是可以: E[] elements = (E[])new Object[capacity];参考: ArrayList源码中声明: Object[] elementData，而非泛型参数类型数组 父类有泛型，子类可以选择保留泛型也可以选择指定泛型类型: 子类不保留父类的泛型：按需实现 没有类型擦除 具体类型 子类保留父类的泛型：泛型子类 全部保留 部分保留 class Father&lt;T1, T2&gt; &#123; &#125; //子类不保留父类的泛型 // 1)没有类型 擦除 class Son1 extends Father &#123;//等价于class Son extends Father&lt;Object , 0bject&gt;&#123; &#125; // 2)具体类型 class Son2 extends Father&lt;Integer, String&gt; &#123; &#125; //子类保留父类的泛型 // 1)全部保留 class Son3&lt;T1, T2&gt; extends Father&lt;T1, T2&gt; &#123; &#125; // 2)部分保留 class Son4&lt;T2&gt; extends Father&lt;Integer, T2&gt; &#123; &#125; class Father&lt;T1, T2&gt; &#123; &#125; //子类不保留父类的泛型 // 1)没有类型擦除 class Son&lt;A, B&gt; extends Father&#123;//等价于class Son extends Father&lt;Object , 0bject&gt;&#123; &#125; // 2)具体类型 class Son2&lt;A, B&gt; extends Father&lt;Integer, String&gt; &#123; &#125; //子类保留父类的泛型 // 1)全部保留 class Son3&lt;T1, T2, A, B&gt; extends Father&lt;T1, T2&gt; &#123; &#125; // 2)部分保留 class Son4&lt;T2, A, B&gt; extends Father&lt;Integer, T2&gt; &#123; &#125; 结论：子类必须是“富二代”，子类除了指定或保留父类的泛型，还可以增加自己的泛型 11.2.2 自定义泛型方法public T getOrderT() &#123; return orderT; &#125; public void setOrderT(T orderT) &#123; this.orderT = orderT; &#125; boolean add(E e); //以上三种不是泛型方法，而是普通方法 &lt;T&gt; T[] toArray(T[] a);//这是一个泛型方法 //泛型方法:在方法中出现了泛型的结构，泛型参数与类的泛型参数没有任何关系，换句话说，泛型方法所属的类是不是泛型类都没有关系，所以在非泛型类中也可以定义使用 //泛型方法，可以声明为静态的。原因:泛型参数是在调用方法时确定的，并非在实例化类时确定 //定义时需要在前方加上类似&lt;E&gt;的标识来告诉编译器这是一个泛型方法，其泛型和类没有任何关系 public &lt;E&gt; List&lt;E&gt; copyFromArrayTolist(E[] arr)&#123; ArrayList&lt;E&gt; list = new ArrayList&lt;&gt;(); for(E e : arr)&#123; list.add(e); return list; &#125; Order&lt;String&gt; order = new 0rder&lt;&gt;(); Integer[] arr = new Integer[]&#123;1,2,3,4&#125;; List&lt;Integer&gt; list = order.copyFromArrayToList(arr); System.out.println(list);//[1,2,3,4] 11.3 泛型在继承方面的体现虽然类A是类B的父类，但是G 和G 二者不具备子父类关系，二者是并列关系 补充：类A是类B的父类，A是B的父类 Object obj = null; String str = null; obj = str; Object[] arr1 = null; String[] arr2 = null; arr1 = arr2; //编译不通过 //Date date = new Date(); //str = date; List&lt;Object&gt; list1 = null; List&lt;String&gt; list2 = null; //此时的list1和list2的类型不具有父子关系，编译不通过 //list1 = list2; /* 反证法: 假设list1 = list2; list1.add(123);导致混入非String的数据。出错。 */ 11.4 通配符的使用使用类型通配符：?，比如：List&lt;?&gt; ，Map&lt;?,?&gt; List&lt;?&gt;是List&lt;String&gt;、 List&lt;Object&gt;等各种泛型List的父类。比如，类A是类B的父类，但G&lt;A&gt;和G&lt;B&gt;是没有关系的，二者共同的父类是G&lt;?&gt; 11.4.1 使用通配符后对数据的写入和读取1.写入数据不能向使用通配符后的集合写入数据。因为我们不知道要添加的元素类型，就向其中添加对象 将任意元素加入到其中都不是类型安全的： Collection&lt;?&gt; c = new ArrayList&lt;String&gt;(); c.add(new Object()); //编译时错误 //add方法有类型参数E作为集合的元素类型，我们传给add的任何参数都必须是这个未知类型的子类。因为我们不知道c的元素类型，自然也就不知道其子类，所以我们无法添加任何东西进去 //唯一的例外的是null，它是所有类型的成员 2.读取数据我们可以读取到使用通配符后的集合对象中的数据。比如，读取List&lt;?&gt;的对象list中的元素时，永远是安全的，因为我们调用get()方法并得到其返回值后，不管其数据的真实类型是什么，它都总是一个Object List&lt;String&gt; list1 = new ArrayList&lt;&gt;(); List&lt;String&gt; list2 = new ArrayList&lt;&gt;(); List&lt;?&gt; list = null; list = list1;//能赋值成功 list = list2;//能赋值成功 List&lt;String&gt; list3 = new ArrayList&lt;&gt;(); list3.add(&quot;AA&quot;); list3.add(&quot;BB&quot;); list3.add(&quot;CC&quot;); list = list3; //添加：对于List&lt;?&gt;就不能向其内部添加数据，除了添加null //list.add(&quot;DD&quot;); //获取：允许读取数据，读取的数据类型为Object Object o =list.get(0); System.out.println(o); 11.4.2 有限制的通配符 &lt;?&gt;允许所有泛型的引用调用 通配符指定上限，上限extends：使用时指定的类型必须是继承某个类，或者实现某个接口，即&lt;= 通配符指定下限，下限super：使用时指定的类型不能小于操作的类，即&gt;= 举例： (无穷小，Number] ：**只允许泛型为Number及Number子类的引用调用** [Number ，无穷大) ：**只允许泛型为Number及Number父类的引用调用** ：**只允许泛型为实现Comparable接口的实现类的引用调用** //? extends A: // G&lt;? extends A&gt;可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的子类 //? super A: // G&lt;? super A&gt;可以作为G&lt;A&gt;和G&lt;B&gt;的父类，其中B是A的父类 List&lt;? extends Person&gt; list1 = null; List&lt;? super Person&gt; list2 = null; List&lt;Student&gt; list3 = null; List&lt;Person&gt; list4 = null; List&lt;Object&gt; list5 = null; list1 = list3; list1 = list4; //list1 = list5;//编译失败，因为Object是Person的父类，而? extends Person指明的集合只能由Person及其子类可以调用 //list2 = list3;//编译失败，因为Student是Person的子类，而? super Person指明的集合只能由Person及其父类可以调用 list2 = list4; list2 = list5; //读取数据: list1 = list3; Person p = list1.get(0);//Object o = list1.get(0)也可以获取，但声明的类型最小只能是Person，不能是Student //编译不通过 //Student s = list1.get(0); list2 = list4; //编译不通过 //Person p1 = list2.get(0); Object o = list2.get(0);//可以获取，但声明的类型只能是Object //写入数据 //编译不通过 //list1.add(new Person());//添加的Person类型有是list1中数据的类型的父类的可能，即?指的数据类型可能比Person更小 //list1.add(new Student());//添加的Student类型也有是list1中数据的类型的父类的可能，即?指的数据类型可能比Student更小 //编译通过 list2.add(new Person());//?指的是Person及其父类，那么list2中存的数据类型最小都是Person类型和其子类，所以Person类型可以添加 list2.add(new Student());//Student是Person的子类，所以也可以添加 //list2.add(new Object());//不能添加因为有可能?指的是Person和Object之间的类型，那么此时Object就是其中数据类型的父类，则添加不成功 11.5 练习定义个泛型类DAO&lt;T&gt;,在其中定义一个Map成员变量，Map的键为String类型，值为T类型。 分别创建以下方法: public void save(String id,T entity):保存T类型的对象到Map成员变量中 public T get(Stringid):从map中获取id 对应的对象 public void update(String id,T entity):替换map中key为id的内容，改为entity对象 public List&lt;T&gt; list():返回map中存放的所有T对象 public void delete(String id):删除指定id 对象 定义一个User类: 该类包含: private成员变量(int类型) id, age; (String类型) name 定义一个测试类: 创建DAO类的对象，分别调用其save、get、update、list、 delete方法来操作User对象 使用Junit 单元测试类进行测试 public class DAO&lt;T&gt; &#123; //由于存入map的key是单独的String类型，则key-value的存储位置是String类中的HashCode()和equals()决定 // 所以就没有必要在User中重写HashCode()，但是equals()有必要重写，因为可能会涉及到判断key对应的value值的一些情况 public Map&lt;String,T&gt; map = new HashMap&lt;&gt;(); public void save(String id,T entity)&#123; map.put(id,entity); &#125; public T get(String id)&#123; return map.get(id); &#125; public void update(String id,T entity)&#123; if (map.containsKey(id))&#123; map.put(id,entity); &#125; //map.replace(id,entity);//方法二 &#125; public List&lt;T&gt; list()&#123; //错误的 //Collection&lt;T&gt; values = map.values(); //return (List&lt;T&gt;)values; //正确的 ArrayList&lt;T&gt; list = new ArrayList&lt;&gt;(); Collection&lt;T&gt; values = map.values(); for (T value : values) &#123; list.add(value); &#125; return list; &#125; public void delete(String id)&#123; map.remove(id); &#125; &#125; public class User &#123; private int id; private int age; private String name; public User() &#123; &#125; public User(int id, int age, String name) &#123; this.id = id; this.age = age; this.name = name; &#125; public int getId() &#123; return id; &#125; public void setId(int id) &#123; this.id = id; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; @Override public String toString() &#123; return &quot;User&#123;&quot; + &quot;id=&quot; + id + &quot;, age=&quot; + age + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;&#125;&#39;; &#125; @Override public boolean equals(Object o) &#123; if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; if (id != user.id) return false; if (age != user.age) return false; return name.equals(user.name); &#125; &#125; public class DAOTest &#123; @Test public void Test()&#123; DAO&lt;User&gt; userDAO = new DAO&lt;&gt;(); User user1 = new User(1,10,&quot;Tom&quot;); User user2 = new User(2,34,&quot;Jerry&quot;); User user3 = new User(3,23,&quot;Jack&quot;); User user4 = new User(4,14,&quot;Eric&quot;); User user5 = new User(5,25,&quot;Mary&quot;); userDAO.save(&quot;1001&quot;,user1);//save方法测试 userDAO.save(&quot;1002&quot;,user2); userDAO.save(&quot;1003&quot;,user3); userDAO.save(&quot;1004&quot;,user4); userDAO.save(&quot;1005&quot;,user5); List&lt;User&gt; list = userDAO.list();//list()方法测试 list.forEach(System.out::println); System.out.println(&quot;======================&quot;); userDAO.update(&quot;1003&quot;,new User(3,25,&quot;Jack&quot;));//update()方法测试 List&lt;User&gt; list1 = userDAO.list(); list1.forEach(System.out::println); System.out.println(&quot;======================&quot;); User user = userDAO.get(&quot;1002&quot;);//get()方法测试 System.out.println(user); System.out.println(&quot;======================&quot;); userDAO.delete(&quot;1004&quot;);//delete()方法测试 List&lt;User&gt; list2 = userDAO.list(); list2.forEach(System.out::println); //输出结果: /* User&#123;id=5, age=25, name=&#39;Mary&#39;&#125; User&#123;id=4, age=14, name=&#39;Eric&#39;&#125; User&#123;id=3, age=23, name=&#39;Jack&#39;&#125; User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125; User&#123;id=1, age=10, name=&#39;Tom&#39;&#125; ====================== User&#123;id=5, age=25, name=&#39;Mary&#39;&#125; User&#123;id=4, age=14, name=&#39;Eric&#39;&#125; User&#123;id=3, age=25, name=&#39;Jack&#39;&#125; User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125; User&#123;id=1, age=10, name=&#39;Tom&#39;&#125; ====================== User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125; ====================== User&#123;id=5, age=25, name=&#39;Mary&#39;&#125; User&#123;id=3, age=25, name=&#39;Jack&#39;&#125; User&#123;id=2, age=34, name=&#39;Jerry&#39;&#125; User&#123;id=1, age=10, name=&#39;Tom&#39;&#125; */ &#125; &#125; 十二、Java IO流12.1 File类的使用 java.io.File类：文件和文件目录路径的抽象表示形式，与平台无关，**File类的一个对象，代表一个文件或一个文件目录(**俗称：文件夹) File能新建、删除、重命名文件和目录，但File不能访问文件内容本身。如果需要访问文件内容本身，则需要使用输入/输出流（Input/Output），到时File对象会经常作为参数传递给流的构造器 想要在Java程序中表示一个真实存在的文件或目录，那么必须有一个File对象，但是Java程序中的一个File对象，可能没有一个真实存在的文件或目录 当一个File对象是否有在硬件中对应的文件或文件目录存在或不存在时： image-20210807161256849 12.1.1 常用构造器public File(String pathname)：以pathname为路径创建File对象，可以是绝对路径或者相对路径，如果pathname是相对路径，则默认的当前路径在系统属性user.dir中存储 绝对路径：是一个固定的路径，从盘符开始 相对路径：是相对于某个位置开始 public File(String parent,String child)：以parent为父路径，child为子路径创建File对象 public File(File parent,String child)：根据一个父File对象和子文件路径创建File对象 //实例化：此时实例化出来的File对象都只是内存层面的，还没有真正的创建出一个文件或目录到硬盘层面 //相对路径：相较于某个路径下，指明的路径 //绝对路径：包含盘符在内的文件或文件目录的路径 //创建实例化对象方式一:public File(String pathname) File file = new File(&quot;hello.txt&quot;);//相对路径，相对于当前项目或模块下 File file1 = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\hello.txt&quot;);//绝对路径 System.out.println(file);//hello.txt System.out.println(file1);//E:\\桌面文件\\IOTest\\hello.txt //创建实例化对象方式二:public File(String parent,String child) File file2 = new File(&quot;E:\\\\桌面文件\\\\IOTest&quot;,&quot;IOHello&quot;);//parent路径指的是我们要创建文件或目录到哪个文件目录下，而child是我们要创建的文件或目录的名字 System.out.println(file2);//E:\\桌面文件\\IOTest\\IOHello //创建实例化对象方式三:public File(File parent,String child) File file3 = new File(file2,&quot;hello.txt&quot;);//这里的parent是个File对象，说明是我们预先创建好的一个File对象，然后在这个对象(目录)下再创建一个新的文件或目录 System.out.println(file3);//E:\\桌面文件\\IOTest\\IOHello\\hello.txt 12.1.2 路径分隔符路径中的每级目录之间用一个路径分隔符隔开。 路径分隔符和系统有关： windows和DOS系统默认使用“\\” 来表示 UNIX和URL使用“/”来表示 Java程序支持跨平台运行，因此路径分隔符要慎用。为了解决这个隐患，File类提供了一个常量：public static final String separator。根据操作系统，动态的提供分隔符 举例： File file1 = new File(&quot;d: \\\\atguigu\\\\info.txt&quot;); File file2 = new File(&quot;d:&quot; + File.separator + &quot;atguigu&quot; + File.separator + &quot;info.txt&quot;); File file3 = new File(&quot;d:/atguigu&quot;); 12.1.3 File类的常用方法1.File类的获取功能 public String getAbsolutePath()：获取绝对路径 public String getPath()：获取路径 public String getName()：获取名称 public String getParent()：获取上层文件目录路径。若无，返回null public long length()：**获取文件长度(即:字节数)**。不能获取目录的长度 public long lastModified()：获取最后次的修改时间，毫秒值 public String[] list()：获取指定目录下的所有文件或者文件目录的名称数组（适用于文件目录） public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File数组（适用于文件目录） File file1 = new File(&quot;hello.txt&quot;);//相对路径 File file2 = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\hello.txt&quot;);//绝对路径 //在没有创建实体文件的情况下，length和lastModified都为0 //public String getAbsolutePath()：获取绝对路径 System.out.println(file1.getAbsoluteFile());//E:\\JavaProject\\IDEAProject\\自主练习\\Demo\\hello.txt //public String getAbsolutePath()：获取绝对路径 System.out.println(file1.getPath());//hello.txt //public String getName()：获取名称 System.out.println(file1.getName());//hello.txt //public String getParent()：获取上层文件目录路径。若无，返回null System.out.println(file1.getParent());//null //public long length()：获取文件长度(即:字节数)。不能获取目录的长度 System.out.println(file1.length());//0 //public long lastModified()：获取最后次的修改时间，毫秒值 System.out.println(file1.lastModified());//0 System.out.println(); System.out.println(file2.getAbsoluteFile());//E:\\桌面文件\\IOTest\\hello.txt System.out.println(file2.getPath());//E:\\桌面文件\\IOTest\\hello.txt System.out.println(file2.getName());//hello.txt System.out.println(file2.getParent());//E:\\桌面文件\\IOTest System.out.println(file2.length());//0 System.out.println(file2.lastModified());//0 File file = new File(&quot;E:\\\\JavaProject\\\\IDEAProject\\\\Exercises\\\\Demo\\\\src&quot;); //public String[] list()：获取指定目录下的所有文件或者文件目录的名称数组 String[] list = file.list(); for (String s : list) &#123; System.out.println(s);//Annotation array Collection CommonClass enumeration Generic IO oop Test Thread &#125; //public File[] listFiles()：获取指定目录下的所有文件或者文件目录的File数组 File[] files = file.listFiles(); for (File file1 : files) &#123; System.out.println(file1); //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\Annotation //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\array //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\Collection //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\CommonClass //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\enumeration //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\Generic //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\IO //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\oop //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\Test //E:\\JavaProject\\IDEAProject\\Exercises\\Demo\\src\\Thread &#125; 2.File类的重命名功能public boolean renameTo(File dest)：把文件重命名为指定的文件路径 //比如: file1.renameTo(file2)为例: //要想保证返回true, 需要file1在硬盘中是存在的，而file2不能在指定路径的硬盘中已经存在 //当file1.renameTo(file2)成功后，再file2.renameTo(file1)也能将文件重新拿回来，说明文件需要被剪切到到的位置也可以用相对路径 File file1 = new File(&quot;hello.txt&quot;); File file2 = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\hi.txt&quot;); boolean b = file1.renameTo(file2); System.out.println(b); 3.File类的判断功能 public boolean isDirectory()：判断是否是文件目录 public boolean isFile()：判断是否是文件 public boolean exists()：判断是否存在 public boolean canRead()：判断是否可读 public boolean canWrite()：判断是否可写 public boolean isHidden()：判断是否隐藏 File file = new File(&quot;hello.txt&quot;); //public boolean isFile()：判断是否是文件目录 System.out.println(file.isDirectory());//false //public boolean isFile()：判断是否是文件 System.out.println(file.isFile());//true //public boolean exists()：判断是否存在 System.out.println(file.exists());//true //public boolean canRead()：判断是否可写 System.out.println(file.canRead());//true //public boolean canWrite()：判断是否可写 System.out.println(file.canWrite());//true //public boolean isHidden()：判断是否隐藏 System.out.println(file.isHidden());//false File file1 = new File(&quot;E:\\\\桌面文件\\\\IOTest&quot;); System.out.println(file1.isDirectory());//true System.out.println(file1.isFile());//false System.out.println(file1.exists());//true System.out.println(file1.canRead());//true System.out.println(file1.canWrite());//true System.out.println(file1.isHidden());//false//public boolean isDirectory()：判断是否是文件目录 4.File类的创建功能 public boolean createNewFile()：创建文件。若文件存在， 则不创建，返回false public boolean mkdir()：创建文件目录。如果此文件目录存在，就不创建了。如果此文件目录的上层目录不存在，也不创建 public boolean mkdirs()：创建文件目录。如果上层文件目录不存在， 一并创建 注意事项：如果你创建文件或者文件目录没有写盘符路径，那么，默认在项目路径下 5.File类的删除功能 public boolean delete()：删除文件或者文件夹 删除注意事项：Java中的删除不走回收站 要删除一个文件目录，请注意该文件目录内不能包含文件或者文件目录 //文件创建 File file = new File(&quot;hello.txt&quot;); if(!file.exists())&#123;//文件不存在 //public boolean createNewFile()：创建文件 file.createNewFile(); System.out.println(&quot;创建成功&quot;); &#125;else&#123;//文件存在 //public boolean delete()：删除文件或者文件夹 file.delete(); System.out.println(&quot;删除成功&quot;); &#125; //文件目录的创建 //当要创建的文件目录的上层目录存在时，mkdir和mkdirs的作用效果都一样 //当要创建的文件目录的上层目录不存在时，只有mkdirs能创建成功 File file1 = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\IOTest01&quot;); boolean mkdir = file1.mkdir(); if (mkdir)&#123; System.out.println(&quot;创建成功1&quot;); &#125; File file2 = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\IOTest02&quot;); boolean mkdir1 = file2.mkdirs(); if(mkdir1)&#123; System.out.println(&quot;创建成功2&quot;); &#125; 6.File类练习1.利用File构造器，new一个文件目录file 1)在其中创建多个文件和目录 2)编写方法，实现删除file中指定文件的操作 2.判断指定目录下是否有后缀名为.jpg的文件，如果有，就输出该文件名称 3.遍历指定目录所有文件名称，包括子文件目录中的文件。 拓展1:并计算指定目录占用空间的大小 拓展2:删除指定文件目录及其下的所有文件 12.2 IO流原理及流的分类I/O是Input/Output的缩写，I/O技术是非常实用的技术，用于处理设备之间的数据传输。如读/写文件，网络通讯等 Java程序中，对于数据的输入/输出操作以“流(stream)”的方式进行 java.io包下提供了各种“流”类和接口，用以获取不同种类的数据，并通过标准的方法输入或输出数据 12.2.1 IO流的原理image-20210807170244977 12.2.2 流的分类image-20210807170938002 image-20210807171355287 12.2.3 IO流的体系结构image-20210807172114754 12.3 节点流(或文件流)12.3.1 FileReader类从硬盘读入数据到内存 1.使用FileReader类read()实现数据的读入//说明点: //1. read()的理解:返回读入的一个字符。如果达到文件末尾，返回-1 //2.异常的处理:为了保证流资源一定可以执行关闭操作。需要使用try-catch-finally处理 //3.读入的文件一定要存在，否则就会报FileNotFoundException @Test public void TestFileReader() &#123; FileReader fileReader = null; try &#123; //1.实例化File类的对象，指明要操作的文件 File file = new File(&quot;hello.txt&quot;); //2.提供具体的流 fileReader = new FileReader(file); //3.数据读入 //read():返回读入的一个字符，如果达到文件内容末尾，返回-1 //方式一： //int data = fileReader.read(); //while (data != -1)&#123; // System.out.print((char) data); // data = fileReader.read(); //&#125; //方式二： int data; while ((data = fileReader.read()) != -1)&#123; System.out.print((char) data); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.流的关闭操作 //(1)一般情况下是：先打开的后关闭，后打开的先关闭 //(2)另一种情况：看依赖关系，如果流a依赖流b，应该先关闭流a，再关闭流b。例如，处理流a依赖节点流b，应该先关闭处理流a，再关闭节点流b //(3)可以只关闭处理流，不用关闭节点流。处理流关闭的时候，会调用其处理的节点流的关闭方法 try &#123;//此处的if和try-catch嵌套，谁在外面都行 if(fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 2.使用FileReader类read(char[] cbuf)实现数据的读入//对read()操作升级：使用read重载方法，一次性读取几个字符存入数组 @Test public void TestFileReader1()&#123; FileReader fileReader = null; try &#123; //1.File类的实例化 File file = new File(&quot;hello.txt&quot;); //2.FileReader流的实例化 fileReader = new FileReader(file); //3.读入的操作 //read(char cbuf):返回每次读入cbuf数组中的字符的个数，如果达到文件内容末尾，则返回-1 char[] cbuffer = new char[5]; int len; while ((len = fileReader.read(cbuffer)) != -1)&#123; //方法一： for (int i = 0; i &lt; len; i++) &#123;//不能写好i&lt;cbuffer.length，因为每次读取数组中的字符都会覆盖上次读取，当最后几个字符的长度不足于填充满数组，那么最后一次遍历就会把没有被覆盖掉的几个字符也输出出来，所以我们应该读取几个字符就遍历输出几个 System.out.print(cbuffer[i]); &#125; //方法二： //String str = new String(cbuffer); //System.out.println(str);//也是错误的,跟上方for循环i&lt;cbuffer.length一样的逻辑 String str = new String(cbuffer,0,len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源的关闭 try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.2 FileWriter类从内存写出数据到硬盘 //说明: //1.输出操作，对应的File可以不存在的。不会报异常 //2.File对应的硬盘中的文件如果不存在，在输出的过程中，会自动创建此文件 //File对应的硬盘中的文件如果存在: // 如果流使用的构造器是:Filewriter(file,false)/Filewriter(file):对原有文件进行覆盖 // 如果流使用的构造器是:Filewriter(file,true):不会对原有文件覆盖，而是在原有文件基础上追加内容 @Test public void TestFileWriter()&#123; FileWriter fileWriter = null; try &#123; //1.实例化File类对象 File file = new File(&quot;hello1.txt&quot;); //2.实例化FileWriter对象 fileWriter = new FileWriter(file); //3.写出操作 fileWriter.write(&quot;I have a dream!\\n&quot;); fileWriter.write(&quot;you should have a dream,too!&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流 try &#123; if (fileWriter != null) fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.3 FileReader和FileWriter实现文本内容的复制@Test public void TestFileReaderFileWriter()&#123; FileReader fileReader = null; FileWriter fileWriter = null; try &#123; //1.创建File类的对象，指明读入和写出的文件 File in = new File(&quot;hello1.txt&quot;); File out = new File(&quot;hello2.txt&quot;); //2.创建输入流和输出流的对象 fileReader = new FileReader(in); fileWriter = new FileWriter(out); //3.数据的读入和写出操作 char[] input = new char[5]; int len;//记录每次读取到的字符个数 while ((len = fileReader.read(input)) != -1)&#123; String output = new String(input,0,len); fileWriter.write(output); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流资源 //方法一： try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileWriter != null) fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; //方法二： try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileWriter != null) fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.4 字符流不能处理图片的测试@Test public void TestCopyImage()&#123; //测试失败，文件能复制，但不能打开。不能用字符流来处理图片等的字节数据 FileReader fileReader = null; FileWriter fileWriter = null; try &#123; //1.创建File类的对象，指明读入和写出的图片 File in = new File(&quot;TestImage.jpg&quot;); File out = new File(&quot;TestImage1.jpg&quot;); //2.创建输入流和输出流的对象 fileReader = new FileReader(in); fileWriter = new FileWriter(out); //3.数据的读入和写出操作 char[] input = new char[5]; int len;//记录每次读取到的字符个数 while ((len = fileReader.read(input)) != -1)&#123; String output = new String(input,0,len); fileWriter.write(output); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileReader != null) fileReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileWriter != null) fileWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.5 FileInputStream不能读取文本的测试//结论:可以使用字节流FileInputstream处理文本文件，但可能会出现中文乱码 //1．对于文本文件( .txt,.java,.c,.cpp)，使用字符流处理（建议） //2．对于非文本文件(.jpg,.mp3 , .mp4,.avi,.doc,.ppt,. . .)，使用字节流处理（必须） @Test public void TestFileInputStreamText()&#123; FileInputStream fileInputStream = null; try &#123; //1.创建File对象 File file = new File(&quot;hello.txt&quot;); //2.创建FileInputStream对象 fileInputStream = new FileInputStream(file); //3.读取数据 byte[] data = new byte[5]; int len;//记录读取的字节个数 while ((len = fileInputStream.read(data)) != -1)&#123; String str = new String(data,0,len); System.out.print(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.关闭流 try &#123; if (fileInputStream != null) fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.6 FileInputStream和FileOutputStream读写非文本文件//能复制成功 @Test public void TestFileInputOutputStream()&#123; //实现图片的复制 FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try &#123; //1.创建File类的对象，指明读入和写出的图片 File in = new File(&quot;TestImage.jpg&quot;); File out = new File(&quot;TestImage1.jpg&quot;); //2.创建输入流和输出流的对象 fileInputStream = new FileInputStream(in); fileOutputStream = new FileOutputStream(out); //3.数据的读入和写出操作 byte[] input = new byte[5]; int len;//记录每次读取到的字符个数 while ((len = fileInputStream.read(input)) != -1)&#123; fileOutputStream.write(input,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileInputStream != null) fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.3.7 FileInputStream和FileOutputStream复制文件的方法测试//此时，复制成功的文本，点开文件查看不会乱码 //而在12.3.5中使用FileInputStream读入文本内容出现乱码是因为我们在读取数据后输出到控制台进行查看，这样会导致中文字符的字节被截断，而现在我们是在文本数据完整地读取和写出过后在文件中查看，此时中文字符的字节就不会被截断，所以就不会出现乱码 public void copy(String srcPath,String destPath)&#123; FileInputStream fileInputStream = null; FileOutputStream fileOutputStream = null; try &#123; //1.创建File类的对象，指明读入和写出的图片 File in = new File(srcPath); File out = new File(destPath); //2.创建输入流和输出流的对象 fileInputStream = new FileInputStream(in); fileOutputStream = new FileOutputStream(out); //3.数据的读入和写出操作 byte[] input = new byte[1024]; int len;//记录每次读取到的字符个数 while ((len = fileInputStream.read(input)) != -1)&#123; fileOutputStream.write(input,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileInputStream != null) fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void TestCopy()&#123; String srcPath = &quot;E:\\\\桌面文件\\\\IOTest\\\\[乒乓球].ts&quot;; String destPath = &quot;E:\\\\桌面文件\\\\IOTest\\\\[乒乓球复制版].ts&quot;; long start = System.currentTimeMillis(); copy(srcPath,destPath); long end = System.currentTimeMillis(); System.out.println(&quot;复制用时：&quot; + (end - start)); &#125; 12.4 缓冲流(处理流之一)作用：提高流的读取、写入速度 由于缓冲流是作用于节点流上的，只是将节点流读取的数据放入了一个缓存数组中，所以在缓冲流中有一个flush()方法来刷新缓冲区，但我们不用显示地调用flush来进行刷新，因为在源码中它已经调用此方法来进行自动刷新 12.4.1 字节流型//经过测试，缓冲流对文件的复制的确比节点流的速度快 @Test public void TestBuffer()&#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; try &#123; //1.实例化File File srcFile = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\[乒乓球].ts&quot;); File destFile = new File(&quot;E:\\\\桌面文件\\\\IOTest\\\\[乒乓球缓冲流复制版].ts&quot;); //2.实例化流对象：先实例化内层的流，再实例化外层的流 //2.1 实例化节点流 FileInputStream fileInputStream = new FileInputStream(srcFile); FileOutputStream fileOutputStream = new FileOutputStream(destFile); //2.2 实例化缓冲流 bis = new BufferedInputStream(fileInputStream); bos = new BufferedOutputStream(fileOutputStream); //3.文件的赋值 byte[] buffer = new byte[1024]; int len; while ((len = bis.read(buffer)) != -1)&#123; bos.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //4.资源关闭 //要求：先关闭外层的流，再关闭内层的流 //说明：关闭外层流的同时，内层流也会自动的进行关闭。关于内层流的关闭，我们可以省略 try &#123; if (bis != null) bis.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (bos != null) bos.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.4.2 字符流型@Test public void TestBufferReaderWriter()&#123; BufferedReader br = null; BufferedWriter bw = null; try &#123; //1.实例化流和文件对象 br = new BufferedReader(new FileReader(new File(&quot;hello1.txt&quot;))); bw = new BufferedWriter(new FileWriter(new File(&quot;hello2.txt&quot;))); //2.复制文件 //方式一：使用char[]数组 //char[] cbuf = new char[1024]; //int len; //while ((len = br.read(cbuf)) != -1)&#123; // bw.write(cbuf,0,len); // //bw.flush(); //&#125; //方式二：使用String String data; while ((data = br.readLine()) != null)&#123; bw.write(data + &quot;\\n&quot;);//data不包含换行符 //也可以调用bw.newLine()进行换行 &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //3.关闭资源 try &#123; if (br != null) br.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (bw != null) bw.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.4.3 缓冲流练习1.分别使用节点流:FilelnputStream、FileOutputStream和缓冲流:BufferedInputStream、BufferedOutputStream实现文本/文件/图片/视频文件的复制。并比较二者在数据复制方面的效率 2.实现图片加密操作。 提示: int b = 0; while((b = fis.read()) != -1)&#123; fos.write(b ^ 5); &#125; 3.获取文本上每个字符出现的次数 提示:遍历文本的每一个字符;字符及出现的次数保存在Map中;将Map中数据写入文件 12.5 转换流(处理流之二)转换流提供了在字节流和字符流之间的转换 Java API提供了两个转换流： lnputStreamReader：将lnputStream转换为Reader OutputStreamWriter:将Writer转换为OutputStream 字节流中的数据都是字符时，转成字符流操作更高效 很多时候我们使用转换流来处理文件乱码问题。实现编码和解码的功能 image-20210808140840759 12.5.1 InputStreamReader//处理流之二:转换流的使用 //1.转换流:属于字符流 // InputStreamReader:将一个字节的输入流转换为字符的输入流 // OutputStreamWriter:将一个字符的输出流转换为字节的输出流 //2.作用:提供字节流与字符流之间的转换 //3.解码:字节、字节数组---&gt;字符数组、字符串 // 编码:字符数组、字符串---&gt;字节、字节数组 //4.字符集 @Test public void TestInputStreamReader()&#123; InputStreamReader inputStreamReader = null; try &#123; FileInputStream fileInputStream = new FileInputStream(&quot;hello1.txt&quot;); //参数2指明了字符集，具体使用哪个字符集，取决于读入文件保存时使用的字符集 //InputStreamReader inputStreamReader = new InputStreamReader(fileInputStream);//使用系统默认的字符集 inputStreamReader = new InputStreamReader(fileInputStream,&quot;UTF-8&quot;); char[] cbuf = new char[20]; int len; while ((len = inputStreamReader.read(cbuf)) != -1)&#123; String str = new String(cbuf,0,len); System.out.println(str); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (inputStreamReader != null) inputStreamReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.5.2 OutputStreamWriter//InputStreamReader和OutputStreamWriter实现文件的读入和写出 //文件以UTF-8格式读入，以GBK形式写出 @Test public void TestOutputStreamWriter()&#123; InputStreamReader inputStreamReader = null; OutputStreamWriter outputStreamWriter = null; try &#123; FileInputStream fileInputStream = new FileInputStream(new File(&quot;hello2(UTF-8).txt&quot;)); FileOutputStream fileOutputStream = new FileOutputStream(new File(&quot;hello2(GBK).txt&quot;)); inputStreamReader = new InputStreamReader(fileInputStream,&quot;UTF-8&quot;); outputStreamWriter = new OutputStreamWriter(fileOutputStream,&quot;GBK&quot;); //数据读写 char[] cbuf = new char[1024]; int len; while ((len = inputStreamReader.read(cbuf)) != -1)&#123; outputStreamWriter.write(cbuf,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(inputStreamReader != null) inputStreamReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (outputStreamWriter != null) outputStreamWriter.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.5.3 多种字符编码集的说明编码表的由来 计算机只能识别二进制数据，早期由来是电信号。为了方便应用计算机，让它可以识别各个国家的文字。就将各个国家的文字用数字来表示，并一一对应，形成一张表。这就是编码表 常见的编码表 ASCII：美国标准信息交换码。用一个字节的7位可以表示 ISO8859-1：拉丁码表。欧洲码表。用一个字节的8位表示 GB2312：中国的中文编码表。最多两个字节编码所有字符 GBK：中国的中文编码表升级，融合了更多的中文文字符号。最多两个字节编码 Unicode：国际标准码，融合了目前人类使用的所有字符。为每个字符分配唯一的字符码。所有的文字都用两个字节来表示 UTF-8：变长的编码方式，可用1-4个字节来表示一个字符 image-20210808152050497 Unicode不完美，这里就有三个问题，一个是，我们已经知道，英文字母只用一个字节表示就够了，第二个问题是如何才能区别Unicode和ASCII?计算机怎么知道两个字节表示一个符号，而不是分别表示两个符号呢?第三个，如果和GBK等双字节编码方式一样，用最高位是1或0表示两个字节和一个字节，就少了很多值无法用于表示字符，不够表示所有字符。Unicode在很长一段时间内无法推广，直到互联网的出现 面向传输的众多UTF（UCS Transfer Format）标准出现了，顾名思义，UTF-8就是每次8个位传输数据，而UTF-16就是每次16个位。这是为传输而设计的编码，并使编码无国界，这样就可以显示全世界上所有文化的字符了 Unicode只是定义了一个庞大的、全球通用的字符集，并为每个字符规定了唯一确定的编号，具体存储成什么样的字节流，取决于字符编码方案。推荐的Unicode编码是UTF-8和UTF-16 image-20210808151906856 说明：在标准UTF-8编码中，超出基本多语言范围(BMP-Basic Multilinqual Plane)的字符被编码为4字节格式，但在修正的UTF-8编码中，他们由代理编码对( surrogatepairs )表示，然后这些代理编码对在序列中分别重新编码。结果标准UTF-8编码中需要4个字节的字符，在修正后的UTF-8编码中将需要6个字节 12.6 标准输入、输出流（处理流之三）System.in和System.out分别代表了系统标准的输入和输出设备 默认输入设备是：键盘，输出设备是：显示器 System.in的类型是InputStream；System.out的类型是PrintStream，其是OutputStream的子类FilterOutputStream的子类 重定向：通过System类的setIn，setOut方法对默认设备进行改变 public static void setln(InputStream in) public static void setOut(PrintStream out) //1.标准的输入、输出流 //system.in:标准的输入流，默认从键盘输入 //system.out:标准的输出流，默认从控制台输出 public static void main(String[] args) &#123; //从键盘输入字符串，要求将读取到的整行字符串转成大写输出。然后继续进行输入操作，直至当输入“e”或者“exit”时，退出程序 //方法一：使用Scanner，调用next() //方法二：使用System.in。System.in --&gt; 转换流 --&gt; BufferReader的readLine() BufferedReader bufferedReader = null;//将节点流的字符流进行包装，变成缓冲流 try &#123; InputStreamReader inputStreamReader = new InputStreamReader(System.in);//将标准输入流转换成字符流 bufferedReader = new BufferedReader(inputStreamReader);//将字符流传入得到一个缓冲字符流 while (true)&#123; System.out.print(&quot;请输入数据：&quot;); String data = bufferedReader.readLine();//调用缓冲字符流的readLine()方法读取一行数据 if (&quot;e&quot;.equalsIgnoreCase(data) || &quot;exit&quot;.equalsIgnoreCase(data))&#123;//判断是否退出 System.out.println(&quot;程序结束&quot;); break; &#125; String upperData = data.toUpperCase();//将数据转换成大写 System.out.println(upperData); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (bufferedReader != null) bufferedReader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.7 打印流(处理流之四)实现将基本数据类型的数据格式转化为字符串输出 打印流(只有输出流)：PrintStream和PrintWriter 提供了一系列重载的print()和println()方法，用于多种数据类型的输出 PrintStream和PrintWriter的输出不会抛出lOException异常 PrintStream和PrintWriter有自动flush功能 PrintStream打印的所有字符都使用平台的默认字符编码转换为字节。在需要写入字符而不是写入字节的情况下，应该使用PrintWriter 类 System.out返回的是PrintStream的实例 @Test public void TestPrintStreamWriter()&#123; PrintStream ps = null; try &#123; FileOutputStream fos = new FileOutputStream(new File(&quot;hello3.txt&quot;)); //创建打印输出流，设置为自动刷新模式(写入换行符或字节‘\\n’时都会刷新输出缓冲区) ps = new PrintStream(fos,true); if (ps != null) &#123;//把标准输出流(控制台输出)改成文件 System.setOut(ps); &#125; for (int i = 0; i &lt;= 255; i++) &#123; //输出ASCII字符 System.out.print((char) i); if (i % 50 == 0) &#123;//每50个数据一行 System.out.println(); //换行 &#125; &#125; &#125; catch (FileNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if (ps != null) ps.close(); &#125; &#125; 12.8 数据流(处理流之五)为了方便地操作Java语言的基本数据类型和String的数据，可以使用数据流 数据流有两个类：(用于读取和写出基本数据类型、String类的数据) DatalnputStream和 DataOutputStream 分别“套接”在 InputStream和l OutputStream子类的流上 DatalnputStream中的方法： boolean readBoolean() byte readByte() char readChar() float readFloat() double readDouble() short readShort() long readLong() int readlnt() String readUTF() void readFully(byte[] b) DataOutputStream中的方法：将上述的方法的read改为相应的write即可 @Test public void TestDataOutputStream()&#123; //将内存中的字符串、基本数据类型的变量写出到文件夹中 DataOutputStream dataOutputStream = null; try &#123; dataOutputStream = new DataOutputStream(new FileOutputStream(&quot;data.txt&quot;)); dataOutputStream.writeUTF(&quot;张三&quot;); dataOutputStream.flush();//刷新操作，将内存中的数据写入文件 dataOutputStream.writeInt(23); dataOutputStream.flush(); dataOutputStream.writeBoolean(true); dataOutputStream.flush(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (dataOutputStream != null) dataOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void TestDataInputStream() &#123; //将文件中的字符串、基本数据类型数据读取到到内存中 //注意点：读取文件数据的顺序必须和保存数据的顺序一致 DataInputStream dataInputStream = null; try &#123; dataInputStream = new DataInputStream(new FileInputStream(&quot;data.txt&quot;)); String name = dataInputStream.readUTF(); int age = dataInputStream.readInt(); boolean sex = dataInputStream.readBoolean(); System.out.println(&quot;name = &quot; + name); System.out.println(&quot;age = &quot; + age); System.out.println(&quot;sex&quot; + sex); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (dataInputStream != null) dataInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 12.9 对象流(处理流之六)ObjectInputStream和OjbectOutputSteam：用于存储和读取基本数据类型数据或对象的处理流。它的强大之处就是可以把Java中的对象写入到数据源中，也能把对象从数据源中还原回来 序列化：用ObjectOutputStream类保存基本类型数据或对象的机制 反序列化：用ObjectInputStream类读取基本类型数据或对象的机制 ObjectOutputStream和ObjectInputStream不能序列化static和ltransient修饰的成员变量 12.9.1 对象的序列化对象序列化机制允许把内存中的Java对象转换成平台无关的二进制流，从而允许把这种二进制流持久地保存在磁盘上，或通过网络将这种二进制流传输到另一个网络节点。当其它程序获取了这种二进制流，就可以恢复成原来的Java对象 序列化的好处在于可将任何实现了Serializable接口的对象转化为字节数据，使其在保存和传输时可被还原 序列化是RMI(Remote Method lnvoke - 远程方法调用）过程的参数和返回值都必须实现的机制，而RMI是JavaEE的基础。因此序列化机制是JavaEE 平台的基础 如果需要让某个对象支持序列化机制，则必须让对象所属的类及其属性是可序列化的，为了让某个类是可序列化的，该类必须实现如下两个接口之一。否则，会抛出NotSerializableException异常 Serializable Externalizable 12.9.2 测试ObjectOutputStream和ObjectInputStream@Test public void TestObjectOutputStream() &#123; //序列化过程:将内存中的java对象保存到磁盘中或通过网络传输出出去:使用ObjectOutputStream实现 ObjectOutputStream objectOutputStream = null; try &#123; objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;Object.dat&quot;)); objectOutputStream.writeObject(new String(&quot;我爱北京天安门&quot;)); objectOutputStream.flush();//刷新操作 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(objectOutputStream != null) objectOutputStream.close();//关闭 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void TestObjectInputStream()&#123; //反序列化过程:将保存到磁盘文件中的对象还原为内存中的java对象:使用ObjectInputStream实现 ObjectInputStream objectInputStream = null; try &#123; objectInputStream = new ObjectInputStream(new FileInputStream(&quot;Object.dat&quot;)); Object o = objectInputStream.readObject(); String str = (String) o; System.out.println(str); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(objectInputStream != null) &#123; try &#123; objectInputStream.close();//关闭 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 12.9.3 自定义类实现序列化和反序列化操作自定义类能被序列化的要求： 自定义类需要实现Serializable接口和Externalizable接口之一 当前类提供一个全局常量: serialVersionUID 除了当前Person类需要实现Serializable接口之外，还必须保证其内部所有属性(属性的类型也实现接口)也必须是可序列化的(默认情况下，基本数据类型都可序列化) public class Person implements Serializable &#123; public static final long serialVersionUID = 79275029514L;//随便赋值，这是一个标识 private String name; private int age; public Person() &#123; &#125; public Person(String name, int age) &#123; this.name = name; this.age = age; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; @Override public String toString() &#123; return &quot;Person&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &#39;&#125;&#39;; &#125; &#125; @Test public void TestCustomizeObject()&#123; //将java对象序列化 ObjectOutputStream objectOutputStream = null; try &#123; objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;Object.dat&quot;)); objectOutputStream.writeObject(new Person(&quot;张三&quot;,20)); objectOutputStream.flush();//刷新操作 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if(objectOutputStream != null) objectOutputStream.close();//关闭 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void TestCustomizeObject()&#123; //将java对象反序列化 ObjectInputStream objectInputStream = null; try &#123; objectInputStream = new ObjectInputStream(new FileInputStream(&quot;Object.dat&quot;)); Object obj = objectInputStream.readObject(); Person p = (Person) obj; System.out.println(p); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; finally &#123; if(objectInputStream != null) &#123; try &#123; objectInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 12.9.4 序列化时serialVersionUID的理解凡是实现Serializable接口的类都有一个表示序列化版本标识符的静态变量：private static final long serialVersionUID serialVersionUID用来表明类的不同版本间的兼容性。简言之，其目的是以序列化对象进行版本控制，有关各版本反序列化时是否兼容 如果类没有显示定义这个静态常量，它的值是Java运行时环境根据类的内部细节自动生成的。若类的实例变量做了修改，serialVersionUID可能发生变化。故建议，显式声明 简单来说，Java的序列化机制是通过在运行时判断类的serialVersionUID来验证版本一致性的。在进行反序列化时，JVM会把传来的字节流中的serialVersionUID与本地相应实体类的serialVersionUID进行比较，如果相同就认为是一致的，可以进行反序列化，否则就会出现序列化版本不一致的异常(InvalidCastException) （自己的理解）首先假设Person类的serialVersionUID被显式声明，此时对Person类的person对象进行序列化，然后我们对这个Person类内部进行一些比如属性个数增加，方法增多，属性值变化等的修改，然后我们对对象person进行反序列化，此时由于serialVersionUID的显式声明，即被唯一确定，那么这个对象依然能携带着被修改的部分被还原；再假设Person类的serialVersionUID没有被显式声明，则person对象在进行序列化时Java运行环境会自动生成一个serialVersionUID，但当我们做了一些修改后，Java运行环境为Person类自动生成的serialVersionUID就可能会发生变化，那么我们进行反序列化时，JVM就会因为serialVersionUID的不同无法判断被序列化的对象person是哪个类的对象，从而就无法还原 12.10 随机存取文件流RandomAccessFile声明在java.io包下，但直接继承于java.lang.Object类。并且它实现了Datalnput、DataOutput这两个接口，也就意味着这个类既可以读也可以写 RandomAccessFile类支持“随机访问”的方式，程序可以直接跳到文件的任意地方来读、写文件 支持只访问文件的部分内容 可以向已存在的文件后追加内容 RandomAccessFile对象包含一个记录指针，用以标示当前读写处的位置 RandomAccessFile 类对象可以自由移动记录指针： long getFilePointer()：获取文件记录指针的当前位置 void seek(long pos)：将文件记录指针定位到pos位置 构造器: public RandomAccessFile(File file, String mode) public RandomAccessFile(String name, String mode) 创建RandomAccessFile类实例需要指定一个mode参数，该参数指定RandomAccessFile的访问模式： r：以只读方式打开 rw：打开以便读取和写入 rwd：打开以便读取和写入；同步文件内容的更新 rws：打开以便读取和写入；同步文件内容和元数据的更新 如果模式为只读r，则不会创建文件，而是会去读取一个已经存在的文件，如果读取的文件不存在则会出现异常 如果模式为rw读写。如果文件不存在则会去创建文件；如果存在则不会创建，但是会对原有文件的内容进行覆盖(默认从头覆盖) 补充：JDK1.6上面写的每次write数据时，**”rw”模式，数据不会立即写到硬盘中；而“rwd”，数据会被立即写入硬盘。如果写数据过程发生异常，“rwd”模式中已被wite的数据被保存到硬盘，而“rw”则全部丢失** 12.10.1 RandomAccessFile的使用1.RandomAccessFile对文件数据的读取和写入//RandomAccessFiLe的使用 //1.RandomAccessFile直接继承于java.Lang.object类，实现了DataInput和DataOutput接口 //2.RandomAccessFile既可以作为一个输入流，又可以作为一个输出流 @Test public void TestRandomAccessFile()&#123; //对数据进行读取和写入（复制） RandomAccessFile randomAccessFile1 = null; RandomAccessFile randomAccessFile2 = null; try &#123; randomAccessFile1 = new RandomAccessFile(new File(&quot;TestImage.jpg&quot;),&quot;r&quot;); randomAccessFile2 = new RandomAccessFile(new File(&quot;TestImage2.jpg&quot;),&quot;rw&quot;); byte[] buffer = new byte[1024]; int len; while ((len = randomAccessFile1.read(buffer)) != -1)&#123; randomAccessFile2.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; if (randomAccessFile1 != null) &#123; try &#123; randomAccessFile1.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (randomAccessFile2 != null) &#123; try &#123; randomAccessFile2.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 2.RandomAccessFile对文件原有数据的覆盖效果@Test public void Test()&#123; //向文件添加新数据时默认从头开始覆盖原有内容 RandomAccessFile randomAccessFile = null; try &#123; randomAccessFile = new RandomAccessFile(new File(&quot;hello.txt&quot;),&quot;rw&quot;); randomAccessFile.write(&quot;xyz&quot;.getBytes());//write展示出的效果是对原有内容的覆盖 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (randomAccessFile != null) randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 3.RandomAccessFile实现对文件数据的插入//实现数据的插入 @Test public void TestRandomAccessFileInsert() throws FileNotFoundException &#123; RandomAccessFile randomAccessFile = null; try &#123; randomAccessFile = new RandomAccessFile(new File(&quot;hello.txt&quot;),&quot;rw&quot;); randomAccessFile.seek(3);//将角标移动到3的位置(角标从0开始) //将指针3后面的数据内容保存到StringBuilder中 StringBuilder builder = new StringBuilder((int) new File(&quot;hello.txt&quot;).length()); byte[] buffer = new byte[20]; int len; while ((len = randomAccessFile.read(buffer)) != -1)&#123; builder.append(new String(buffer,0,len)); &#125; //将指针重新定位到3处 randomAccessFile.seek(3); randomAccessFile.write(&quot;abc&quot;.getBytes()); //将StringBuilder中数据写入文件中 randomAccessFile.write(builder.toString().getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (randomAccessFile != null) randomAccessFile.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; //思考：将StringBuilder替换为ByteArrayOutputStream 12.11 NIO.2中Path、Paths、Files类的使用12.11.1 NIO的介绍Java NlO (New lO，Non-Blocking lO)是从Java 1.4版本开始引入的一套新的IO APl，可以替代标准的Java lO API。NIO与原来的IO有同样的作用和目的，但是使用的方式完全不同，NIO支持面向缓冲区的(IO是面向流的)、基于通道的IO操作。NIO将以更加高效的方式进行文件的读写操作 JavaAPI中提供了两套NIO，一套是针对标准输入输出NIO，另一套就是网络编程NIO java.nio.channels.Channel FileChannel：处理本地文件 SocketChannel：TCP网络编程的客户端的Channel ServerSocketChannel：TCP网络编程的服务器端的Channel DatagramChannel：UDP网络编程中发送端和接收端的Channel 随着JDK7的发布，Java对NIO进行了极大的扩展，增强了对文件处理和文件系统特性的支持，以至于我们称他们为NIO.2。因为NIO提供的一些功能，NIO已经成为文件处理中越来越重要的部分 12.11.2 Path、Paths、Files核心API早期的Java只提供了一个File类来访问文件系统，但File类的功能比较有限，所提供的方法性能也不高。而且，大多数方法在出错时仅返回失败，并不会提供异常信息 NIO. 2为了弥补这种不足，引入了Path接口， 代表一个平台无关的平台路径，描述了目录结构中文件的位置。Path可以看成是File类的升级版本， 实际引用的资源也可以不存在 在以前IO操作都是这样写的：import java.io.File;File file = new File(&quot;index.html&quot;);但在Java7中，可以这样写:import java.nio.file.Path;import java.nio.file.Paths;Path path = Paths.get(&quot;index.html&quot;); 同时，NIO.2在java.nio.file包下还提供了Files、Paths 工具类，Files包含了大量静态的工具方法来操作文件; Paths则包含了两个返回Path的静态工厂方法 Paths类提供的静态get()方法用来获取Path对象： static Path get(String first, String…more)：用于将多个字符串串连成路径 static Path get(URI uri)：返回指定uri对应的Path路径 1.Path接口Path常用方法： String toString()：返回调用Path对象的字符串表示形式 boolean startsWith(String path)：判断是否以path路径开始 boolean endsWith(String path)：判断是否以path路径结束 boolean isAbsolute()：判断是否是绝对路径 Path getParent()：返回Path对象包含整个路径，不包含Path对象指定的文件路径 Path getRoot()：返回调用Path对象的根路径 Path getFileName()：返回与调用Path对象关联的文件名 int getNameCount()：返回Path根目录后面元素的数量 Path getName(int idx)：返回指定索引位置idx的路径名称 Path toAbsolutePath()：作为绝对路径返回调用Path 对象 Path resolve(Path p)：合并两个路径，返回合并后的路径对应的Path对象 File toFile()：将Path转化为File类的对象 2.Files类java.nio.file.Files用于操作文件或目录的工具类 Files常用方法： Path copy(Path src, Path dest, CopyOption…how)：文件的复制 Path createDirectory(Path path, FileAttribute&lt;?&gt;…attr)：创建一个目录 Path createFile(Path path, FileAttribute&lt;?&gt;…arr)：创建一个文件 void delete(Path path)：删除一个文件/目录，如果不存在，执行报错 void deletelfExists(Path path)：Path对应的文件/目录如果存在，执行删除 Path move(Path src, Path dest, CopyOption…how)：将src移动到dest位置 long size(Path path)：返回path指定文件的大小 用于判断： boolean exists(Path path, LinkOption…opts)：判断文件是否存在 boolean isDirectory(Path path, LinkOption…opts)：判断是否是目录 boolean isRegularFile(Path path, LinkOption…opts)：判断是否是文件 boolean isHidden(Path path)：判断是否是隐藏文件 boolean isReadable(Path path)：判断文件是否可读 boolean isWritable(Path path)：判断文件是否可写 boolean notExists(Path path, LinkOption…opts)：判断文件是否不存在 用于操作内容： SeekableByteChannel newByteChannel(Path path, OpenOption…how)：获取与指定文件的连接,how指定打开方式 DirectoryStream newDirectoryStream(Path path)：打开path指定的目录 InputStream newlnputStream(Path path, OpenOption… how)：获取InputStream 对象 OutputStream newOutputStream(Path path, OpenOptin… how)：获取OutputStream对象 十三、Java网络编程13.1 网络编程概述Java是Internet上的语言，它从语言级上提供了对网络应用程序的支持，程序员能够很容易开发常见的网络应用程序 Java提供的网络类库，可以实现无痛(不用关注底层)的网络连接，联网的底层细节被隐藏在Java的本机安装系统里，由JVM进行控制。并且Java实现了一个跨平台的网络库，程序员面对的是一个统一的网络编程环境 13.1.1 网络基础计算机网络：把分布在不同地理区域的计算机与专门的外部设备用通信线路互连成一个规模大、功能强的网络系统，从而使众多的计算机可以方便地互相传递信息、共享硬件、软件、数据信息等资源 网络编程的目的：直接或间接地通过网络协议与其它计算机实现数据交换，进行通讯 网络编程中有两个主要的问题：①如何准确地定位网络上一台或多台主机；定位主机上的特定的应用②找到主机后如何可靠高效地进行数据传输 13.1.2 如何实现网络中的主机互相通信(网络编程的两个要素)通信双方地址： IP 端口号 一定的规则(即：网络通信协议。有两套参考模型) OSI参考模型：模型过于理想化，未能在因特网上进行广泛推广 **TCP/IP参考模型(或TCP/IP协议)**：事实上的国际标准 image-20210809110936920 1.TCP/IP参考模型各层的作用应用层：提供应用程序的网络接口 传输层：为两台主机间的应用程序提供端到端的通信。传输层从应用层接受数据，并且在必要的时候把它分成较小的单元，传递给网络层，并确保到达对方的各段信息正确无误 网络层：主要协议有IP (Internet protocol) 、ICMP (Internet Control Message Protocol ，互联网控制报文协议)、IGMP ( Internet Group Management Protocol，互联网组管理协议)、ARP (Address Resolution Protocol ,地址解析协议)和RARP (Reverse Address Resolution Protocol ，反向地址解析协议)等。涉及寻址和路由选择 物理层和数据链路层：涉及物理介质访问和二进制数据流传输 2.各层涉及到的具体协议：TCP/IP是基于TCP和IP这两个最初的协议之上的不同的通信协议的大集合。又称为TCP/IP协议簇 协议名称 协议作用 TCP-传输控制协议 TCP用于从应用程序到网络的数据传输控制TCP负责在数据传送之前将它们分割为IP包，然后在它们到达的时候将它们重组 IP-网际协议 IP负责计算机之间的通信IP负责在因特网上发送和接收数据包 HTTP-超文本传输协议 HTTP负责web服务器与web浏览器之间间的通信HTTP用于从web客户端(浏览器)与web服务器发送请求，并从web服务器向web客户端返回内容(网页) HTTPS-安全的HTTP HTTPS负责在web服务器和web浏览器之间的安全通信作为有代表性的应用, HTTPS会用于处理信用卡交易和其他的敏感数据 SSL-安全套接字层 SSL协议用于为安全数据传输加密数据 SMTP-简易邮件传输协议 SMTP用于电子邮件的传输 MIME-多用途因特网邮件扩展 MIME协议使SMTP有能力通过TCP/IP网络传输多媒体文件 ，包括声音、 视频和二进制数据 IMAP-因特网消息访问协议 IMAP用于存储和取回电子邮件 POP-邮局协议 POP用于从电子邮件服务器向个人电脑下载电子邮件 FTP-文件传输协议 FTP负责计算机之间的文件传输 NTP-网络时间协议 NTP用于在计算机之间同步时间(钟) DHCP-动态主机配置协议 DHCP用于向网络中的计算机分配动态IP地址 SNMP-简单网络管理协议 SNMP用于计算机网络的管理 LDAP-轻量级的目录访问协议 LDAP用于从因特网搜集关于用户和电子邮件地址的信息 ICMP-因特网消息控制协议 ICMP负责网络中的错误处理 ARP-Address Resolution Protocol ARP-用于通过IP来查找基于IP地址的计算机网卡的硬件地址 BOOTP-Boot Protocol BOOTP用于从网络启动计算机 PPTP-点对点隧道协议 PPTP用于私人网络之间的连接(隧道) 3.网络通信示例图image-20210809114126991 13.2 通信要素1：IP和端口号13.2.1 IP地址IP地址：InetAddress（Java中一个InetAddress对象就代表一个IP地址） 唯一的标识Internet上的计算机(通信实体) 本地回环地址(hostAddress)：127.0.0.1 主机名(hostName)：localhost IP地址分类方式1: IPV4 和IPV6 IPV4：4个字节组成，4个0-255。 大概42亿，30亿都在北美，亚洲4亿。2011年初已经用尽。以点分十进制表示，如192.168.0.1 VIPV6：128位(16个字节)，写成8个无符号整数，每个整数用四个十六进制位表示，数之间用冒号(:)分开，如: 3ffe:3201:1401:1280:c8ff.fe4d:db39:1984 IP地址分类方式2：**公网地址(万维网使用)和私有地址(局域网使用)**。192.168.开头的就是私有址址，范围即为192.168.0.0——192.168.255.255，专门为组织机构内部使用 特点：不易记忆 1.通过域名访问对应的IP地址的网址image-20210809144629029 2.InetAddress类的使用//如何实例化InetAddress:两个方法getByName(String host)、getLocalHost() //两个常用方法:getHostName()、getHostAddress() InetAddress address = InetAddress.getByName(&quot;192.168.9.59&quot;);//通过字符串生成一个IP地址 System.out.println(address);///192.168.9.59 InetAddress address1 = InetAddress.getByName(&quot;www.baidu.com&quot;);//通过域名然后内部解析后生成一个IP地址 System.out.println(address1);//www.baidu.com/14.215.177.39 System.out.println(address1.getHostName());//获取主机名字 System.out.println(address1.getHostAddress());//获取主机地址 InetAddress address2 = InetAddress.getByName(&quot;127.0.0.1&quot;);//通过字符串获取本机IP地址 System.out.println(address2); InetAddress address3 = InetAddress.getLocalHost();//另一种获取本机IP地址的方法 System.out.println(address3); 13.2.2 端口号端口号标识正在计算机上运行的进程(程序) 不同的进程有不同的端口号 被规定为一个16位的整数0~65535 端口分类： 公认端口：0~1023。 被预先定义的服务通信占用(如: HTTP占用端口 80，FTP占用端口21，Telnet占用端口23) 注册端口：1024~49151。 分配给用户进程或应用程序。( 如: Tomcat占 用端口8080，MySQL占用端口3306，Oracle 占用端口1521等) 动态/私有端口：49152~65535 端口号与IP地址的组合得出一个网络套接字：Socket 1.两台主机间同一应用的通信：image-20210809150824749 13.3 通信要素2：网络通信协议网络通信协议：计算机网络中实现通信必须有一些约定，即通信协议，对速率、传输代码、代码结构、传输控制步骤、出错控制等制定标准 计算机网络通信涉及内容很多，比如指定源地址和目标地址，加密解密，压缩解压缩，差错控制，流量控制，路由控制，这就产生了如何实现如此复杂的网络协议的问题 通信协议分层的思想：在制定协议时，把复杂成份分解成一些简单的成份，再将它们复合起来。最常用的复合方式是层次方式，即同层间可以通信、上一层可以调用下一层，而与再下一层不发生关系。各层互不影响，利于系统的开发和扩展 13.3.1 TCP/IP协议簇涉及到传输层和网络层的协议 传输层协议中有两个非常重要的协议: 传输控制协议TCP(Transmission Control Protocol) 用户数据报协议UDP(User Datagram Protocol) TCP/IP以其两个主要协议：传输控制协议(TCP)和网络互联协议(IP)而得名，实际上是一组协议，包括多个具有不同功能且互为关联的协议 IP(Internet Protocol)协议是网络层的主要协议，支持网间互连的数据通信 TCP/IP协议模型从更实用的角度出发，形成了高效的四层体系结构，即物理链路层、IP层、传输层和应用层 13.3.2 传输层的TCP和UDP协议主要区别TCP协议： 使用TCP协议前，须先建立TCP连接，形成传输数据通道 传输前，采用“三次握手”方式，点对点通信，是可靠的 TCP协议进行通信的两个应用进程：客户端、服务端 在连接中可进行大数据量的传输 传输完毕，需释放已建立的连接，效率低 UDP协议： 将数据、源、目的封装成数据包，不需要建立连接 每个数据报的大小限制在64K内 发送不管对方是否准备好，接收方收到也不确认，故是不可靠的 可以广播发送 发送数据结束时无需释放资源，开销小，速度快 TCP生活案例：打电话UDP生活案例：发送短信、发电报 1.TCP三次握手和四次挥手 第一次握手：建立连接时，客户端发送SYN包（seq=x）到服务器，并进入SYN_SENT状态，等待服务器确认；SYN：同步序列编号（Synchronize Sequence Numbers） 第二次握手：服务器收到SYN包，必须确认客户端的SYN（ack=x+1），同时自己也发送一个SYN包（seq=y），即SYN+ACK包，此时服务器进入SYN_RECV状态 第三次握手：客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1)，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手 image-20210809153742315 客户端或服务器均可主动发起挥手动作，在socket编程中，任何一方执行close0操作即可产生挥手操作 (1)客户端A发送个FIN，用来关闭客户A到服务器B的数据传送 (2)服务器B收到这个FIN，它发回个ACK，确认序号为收到序号加1和SYN一样，一个FIN将占用一个序号 (3)服务器B关闭与客户端A的连接，发送个FIN给客户端A (4)客户端A发回ACK报文确认,并将确认序号设置为收到序号加1 13.4 TCP网络编程13.4.1 实例1：客户端发送信息给服务端，服务端将信息显示在控制台//实现TCP网络编程 //实例1:客户端发送信息给服务端，服务端将信息显示在控制台 //测试程序时要先启动服务器端等待客户端呼叫 @Test public void Client()&#123;//客户端 Socket socket = null; OutputStream outputStream = null; try &#123; //1.创建IP地址对象 InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;);//服务器IP地址，由于是自己测试，所以用本机IP //2.创建Socket对象，指明服务器端的ip和端口号 socket = new Socket(address,8899);//利用要传输到的IP地址和传输到的端口号创建一个套接字Socket对象 //3.获取一个输出流，用于输出数据 outputStream = socket.getOutputStream();//通过这个对象获取一个输出流 //4.输出数据 outputStream.write(&quot;你好，我是客户端&quot;.getBytes());//输出内容到服务端 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//5.关闭资源 if (outputStream != null) &#123; try &#123; outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (socket != null) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; @Test public void Server()&#123;//服务器端 ServerSocket serverSocket = null; Socket socket = null; InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = null; try &#123; //1.创建ServerSocket对象，指明自己的端口号 serverSocket = new ServerSocket(8899); //2.调用accept()方法来接收客户端传输过来的socket socket = serverSocket.accept(); //3.获取一个输入流来读取数据 inputStream = socket.getInputStream(); //这样写可能会乱码，如果传过来的信息的字节流因为buffer数组的容量不够大，读取的时候被拆散开，那么在转换成字符串的时候就可能会出现乱码 //比如客户端传过来一段中文，buffer数组的容量又为5，即一次性只能读取5个字节，而一个中文字符如果占3个字节， //那么第二个中文字符的字节就会被拆散开，在另一部分字节被读取之前，我们又需要把已读取的字节转换成字符串输出出来，这时候就可能会出现乱码 //byte[] buffer = new byte[20]; //int len; //while ((len = inputStream.read(buffer)) != -1)&#123; // String str = new String(buffer,0,len); // System.out.println(str); //&#125; //4.读取输入流中数据 byteArrayOutputStream = new ByteArrayOutputStream(); //5.对数据进行操作 byte[] buffer = new byte[5]; int len; while ((len = inputStream.read(buffer)) != -1)&#123; byteArrayOutputStream.write(buffer,0,len); &#125; System.out.println(byteArrayOutputStream.toString()); System.out.println(&quot;收到来自&quot; + socket.getInetAddress().getHostAddress() + &quot;的消息&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//6.关闭资源 if ((socket != null)) &#123; try &#123; socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (serverSocket != null) &#123; try &#123; serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (inputStream != null) &#123; try &#123; inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; if (byteArrayOutputStream != null) &#123; try &#123; byteArrayOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; 13.4.2 实例2：客户端发送文件给服务端，服务端将文件保存在本地//实例2:客户端发送文件给服务端，服务端将文件保存在本地 @Test public void Client()&#123;//客户端 Socket socket = null; OutputStream outputStream = null; FileInputStream fileInputStream = null; try &#123; //1.创建IP地址对象 InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;); //2.创建Socket对象 socket = new Socket(address,9090); //3.获取输出流，用于输出数据到服务器端 outputStream = socket.getOutputStream(); //4.创建一个文件字节输入流，读取文件到数组buffer中让输出流输出 fileInputStream = new FileInputStream(new File(&quot;TestImage.jpg&quot;)); byte[] buffer = new byte[1024]; int len; while ((len = fileInputStream.read(buffer)) != -1)&#123; outputStream.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//5.关闭资源 try &#123; if (fileInputStream != null) fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void Server()&#123;//服务器端 ServerSocket serverSocket = null; Socket socket = null; InputStream inputStream = null; FileOutputStream fileOutputStream = null; try &#123; //1.创建ServerSocket对象 serverSocket = new ServerSocket(9090); //2.调用ServerSocket的accept()方法获取客户端的套接字对象以进行通信 socket = serverSocket.accept(); //3.获取一个输入流来读取客户端的数据 inputStream = socket.getInputStream(); //4.创建一个文件字节输出流，把客户端的文件保存到本地 fileOutputStream = new FileOutputStream(new File(&quot;SocketImage.jpg&quot;)); //5.用输入流读取客户端的数据，再让文件字节输出流输出数据保存到本地 byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1)&#123; fileOutputStream.write(buffer,0,len); &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; try &#123; if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (serverSocket != null) serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 13.4.3 实例3：从客户端发送文件给服务端，服务端保存到本地，并返回“发送成功”给客户端，并关闭相应的连接//3.从客户端发送文件给服务端，服务端保存到本地,并返回“发送成功”给客户端,并关闭相应的连接 @Test public void Client()&#123; Socket socket = null; OutputStream outputStream = null; FileInputStream fileInputStream = null; InputStream inputStream = null; ByteArrayOutputStream byteArrayOutputStream = null; try &#123; //1.创建IP地址对象 InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;); //2.创建Socket对象 socket = new Socket(address,9090); //3.获取输出流，用于输出数据到服务器端 outputStream = socket.getOutputStream(); //4.创建一个文件字节输入流，读取文件到数组buffer中让输出流输出 fileInputStream = new FileInputStream(new File(&quot;TestImage.jpg&quot;)); byte[] buffer = new byte[1024]; int len; while ((len = fileInputStream.read(buffer)) != -1)&#123; outputStream.write(buffer,0,len); &#125; //注意，此处需要利用socket对象关闭输出流来告诉服务器端传输已完成，否则服务器端就会一直等待客户端的下一次传输而不执行下方的反馈代码 socket.shutdownOutput(); //5.获取一个输入流，用于读取来自服务器端的数据 inputStream = socket.getInputStream(); //6.创建字节数组输出流，用于将输入流读取的服务器端数据输出 byteArrayOutputStream = new ByteArrayOutputStream(); byte[] buffer1 = new byte[20];//存储读取到的数据 int len1; while ((len1 = inputStream.read(buffer1)) != -1)&#123; byteArrayOutputStream.write(buffer1,0,len1);//将读取到的数据写到自身类定义的数组中 &#125; System.out.println(byteArrayOutputStream.toString());//将数组转换成字符串输出到控制台 &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//7.关闭资源 try &#123; if (fileInputStream != null) fileInputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (byteArrayOutputStream != null) byteArrayOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Test public void Server()&#123; ServerSocket serverSocket = null; Socket socket = null; InputStream inputStream = null; FileOutputStream fileOutputStream = null; OutputStream outputStream = null; try &#123; //1.创建ServerSocket对象 serverSocket = new ServerSocket(9090); //2.调用ServerSocket的accept()方法获取客户端的套接字对象以进行通信 socket = serverSocket.accept(); //3.获取一个输入流来读取客户端的数据 inputStream = socket.getInputStream(); //4.创建一个文件字节输出流，把客户端的文件保存到本地 fileOutputStream = new FileOutputStream(new File(&quot;SocketImage1.jpg&quot;)); //5.用输入流读取客户端的数据，再让文件字节输出流输出数据保存到本地 byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1)&#123; fileOutputStream.write(buffer,0,len); &#125; System.out.println(&quot;接收数据完成&quot;); //6.获取一个输出流对象，用于给客户端反馈 outputStream = socket.getOutputStream(); outputStream.write(&quot;服务器端已收到文件&quot;.getBytes()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123;//7.关闭资源 try &#123; if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (socket != null) socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (serverSocket != null) serverSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (outputStream != null) outputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 13.4.4 实例4：服务端读取图片并发送给客户端，客户端保存图片到本地13.4.5 实例5：客户端给服务端发送文本，服务端会将文本转成大写在返回给客户端13.5 UDP网络编程类 DatagramSocket和DatagramPacket实现了基于UDP协议网络程序 UDP数据报通过数据报套接字DatagramSocket发送和接收，系统不保证UDP数据报一定能够安全送到目的地，也不能确定什么时候可以抵达 DatagramPacket对象封装了UDP数据报，在数据报中包含了发送端的IP地址和端口号以及接收端的IP地址和端口号 UDP协议中每个数据报都给出了完整的地址信息，因此无须建立发送方和接收方的连接。如同发快递包裹一样 //UDP网络编程 //UDP要传输的数据、传输到的主机IP及端口都打包在数据报中，所以socket只是一个根据数据报中的IP和端口进行发送数据报和接收数据报的作用 @Test public void Send() throws IOException &#123;//发送端 //1.创建数据报套接字DatagramSocket对象，用于传输数据 DatagramSocket socket = new DatagramSocket(); String str = &quot;我是UDP发送端&quot;;//要传输的数据 byte[] data = str.getBytes(); //2.获取要发送到的IP地址对象 InetAddress address = InetAddress.getByName(&quot;127.0.0.1&quot;); //3.创建发送端的数据报对象，其中包含要传输的数据、要传输到的主机的IP地址及端口 DatagramPacket packet = new DatagramPacket(data,0,data.length,address,9090); //4.发送打包好的数据报 socket.send(packet); //5.关闭socket socket.close(); &#125; @Test public void Receiver() throws IOException &#123;//接收端 //1.创建数据报套接字DatagramSocket对象，用于接收传入的端口参数中的数据 DatagramSocket socket = new DatagramSocket(9090); byte[] buffer = new byte[100];//存储数据的数组 //2.创建接收端的数据报对象，来接收保存传来的数据报 DatagramPacket packet = new DatagramPacket(buffer,0,buffer.length); //3.接收发送端的数据报 socket.receive(packet); System.out.println(new String(packet.getData(),0,packet.getLength()));//对数据进行处理操作 //4.关闭socket socket.close(); &#125; 13.6 URL编程URL(Uniform Resource Locator)：统一资源定位符，它表示Internet上某一资源的地址 它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源 通过URL我们可以访问Internet上的各种网络资源，比如最常见的 www，ftp站点。浏览器通过解析给定的URL可以在网络上查找相应的文件或其他资源 URL的基本结构由5部分组成：&lt;传输协议&gt;://&lt;主机名&gt;:&lt;端口号&gt;/&lt;文件名&gt;#片段名?参数列表&gt; 例如：http://192.168.1.100:8080/helloworld/index.jsp#a?username=shkstart&amp;password=123&gt; #片段名：即锚点，例如看小说，直接定位到章节 参数列表格式：参数名=参数值&amp;参数名=参数值… 13.6.1 构造器为了表示URL，java.net中实现了类URL。我们可以通过下面的构造器来初始化一个URL对象： public URL(String spec)：通过一个表示URL地址的字符串可以构造一个URL对象。例如：URL url = new URL (&quot;http://www.baidu.com&quot;); public URL(URL context，String spec)：通过基URL和相对URL构造一个URL对象。例如：URL downloadUrl = new URL(url, &quot;download.html&quot;); public URL(String protocol, String host, String file)；例如：new URL(&quot;http&quot;,&quot;www.baidu.com&quot;,&quot;download.html&quot;); public URL(String protocol, String host, int port, String file)；例如：URL gamelan = new URL(&quot;http&quot;, &quot;www.baidu.com&quot;, 80, &quot;download.html&quot;); URL类的构造器都声明抛出非运行时异常，必须要对这一异常进行处理，通常是用try-catch语句进行捕获 13.6.2 常用方法一个URL对象生成后，其属性是不能被改变的，但可以通过它给定的方法来获取这些属性： public String getProtocol( )：获取该URL的协议名 public String getHost( )：获取该URL的主机名 public String getPort( )：获取该URL的端口号 public String getPath( )：获取该URL的文件路径 public String getFile( )：获取该URL的文件名 public String getQuery( )：获取该URL的查询名 //URL网络编程 //1.URL:统—资源定位符，对应着互联网的某—资源地址2.格式: //http://Localhost:8080/TestImage.jpg?username=Tom // 协议 主机名 端口号 资源地址 参数列表 @Test public void TestURL()&#123; URL url = null; try &#123; url = new URL(&quot;http://Localhost:8080/examples/TestImage.jpg?username=Tom&quot;); //public String getProtocol()：获取该URL的协议名 System.out.println(url.getProtocol());// http //public String getHost()：获取该URL的主机名 System.out.println(url.getHost());// Localhost //public String getPort()：获取该URL的端口号 System.out.println(url.getPort());// 8080 //public String getPath()：获取该URL的文件路径 System.out.println(url.getPath());// /TestImage.jpg //public String getFile()：获取该URL的文件名 System.out.println(url.getFile());// /TestImage.jpg?username=Tom //public String getQuery()：获取该URL的查询名 System.out.println(url.getQuery());// username=Tom &#125; catch (MalformedURLException e) &#123; e.printStackTrace(); &#125; &#125; //URL实现Tomcat服务器端资源下载 @Test public void TestURLDownload()&#123; HttpURLConnection urlConnection = null; InputStream inputStream = null; FileOutputStream fileOutputStream = null; try &#123; //1.创建一个URL对象，确定要访问的地址和资源 URL url = new URL(&quot;http://Localhost:8080/examples/TestImage.jpg&quot;); //2.获取Http连接 urlConnection = (HttpURLConnection) url.openConnection();//用于获取跟服务器的连接 //3.连接到目的地址 urlConnection.connect(); //4.获取一个输入流对象，用来读入资源 inputStream = urlConnection.getInputStream(); //5.创建一个文件字节输出流对象，用来将输入流读取的资源保存到本地 fileOutputStream = new FileOutputStream(&quot;URLImage.jpg&quot;); byte[] buffer = new byte[1024]; int len; while ((len = inputStream.read(buffer)) != -1)&#123; fileOutputStream.write(buffer,0,len); &#125; System.out.println(&quot;下载完成&quot;); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; finally &#123; //6.关闭资源和连接 try &#123; if (fileOutputStream != null) fileOutputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; try &#123; if (inputStream != null) inputStream.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; if (urlConnection != null) urlConnection.disconnect(); &#125; &#125; 十四、Java反射机制14.1 Java反射机制概述Reflection(反射）是被视为动态语言的关键，反射机制允许程序在执行期借助于Reflection API取得任何类的内部信息，并能直接操作任意对象的内部属性及方法 加载完类之后，在堆内存的方法区中就产生了一个Class类型的对象（一个类只有一个Class对象），这个对象就包含了完整的类的结构信息。我们可以通过这个对象看到类的结构。这个对象就像一面镜子，透过这个镜子看到类的结构，所以，我们形象的称之为：反射 正常方式：引入需要的“包类”名称 —&gt; 通过new实例化 —&gt; 取得实例化对象反射方式：实例化对象 —&gt; getClass()方法 —&gt; 得到完整的“包类”名称 14.1.1 动态语言与静态语言1、动态语言 是一类在运行时可以改变其结构的语言：例如新的函数、对象、甚至代码可以被引进，已有的函数可以被删除或是其他结构上的变化。通俗点说就是在运行时代码可以根据某些条件改变自身结构主要动态语言：Object-C、C#、JavaSript、PHP、Python、Erlang 2、静态语言 与动态语言相对应的，运行时结构不可变的语言就是静态语言。如Java、C、C++Java不是动态语言，但Java可以称之为“准动态语言”。即Java有一定的动态性，我们可以利用反射机制、字节码操作获得类似动态语言的特性，Java的动态性让编程的时候更加灵活 14.1.2 Java反射机制研究及应用Java反射机制提供的功能： 在运行时判断任意一个对象所属的类 在运行时构造任意一个类的对象 在运行时判断任意一个类所具有的成员变量和方法 在运行时获取泛型信息 在运行时调用任意一个对象的成员变量和方法 在运行时处理注解 生成动态代理 14.1.3 反射相关的API java.lang.Class：代表一个类(所有的类都相当于是Class的对象) java.lang.reflect.Method：代表类的方法 java.lang.reflect.Field：代表类的成员变量 java.lang.reflect.Constructor：代表类的构造器 …… 14.1.4 反射前后对一个类的操作对比//反射之前，对于Person类的操作 @Test public void TestBeforeReflection()&#123; //1.创建Person对象 Person p1 = new Person(&quot;Tom&quot;,12); //2.通过对象，调用其内部的属性、方法 p1.age = 10; System.out.println(p1.toString()); p1.show(); //在Person类外部，不可以通过Person类的对象调用其内部私有结构 //比如，name、showNation()、Person(String name) &#125; //使用反射之后 @Test public void TestAfterReflection() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Class clazz = Person.class; //1.通过反射创建Person类的对象 Constructor constructor = clazz.getConstructor(String.class, int.class); Object tom = constructor.newInstance(&quot;Tom&quot;, 12); Person p1 = (Person) tom; System.out.println(p1.toString());//Person&#123;name=&#39;Tom&#39;, age=12&#125; //2.通过反射，调用对象指定的属性、方法 //调用属性 Field age = clazz.getDeclaredField(&quot;age&quot;); age.set(p1,10); System.out.println(p1.toString());//Person&#123;name=&#39;Tom&#39;, age=10&#125; //调用方法 Method show = clazz.getDeclaredMethod(&quot;show&quot;); show.invoke(p1);//这是Person类 //通过反射，还可以调用Person类的私有结构的。比如:私有的构造器、方法、属性 //私有构造器 Constructor constructor1 = clazz.getDeclaredConstructor(String.class); constructor1.setAccessible(true); Person jerry = (Person) constructor1.newInstance(&quot;Jerry&quot;); System.out.println(jerry);//Person&#123;name=&#39;Jerry&#39;, age=0&#125; //私有属性 Field name = clazz.getDeclaredField(&quot;name&quot;); name.setAccessible(true); name.set(jerry,&quot;Mary&quot;); System.out.println(jerry);//Person&#123;name=&#39;Mary&#39;, age=0&#125; //私有方法 Method showNation = clazz.getDeclaredMethod(&quot;showNation&quot;, String.class); showNation.setAccessible(true); String nation = (String) showNation.invoke(jerry,&quot;中国&quot;);//相当于String nation = jerry.showNation(&quot;中国&quot;) 我的国籍是中国 System.out.println(nation);//中国 &#125; 14.2 Class类的理解及获取Class实例14.2.1 Class类的理解关于java.Lang.class类的理解： 1.类的加载过程: 程序经过javac.exe命令以后，会生成一个或多个字节码文件(.class结尾)接着我们使用java.exe命令对某个字节码文件进行解释运行，相当于将某个字节码文件加载到内存中。此过程就称为类的加载。加载到内存中的类，我们就称为运行时类，此运行时类，就作为Class的一个实例 比如，上方的Person类被编写成Person.class文件还不是一个运行时类，就不是Class的实例；而当我们将Person.class加载到内存(或是说JVM)中进行解释运行时，此时这个Person类才称得上是Class的实例 2.换句话说，Class的实例就对应着一个运行时类 3.加载到内存中的运行时类，会缓存一定的时间。在此时间之内，我们可以通过不同的方式来获取此运行时类 14.2.2 获取Class类的实例//获取Class实例的四种方式(前三种需要掌握) @Test public void getClassExample() throws ClassNotFoundException &#123; //1.方式一：调用运行时类的属性.class Class&lt;Person&gt; clazz1 = Person.class; System.out.println(clazz1);//class Reflection.Person //方式二：通过运行时类的对象调用getClass()方法 Person p = new Person(); Class clazz2 = p.getClass(); System.out.println(clazz2);//class Reflection.Person //方式三：调用Class的静态方法:forName(String classPath) 使用最多 Class clazz3 = Class.forName(&quot;Reflection.Person&quot;); System.out.println(clazz3);//class Reflection.Person System.out.println(clazz1 == clazz2);//true System.out.println(clazz1 == clazz3);//true System.out.println(clazz2 == clazz3);//true //方式四：使用类的加载器:ClassLoader(了解) ClassLoader classLoader = ReflectionTest02.class.getClassLoader(); Class clazz4 = classLoader.loadClass(&quot;Reflection.Person&quot;); System.out.println(clazz4);//class Reflection.Person System.out.println(clazz1 == clazz4);//true &#125; 14.2.3 哪些类型可以作为Class对象(1) class：外部类，成员(成员内部类，静态内部类)，局部内部类，匿名内部类 (2) interface：接口 (3 []：数组 (4) enum：枚举 (5) annotation：注解@interface (6) primitive type：基本数据类型 (7) void @Test public void Test()&#123; Class c1 = Object.class;//对象 Class c2 = Comparable.class;//接口 Class c3 = String[].class;//一维数组 Class c4 = int[][].class;//二维数组 Class c5 = ElementType.class;//枚举类 Class c6 = Override.class;//注解 Class c7 = int.class;//基本数据类型 Class c8 = void.class;//void Class c9 = Class.class;//Class本身 int[] a = new int[10]; int[] b = new int[100]; Class c10 = a.getClass(); Class c11 = b.getClass(); //只要元素类型与维度一样，就是同一个Class System.out.println(c10 == c11);//true &#125; 14.3 类的加载与ClassLoader的理解14.3.1 类的加载过程image-20210810202245961 加载： 将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口（即引用地址）。所有需要访问和使用类数据只能通过这个Class对象。这个加载的过程需要类加载器参与 链接：将Java类的二进制代码合并到JVM的运行状态之中的过程 验证：确保加载的类信息符合JVM规范，例如：以cafe开头，没有安全方面的问题 准备：正式为类变量(static）分配内存并设置类变量默认初始值的阶段，这些内存都将在方法区中进行分配 解析：虚拟机常量池内的符号引用（常量名）替换为直接引用（地址）的过程 初始化： 执行类构造器()方法的过程。类构造器()方法是由编译期自动收集类中所有类变量的赋值动作和静态代码块中的语句合并产生的（类构造器是构造类信息的，不是构造该类对象的构造器） 当初始化一个类的时候，如果发现其父类还没有进行初始化，则需要先触发其父类的初始化 虚拟机会**** image-20210810203452201 14.3.2 理解类加载器ClassLoader1.类加载器的作用： 类加载的作用：将class文件字节码内容加载到内存中，并将这些静态数据转换成方法区的运行时数据结构，然后在堆中生成一个代表这个类的java.lang.Class对象，作为方法区中类数据的访问入口 类缓存：标准的JavaSE类加载器可以按要求查找类，但一旦某个类被加载到类加载器中，它将维持加载（缓存）一段时间。不过JVM垃圾回收机制可以回收这些Class对象 image-20210810204715392 image-20210810205237266 2.获取三种类加载器@Test public void TestClassLoader()&#123; //对于自定义类，使用系统类加载器进行加载 ClassLoader classLoader = ReflectionTest03.class.getClassLoader();//获得系统类加载器 System.out.println(classLoader);//sun.misc.Launcher$AppClassLoader@18b4aac2 //调用系统类加载器的getParent()：获取扩展类加载器 ClassLoader classLoader1 = classLoader.getParent(); System.out.println(classLoader1);//sun.misc.Launcher$ExtClassLoader@1f32e575，获取到的扩展类加载器 //调用扩展类加载器的getParent()：无法获取引导类加载器 //引导类加载器主要负责java的核心类库，无法加载自定义类 ClassLoader classLoader2 = classLoader1.getParent(); System.out.println(classLoader2);//null，不能直接获取引导类加载器 ClassLoader classLoader3 = String.class.getClassLoader(); System.out.println(classLoader3);//null,说明String类是引导类加载的 &#125; 3.使用ClassLoader加载配置文件@Test public void TestLoadProperty() throws IOException &#123; Properties pros = new Properties();//用来读取配置文件 //读取配置文件的方式一：此时的配置文件默认在当前项目(或Module)下 //FileInputStream fileInputStream = new FileInputStream(&quot;jdbc.properties&quot;); //pros.load(fileInputStream); //读取配置文件的方式二：此时的配置文件默认在当前项目(或Module)的src下 ClassLoader classLoader = ReflectionTest03.class.getClassLoader(); InputStream inputStream = classLoader.getResourceAsStream(&quot;jdbc1.properties&quot;); pros.load(inputStream); String name = pros.getProperty(&quot;name&quot;); String password = pros.getProperty(&quot;password&quot;); System.out.println(&quot;name = &quot; + name + &quot;, password = &quot; + password);//方式一：name = Tom, password = abc123 方式二：name = Mary, password = 123 &#125; 14.4 创建运行时对象14.4.1 通过反射创建运行时类对象//通过反射，创建运行时类对象 /* newInstance():调用此方法，创建对应的运行时类的对象 要想此方法正常的创建运行时类的对象， 要求:1.运行时类必须提供空参的构造器 2.空参的构造器的访问权限得够。通常，设置为public，如果想访问private构造器，需要调用setAccessible()方法设置可调用性 在javabean中要求提供一个public的空参构造器。 原因:1.便于通过反射，创建运行时类的对象 2.便于子类继承此运行时类时，默认调用super()时，保证父类有此构造器 */ Class clazz = Person.class; Person p1 = (Person) clazz.newInstance(); System.out.println(p1); /* 或者 Class&lt;Person&gt; clazz = Person.class; */ 14.4.2 体会反射的动态性//体会反射的动态性 //创建一个指定类的对象。classPath指定类的全类名 public Object getInstance(String classPath) throws ClassNotFoundException, InstantiationException, IllegalAccessException &#123; Class clazz = Class.forName(classPath); return clazz.newInstance(); &#125; @Test public void TestDynamic()&#123; int num = new Random().nextInt(3);//0、1、2 String classPath = &quot;&quot;; switch (num)&#123; case 0: classPath = &quot;java.util.Date&quot;; break; case 1: classPath = &quot;java.lang.Object&quot;; break; case 2: classPath = &quot;Reflection.Reflection03&quot;; break; &#125; try &#123; Object obj = getInstance(classPath); System.out.println(obj); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; catch (InstantiationException e) &#123; e.printStackTrace(); &#125; catch (IllegalAccessException e) &#123; e.printStackTrace(); &#125; &#125; 14.5 获取运行时类的完整结构14.5.1 提供一个结构丰富的自定义类Person//自定义类 @MyAnnotation public class Person1 extends Creature&lt;String&gt; implements Comparable&lt;String&gt;,MyInterface&#123; private String name; int age; public int id; public Person1() &#123; &#125; @MyAnnotation(value = &quot;constructor&quot;) private Person1(String name) &#123; this.name = name; &#125; Person1(String name,int age)&#123; this.name = name; this.age = age; &#125; @MyAnnotation(value = &quot;nation&quot;) private String show(String nation)&#123; System.out.println(&quot;我的国籍是&quot; + nation); return nation; &#125; public String display(String interest,int age) throws NullPointerException,ClassCastException&#123; return interest + age; &#125; @Override public void Info() &#123; System.out.println(&quot;这是一个人&quot;); &#125; @Override public int compareTo(String o) &#123; return 0; &#125; private static void showDesc()&#123; System.out.println(&quot;我是Person1类的静态方法&quot;); &#125; @Override public String toString() &#123; return &quot;Person1&#123;&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &quot;, id=&quot; + id + &#39;&#125;&#39;; &#125; &#125; //自定义类的父类 public class Creature&lt;T&gt; implements Serializable &#123; private char gender; public double weight; private void breath()&#123; System.out.println(&quot;生物呼吸&quot;); &#125; public void eat()&#123; System.out.println(&quot;生物吃东西&quot;); &#125; &#125; //自定义类的注解 @Target(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;) @Retention(RetentionPolicy.SOURCE) public @interface MyAnnotation &#123; String value() default &quot;hello&quot;; &#125; //自定义类实现的接口 public interface MyInterface &#123; void Info(); &#125; 14.5.2 获取运行时类的属性结构及其内部结构//获取运行时类的属性结构 @Test public void TestGetField()&#123; Class&lt;Person1&gt; clazz = Person1.class; //获取属性结构 //getFields():获取当前运行时类及其父类中声明为public访问权限的属性 Field[] fields = clazz.getFields(); for (Field field : fields) &#123; System.out.println(field); //public int Reflection.Person1.id // public double Reflection.Creature.weight &#125; System.out.println(&quot;*********************&quot;); //getDeclaredFields():获取当前运行时类中声明的所有属性（不包含父类中声明的属性） Field[] declaredFields = clazz.getDeclaredFields(); for (Field declaredField : declaredFields) &#123; System.out.println(declaredField); //private java.lang.String Reflection.Person1.name // int Reflection.Person1.age // public int Reflection.Person1.id &#125; System.out.println(&quot;*********************&quot;); //获取属性的权限修饰符，数据类型，变量名 for (Field declaredField : declaredFields) &#123; //权限修饰符 int modifier = declaredField.getModifiers(); System.out.print(Modifier.toString(modifier) + &quot;\\t&quot;); //数据类型 Class type = declaredField.getType(); System.out.print(type + &quot;\\t&quot;); //变量名 String name = declaredField.getName(); System.out.println(name); //private class java.lang.String name // int age //public int id &#125; &#125; 14.5.3 获取运行时类的方法结构及其内部结构//获取运行时类的方法结构及其内部结构 @Test public void TestGetMethod()&#123; Class&lt;Person1&gt; clazz = Person1.class; //getMethods():获取当前运行时类及其所有父类中声明为public权限的方法 Method[] methods = clazz.getMethods(); for (Method method : methods) &#123; System.out.println(method); //public int Reflection.Person1.compareTo(java.lang.String) //public int Reflection.Person1.compareTo(java.lang.Object) //public void Reflection.Person1.Info() //public java.lang.String Reflection.Person1.display(java.lang.String,int) throws java.lang.NullPointerException,java.lang.ClassCastException //public void Reflection.Creature.eat() //public final void java.lang.Object.wait() throws java.lang.InterruptedException //public final void java.lang.Object.wait(long,int) throws java.lang.InterruptedException //public final native void java.lang.Object.wait(long) throws java.lang.InterruptedException //public boolean java.lang.Object.equals(java.lang.Object) //public java.lang.String java.lang.Object.toString() //public native int java.lang.Object.hashCode() //public final native java.lang.Class java.lang.Object.getClass() //public final native void java.lang.Object.notify() //public final native void java.lang.Object.notifyAll() &#125; System.out.println(&quot;************************&quot;); //getDeclaredMethods():获取当前运行时类中声明的所有方法(不包含父类中的方法) Method[] declaredMethods = clazz.getDeclaredMethods(); for (Method declaredMethod : declaredMethods) &#123; System.out.println(declaredMethod); //public int Reflection.Person1.compareTo(java.lang.String) //public int Reflection.Person1.compareTo(java.lang.Object) //public void Reflection.Person1.Info() //public java.lang.String Reflection.Person1.display(java.lang.String,int) throws java.lang.NullPointerException,java.lang.ClassCastException //private java.lang.String Reflection.Person1.show(java.lang.String) &#125; System.out.println(&quot;*************************&quot;); //获取方法的内部结构 // @Xxx(注解) // 权限修饰符 返回值类型 方法名 (参数值类型1 形参名1) throws XxxException &#123;&#125; for (Method declaredMethod : declaredMethods) &#123; //1.获取方法声明的注解 Annotation[] annotations = declaredMethod.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation);//@Reflection.MyAnnotation(value=nation) //能被获取到的注解其元注解Retention的值需要是RUNTIME &#125; //2.获取方法的权限修饰符 System.out.print(Modifier.toString(declaredMethod.getModifiers()) + &quot;\\t&quot;); //3.获取方法的返回值类型 System.out.print(declaredMethod.getReturnType().getName() + &quot;\\t&quot;); //4.获取方法名 System.out.print(declaredMethod.getName()); //5.获取形参列表 //方法一： System.out.print(&quot;(&quot;); Class[] parameterTypes = declaredMethod.getParameterTypes();//获取到形参列表的所有参数类型 if(!(parameterTypes == null || parameterTypes.length == 0))&#123;//判断是否为空 for (int i = 0;i &lt; parameterTypes.length;i++) &#123;//遍历形参列表 if (i == parameterTypes.length-1)&#123;//判断是否为形参列表最后一个参数，若是就不用加&quot;,&quot;，然后跳出遍历循环 System.out.print(parameterTypes[i].getName() + &quot; &quot; + &quot;arg_&quot; + i); break; &#125; System.out.print(parameterTypes[i].getName() + &quot; &quot; + &quot;arg_&quot; + i + &quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); //方法二： System.out.print(&quot;(&quot;); Parameter[] parameters = declaredMethod.getParameters(); if (!(parameters == null || parameters.length == 0))&#123; for (int i = 0;i &lt; parameters.length;i++) &#123; if (i == parameters.length - 1)&#123; System.out.print(parameters[i]); break; &#125; System.out.print(parameters[i] + &quot;,&quot;); &#125; &#125; System.out.print(&quot;)&quot;); //6.获取抛出的异常 Class[] exceptionTypes = declaredMethod.getExceptionTypes(); if (!(exceptionTypes == null || exceptionTypes.length == 0))&#123; System.out.print(&quot; throws &quot;); for (int i = 0; i &lt; exceptionTypes.length; i++) &#123; if (i == exceptionTypes.length - 1)&#123; System.out.print(exceptionTypes[i].getName()); break; &#125; System.out.print(exceptionTypes[i].getName() + &quot;,&quot;); &#125; &#125; System.out.println(); //public int compareTo(java.lang.String arg_0) //public volatile int compareTo(java.lang.Object arg_0) //public void Info() //public java.lang.String display(java.lang.String arg_0,int arg_1) throws java.lang.NullPointerException,java.lang.ClassCastException //@Reflection.MyAnnotation(value=nation) //private java.lang.String show(java.lang.String arg_0) &#125; &#125; 14.5.4 获取运行时类的构造器结构//获取运行时类的构造器结构 @Test public void TestGetConstructor()&#123; Class&lt;Person1&gt; clazz = Person1.class; //getConstructor():获取当前运行时类中声明为public的构造器(不包含父类构造器) Constructor[] constructors = clazz.getConstructors(); for (Constructor constructor : constructors) &#123; System.out.println(constructor);//public Reflection.Person1() &#125; //getDeclaredConstructors():获取当前运行时类中声明的所有构造器 Constructor&lt;?&gt;[] declaredConstructors = clazz.getDeclaredConstructors(); for (Constructor&lt;?&gt; declaredConstructor : declaredConstructors) &#123; System.out.println(declaredConstructor); //Reflection.Person1(java.lang.String,int) //private Reflection.Person1(java.lang.String) //public Reflection.Person1() &#125; //获取运行时类的构造器内部结构跟方法一样，使用获取到的构造器再调用相应的获取修饰符、构造器名字、参数类型、参数名的方法即可 &#125; 14.5.5 获取运行时类的父类及父类泛型//获取运行时类的父类及父类泛型 @Test public void TestGetParent()&#123; Class&lt;Person1&gt; clazz = Person1.class; //getSuperClass():获取运行时类的父类 Class superclass = clazz.getSuperclass(); System.out.println(superclass);//class Reflection.Creature //getGenericSuperClass():获取运行时类的带泛型的父类 Type genericSuperclass = clazz.getGenericSuperclass(); System.out.println(genericSuperclass);//Reflection.Creature&lt;java.lang.String&gt; //getActualTypeArguments():获取运行时类的带泛型的父类的泛型 ParameterizedType paramType = (ParameterizedType) genericSuperclass;//将泛型父类对象转换成带泛型参数的父类对象 Type[] actualTypeArguments = paramType.getActualTypeArguments();//获取具体泛型参数类型 for (Type actualTypeArgument : actualTypeArguments) &#123; System.out.println(actualTypeArgument.getTypeName());//java.lang.String &#125; &#125; 14.5.6 获取运行时类的接口、所在包、注解等//获取运行时类的接口、所在包、注解等 @Test public void TestGetOther()&#123; Class&lt;Person1&gt; clazz = Person1.class; //getInterfaces():获取运行时类实现的接口 Class[] interfaces = clazz.getInterfaces(); for (Class anInterface : interfaces) &#123; System.out.println(anInterface);//interface java.lang.Comparable interface Reflection.MyInterface &#125; //获取运行时类父类实现的接口 Class[] interfaces1 = clazz.getSuperclass().getInterfaces(); for (Class aClass : interfaces1) &#123; System.out.println(aClass);//interface java.io.Serializable &#125; //获取运行时类所在的包 Package aPackage = clazz.getPackage(); System.out.println(aPackage);//package Reflection //获取运行时类的注解 Annotation[] annotations = clazz.getAnnotations(); for (Annotation annotation : annotations) &#123; System.out.println(annotation);//@Reflection.MyAnnotation(value=hello) &#125; &#125; 14.6 调用运行时类的指定结构14.6.1 调用运行时类的指定属性//调用运行时类的指定属性 -- 需要掌握 @Test public void TestTransferField() throws InstantiationException, IllegalAccessException, NoSuchFieldException &#123; Class&lt;Person1&gt; clazz = Person1.class; //创建运行时类的对象 Person1 person = clazz.newInstance(); //getField()获取指定的属性:要求运行时类中属性声明为public Field id = clazz.getField(&quot;id&quot;); //设置当前属性的值 set():参数1指明哪个对象的属性 参数2将此属性值设置为多少 id.set(person,1001); //获取当前属性的值 get():参数1获取哪个对象的当前属性值 int pId = (int) id.get(person); System.out.println(pId);//1001 //getDeclaredField(String fieldName)获取运行时类中指定变量名的属性 Field name = clazz.getDeclaredField(&quot;name&quot;); name.setAccessible(true);//保证当前属性是可访问的 //获取、设置当前对象的属性值 name.set(person,&quot;Tom&quot;); System.out.println(name.get(person));//Tom &#125; 14.6.2 调用运行时类的指定方法//调用运行时类的指定方法 @Test public void TestTransferMethod() throws InstantiationException, IllegalAccessException, NoSuchMethodException, InvocationTargetException &#123; Class&lt;Person1&gt; clazz = Person1.class; //创建运行时类的对象 Person1 person = clazz.newInstance(); //获取指定的某个方法(调用非静态方法) //getDeclaredMethod():参数1∶指明获取的方法的名称﹑参数2:指明获取的方法的形参列表 Method show = clazz.getDeclaredMethod(&quot;show&quot;, String.class); show.setAccessible(true);//保证当前方法可访问 //invoke():参数1:方法的调用者，参数2:给方法形参赋值的实参，其返回值为对应类中调用该方法的返回值 Object chn = show.invoke(person, &quot;CHN&quot;);//类似于String chn = person.show(&quot;CHN&quot;); System.out.println(chn);//CHN //调用静态方法 Method showDesc = clazz.getDeclaredMethod(&quot;showDesc&quot;); showDesc.setAccessible(true); Object invoke = showDesc.invoke(Person.class);//类似于Person.showDesc() System.out.println(invoke);//null，方法没有返回值则invoke返回null &#125; 14.6.3 调用运行时类的指定构造器//调用运行时类的指定构造器 @Test public void TestTransferConstructor() throws NoSuchMethodException, InvocationTargetException, InstantiationException, IllegalAccessException &#123; //一般情况都用newInstance()方法调用空参构造器创建对象 Class&lt;Person1&gt; clazz = Person1.class; //调用指定构造器 //getDeclaredConstructor():参数:指明要调用的构造器的参数列表 Constructor&lt;Person1&gt; constructor = clazz.getDeclaredConstructor(String.class); constructor.setAccessible(true);//保证当前构造器可访问 //调用此构造器创建运行时类对象 Person1 person = constructor.newInstance(&quot;Tom&quot;); System.out.println(person);//Person1&#123;name=&#39;Tom&#39;, age=0, id=0&#125; &#125; 14.7 反射的应用：动态代理代理设计模式的原理： 使用一个代理将对象包装起来,然后用该代理对象取代原始对象。任何对原始对象的调用都要通过代理。代理对象决定是否以及何时将方法调用转到原始对象上 之前5.6.2接口中提到的代理机制的操作，属于静态代理，特征是代理类和目标对象的类都是在编译期间确定下来，不利于程序的扩展。同时，每一个代理类只能为一个接口服务，这样一来程序开发中必然产生过多的代理。最好可以通过一个代理类完成全部的代理功能 14.7.1 动态代理动态代理是指客户通过代理类来调用其它对象的方法，并且是在程序运行时根据需要动态创建目标类的代理对象 动态代理使用场合： 调试 远程方法调用 动态代理相比于静态代理的优点：抽象角色中（接口）声明的所有方法都被转移到调用处理器一个集中的方法中处理，这样，我们可以更加灵活和统一的处理众多的方法 14.7.2 静态代理实例//静态代理测试 //特点：代理类和被代理类在编译期间就确定下来了 public class StaticProxyTest &#123; public static void main(String[] args) &#123; //创建被代理类对象 ClothFactory nike = new NikeClothFactory(); //用被代理类对象创建代理类对象 ProxyClothFactory proxyClothFactory = new ProxyClothFactory(nike); //调用代理类的方法 proxyClothFactory.produceCloth(); &#125; &#125; interface ClothFactory&#123; void produceCloth(); &#125; //代理类 class ProxyClothFactory implements ClothFactory&#123; private ClothFactory factory; public ProxyClothFactory(ClothFactory factory)&#123; this.factory = factory; &#125; @Override public void produceCloth() &#123; System.out.println(&quot;代理工厂做准备工作&quot;); factory.produceCloth(); System.out.println(&quot;代理工厂做后续收尾工作&quot;); &#125; &#125; //被代理类 class NikeClothFactory implements ClothFactory&#123; @Override public void produceCloth() &#123; System.out.println(&quot;Nike工厂生产运动服&quot;); &#125; &#125; 14.7.3 动态代理实例//动态代理测试 //要想实现动态代理，需要解决的问题? //问题一:如何根据加载到内存中的被代理类，动态的创建一个代理类及其对象(动态代理的核心) //问题二:当通过代理类的对象调用方法a时，如何动态的去调用被代理类中的同名方法a public class DynamicProxyTest &#123; public static void main(String[] args) &#123; //创建被代理类对象 SuperMan superMan = new SuperMan(); //创建代理类对象 //因为代理类和被代理类都会实现相同的接口，所以可以将代理类转换成接口对象 Human proxyInstance = (Human) ProxyFactor.getProxyInstance(superMan);//此时的proxyInstance就是代理类的对象 //当通过代理类对象调用方法时，会自动调用被代理类中同名的方法 String belief = proxyInstance.getBelief(); System.out.println(belief); proxyInstance.eat(&quot;四川麻辣烫&quot;); System.out.println(&quot;***********************&quot;); NikeClothFactory nikeClothFactory = new NikeClothFactory(); ClothFactory proxyClothFactory = (ClothFactory) ProxyFactor.getProxyInstance(nikeClothFactory); proxyClothFactory.produceCloth(); &#125; &#125; interface Human&#123; String getBelief(); void eat(String food); &#125; //被代理类 class SuperMan implements Human&#123; @Override public String getBelief() &#123; return &quot;I believe I can fly!&quot;; &#125; @Override public void eat(String food) &#123; System.out.println(&quot;我喜欢吃&quot; + food); &#125; &#125; //下方两个类的个人理解:代理类创建实例的步骤和调用代理类中与被代理类中的同名方法的步骤被分成两个类单独处理，由于被代理类的不确定性，则创建出的代理类的对象也具有不确定性，所以就体现出了动态代理的动态性 //根据被代理类创建代理类的工厂 class ProxyFactor&#123; //调用此方法，返回一个代理类的对象 public static Object getProxyInstance(Object obj)&#123;//obj:被代理类对象 MyInvocationHandler handler = new MyInvocationHandler(); handler.bind(obj); return Proxy.newProxyInstance(obj.getClass().getClassLoader(),obj.getClass().getInterfaces(),handler); //newProxyInstance()中的参数： //ClassLoader loader:类加载器定义代理类 //类&lt;?&gt;[] interfaces:代理类需要实现的接口 //InvocationHandler h:调用被代理类的方法的具体处理类的对象 //newProxyInstance()根据传入的被代理类的构造器、代理类需要实现哪些接口、代理类实例调用被代理类方法的具体处理类的对象来创建并返回一个代理类对象 &#125; &#125; //代理类实例调用代理类中与被代理类中被调用的同名方法的具体类 class MyInvocationHandler implements InvocationHandler&#123; private Object obj;//需要使用被代理类的对象进行赋值 public void bind(Object obj)&#123; this.obj = obj; &#125; //当我们通过代理类对象，调用方法a时，就会自动调用如下的方法：invoke() //将被代理类要执行的方法a的功能就声明在invoke()中 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;//相当于是调用代理类中的method方法，然后再在里面调用被代理类的同名方法 //proxy:调用该方法的代理实例 //method:即为代理类对象调用的方法，此方法也就作为了被代理类对象要调用的方法 //args:被调用方法的参数列表 //obj:被代理类对象 Object returnValue = method.invoke(obj, args);//类似obj.method(args) //上述方法的返回值就作为当前类中的invoke()的返回值 return returnValue; &#125; &#125; 14.7.4 动态代理与AOPimage-20210812132140133 image-20210812132406550 image-20210812132428676","categories":[{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"},{"name":"后端","slug":"后端","permalink":"http://rainvex.com/tags/%E5%90%8E%E7%AB%AF/"}]}],"categories":[{"name":"置顶","slug":"置顶","permalink":"http://rainvex.com/categories/%E7%BD%AE%E9%A1%B6/"},{"name":"后端","slug":"后端","permalink":"http://rainvex.com/categories/%E5%90%8E%E7%AB%AF/"},{"name":"教程","slug":"教程","permalink":"http://rainvex.com/categories/%E6%95%99%E7%A8%8B/"},{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/categories/Linux/"}],"tags":[{"name":"置顶","slug":"置顶","permalink":"http://rainvex.com/tags/%E7%BD%AE%E9%A1%B6/"},{"name":"笔记","slug":"笔记","permalink":"http://rainvex.com/tags/%E7%AC%94%E8%AE%B0/"},{"name":"Mybatis","slug":"Mybatis","permalink":"http://rainvex.com/tags/Mybatis/"},{"name":"Java","slug":"Java","permalink":"http://rainvex.com/tags/Java/"},{"name":"Linux","slug":"Linux","permalink":"http://rainvex.com/tags/Linux/"},{"name":"Ubuntu","slug":"Ubuntu","permalink":"http://rainvex.com/tags/Ubuntu/"},{"name":"Hadoop","slug":"Hadoop","permalink":"http://rainvex.com/tags/Hadoop/"},{"name":"SpringMVC","slug":"SpringMVC","permalink":"http://rainvex.com/tags/SpringMVC/"},{"name":"Typora","slug":"Typora","permalink":"http://rainvex.com/tags/Typora/"},{"name":"PicGo","slug":"PicGo","permalink":"http://rainvex.com/tags/PicGo/"},{"name":"图床","slug":"图床","permalink":"http://rainvex.com/tags/%E5%9B%BE%E5%BA%8A/"},{"name":"CentOS","slug":"CentOS","permalink":"http://rainvex.com/tags/CentOS/"},{"name":"Spring5","slug":"Spring5","permalink":"http://rainvex.com/tags/Spring5/"},{"name":"后端","slug":"后端","permalink":"http://rainvex.com/tags/%E5%90%8E%E7%AB%AF/"}]}